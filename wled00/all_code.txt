=== File Paths ===
./FX.cpp
./FX.h
./FX_fcn.cpp
./NodeStruct.h
./alexa.cpp
./audio_reactive.h
./audio_source.h
./bus_manager.h
./bus_wrapper.h
./button.cpp
./cfg.cpp
./colors.cpp
./const.h
./dmx.cpp
./e131.cpp
./fcn_declare.h
./file.cpp
./html_other.h
./html_settings.h
./html_ui.h
./hue.cpp
./improv.cpp
./ir.cpp
./ir_codes.h
./json.cpp
./led.cpp
./lx_parser.cpp
./mqtt.cpp
./my_config.h
./my_config_sample.h
./ntp.cpp
./overlay.cpp
./palettes.h
./pin_manager.cpp
./pin_manager.h
./playlist.cpp
./presets.cpp
./set.cpp
./src/dependencies/async-mqtt-client/AsyncMqttClient.cpp
./src/dependencies/async-mqtt-client/AsyncMqttClient.h
./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/ConnAckPacket.cpp
./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PingRespPacket.cpp
./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PubAckPacket.cpp
./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PubCompPacket.cpp
./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PubRecPacket.cpp
./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PubRelPacket.cpp
./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PublishPacket.cpp
./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/SubAckPacket.cpp
./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/UnsubAckPacket.cpp
./src/dependencies/dmx/ESPDMX.cpp
./src/dependencies/dmx/ESPDMX.h
./src/dependencies/dmx/SparkFunDMX.cpp
./src/dependencies/dmx/SparkFunDMX.h
./src/dependencies/e131/ESPAsyncE131.cpp
./src/dependencies/e131/ESPAsyncE131.h
./src/dependencies/espalexa/Espalexa.h
./src/dependencies/espalexa/EspalexaDevice.cpp
./src/dependencies/espalexa/EspalexaDevice.h
./src/dependencies/json/ArduinoJson-v6.h
./src/dependencies/json/AsyncJson-v6.h
./src/dependencies/network/Network.cpp
./src/dependencies/network/Network.h
./src/dependencies/time/DS1307RTC.cpp
./src/dependencies/time/DS1307RTC.h
./src/dependencies/time/DateStrings.cpp
./src/dependencies/time/Time.cpp
./src/dependencies/time/TimeLib.h
./src/dependencies/timezone/Timezone.cpp
./src/dependencies/timezone/Timezone.h
./src/dependencies/toki/Toki.h
./udp.cpp
./um_manager.cpp
./usermod.cpp
./usermod_v2_empty.h
./usermods_list.cpp
./util.cpp
./wled.cpp
./wled.h
./wled_eeprom.cpp
./wled_ethernet.h
./wled_math.h
./wled_serial.cpp
./wled_server.cpp
./ws.cpp
./xml.cpp

=== File Contents ===

=== ./FX.cpp ===

/*
  WS2812FX.cpp contains all effect methods
  Harm Aldick - 2016
  www.aldick.org
  LICENSE
  The MIT License (MIT)
  Copyright (c) 2016  Harm Aldick
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.

  Modified heavily for WLED
*/

#include "FX.h"

#include "wled.h"

#define IBN 5100
#define PALETTE_SOLID_WRAP (paletteBlend == 1 || paletteBlend == 3)

// Sound reactive external variables.
extern int sampleRaw;
extern float sampleAvg;
extern uint8_t samplePeak;
extern uint8_t myVals[32];
// extern int sampleAgc;
extern int rawSampleAgc;
extern float sampleAgc;
extern uint8_t squelch;
extern byte soundSquelch;
extern byte soundAgc;
extern uint8_t maxVol;
extern uint8_t binNum;

extern float sampleReal;  // "sample" as float, to provide bits that are lost
                          // otherwise. Needed for AGC.
extern float multAgc;     // sampleReal * multAgc = sampleAgc. Our multiplier

// FFT based variables
extern float FFT_MajorPeak;
extern float FFT_Magnitude;
extern float fftBin[];   // raw FFT data
extern int fftResult[];  // summary of bins array. 16 summary bins.
extern float fftAvg[];

// Helper function(s) prototypes
double mapf(double x, double in_min, double in_max, double out_min,
            double out_max);  // for double
static float mapff(float x, float in_min, float in_max, float out_min,
                   float out_max);  // for float

/*
 * No blinking. Just plain old static light.
 */
uint16_t WS2812FX::mode_static(void) {
  fill(SEGCOLOR(0));
  return (SEGMENT.getOption(SEG_OPTION_TRANSITIONAL))
             ? FRAMETIME
             : 350;  // update faster if in transition
}

/*
 * Blink/strobe function
 * Alternate between color1 and color2
 * if(strobe == true) then create a strobe effect
 */
uint16_t WS2812FX::blink(uint32_t color1, uint32_t color2, bool strobe,
                         bool do_palette) {
  uint32_t cycleTime = (255 - SEGMENT.speed) * 20;
  uint32_t onTime = FRAMETIME;
  if (!strobe) onTime += ((cycleTime * SEGMENT.intensity) >> 8);
  cycleTime += FRAMETIME * 2;
  uint32_t it = now / cycleTime;
  uint32_t rem = now % cycleTime;

  bool on = false;
  if (it != SEGENV.step  // new iteration, force on state for one frame, even if
                         // set time is too brief
      || rem <= onTime) {
    on = true;
  }

  SEGENV.step = it;  // save previous iteration

  uint32_t color = on ? color1 : color2;
  if (color == color1 && do_palette) {
    for (uint16_t i = 0; i < SEGLEN; i++) {
      setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 0));
    }
  } else
    fill(color);

  return FRAMETIME;
}

/*
 * Normal blinking. 50% on/off time.
 */
uint16_t WS2812FX::mode_blink(void) {
  return blink(SEGCOLOR(0), SEGCOLOR(1), false, true);
}

/*
 * Classic Blink effect. Cycling through the rainbow.
 */
uint16_t WS2812FX::mode_blink_rainbow(void) {
  return blink(color_wheel(SEGENV.call & 0xFF), SEGCOLOR(1), false, false);
}

/*
 * Classic Strobe effect.
 */
uint16_t WS2812FX::mode_strobe(void) {
  return blink(SEGCOLOR(0), SEGCOLOR(1), true, true);
}

/*
 * Classic Strobe effect. Cycling through the rainbow.
 */
uint16_t WS2812FX::mode_strobe_rainbow(void) {
  return blink(color_wheel(SEGENV.call & 0xFF), SEGCOLOR(1), true, false);
}

/*
 * Color wipe function
 * LEDs are turned on (color1) in sequence, then turned off (color2) in
 * sequence. if (bool rev == true) then LEDs are turned off in reverse order
 */
uint16_t WS2812FX::color_wipe(bool rev, bool useRandomColors) {
  uint32_t cycleTime = 750 + (255 - SEGMENT.speed) * 150;
  uint32_t perc = now % cycleTime;
  uint16_t prog = (perc * 65535) / cycleTime;
  bool back = (prog > 32767);
  if (back) {
    prog -= 32767;
    if (SEGENV.step == 0) SEGENV.step = 1;
  } else {
    if (SEGENV.step == 2) SEGENV.step = 3;  // trigger color change
  }

  if (useRandomColors) {
    if (SEGENV.call == 0) {
      SEGENV.aux0 = random8();
      SEGENV.step = 3;
    }
    if (SEGENV.step == 1) {  // if flag set, change to new random color
      SEGENV.aux1 = get_random_wheel_index(SEGENV.aux0);
      SEGENV.step = 2;
    }
    if (SEGENV.step == 3) {
      SEGENV.aux0 = get_random_wheel_index(SEGENV.aux1);
      SEGENV.step = 0;
    }
  }

  uint16_t ledIndex = (prog * SEGLEN) >> 15;
  uint16_t rem = 0;
  rem = (prog * SEGLEN) * 2;  // mod 0xFFFF
  rem /= (SEGMENT.intensity + 1);
  if (rem > 255) rem = 255;

  uint32_t col1 = useRandomColors ? color_wheel(SEGENV.aux1) : SEGCOLOR(1);
  for (uint16_t i = 0; i < SEGLEN; i++) {
    uint16_t index = (rev && back) ? SEGLEN - 1 - i : i;
    uint32_t col0 = useRandomColors ? color_wheel(SEGENV.aux0)
                                    : color_from_palette(index, true,
                                                         PALETTE_SOLID_WRAP, 0);

    if (i < ledIndex) {
      setPixelColor(index, back ? col1 : col0);
    } else {
      setPixelColor(index, back ? col0 : col1);
      if (i == ledIndex)
        setPixelColor(index,
                      color_blend(back ? col0 : col1, back ? col1 : col0, rem));
    }
  }
  return FRAMETIME;
}

/*
 * Lights all LEDs one after another.
 */
uint16_t WS2812FX::mode_color_wipe(void) { return color_wipe(false, false); }

/*
 * Lights all LEDs one after another. Turns off opposite
 */
uint16_t WS2812FX::mode_color_sweep(void) { return color_wipe(true, false); }

/*
 * Turns all LEDs after each other to a random color.
 * Then starts over with another color.
 */
uint16_t WS2812FX::mode_color_wipe_random(void) {
  return color_wipe(false, true);
}

/*
 * Random color introduced alternating from start and end of strip.
 */
uint16_t WS2812FX::mode_color_sweep_random(void) {
  return color_wipe(true, true);
}

/*
 * Lights all LEDs in one random color up. Then switches them
 * to the next random color.
 */
uint16_t WS2812FX::mode_random_color(void) {
  uint32_t cycleTime = 200 + (255 - SEGMENT.speed) * 50;
  uint32_t it = now / cycleTime;
  uint32_t rem = now % cycleTime;
  uint16_t fadedur = (cycleTime * SEGMENT.intensity) >> 8;

  uint32_t fade = 255;
  if (fadedur) {
    fade = (rem * 255) / fadedur;
    if (fade > 255) fade = 255;
  }

  if (SEGENV.call == 0) {
    SEGENV.aux0 = random8();
    SEGENV.step = 2;
  }
  if (it != SEGENV.step)  // new color
  {
    SEGENV.aux1 = SEGENV.aux0;
    SEGENV.aux0 = get_random_wheel_index(
        SEGENV.aux0);  // aux0 will store our random color wheel index
    SEGENV.step = it;
  }

  fill(color_blend(color_wheel(SEGENV.aux1), color_wheel(SEGENV.aux0), fade));
  return FRAMETIME;
}

/*
 * Lights every LED in a random color. Changes all LED at the same time
 * to new random colors.
 */
uint16_t WS2812FX::dynamic(boolean smooth = false) {
  if (!SEGENV.allocateData(SEGLEN)) return mode_static();  // allocation failed

  if (SEGENV.call == 0) {
    for (uint16_t i = 0; i < SEGLEN; i++) SEGENV.data[i] = random8();
  }

  uint32_t cycleTime = 50 + (255 - SEGMENT.speed) * 15;
  uint32_t it = now / cycleTime;
  if (it != SEGENV.step && SEGMENT.speed != 0)  // new color
  {
    for (uint16_t i = 0; i < SEGLEN; i++) {
      if (random8() <= SEGMENT.intensity) SEGENV.data[i] = random8();
    }
    SEGENV.step = it;
  }

  if (smooth) {
    for (uint16_t i = 0; i < SEGLEN; i++) {
      blendPixelColor(i, color_wheel(SEGENV.data[i]), 16);
    }
  } else {
    for (uint16_t i = 0; i < SEGLEN; i++) {
      setPixelColor(i, color_wheel(SEGENV.data[i]));
    }
  }
  return FRAMETIME;
}

/*
 * Original effect "Dynamic"
 */
uint16_t WS2812FX::mode_dynamic(void) { return dynamic(false); }

/*
 * effect "Dynamic" with smoth color-fading
 */
uint16_t WS2812FX::mode_dynamic_smooth(void) { return dynamic(true); }

/*
 * Does the "standby-breathing" of well known i-Devices.
 */
uint16_t WS2812FX::mode_breath(void) {
  uint16_t var = 0;
  uint16_t counter = (now * ((SEGMENT.speed >> 3) + 10));
  counter = (counter >> 2) + (counter >> 4);  // 0-16384 + 0-2048
  if (counter < 16384) {
    if (counter > 8192) counter = 8192 - (counter - 8192);
    var = sin16(counter) /
          103;  // close to parabolic in range 0-8192, max val. 23170
  }

  uint8_t lum = 30 + var;
  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(
        i,
        color_blend(SEGCOLOR(1),
                    color_from_palette(i, true, PALETTE_SOLID_WRAP, 0), lum));
  }

  return FRAMETIME;
}

/*
 * Fades the LEDs between two colors
 */
uint16_t WS2812FX::mode_fade(void) {
  uint16_t counter = (now * ((SEGMENT.speed >> 3) + 10));
  uint8_t lum = triwave16(counter) >> 8;

  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(
        i,
        color_blend(SEGCOLOR(1),
                    color_from_palette(i, true, PALETTE_SOLID_WRAP, 0), lum));
  }

  return FRAMETIME;
}

/*
 * Scan mode parent function
 */
uint16_t WS2812FX::scan(bool dual) {
  uint32_t cycleTime = 750 + (255 - SEGMENT.speed) * 150;
  uint32_t perc = now % cycleTime;
  uint16_t prog = (perc * 65535) / cycleTime;
  uint16_t size = 1 + ((SEGMENT.intensity * SEGLEN) >> 9);
  uint16_t ledIndex = (prog * ((SEGLEN * 2) - size * 2)) >> 16;

  fill(SEGCOLOR(1));

  int led_offset = ledIndex - (SEGLEN - size);
  led_offset = abs(led_offset);

  if (dual) {
    for (uint16_t j = led_offset; j < led_offset + size; j++) {
      uint16_t i2 = SEGLEN - 1 - j;
      setPixelColor(i2, color_from_palette(i2, true, PALETTE_SOLID_WRAP,
                                           (SEGCOLOR(2)) ? 2 : 0));
    }
  }

  for (uint16_t j = led_offset; j < led_offset + size; j++) {
    setPixelColor(j, color_from_palette(j, true, PALETTE_SOLID_WRAP, 0));
  }

  return FRAMETIME;
}

/*
 * Runs a single pixel back and forth.
 */
uint16_t WS2812FX::mode_scan(void) { return scan(false); }

/*
 * Runs two pixel back and forth in opposite directions.
 */
uint16_t WS2812FX::mode_dual_scan(void) { return scan(true); }

/*
 * Cycles all LEDs at once through a rainbow.
 */
uint16_t WS2812FX::mode_rainbow(void) {
  uint16_t counter = (now * ((SEGMENT.speed >> 2) + 2)) & 0xFFFF;
  counter = counter >> 8;

  if (SEGMENT.intensity < 128) {
    fill(color_blend(color_wheel(counter), WHITE, 128 - SEGMENT.intensity));
  } else {
    fill(color_wheel(counter));
  }

  return FRAMETIME;
}

/*
 * Cycles a rainbow over the entire string of LEDs.
 */
uint16_t WS2812FX::mode_rainbow_cycle(void) {
  uint16_t counter = (now * ((SEGMENT.speed >> 2) + 2)) & 0xFFFF;
  counter = counter >> 8;

  for (uint16_t i = 0; i < SEGLEN; i++) {
    // intensity/29 = 0 (1/16) 1 (1/8) 2 (1/4) 3 (1/2) 4 (1) 5 (2) 6 (4) 7 (8) 8
    // (16)
    uint8_t index = (i * (16 << (SEGMENT.intensity / 29)) / SEGLEN) + counter;
    setPixelColor(i, color_wheel(index));
  }

  return FRAMETIME;
}

/*
 * Theatre-style crawling lights.
 * Inspired by the Adafruit examples.
 */
uint16_t WS2812FX::mode_theater_chase(void) {
  return running(SEGCOLOR(0), SEGCOLOR(1), true);
}

/*
 * Theatre-style crawling lights with rainbow effect.
 * Inspired by the Adafruit examples.
 */
uint16_t WS2812FX::mode_theater_chase_rainbow(void) {
  return running(color_wheel(SEGENV.step), SEGCOLOR(1), true);
}

/*
 * Running lights effect with smooth sine transition base.
 */
uint16_t WS2812FX::running_base(bool saw, bool dual = false) {
  uint8_t x_scale = SEGMENT.intensity >> 2;
  uint32_t counter = (now * SEGMENT.speed) >> 9;

  for (uint16_t i = 0; i < SEGLEN; i++) {
    uint16_t a = i * x_scale - counter;
    if (saw) {
      a &= 0xFF;
      if (a < 16) {
        a = 192 + a * 8;
      } else {
        a = map(a, 16, 255, 64, 192);
      }
      a = 255 - a;
    }
    uint8_t s = dual ? sin_gap(a) : sin8(a);
    uint32_t ca = color_blend(
        SEGCOLOR(1), color_from_palette(i, true, PALETTE_SOLID_WRAP, 0), s);
    if (dual) {
      uint16_t b = (SEGLEN - 1 - i) * x_scale - counter;
      uint8_t t = sin_gap(b);
      uint32_t cb = color_blend(
          SEGCOLOR(1), color_from_palette(i, true, PALETTE_SOLID_WRAP, 2), t);
      ca = color_blend(ca, cb, 127);
    }
    setPixelColor(i, ca);
  }
  return FRAMETIME;
}

/*
 * Running lights in opposite directions.
 * Idea: Make the gap width controllable with a third slider in the future
 */
uint16_t WS2812FX::mode_running_dual(void) { return running_base(false, true); }

/*
 * Running lights effect with smooth sine transition.
 */
uint16_t WS2812FX::mode_running_lights(void) { return running_base(false); }

/*
 * Running lights effect with sawtooth transition.
 */
uint16_t WS2812FX::mode_saw(void) { return running_base(true); }

/*
 * Blink several LEDs in random colors on, reset, repeat.
 * Inspired by www.tweaking4all.com/hardware/arduino/adruino-led-strip-effects/
 */
uint16_t WS2812FX::mode_twinkle(void) {
  fill(SEGCOLOR(1));

  uint32_t cycleTime = 20 + (255 - SEGMENT.speed) * 5;
  uint32_t it = now / cycleTime;
  if (it != SEGENV.step) {
    uint16_t maxOn = map(SEGMENT.intensity, 0, 255, 1,
                         SEGLEN);  // make sure at least one LED is on
    if (SEGENV.aux0 >= maxOn) {
      SEGENV.aux0 = 0;
      SEGENV.aux1 = random16();  // new seed for our PRNG
    }
    SEGENV.aux0++;
    SEGENV.step = it;
  }

  uint16_t PRNG16 = SEGENV.aux1;

  for (uint16_t i = 0; i < SEGENV.aux0; i++) {
    PRNG16 = (uint16_t)(PRNG16 * 2053) + 13849;  // next 'random' number
    uint32_t p = (uint32_t)SEGLEN * (uint32_t)PRNG16;
    uint16_t j = p >> 16;
    //    setPixelColor(j, color_from_palette(j, true, PALETTE_SOLID_WRAP, 0));
    setPixelColor(
        j, color_blend(SEGCOLOR(1),
                       color_from_palette(j, true, PALETTE_SOLID_WRAP, 0),
                       255));  // This supports RGBW.
  }

  return FRAMETIME;
}

/*
 * Dissolve function
 */
uint16_t WS2812FX::dissolve(uint32_t color) {
  bool wa = (SEGCOLOR(1) != 0 &&
             _brightness < 255);  // workaround, can't compare getPixel to color
                                  // if not full brightness

  for (uint16_t j = 0; j <= SEGLEN / 15; j++) {
    if (random8() <= SEGMENT.intensity) {
      for (uint8_t times = 0; times < 10;
           times++)  // attempt to spawn a new pixel 5 times
      {
        uint16_t i = random16(SEGLEN);
        if (SEGENV.aux0) {  // dissolve to primary/palette
          if (getPixelColor(i) == SEGCOLOR(1) || wa) {
            if (color == SEGCOLOR(0)) {
              setPixelColor(i,
                            color_from_palette(i, true, PALETTE_SOLID_WRAP, 0));
            } else {
              setPixelColor(i, color);
            }
            break;  // only spawn 1 new pixel per frame per 50 LEDs
          }
        } else {  // dissolve to secondary
          if (getPixelColor(i) != SEGCOLOR(1)) {
            setPixelColor(i, SEGCOLOR(1));
            break;
          }
        }
      }
    }
  }

  if (SEGENV.call > (255 - SEGMENT.speed) + 15U) {
    SEGENV.aux0 = !SEGENV.aux0;
    SEGENV.call = 0;
  }

  return FRAMETIME;
}

/*
 * Blink several LEDs on and then off
 */
uint16_t WS2812FX::mode_dissolve(void) { return dissolve(SEGCOLOR(0)); }

/*
 * Blink several LEDs on and then off in random colors
 */
uint16_t WS2812FX::mode_dissolve_random(void) {
  return dissolve(color_wheel(random8()));
}

/*
 * Blinks one LED at a time.
 * Inspired by www.tweaking4all.com/hardware/arduino/adruino-led-strip-effects/
 */
uint16_t WS2812FX::mode_sparkle(void) {
  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 1));
  }
  uint32_t cycleTime = 10 + (255 - SEGMENT.speed) * 2;
  uint32_t it = now / cycleTime;
  if (it != SEGENV.step) {
    SEGENV.aux0 = random16(SEGLEN);  // aux0 stores the random led index
    SEGENV.step = it;
  }

  setPixelColor(SEGENV.aux0, SEGCOLOR(0));
  return FRAMETIME;
}

/*
 * Lights all LEDs in the color. Flashes single col 1 pixels randomly. (List
 * name: Sparkle Dark) Inspired by
 * www.tweaking4all.com/hardware/arduino/adruino-led-strip-effects/
 */
uint16_t WS2812FX::mode_flash_sparkle(void) {
  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 0));
  }

  if (now - SEGENV.aux0 > SEGENV.step) {
    if (random8((255 - SEGMENT.intensity) >> 4) == 0) {
      setPixelColor(random16(SEGLEN), SEGCOLOR(1));  // flash
    }
    SEGENV.step = now;
    SEGENV.aux0 = 255 - SEGMENT.speed;
  }
  return FRAMETIME;
}

/*
 * Like flash sparkle. With more flash.
 * Inspired by www.tweaking4all.com/hardware/arduino/adruino-led-strip-effects/
 */
uint16_t WS2812FX::mode_hyper_sparkle(void) {
  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 0));
  }

  if (now - SEGENV.aux0 > SEGENV.step) {
    if (random8((255 - SEGMENT.intensity) >> 4) == 0) {
      for (uint16_t i = 0; i < max(1, SEGLEN / 3); i++) {
        setPixelColor(random16(SEGLEN), SEGCOLOR(1));
      }
    }
    SEGENV.step = now;
    SEGENV.aux0 = 255 - SEGMENT.speed;
  }
  return FRAMETIME;
}

/*
 * Strobe effect with different strobe count and pause, controlled by speed.
 */
uint16_t WS2812FX::mode_multi_strobe(void) {
  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 1));
  }

  SEGENV.aux0 = 50 + 20 * (uint16_t)(255 - SEGMENT.speed);
  uint16_t count = 2 * ((SEGMENT.intensity / 10) + 1);
  if (SEGENV.aux1 < count) {
    if ((SEGENV.aux1 & 1) == 0) {
      fill(SEGCOLOR(0));
      SEGENV.aux0 = 15;
    } else {
      SEGENV.aux0 = 50;
    }
  }

  if (now - SEGENV.aux0 > SEGENV.step) {
    SEGENV.aux1++;
    if (SEGENV.aux1 > count) SEGENV.aux1 = 0;
    SEGENV.step = now;
  }

  return FRAMETIME;
}

/*
 * Android loading circle
 */
uint16_t WS2812FX::mode_android(void) {
  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 1));
  }

  if (SEGENV.aux1 > ((float)SEGMENT.intensity / 255.0) * (float)SEGLEN) {
    SEGENV.aux0 = 1;
  } else {
    if (SEGENV.aux1 < 2) SEGENV.aux0 = 0;
  }

  uint16_t a = SEGENV.step;

  if (SEGENV.aux0 == 0) {
    if (SEGENV.call % 3 == 1) {
      a++;
    } else {
      SEGENV.aux1++;
    }
  } else {
    a++;
    if (SEGENV.call % 3 != 1) SEGENV.aux1--;
  }

  if (a >= SEGLEN) a = 0;

  if (a + SEGENV.aux1 < SEGLEN) {
    for (int i = a; i < a + SEGENV.aux1; i++) {
      setPixelColor(i, SEGCOLOR(0));
    }
  } else {
    for (int i = a; i < SEGLEN; i++) {
      setPixelColor(i, SEGCOLOR(0));
    }
    for (int i = 0; i < SEGENV.aux1 - (SEGLEN - a); i++) {
      setPixelColor(i, SEGCOLOR(0));
    }
  }
  SEGENV.step = a;

  return 3 + ((8 * (uint32_t)(255 - SEGMENT.speed)) / SEGLEN);
}

/*
 * color chase function.
 * color1 = background color
 * color2 and color3 = colors of two adjacent leds
 */
uint16_t WS2812FX::chase(uint32_t color1, uint32_t color2, uint32_t color3,
                         bool do_palette) {
  uint16_t counter = now * ((SEGMENT.speed >> 2) + 1);
  uint16_t a = counter * SEGLEN >> 16;

  bool chase_random = (SEGMENT.mode == FX_MODE_CHASE_RANDOM);
  if (chase_random) {
    if (a <
        SEGENV
            .step)  // we hit the start again, choose new color for Chase random
    {
      SEGENV.aux1 = SEGENV.aux0;  // store previous random color
      SEGENV.aux0 = get_random_wheel_index(SEGENV.aux0);
    }
    color1 = color_wheel(SEGENV.aux0);
  }
  SEGENV.step = a;

  // Use intensity setting to vary chase up to 1/2 string length
  uint8_t size = 1 + (SEGMENT.intensity * SEGLEN >> 10);

  uint16_t b = a + size;  //"trail" of chase, filled with color1
  if (b > SEGLEN) b -= SEGLEN;
  uint16_t c = b + size;
  if (c > SEGLEN) c -= SEGLEN;

  // background
  if (do_palette) {
    for (uint16_t i = 0; i < SEGLEN; i++) {
      setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 1));
    }
  } else
    fill(color1);

  // if random, fill old background between a and end
  if (chase_random) {
    color1 = color_wheel(SEGENV.aux1);
    for (uint16_t i = a; i < SEGLEN; i++) setPixelColor(i, color1);
  }

  // fill between points a and b with color2
  if (a < b) {
    for (uint16_t i = a; i < b; i++) setPixelColor(i, color2);
  } else {
    for (uint16_t i = a; i < SEGLEN; i++)  // fill until end
      setPixelColor(i, color2);
    for (uint16_t i = 0; i < b; i++)  // fill from start until b
      setPixelColor(i, color2);
  }

  // fill between points b and c with color2
  if (b < c) {
    for (uint16_t i = b; i < c; i++) setPixelColor(i, color3);
  } else {
    for (uint16_t i = b; i < SEGLEN; i++)  // fill until end
      setPixelColor(i, color3);
    for (uint16_t i = 0; i < c; i++)  // fill from start until c
      setPixelColor(i, color3);
  }

  return FRAMETIME;
}

/*
 * Bicolor chase, more primary color.
 */
uint16_t WS2812FX::mode_chase_color(void) {
  return chase(SEGCOLOR(1), (SEGCOLOR(2)) ? SEGCOLOR(2) : SEGCOLOR(0),
               SEGCOLOR(0), true);
}

/*
 * Primary running followed by random color.
 */
uint16_t WS2812FX::mode_chase_random(void) {
  return chase(SEGCOLOR(1), (SEGCOLOR(2)) ? SEGCOLOR(2) : SEGCOLOR(0),
               SEGCOLOR(0), false);
}

/*
 * Primary, secondary running on rainbow.
 */
uint16_t WS2812FX::mode_chase_rainbow(void) {
  uint8_t color_sep = 256 / SEGLEN;
  if (color_sep == 0)
    color_sep = 1;  // correction for segments longer than 256 LEDs
  uint8_t color_index = SEGENV.call & 0xFF;
  uint32_t color =
      color_wheel(((SEGENV.step * color_sep) + color_index) & 0xFF);

  return chase(color, SEGCOLOR(0), SEGCOLOR(1), false);
}

/*
 * Primary running on rainbow.
 */
uint16_t WS2812FX::mode_chase_rainbow_white(void) {
  uint16_t n = SEGENV.step;
  uint16_t m = (SEGENV.step + 1) % SEGLEN;
  uint32_t color2 =
      color_wheel(((n * 256 / SEGLEN) + (SEGENV.call & 0xFF)) & 0xFF);
  uint32_t color3 =
      color_wheel(((m * 256 / SEGLEN) + (SEGENV.call & 0xFF)) & 0xFF);

  return chase(SEGCOLOR(0), color2, color3, false);
}

/*
 * Red - Amber - Green - Blue lights running
 */
uint16_t WS2812FX::mode_colorful(void) {
  uint8_t numColors = 4;  // 3, 4, or 5
  uint32_t cols[9]{0x00FF0000, 0x00EEBB00, 0x0000EE00, 0x000077CC};
  if (SEGMENT.intensity > 160 || SEGMENT.palette) {  // palette or color
    if (!SEGMENT.palette) {
      numColors = 3;
      for (uint8_t i = 0; i < 3; i++) cols[i] = SEGCOLOR(i);
    } else {
      uint16_t fac = 80;
      if (SEGMENT.palette == 52) {
        numColors = 5;
        fac = 61;
      }  // C9 2 has 5 colors
      for (uint8_t i = 0; i < numColors; i++) {
        cols[i] = color_from_palette(i * fac, false, true, 255);
      }
    }
  } else if (SEGMENT.intensity < 80)  // pastel (easter) colors
  {
    cols[0] = 0x00FF8040;
    cols[1] = 0x00E5D241;
    cols[2] = 0x0077FF77;
    cols[3] = 0x0077F0F0;
  }
  for (uint8_t i = numColors; i < numColors * 2 - 1; i++)
    cols[i] = cols[i - numColors];

  uint32_t cycleTime = 50 + (8 * (uint32_t)(255 - SEGMENT.speed));
  uint32_t it = now / cycleTime;
  if (it != SEGENV.step) {
    if (SEGMENT.speed > 0) SEGENV.aux0++;
    if (SEGENV.aux0 >= numColors) SEGENV.aux0 = 0;
    SEGENV.step = it;
  }

  for (uint16_t i = 0; i < SEGLEN; i += numColors) {
    for (uint16_t j = 0; j < numColors; j++)
      setPixelColor(i + j, cols[SEGENV.aux0 + j]);
  }

  return FRAMETIME;
}

/*
 * Emulates a traffic light.
 */
uint16_t WS2812FX::mode_traffic_light(void) {
  for (uint16_t i = 0; i < SEGLEN; i++)
    setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 1));
  uint32_t mdelay = 500;
  for (int i = 0; i < SEGLEN - 2; i += 3) {
    switch (SEGENV.aux0) {
      case 0:
        setPixelColor(i, 0x00FF0000);
        mdelay = 150 + (100 * (uint32_t)(255 - SEGMENT.speed));
        break;
      case 1:
        setPixelColor(i, 0x00FF0000);
        mdelay = 150 + (20 * (uint32_t)(255 - SEGMENT.speed));
        setPixelColor(i + 1, 0x00EECC00);
        break;
      case 2:
        setPixelColor(i + 2, 0x0000FF00);
        mdelay = 150 + (100 * (uint32_t)(255 - SEGMENT.speed));
        break;
      case 3:
        setPixelColor(i + 1, 0x00EECC00);
        mdelay = 150 + (20 * (uint32_t)(255 - SEGMENT.speed));
        break;
    }
  }

  if (now - SEGENV.step > mdelay) {
    SEGENV.aux0++;
    if (SEGENV.aux0 == 1 && SEGMENT.intensity > 140)
      SEGENV.aux0 = 2;  // skip Red + Amber, to get US-style sequence
    if (SEGENV.aux0 > 3) SEGENV.aux0 = 0;
    SEGENV.step = now;
  }

  return FRAMETIME;
}

/*
 * Sec flashes running on prim.
 */
#define FLASH_COUNT 4
uint16_t WS2812FX::mode_chase_flash(void) {
  uint8_t flash_step = SEGENV.call % ((FLASH_COUNT * 2) + 1);

  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 0));
  }

  uint16_t delay = 10 + ((30 * (uint16_t)(255 - SEGMENT.speed)) / SEGLEN);
  if (flash_step < (FLASH_COUNT * 2)) {
    if (flash_step % 2 == 0) {
      uint16_t n = SEGENV.step;
      uint16_t m = (SEGENV.step + 1) % SEGLEN;
      setPixelColor(n, SEGCOLOR(1));
      setPixelColor(m, SEGCOLOR(1));
      delay = 20;
    } else {
      delay = 30;
    }
  } else {
    SEGENV.step = (SEGENV.step + 1) % SEGLEN;
  }
  return delay;
}

/*
 * Prim flashes running, followed by random color.
 */
uint16_t WS2812FX::mode_chase_flash_random(void) {
  uint8_t flash_step = SEGENV.call % ((FLASH_COUNT * 2) + 1);

  for (uint16_t i = 0; i < SEGENV.step; i++) {
    setPixelColor(i, color_wheel(SEGENV.aux0));
  }

  uint16_t delay = 1 + ((10 * (uint16_t)(255 - SEGMENT.speed)) / SEGLEN);
  if (flash_step < (FLASH_COUNT * 2)) {
    uint16_t n = SEGENV.step;
    uint16_t m = (SEGENV.step + 1) % SEGLEN;
    if (flash_step % 2 == 0) {
      setPixelColor(n, SEGCOLOR(0));
      setPixelColor(m, SEGCOLOR(0));
      delay = 20;
    } else {
      setPixelColor(n, color_wheel(SEGENV.aux0));
      setPixelColor(m, SEGCOLOR(1));
      delay = 30;
    }
  } else {
    SEGENV.step = (SEGENV.step + 1) % SEGLEN;

    if (SEGENV.step == 0) {
      SEGENV.aux0 = get_random_wheel_index(SEGENV.aux0);
    }
  }
  return delay;
}

/*
 * Alternating pixels running function.
 */
uint16_t WS2812FX::running(uint32_t color1, uint32_t color2, bool theatre) {
  uint8_t width = (theatre ? 3 : 1) + (SEGMENT.intensity >> 4);  // window
  uint32_t cycleTime = 50 + (255 - SEGMENT.speed);
  uint32_t it = now / cycleTime;
  bool usePalette = color1 == SEGCOLOR(0);

  for (uint16_t i = 0; i < SEGLEN; i++) {
    uint32_t col = color2;
    if (usePalette) color1 = color_from_palette(i, true, PALETTE_SOLID_WRAP, 0);
    if (theatre) {
      if ((i % width) == SEGENV.aux0) col = color1;
    } else {
      int8_t pos = (i % (width << 1));
      if ((pos < SEGENV.aux0 - width) ||
          ((pos >= SEGENV.aux0) && (pos < SEGENV.aux0 + width)))
        col = color1;
    }
    setPixelColor(i, col);
  }

  if (it != SEGENV.step) {
    SEGENV.aux0 = (SEGENV.aux0 + 1) % (theatre ? width : (width << 1));
    SEGENV.step = it;
  }
  return FRAMETIME;
}

/*
 * Alternating color/sec pixels running.
 */
uint16_t WS2812FX::mode_running_color(void) {
  return running(SEGCOLOR(0), SEGCOLOR(1));
}

/*
 * Alternating red/white pixels running.
 */
uint16_t WS2812FX::mode_candy_cane(void) { return running(RED, WHITE); }

/*
 * Alternating orange/purple pixels running.
 */
uint16_t WS2812FX::mode_halloween(void) { return running(PURPLE, ORANGE); }

/*
 * Random colored pixels running. ("Stream")
 */
uint16_t WS2812FX::mode_running_random(void) {
  uint32_t cycleTime = 25 + (3 * (uint32_t)(255 - SEGMENT.speed));
  uint32_t it = now / cycleTime;
  if (SEGENV.call == 0)
    SEGENV.aux0 = random16();  // random seed for PRNG on start

  uint8_t zoneSize = ((255 - SEGMENT.intensity) >> 4) + 1;
  uint16_t PRNG16 = SEGENV.aux0;

  uint8_t z = it % zoneSize;
  bool nzone = (!z && it != SEGENV.aux1);
  for (int i = SEGLEN - 1; i >= 0; i--) {  // WLEDSR bugfix
    if (nzone || z >= zoneSize) {
      uint8_t lastrand = PRNG16 >> 8;
      int16_t diff = 0;
      while (abs(diff) < 42) {  // make sure the difference between adjacent
                                // colors is big enough
        PRNG16 = (uint16_t)(PRNG16 * 2053) +
                 13849;  // next zone, next 'random' number
        diff = (PRNG16 >> 8) - lastrand;
      }
      if (nzone) {
        SEGENV.aux0 = PRNG16;  // save next starting seed
        nzone = false;
      }
      z = 0;
    }
    setPixelColor(i, color_wheel(PRNG16 >> 8));
    z++;
  }

  SEGENV.aux1 = it;
  return FRAMETIME;
}

/*
 * K.I.T.T.
 */
uint16_t WS2812FX::mode_larson_scanner(void) { return larson_scanner(false); }

uint16_t WS2812FX::larson_scanner(bool dual) {
  uint16_t counter = now * ((SEGMENT.speed >> 2) + 8);
  uint16_t index = counter * SEGLEN >> 16;

  fade_out(SEGMENT.intensity);

  if (SEGENV.step > index && SEGENV.step - index > SEGLEN / 2) {
    SEGENV.aux0 = !SEGENV.aux0;
  }

  for (uint16_t i = SEGENV.step; i < index; i++) {
    uint16_t j = (SEGENV.aux0) ? i : SEGLEN - 1 - i;
    setPixelColor(j, color_from_palette(j, true, PALETTE_SOLID_WRAP, 0));
  }
  if (dual) {
    uint32_t c;
    if (SEGCOLOR(2) != 0) {
      c = SEGCOLOR(2);
    } else {
      c = color_from_palette(index, true, PALETTE_SOLID_WRAP, 0);
    }

    for (uint16_t i = SEGENV.step; i < index; i++) {
      uint16_t j = (SEGENV.aux0) ? SEGLEN - 1 - i : i;
      setPixelColor(j, c);
    }
  }

  SEGENV.step = index;
  return FRAMETIME;
}

/*
 * Firing comets from one end. "Lighthouse"
 */
// uint16_t WS2812FX::mode_comet(void) {
//   uint16_t counter = now * ((SEGMENT.speed >> 2) + 1);
//   uint16_t index = counter * SEGLEN >> 16;
//   if (SEGENV.call == 0) SEGENV.aux0 = index;

//   fade_out(SEGMENT.intensity);

//   setPixelColor(index, color_from_palette(index, true, PALETTE_SOLID_WRAP,
//   0)); if (index > SEGENV.aux0) {
//     for (uint16_t i = SEGENV.aux0; i < index; i++) {
//       setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 0));
//     }
//   } else if (index < SEGENV.aux0 && index < 10) {
//     for (uint16_t i = 0; i < index; i++) {
//       setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 0));
//     }
//   }
//   SEGENV.aux0 = index++;

//   return FRAMETIME;
// }
uint16_t WS2812FX::mode_comet(void) {
  // Speed controls fade rate
  uint8_t fadeRate = map(SEGMENT.speed, 0, 255, 224, 255);
  fade_out(fadeRate);

  float bassLevel = 0;
  // Use first 3-4 FFT bins which represent bass frequencies (60-200Hz)
  for (int i = 0; i < 4; i++) {
    bassLevel += fftResult[i];
  }
  bassLevel = bassLevel / 4.0f;  // get average

  uint16_t size = 0;
  uint16_t pos = random(SEGLEN);

  // Only create new comets after previous effect has had time to move based on
  // speed
  static unsigned long lastComet = 0;
  uint16_t minDelay = map(SEGMENT.speed, 0, 255, 100,
                          20);  // Speed also affects frequency of new comets

  if ((bassLevel > soundSquelch * 2) && (millis() - lastComet > minDelay)) {
    size = bassLevel * SEGMENT.intensity / 256 / 4 + 1;
    if (pos + size >= SEGLEN) size = SEGLEN - pos;
    lastComet = millis();
  }

  for (int i = 0; i < size; i++) {
    setPixelColor(pos + i,
                  color_from_palette(millis(), false, PALETTE_SOLID_WRAP, 0));
  }

  return FRAMETIME;
}

/*
 * Fireworks function.
 */
uint16_t WS2812FX::mode_fireworks_core(bool useAudio) {
  fade_out(0);
  if (SEGENV.call == 0) {
    SEGENV.aux0 = UINT16_MAX;
    SEGENV.aux1 = UINT16_MAX;
  }
  bool valid1 = (SEGENV.aux0 < SEGLEN);
  bool valid2 = (SEGENV.aux1 < SEGLEN);
  uint32_t sv1 = 0, sv2 = 0;
  if (valid1) sv1 = getPixelColor(SEGENV.aux0);
  if (valid2) sv2 = getPixelColor(SEGENV.aux1);

  // WLEDSR
  uint8_t blurAmount = 255 - SEGMENT.speed;  // make parameter explicit
  uint8_t my_intensity = 129 - (SEGMENT.intensity >> 1);
  bool addPixels = true;  // false -> inhibit new pixels in silence
  int soundColor = -1;    // -1 = random color; 0..255 = use as palette index

  if (useAudio) {
    if (FFT_MajorPeak < 100) {
      blurAmount = 254;
    }  // big blobs
    else {
      if (FFT_MajorPeak > 3200) {
        blurAmount = 1;
      }  // small blobs
      else {  // blur + color depends on major frequency
        float musicIndex = logf(FFT_MajorPeak);  // log scaling of peak freq
        blurAmount = mapff(musicIndex, 4.60, 8.08, 253,
                           1);  // map to blur range (low freq = more blur)
        blurAmount = constrain(blurAmount, 1,
                               253);  // remove possible "overshot" results
        soundColor =
            mapff(musicIndex, 4.6, 8.08, 0, 255);  // pick color from frequency
      }
    }
    if (sampleAgc <= 1.0) {     // silence -> no new pixels, just blur
      valid1 = valid2 = false;  // do not copy last pixels
      addPixels = false;
      blurAmount = 128;
    }
    my_intensity =
        129 -
        (SEGMENT.speed >>
         1);  // dirty hack: use "speed" slider value intensity (no idea how to
              // _disable_ the first slider, but show the second one)
    if (samplePeak == 1)
      my_intensity -= my_intensity / 4;  // inclease intensity at peaks
    if (samplePeak > 1)
      my_intensity = my_intensity / 2;  // double intensity at main peaks
  }
  // WLEDSR end

  blur(blurAmount);
  if (valid1) setPixelColor(SEGENV.aux0, sv1);
  if (valid2) setPixelColor(SEGENV.aux1, sv2);

  if (addPixels) {  // WLEDSR
    for (uint16_t i = 0; i < max(1, SEGLEN / 20); i++) {
      if (random8(my_intensity) == 0) {
        uint16_t index = random(SEGLEN);
        if (soundColor < 0)
          setPixelColor(index, color_from_palette(random8(), false, false, 0));
        else
          setPixelColor(index, color_from_palette(soundColor + random8(24),
                                                  false, false, 0));  // WLEDSR
        SEGENV.aux1 = SEGENV.aux0;
        SEGENV.aux0 = index;
      }
    }
  }
  return FRAMETIME;
}

uint16_t WS2812FX::mode_fireworks() { return mode_fireworks_core(false); }
uint16_t WS2812FX::mode_fireworks_audio() { return mode_fireworks_core(true); }

// Twinkling LEDs running. Inspired by
// https://github.com/kitesurfer1404/WS2812FX/blob/master/src/custom/Rain.h
uint16_t WS2812FX::mode_rain() {
  SEGENV.step += FRAMETIME;
  if (SEGENV.step > SPEED_FORMULA_L) {
    SEGENV.step = 0;
    // shift all leds left
    uint32_t ctemp = getPixelColor(0);
    for (uint16_t i = 0; i < SEGLEN - 1; i++) {
      setPixelColor(i, getPixelColor(i + 1));
    }
    setPixelColor(SEGLEN - 1, ctemp);
    SEGENV.aux0++;
    SEGENV.aux1++;
    if (SEGENV.aux0 == 0) SEGENV.aux0 = UINT16_MAX;
    if (SEGENV.aux1 == 0) SEGENV.aux0 = UINT16_MAX;
    if (SEGENV.aux0 == SEGLEN) SEGENV.aux0 = 0;
    if (SEGENV.aux1 == SEGLEN) SEGENV.aux1 = 0;
  }
  return mode_fireworks();
}

/*
 * Fire flicker function
 */
uint16_t WS2812FX::mode_fire_flicker(void) {
  uint32_t cycleTime = 40 + (255 - SEGMENT.speed);
  uint32_t it = now / cycleTime;
  if (SEGENV.step == it) return FRAMETIME;

  byte w = (SEGCOLOR(0) >> 24);
  byte r = (SEGCOLOR(0) >> 16);
  byte g = (SEGCOLOR(0) >> 8);
  byte b = (SEGCOLOR(0));
  byte lum = (SEGMENT.palette == 0) ? max(w, max(r, max(g, b))) : 255;
  lum /= (((256 - SEGMENT.intensity) / 16) + 1);
  for (uint16_t i = 0; i < SEGLEN; i++) {
    byte flicker = random8(lum);
    if (SEGMENT.palette == 0) {
      setPixelColor(i, max(r - flicker, 0), max(g - flicker, 0),
                    max(b - flicker, 0), max(w - flicker, 0));
    } else {
      setPixelColor(
          i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 0, 255 - flicker));
    }
  }

  SEGENV.step = it;
  return FRAMETIME;
}

/*
 * Gradient run base function
 */
uint16_t WS2812FX::gradient_base(bool loading) {
  uint16_t counter = now * ((SEGMENT.speed >> 2) + 1);
  uint16_t pp = counter * SEGLEN >> 16;
  if (SEGENV.call == 0) pp = 0;
  float val;  // 0.0 = sec 1.0 = pri
  float brd = loading ? SEGMENT.intensity : SEGMENT.intensity / 2;
  if (brd < 1.0) brd = 1.0;
  int p1 = pp - SEGLEN;
  int p2 = pp + SEGLEN;

  for (uint16_t i = 0; i < SEGLEN; i++) {
    if (loading) {
      val = abs(((i > pp) ? p2 : pp) - i);
    } else {
      val = min(abs(pp - i), min(abs(p1 - i), abs(p2 - i)));
    }
    val = (brd > val) ? val / brd * 255 : 255;
    setPixelColor(
        i,
        color_blend(SEGCOLOR(0),
                    color_from_palette(i, true, PALETTE_SOLID_WRAP, 1), val));
  }

  return FRAMETIME;
}

/*
 * Gradient run
 */
uint16_t WS2812FX::mode_gradient(void) { return gradient_base(false); }

/*
 * Gradient run with hard transition
 */
uint16_t WS2812FX::mode_loading(void) { return gradient_base(true); }

// American Police Light with all LEDs Red and Blue
uint16_t WS2812FX::police_base(uint32_t color1, uint32_t color2) {
  uint16_t delay =
      1 + (FRAMETIME << 3) / SEGLEN;  // longer segments should change faster
  uint32_t it = now / map(SEGMENT.speed, 0, 255, delay << 4, delay);
  uint16_t offset = it % SEGLEN;

  uint16_t width =
      ((SEGLEN * (SEGMENT.intensity + 1)) >> 9);  // max width is half the strip
  if (!width) width = 1;
  for (uint16_t i = 0; i < width; i++) {
    uint16_t indexR = (offset + i) % SEGLEN;
    uint16_t indexB = (offset + i + (SEGLEN >> 1)) % SEGLEN;
    setPixelColor(indexR, color1);
    setPixelColor(indexB, color2);
  }
  return FRAMETIME;
}

// Police Lights Red and Blue
uint16_t WS2812FX::mode_police() {
  fill(SEGCOLOR(1));
  return police_base(RED, BLUE);
}

// Police Lights with custom colors
uint16_t WS2812FX::mode_two_dots() {
  fill(SEGCOLOR(2));
  uint32_t color2 = (SEGCOLOR(1) == SEGCOLOR(2)) ? SEGCOLOR(0) : SEGCOLOR(1);

  return police_base(SEGCOLOR(0), color2);
}

/*
 * Fairy, inspired by https://www.youtube.com/watch?v=zeOw5MZWq24
 */
// 4 bytes
typedef struct Flasher {
  uint16_t stateStart;
  uint8_t stateDur;
  bool stateOn;
} flasher;

#define FLASHERS_PER_ZONE 6
#define MAX_SHIMMER 92

uint16_t WS2812FX::mode_fairy() {
  // set every pixel to a 'random' color from palette (using seed so it doesn't
  // change between frames)
  uint16_t PRNG16 = 5100 + _segment_index;
  for (uint16_t i = 0; i < SEGLEN; i++) {
    PRNG16 = (uint16_t)(PRNG16 * 2053) + 1384;  // next 'random' number
    setPixelColor(i, color_from_palette(PRNG16 >> 8, false, false, 0));
  }

  // amount of flasher pixels depending on intensity (0: none, 255: every LED)
  if (SEGMENT.intensity == 0) return FRAMETIME;
  uint8_t flasherDistance = ((255 - SEGMENT.intensity) / 28) + 1;  // 1-10
  uint16_t numFlashers = (SEGLEN / flasherDistance) + 1;

  uint16_t dataSize = sizeof(flasher) * numFlashers;
  if (!SEGENV.allocateData(dataSize)) return FRAMETIME;  // allocation failed
  Flasher* flashers = reinterpret_cast<Flasher*>(SEGENV.data);
  uint16_t now16 = now & 0xFFFF;

  // Up to 11 flashers in one brightness zone, afterwards a new zone for every 6
  // flashers
  uint16_t zones = numFlashers / FLASHERS_PER_ZONE;
  if (!zones) zones = 1;
  uint8_t flashersInZone = numFlashers / zones;
  uint8_t flasherBri[FLASHERS_PER_ZONE * 2 - 1];

  for (uint16_t z = 0; z < zones; z++) {
    uint16_t flasherBriSum = 0;
    uint16_t firstFlasher = z * flashersInZone;
    if (z == zones - 1)
      flashersInZone = numFlashers - (flashersInZone * (zones - 1));

    for (uint16_t f = firstFlasher; f < firstFlasher + flashersInZone; f++) {
      uint16_t stateTime = now16 - flashers[f].stateStart;
      // random on/off time reached, switch state
      if (stateTime > flashers[f].stateDur * 10) {
        flashers[f].stateOn = !flashers[f].stateOn;
        if (flashers[f].stateOn) {
          flashers[f].stateDur = 12 + random8(12 + ((255 - SEGMENT.speed) >>
                                                    2));  //*10, 250ms to 1250ms
        } else {
          flashers[f].stateDur = 20 + random8(6 + ((255 - SEGMENT.speed) >>
                                                   2));  //*10, 250ms to 1250ms
        }
        // flashers[f].stateDur = 51 + random8(2 + ((255 - SEGMENT.speed) >>
        // 1));
        flashers[f].stateStart = now16;
        if (stateTime < 255) {
          flashers[f].stateStart -=
              255 - stateTime;  // start early to get correct bri
          flashers[f].stateDur += 26 - stateTime / 10;
          stateTime = 255 - stateTime;
        } else {
          stateTime = 0;
        }
      }
      if (stateTime > 255)
        stateTime = 255;  // for flasher brightness calculation, fades in first
                          // 255 ms of state
      // flasherBri[f - firstFlasher] = (flashers[f].stateOn) ? 255-gamma8((510
      // - stateTime) >> 1) : gamma8((510 - stateTime) >> 1);
      flasherBri[f - firstFlasher] =
          (flashers[f].stateOn) ? stateTime : 255 - (stateTime >> 0);
      flasherBriSum += flasherBri[f - firstFlasher];
    }
    // dim factor, to create "shimmer" as other pixels get less voltage if a lot
    // of flashers are on
    uint8_t avgFlasherBri = flasherBriSum / flashersInZone;
    uint8_t globalPeakBri =
        255 - ((avgFlasherBri * MAX_SHIMMER) >>
               8);  // 183-255, suitable for 1/5th of LEDs flashers

    for (uint16_t f = firstFlasher; f < firstFlasher + flashersInZone; f++) {
      uint8_t bri = (flasherBri[f - firstFlasher] * globalPeakBri) / 255;
      PRNG16 = (uint16_t)(PRNG16 * 2053) + 1384;  // next 'random' number
      uint16_t flasherPos = f * flasherDistance;
      setPixelColor(
          flasherPos,
          color_blend(SEGCOLOR(1),
                      color_from_palette(PRNG16 >> 8, false, false, 0), bri));
      for (uint16_t i = flasherPos + 1;
           i < flasherPos + flasherDistance && i < SEGLEN; i++) {
        PRNG16 = (uint16_t)(PRNG16 * 2053) + 1384;  // next 'random' number
        setPixelColor(
            i, color_from_palette(PRNG16 >> 8, false, false, 0, globalPeakBri));
      }
    }
  }
  return FRAMETIME;
}

/*
 * Fairytwinkle. Like Colortwinkle, but starting from all lit and not relying on
 * getPixelColor Warning: Uses 4 bytes of segment data per pixel
 */
uint16_t WS2812FX::mode_fairytwinkle() {
  uint16_t dataSize = sizeof(flasher) * SEGLEN;
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed
  Flasher* flashers = reinterpret_cast<Flasher*>(SEGENV.data);
  uint16_t now16 = now & 0xFFFF;
  uint16_t PRNG16 = 5100 + _segment_index;

  uint16_t riseFallTime = 400 + (255 - SEGMENT.speed) * 3;
  uint16_t maxDur = riseFallTime / 100 + ((255 - SEGMENT.intensity) >> 2) + 13 +
                    ((255 - SEGMENT.intensity) >> 1);

  for (uint16_t f = 0; f < SEGLEN; f++) {
    uint16_t stateTime = now16 - flashers[f].stateStart;
    // random on/off time reached, switch state
    if (stateTime > flashers[f].stateDur * 100) {
      flashers[f].stateOn = !flashers[f].stateOn;
      bool init = !flashers[f].stateDur;
      if (flashers[f].stateOn) {
        flashers[f].stateDur =
            riseFallTime / 100 + ((255 - SEGMENT.intensity) >> 2) +
            random8(12 + ((255 - SEGMENT.intensity) >> 1)) + 1;
      } else {
        flashers[f].stateDur =
            riseFallTime / 100 + random8(3 + ((255 - SEGMENT.speed) >> 6)) + 1;
      }
      flashers[f].stateStart = now16;
      stateTime = 0;
      if (init) {
        flashers[f].stateStart -= riseFallTime;  // start lit
        flashers[f].stateDur = riseFallTime / 100 +
                               random8(12 + ((255 - SEGMENT.intensity) >> 1)) +
                               5;  // fire up a little quicker
        stateTime = riseFallTime;
      }
    }
    if (flashers[f].stateOn && flashers[f].stateDur > maxDur)
      flashers[f].stateDur = maxDur;  // react more quickly on intensity change
    if (stateTime > riseFallTime)
      stateTime = riseFallTime;  // for flasher brightness calculation, fades in
                                 // first 255 ms of state
    uint8_t fadeprog = 255 - ((stateTime * 255) / riseFallTime);
    uint8_t flasherBri =
        (flashers[f].stateOn) ? 255 - gamma8(fadeprog) : gamma8(fadeprog);
    uint16_t lastR = PRNG16;
    uint16_t diff = 0;
    while (diff <
           0x4000) {  // make sure colors of two adjacent LEDs differ enough
      PRNG16 = (uint16_t)(PRNG16 * 2053) + 1384;  // next 'random' number
      diff = (PRNG16 > lastR) ? PRNG16 - lastR : lastR - PRNG16;
    }
    setPixelColor(f,
                  color_blend(SEGCOLOR(1),
                              color_from_palette(PRNG16 >> 8, false, false, 0),
                              flasherBri));
  }
  return FRAMETIME;
}

/*
 * Tricolor chase function
 */
uint16_t WS2812FX::tricolor_chase(uint32_t color1, uint32_t color2) {
  uint32_t cycleTime = 50 + ((255 - SEGMENT.speed) << 1);
  uint32_t it = now / cycleTime;  // iterator
  uint8_t width =
      (1 + (SEGMENT.intensity >> 4));  // value of 1-16 for each colour
  uint8_t index = it % (width * 3);

  for (uint16_t i = 0; i < SEGLEN; i++, index++) {
    if (index > (width * 3) - 1) index = 0;

    uint32_t color = color1;
    if (index > (width << 1) - 1)
      color = color_from_palette(i, true, PALETTE_SOLID_WRAP, 1);
    else if (index > width - 1)
      color = color2;

    setPixelColor(SEGLEN - i - 1, color);
  }
  return FRAMETIME;
}

/*
 * Tricolor chase mode
 */
uint16_t WS2812FX::mode_tricolor_chase(void) {
  return tricolor_chase(SEGCOLOR(2), SEGCOLOR(0));
}

/*
 * ICU mode
 */
uint16_t WS2812FX::mode_icu(void) {
  uint16_t dest = SEGENV.step & 0xFFFF;
  uint8_t space = (SEGMENT.intensity >> 3) + 2;

  fill(SEGCOLOR(1));

  byte pindex = map(dest, 0, SEGLEN - SEGLEN / space, 0, 255);
  uint32_t col = color_from_palette(pindex, false, false, 0);

  setPixelColor(dest, col);
  setPixelColor(dest + SEGLEN / space, col);

  if (SEGENV.aux0 == dest) {  // pause between eye movements
    if (random8(6) == 0) {    // blink once in a while
      setPixelColor(dest, SEGCOLOR(1));
      setPixelColor(dest + SEGLEN / space, SEGCOLOR(1));
      return 200;
    }
    SEGENV.aux0 = random16(SEGLEN - SEGLEN / space);
    return 1000 + random16(2000);
  }

  if (SEGENV.aux0 > SEGENV.step) {
    SEGENV.step++;
    dest++;
  } else if (SEGENV.aux0 < SEGENV.step) {
    SEGENV.step--;
    dest--;
  }

  setPixelColor(dest, col);
  setPixelColor(dest + SEGLEN / space, col);

  return SPEED_FORMULA_L;
}

/*
 * Custom mode by Aircoookie. Color Wipe, but with 3 colors
 */
uint16_t WS2812FX::mode_tricolor_wipe(void) {
  uint32_t cycleTime = 1000 + (255 - SEGMENT.speed) * 200;
  uint32_t perc = now % cycleTime;
  uint16_t prog = (perc * 65535) / cycleTime;
  uint16_t ledIndex = (prog * SEGLEN * 3) >> 16;
  uint16_t ledOffset = ledIndex;

  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 2));
  }

  if (ledIndex < SEGLEN) {  // wipe from 0 to 1
    for (uint16_t i = 0; i < SEGLEN; i++) {
      setPixelColor(i, (i > ledOffset) ? SEGCOLOR(0) : SEGCOLOR(1));
    }
  } else if (ledIndex < SEGLEN * 2) {  // wipe from 1 to 2
    ledOffset = ledIndex - SEGLEN;
    for (uint16_t i = ledOffset + 1; i < SEGLEN; i++) {
      setPixelColor(i, SEGCOLOR(1));
    }
  } else  // wipe from 2 to 0
  {
    ledOffset = ledIndex - SEGLEN * 2;
    for (uint16_t i = 0; i <= ledOffset; i++) {
      setPixelColor(i, SEGCOLOR(0));
    }
  }

  return FRAMETIME;
}

/*
 * Fades between 3 colors
 * Custom mode by Keith Lord:
 * https://github.com/kitesurfer1404/WS2812FX/blob/master/src/custom/TriFade.h
 * Modified by Aircoookie
 */
uint16_t WS2812FX::mode_tricolor_fade(void) {
  uint16_t counter = now * ((SEGMENT.speed >> 3) + 1);
  uint32_t prog = (counter * 768) >> 16;

  uint32_t color1 = 0, color2 = 0;
  byte stage = 0;

  if (prog < 256) {
    color1 = SEGCOLOR(0);
    color2 = SEGCOLOR(1);
    stage = 0;
  } else if (prog < 512) {
    color1 = SEGCOLOR(1);
    color2 = SEGCOLOR(2);
    stage = 1;
  } else {
    color1 = SEGCOLOR(2);
    color2 = SEGCOLOR(0);
    stage = 2;
  }

  byte stp = prog;  // % 256
  for (uint16_t i = 0; i < SEGLEN; i++) {
    uint32_t color;
    if (stage == 2) {
      color = color_blend(color_from_palette(i, true, PALETTE_SOLID_WRAP, 2),
                          color2, stp);
    } else if (stage == 1) {
      color = color_blend(
          color1, color_from_palette(i, true, PALETTE_SOLID_WRAP, 2), stp);
    } else {
      color = color_blend(color1, color2, stp);
    }
    setPixelColor(i, color);
  }

  return FRAMETIME;
}

/*
 * Creates random comets
 * Custom mode by Keith Lord:
 * https://github.com/kitesurfer1404/WS2812FX/blob/master/src/custom/MultiComet.h
 */
#define MAX_COMETS 12  // was 8
uint16_t WS2812FX::mode_multi_comet_core(bool useAudio) {
  uint32_t cycleTime = 10 + (uint32_t)(255 - SEGMENT.speed);
  uint32_t it = now / cycleTime;
  if (!SEGENV.allocateData(sizeof(uint16_t) * MAX_COMETS))
    return mode_static();  // allocation failed
  uint16_t* comets = reinterpret_cast<uint16_t*>(SEGENV.data);

  if (SEGENV.call == 0) {  // do some initializations
    for (uint8_t i = 0; i < MAX_COMETS; i++)
      comets[i] = SEGLEN;  // WLEDSR make sure comments are startedindividually
    SEGENV.aux0 = 0;
  }

  if (SEGENV.step == it) return FRAMETIME;

  uint16_t armed = SEGENV.aux0;  // WELDSR allows to delay comet launch
  bool shotOne = false;  // WLEDSR avoids starting several coments at thesame
                         // time (invisible due to overlap)
  fade_out(SEGMENT.intensity);

  for (uint8_t i = 0; i < MAX_COMETS; i++) {
    if (comets[i] < SEGLEN) {
      uint16_t index = comets[i];
      if (SEGCOLOR(2) != 0) {
        setPixelColor(index, i % 2 ? color_from_palette(index, true,
                                                        PALETTE_SOLID_WRAP, 0)
                                   : SEGCOLOR(2));
      } else {
        setPixelColor(index,
                      color_from_palette(index, true, PALETTE_SOLID_WRAP, 0));
      }
      comets[i]++;
    } else {
      // randomly launch a new comet
      if (!useAudio) {
        if (!random(SEGLEN) && !shotOne) {
          comets[i] = 0;
          shotOne = true;  // WLEDSR avoid starting several comets at once(as
                           // they are invisible)
        }
      } else {  // WLEDSR delay comet "launch" during silence, and wait until
                // next beat
        if (random(SEGLEN) < 5) armed++;  // new comet loaded and ready
        if (armed > 2) armed = 2;  // max two armed at once (avoid overlap)
        if ((armed > 0) && (shotOne == false) && (sampleAgc > 1.0) &&
            ((samplePeak > 1) ||
             (int(rawSampleAgc) > 112))) {  // delayed lauch - wait until peak,
          // don't launch in silence
          comets[i] = 0;  // start a new comet!
          armed--;        // un-arm one
          shotOne = true;
        }
      }
    }
  }

  SEGENV.aux0 = armed;  // WLEDSR
  SEGENV.step = it;
  return FRAMETIME;
}
// uint16_t WS2812FX::mode_multi_comet_core(
//     bool useAudio) {  // TODO Modified version with bass response

//   uint16_t maxRipples = 16;
//   uint16_t dataSize = sizeof(ripple) * maxRipples;

//   if (!SEGENV.allocateData(dataSize)) return mode_static();  // allocation
//                                                              // failed
//   Ripple* ripples = reinterpret_cast<Ripple*>(SEGENV.data);

//   // fadeToBlackBy(leds, 64);
//   uint8_t fadeRate = map(SEGMENT.speed, 0, 255, 224, 255);
//   fade_out(fadeRate);

//   float bassLevel = 0;
//   // Use first 4 FFT bins (bass frequencies ~60-200Hz)
//   for (int i = 0; i < 4; i++) {
//     bassLevel += fftResult[i];
//   }
//   bassLevel = bassLevel / 4.0f;  // get average

//   for (int i = 0; i < SEGMENT.intensity / 16 + 1;
//        i++) {  // Limit the number of ripples
//     if (useAudio) {
//       // Only spawn new ripples based on bass level for audio mode
//       if ((bassLevel > soundSquelch * 2) &&
//           (random8() < 24)) {  // reduced chance of spawning
//         ripples[i].state = -1;
//       }
//     } else {
//       // Original non-audio trigger
//       if (random8((255 - SEGMENT.intensity) >> 4) == 0) {
//         ripples[i].state = -1;
//       }
//     }

//     switch (ripples[i].state) {
//       case -2:  // Inactive mode
//         break;

//       case -1:  // Initialize ripple variables
//         ripples[i].pos = random16(SEGLEN);

//         if (useAudio) {
//           // Use bass level to influence color and intensity
//           uint8_t colorVar =
//               bassLevel / 2;  // reduce range to avoid too much variation
// #ifdef ESP32
//           ripples[i].color = (int)(log10f(FFT_MajorPeak) * 128) + colorVar;
// #else
//           ripples[i].color = random8() + colorVar;
// #endif
//         } else {
// #ifdef ESP32
//           ripples[i].color = (int)(log10f(FFT_MajorPeak) * 128);
// #else
//           ripples[i].color = random8();
// #endif
//         }

//         ripples[i].state = 0;
//         break;

//       case 0:  // Middle of the ripple
//         setPixelColor(
//             ripples[i].pos,
//             color_blend(SEGCOLOR(1),
//                         color_from_palette(ripples[i].color, false,
//                                            PALETTE_SOLID_WRAP, 0),
//                         useAudio ? (uint8_t)min(bassLevel * 2, 255.0f) :
//                         255));
//         ripples[i].state++;
//         break;

//       case maxsteps:  // At the end of the ripples. -2 is an inactive mode.
//         ripples[i].state = -2;
//         break;

//       default:  // Middle of the ripples
//         int16_t index = ripples[i].pos;
//         uint8_t width = useAudio ? (2 + (bassLevel / 64))
//                                  : 2;  // dynamic width based on bass

//         // Draw pixels on either side of the center
//         for (int j = -width; j <= width; j++) {
//           uint16_t thisPos = (index + j + SEGLEN) % SEGLEN;
//           setPixelColor(
//               thisPos,
//               color_blend(SEGCOLOR(1),
//                           color_from_palette(ripples[i].color, false,
//                                              PALETTE_SOLID_WRAP, 0),
//                           useAudio ? (uint8_t)min(
//                                          (bassLevel / ripples[i].state),
//                                          255.0f)
//                                    : (255 / ripples[i].state)));
//         }
//         ripples[i].state++;  // Next step.
//         break;
//     }
//   }

//   return FRAMETIME;
// }

// normal multi-comet
uint16_t WS2812FX::mode_multi_comet(void) {
  return (mode_multi_comet_core(false));
}
// audioresponsive multi-comet
uint16_t WS2812FX::mode_multi_comet_audio(void) {
  return (mode_multi_comet_core(true));
}

/*
 * Creates two Larson scanners moving in opposite directions
 * Custom mode by Keith Lord:
 * https://github.com/kitesurfer1404/WS2812FX/blob/master/src/custom/DualLarson.h
 */
uint16_t WS2812FX::mode_dual_larson_scanner(void) {
  return larson_scanner(true);
}

/*
 * Running random pixels ("Stream 2")
 * Custom mode by Keith Lord:
 * https://github.com/kitesurfer1404/WS2812FX/blob/master/src/custom/RandomChase.h
 */
uint16_t WS2812FX::mode_random_chase(void) {
  if (SEGENV.call == 0) {
    SEGENV.step = RGBW32(random8(), random8(), random8(), 0);
    SEGENV.aux0 = random16();
  }
  uint16_t prevSeed = random16_get_seed();  // save seed so we can restore it at
                                            // the end of the function
  uint32_t cycleTime = 25 + (3 * (uint32_t)(255 - SEGMENT.speed));
  uint32_t it = now / cycleTime;
  uint32_t color = SEGENV.step;
  random16_set_seed(SEGENV.aux0);

  for (int i = SEGLEN - 1; i >= 0; i--) {  // WLEDSR bugfix
    uint8_t r = random8(6) != 0 ? (color >> 16 & 0xFF) : random8();
    uint8_t g = random8(6) != 0 ? (color >> 8 & 0xFF) : random8();
    uint8_t b = random8(6) != 0 ? (color & 0xFF) : random8();
    color = RGBW32(r, g, b, 0);
    setPixelColor(i, r, g, b);
    if (i == SEGLEN - 1 &&
        SEGENV.aux1 != (it & 0xFFFF)) {  // new first color in next frame
      SEGENV.step = color;
      SEGENV.aux0 = random16_get_seed();
    }
  }

  SEGENV.aux1 = it & 0xFFFF;

  random16_set_seed(prevSeed);  // restore original seed so other effects can
                                // use "random" PRNG
  return FRAMETIME;
}

// 7 bytes
typedef struct Oscillator {
  int16_t pos;
  int8_t size;
  int8_t dir;
  int8_t speed;
} oscillator;

/*
/  Oscillating bars of color, updated with standard framerate
*/
uint16_t WS2812FX::mode_oscillate(void) {
  uint8_t numOscillators = 3;
  uint16_t dataSize = sizeof(oscillator) * numOscillators;

  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed

  Oscillator* oscillators = reinterpret_cast<Oscillator*>(SEGENV.data);

  if (SEGENV.call == 0) {
    oscillators[0] = {(int16_t)(SEGLEN / 4), (int8_t)(SEGLEN / 8), 1, 1};
    oscillators[1] = {(int16_t)(SEGLEN / 4 * 3), (int8_t)(SEGLEN / 8), 1, 2};
    oscillators[2] = {(int16_t)(SEGLEN / 4 * 2), (int8_t)(SEGLEN / 8), -1, 1};
  }

  uint32_t cycleTime = 20 + (2 * (uint32_t)(255 - SEGMENT.speed));
  uint32_t it = now / cycleTime;

  for (uint8_t i = 0; i < numOscillators; i++) {
    // if the counter has increased, move the oscillator by the random step
    if (it != SEGENV.step)
      oscillators[i].pos += oscillators[i].dir * oscillators[i].speed;
    oscillators[i].size = SEGLEN / (3 + SEGMENT.intensity / 8);
    if ((oscillators[i].dir == -1) && (oscillators[i].pos <= 0)) {
      oscillators[i].pos = 0;
      oscillators[i].dir = 1;
      // make bigger steps for faster speeds
      oscillators[i].speed =
          SEGMENT.speed > 100 ? random8(2, 4) : random8(1, 3);
    }
    if ((oscillators[i].dir == 1) && (oscillators[i].pos >= (SEGLEN - 1))) {
      oscillators[i].pos = SEGLEN - 1;
      oscillators[i].dir = -1;
      oscillators[i].speed =
          SEGMENT.speed > 100 ? random8(2, 4) : random8(1, 3);
    }
  }

  for (uint16_t i = 0; i < SEGLEN; i++) {
    uint32_t color = BLACK;
    for (uint8_t j = 0; j < numOscillators; j++) {
      if (i >= oscillators[j].pos - oscillators[j].size &&
          i <= oscillators[j].pos + oscillators[j].size) {
        color = (color == BLACK) ? SEGCOLOR(j)
                                 : color_blend(color, SEGCOLOR(j), 128);
      }
    }
    setPixelColor(i, color);
  }

  SEGENV.step = it;
  return FRAMETIME;
}

uint16_t WS2812FX::mode_lightning(void) {
  uint16_t ledstart = random16(SEGLEN);  // Determine starting location of flash
  uint16_t ledlen =
      1 +
      random16(
          SEGLEN -
          ledstart);  // Determine length of flash (not to go beyond NUM_LEDS-1)
  uint8_t bri = 255 / random8(1, 3);

  if (SEGENV.aux1 == 0)  // init, leader flash
  {
    SEGENV.aux1 = random8(4, 4 + SEGMENT.intensity / 20);  // number of flashes
    SEGENV.aux1 *= 2;

    bri = 52;           // leader has lower brightness
    SEGENV.aux0 = 200;  // 200ms delay after leader
  }

  fill(SEGCOLOR(1));

  if (SEGENV.aux1 > 3 && !(SEGENV.aux1 & 0x01)) {  // flash on even number >2
    for (int i = ledstart; i < ledstart + ledlen; i++) {
      setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 0, bri));
    }
    SEGENV.aux1--;

    SEGENV.step = millis();
    // return random8(4, 10); // each flash only lasts one frame/every 24ms...
    // originally 4-10 milliseconds
  } else {
    if (millis() - SEGENV.step > SEGENV.aux0) {
      SEGENV.aux1--;
      if (SEGENV.aux1 < 2) SEGENV.aux1 = 0;

      SEGENV.aux0 = (50 + random8(100));  // delay between flashes
      if (SEGENV.aux1 == 2) {
        SEGENV.aux0 =
            (random8(255 - SEGMENT.speed) * 100);  // delay between strikes
      }
      SEGENV.step = millis();
    }
  }
  return FRAMETIME;
}

// Pride2015
// Animated, ever-changing rainbows.
// by Mark Kriegsman: https://gist.github.com/kriegsman/964de772d64c502760e5
uint16_t WS2812FX::mode_pride_2015(void) {
  uint16_t duration = 10 + SEGMENT.speed;
  uint16_t sPseudotime = SEGENV.step;
  uint16_t sHue16 = SEGENV.aux0;

  uint8_t sat8 = beatsin88(87, 220, 250);
  uint8_t brightdepth = beatsin88(341, 96, 224);
  uint16_t brightnessthetainc16 = beatsin88(203, (25 * 256), (40 * 256));
  uint8_t msmultiplier = beatsin88(147, 23, 60);

  uint16_t hue16 = sHue16;  // gHue * 256;
  uint16_t hueinc16 = beatsin88(113, 1, 3000);

  sPseudotime += duration * msmultiplier;
  sHue16 += duration * beatsin88(400, 5, 9);
  uint16_t brightnesstheta16 = sPseudotime;
  CRGB fastled_col;

  for (uint16_t i = 0; i < SEGLEN; i++) {
    hue16 += hueinc16;
    uint8_t hue8 = hue16 >> 8;

    brightnesstheta16 += brightnessthetainc16;
    uint16_t b16 = sin16(brightnesstheta16) + 32768;

    uint16_t bri16 = (uint32_t)((uint32_t)b16 * (uint32_t)b16) / 65536;
    uint8_t bri8 = (uint32_t)(((uint32_t)bri16) * brightdepth) / 65536;
    bri8 += (255 - brightdepth);

    CRGB newcolor = CHSV(hue8, sat8, bri8);
    fastled_col = col_to_crgb(getPixelColor(i));

    nblend(fastled_col, newcolor, 64);
    setPixelColor(i, fastled_col.red, fastled_col.green, fastled_col.blue);
  }
  SEGENV.step = sPseudotime;
  SEGENV.aux0 = sHue16;
  return FRAMETIME;
}

// eight colored dots, weaving in and out of sync with each other
uint16_t WS2812FX::mode_juggle(void) {
  fade_out(SEGMENT.intensity);
  CRGB fastled_col;
  byte dothue = 0;
  for (byte i = 0; i < 8; i++) {
    uint16_t index =
        0 + beatsin88((128 + SEGMENT.speed) * (i + 7), 0, SEGLEN - 1);
    fastled_col = col_to_crgb(getPixelColor(index));
    fastled_col |= (SEGMENT.palette == 0)
                       ? CHSV(dothue, 220, 255)
                       : ColorFromPalette(currentPalette, dothue, 255);
    setPixelColor(index, fastled_col.red, fastled_col.green, fastled_col.blue);
    dothue += 32;
  }
  return FRAMETIME;
}

uint16_t WS2812FX::mode_palette_core(bool useAudio) {
  uint16_t counter = 0;
  uint16_t cooldown = 0;  // WLEDSR
  bool fadeOut =
      (useAudio && (sampleAgc < 1));  // WLEDSR - fade away when silence

  // WLEDSR
  if (useAudio) {
    // binNum = SEGMENT.custom2;                               // Select a bin
    // for peak detection. maxVol = SEGMENT.custom3/2; // Our volume comparator.
    if (SEGENV.call == 0) {  // initialize a few things
      counter = (now * ((SEGMENT.speed >> 3) + 1)) & 0xFFFF;
      counter = counter >> 8;
      SEGENV.aux0 = counter;
      SEGENV.aux1 = 64;
    }

    counter = SEGENV.aux0;
    cooldown = SEGENV.aux1;
    if ((sampleAgc > 1) &&
        ((samplePeak > 1) ||
         (samplePeak > 0 && (SEGMENT.speed < 48 || SEGMENT.speed > 252)))) {
      // start rotating on beat
      cooldown = 12 + (SEGMENT.speed >> 2) + 1;
    }
    // keep rotating after beat
    if (cooldown > 0) {
      cooldown--;
      counter += (SEGMENT.speed >> 2) + 4;
      counter += (cooldown >> 2);
    }
    SEGENV.aux0 = counter;
    SEGENV.aux1 = cooldown;
    counter = counter >> 5;
    counter = counter & 0xFF;
    // WLEDSR end

  } else {
    if (SEGMENT.speed != 0) {
      counter = (now * ((SEGMENT.speed >> 3) + 1)) & 0xFFFF;
      counter = counter >> 8;
    }
  }

  if (fadeOut)
    fade_out(6);  // WLEDSR: fade away
  else {
    bool noWrap =
        (paletteBlend == 2 || (paletteBlend == 0 && SEGMENT.speed == 0));
    for (uint16_t i = 0; i < SEGLEN; i++) {
      uint8_t colorIndex = (i * 255 / SEGLEN) - counter;

      if (noWrap)
        colorIndex =
            map(colorIndex, 0, 255, 0, 240);  // cut off blend at palette "end"

      setPixelColor(i, color_from_palette(colorIndex, false, true, 255));
    }
  }
  return FRAMETIME;
}

uint16_t WS2812FX::mode_palette(void) {
  // standard version
  return mode_palette_core(false);
}
uint16_t WS2812FX::mode_palette_audio(void) {
  // audioresponsive version: fades out in silence, rotates at beat
  return mode_palette_core(true);
}

// WLED limitation: Analog Clock overlay will NOT work when Fire2012 is active
// Fire2012 by Mark Kriegsman, July 2012
// as part of "Five Elements" shown here: http://youtu.be/knWiGsmgycY
////
// This basic one-dimensional 'fire' simulation works roughly as follows:
// There's a underlying array of 'heat' cells, that model the temperature
// at each point along the line.  Every cycle through the simulation,
// four steps are performed:
//  1) All cells cool down a little bit, losing heat to the air
//  2) The heat from each cell drifts 'up' and diffuses a little
//  3) Sometimes randomly new 'sparks' of heat are added at the bottom
//  4) The heat from each cell is rendered as a color into the leds array
//     The heat-to-color mapping uses a black-body radiation approximation.
//
// Temperature is in arbitrary units from 0 (cold black) to 255 (white hot).
//
// This simulation scales it self a bit depending on NUM_LEDS; it should look
// "OK" on anywhere from 20 to 100 LEDs without too much tweaking.
//
// I recommend running this simulation at anywhere from 30-100 frames per
// second, meaning an interframe delay of about 10-35 milliseconds.
//
// Looks best on a high-density LED setup (60+ pixels/meter).
//
//
// There are two main parameters you can play with to control the look and
// feel of your fire: COOLING (used in step 1 above) (Speed = COOLING), and
// SPARKING (used in step 3 above) (Effect Intensity = Sparking).

uint16_t WS2812FX::mode_fire_2012() {
  uint32_t it = now >> 5;  // div 32

  if (!SEGENV.allocateData(SEGLEN)) return mode_static();  // allocation failed

  byte* heat = SEGENV.data;

  if (it != SEGENV.step) {
    uint8_t ignition = max(
        7, SEGLEN /
               10);  // ignition area: 10% of segment length or minimum 7 pixels

    // Step 1.  Cool down every cell a little
    for (uint16_t i = 0; i < SEGLEN; i++) {
      uint8_t temp = qsub8(
          heat[i], random8(0, (((20 + SEGMENT.speed / 3) * 10) / SEGLEN) + 2));
      heat[i] = (temp == 0 && i < ignition)
                    ? 16
                    : temp;  // prevent ignition area from becoming black
    }

    // Step 2.  Heat from each cell drifts 'up' and diffuses a little
    for (uint16_t k = SEGLEN - 1; k > 1; k--) {
      heat[k] =
          (heat[k - 1] + (heat[k - 2] << 1)) / 3;  // heat[k-2] multiplied by 2
    }

    // Step 3.  Randomly ignite new 'sparks' of heat near the bottom
    if (random8() <= SEGMENT.intensity) {
      uint8_t y = random8(ignition);
      if (y < SEGLEN) heat[y] = qadd8(heat[y], random8(160, 255));
    }
    SEGENV.step = it;
  }

  // Step 4.  Map from heat cells to LED colors
  for (uint16_t j = 0; j < SEGLEN; j++) {
    CRGB color = ColorFromPalette(currentPalette, min(heat[j], (byte)240), 255U,
                                  LINEARBLEND);
    setPixelColor(j, color.red, color.green, color.blue);
  }
  return FRAMETIME;
}

// ColorWavesWithPalettes by Mark Kriegsman:
// https://gist.github.com/kriegsman/8281905786e8b2632aeb This function draws
// color waves with an ever-changing, widely-varying set of parameters, using a
// color palette.
uint16_t WS2812FX::mode_colorwaves() {
  uint16_t duration = 10 + SEGMENT.speed;
  uint16_t sPseudotime = SEGENV.step;
  uint16_t sHue16 = SEGENV.aux0;

  uint8_t brightdepth = beatsin88(341, 96, 224);
  uint16_t brightnessthetainc16 = beatsin88(203, (25 * 256), (40 * 256));
  uint8_t msmultiplier = beatsin88(147, 23, 60);

  uint16_t hue16 = sHue16;  // gHue * 256;
  // uint16_t hueinc16 = beatsin88(113, 300, 1500);
  uint16_t hueinc16 = beatsin88(113, 60, 300) * SEGMENT.intensity * 10 /
                      255;  // Use the Intensity Slider for the hues

  sPseudotime += duration * msmultiplier;
  sHue16 += duration * beatsin88(400, 5, 9);
  uint16_t brightnesstheta16 = sPseudotime;
  CRGB fastled_col;

  for (uint16_t i = 0; i < SEGLEN; i++) {
    hue16 += hueinc16;
    uint8_t hue8 = hue16 >> 8;
    uint16_t h16_128 = hue16 >> 7;
    if (h16_128 & 0x100) {
      hue8 = 255 - (h16_128 >> 1);
    } else {
      hue8 = h16_128 >> 1;
    }

    brightnesstheta16 += brightnessthetainc16;
    uint16_t b16 = sin16(brightnesstheta16) + 32768;

    uint16_t bri16 = (uint32_t)((uint32_t)b16 * (uint32_t)b16) / 65536;
    uint8_t bri8 = (uint32_t)(((uint32_t)bri16) * brightdepth) / 65536;
    bri8 += (255 - brightdepth);

    CRGB newcolor = ColorFromPalette(currentPalette, hue8, bri8);
    fastled_col = col_to_crgb(getPixelColor(i));

    nblend(fastled_col, newcolor, 128);
    setPixelColor(i, fastled_col.red, fastled_col.green, fastled_col.blue);
  }
  SEGENV.step = sPseudotime;
  SEGENV.aux0 = sHue16;
  return FRAMETIME;
}

// colored stripes pulsing at a defined Beats-Per-Minute (BPM)
uint16_t WS2812FX::mode_bpm() {
  //  CRGB fastled_col;
  uint32_t stp = (now / 20) & 0xFF;
  uint8_t beat = beatsin8(SEGMENT.speed, 64, 255);
  for (uint16_t i = 0; i < SEGLEN; i++) {
    //    fastled_col = ColorFromPalette(currentPalette, stp + (i * 2), beat -
    //    stp + (i * 10)); setPixelColor(i, fastled_col.red, fastled_col.green,
    //    fastled_col.blue);
    setPixelColor(
        i, color_blend(
               SEGCOLOR(1),
               color_from_palette(stp + (i * 2), false, PALETTE_SOLID_WRAP, 0),
               beat - stp + (i * 10)));  // This supports RGBW.
  }
  return FRAMETIME;
}

uint16_t WS2812FX::mode_fillnoise8() {
  if (SEGENV.call == 0) SEGENV.step = random16(12345);
  CRGB fastled_col;
  for (uint16_t i = 0; i < SEGLEN; i++) {
    uint8_t index = inoise8(i * SEGLEN, SEGENV.step + i * SEGLEN);
    fastled_col = ColorFromPalette(currentPalette, index, 255, LINEARBLEND);
    setPixelColor(i, fastled_col.red, fastled_col.green, fastled_col.blue);
  }
  SEGENV.step += beatsin8(SEGMENT.speed, 1, 6);  // 10,1,4

  return FRAMETIME;
}

uint16_t WS2812FX::mode_noise16_1() {
  uint16_t scale = 320;  // the "zoom factor" for the noise
  CRGB fastled_col;
  SEGENV.step += (1 + SEGMENT.speed / 16);

  for (uint16_t i = 0; i < SEGLEN; i++) {
    uint16_t shift_x =
        beatsin8(11);  // the x position of the noise field swings @ 17 bpm
    uint16_t shift_y =
        SEGENV.step / 42;  // the y position becomes slowly incremented

    uint16_t real_x =
        (i + shift_x) *
        scale;  // the x position of the noise field swings @ 17 bpm
    uint16_t real_y =
        (i + shift_y) * scale;  // the y position becomes slowly incremented
    uint32_t real_z =
        SEGENV.step;  // the z position becomes quickly incremented

    uint8_t noise = inoise16(real_x, real_y, real_z) >>
                    8;  // get the noise data and scale it down

    uint8_t index = sin8(noise * 3);  // map LED color based on noise data

    fastled_col = ColorFromPalette(
        currentPalette, index, 255,
        LINEARBLEND);  // With that value, look up the 8 bit colour palette
                       // value and assign it to the current LED.
    setPixelColor(i, fastled_col.red, fastled_col.green, fastled_col.blue);
  }

  return FRAMETIME;
}

uint16_t WS2812FX::mode_noise16_2() {
  uint16_t scale = 1000;  // the "zoom factor" for the noise
                          //  CRGB fastled_col;
  SEGENV.step += (1 + (SEGMENT.speed >> 1));

  for (uint16_t i = 0; i < SEGLEN; i++) {
    uint16_t shift_x = SEGENV.step >> 6;  // x as a function of time

    uint32_t real_x =
        (i + shift_x) *
        scale;  // calculate the coordinates within the noise field

    uint8_t noise =
        inoise16(real_x, 0, 4223) >> 8;  // get the noise data and scale it down

    uint8_t index = sin8(noise * 3);  // map led color based on noise data

    //    fastled_col = ColorFromPalette(currentPalette, index, noise,
    //    LINEARBLEND);   // With that value, look up the 8 bit colour palette
    //    value and assign it to the current LED. setPixelColor(i,
    //    fastled_col.red, fastled_col.green, fastled_col.blue);
    setPixelColor(
        i, color_blend(SEGCOLOR(1),
                       color_from_palette(index, false, PALETTE_SOLID_WRAP, 0),
                       noise));  // This supports RGBW.
  }

  return FRAMETIME;
}

uint16_t WS2812FX::mode_noise16_3() {
  uint16_t scale = 800;  // the "zoom factor" for the noise
                         //  CRGB fastled_col;
  SEGENV.step += (1 + SEGMENT.speed);

  for (uint16_t i = 0; i < SEGLEN; i++) {
    uint16_t shift_x = 4223;  // no movement along x and y
    uint16_t shift_y = 1234;

    uint32_t real_x =
        (i + shift_x) *
        scale;  // calculate the coordinates within the noise field
    uint32_t real_y =
        (i + shift_y) * scale;  // based on the precalculated positions
    uint32_t real_z = SEGENV.step * 8;

    uint8_t noise = inoise16(real_x, real_y, real_z) >>
                    8;  // get the noise data and scale it down

    uint8_t index = sin8(noise * 3);  // map led color based on noise data

    //    fastled_col = ColorFromPalette(currentPalette, index, noise,
    //    LINEARBLEND);   // With that value, look up the 8 bit colour palette
    //    value and assign it to the current LED. setPixelColor(i,
    //    fastled_col.red, fastled_col.green, fastled_col.blue);
    setPixelColor(
        i, color_blend(SEGCOLOR(1),
                       color_from_palette(index, false, PALETTE_SOLID_WRAP, 0),
                       noise));  // This supports RGBW.
  }

  return FRAMETIME;
}

// https://github.com/aykevl/ledstrip-spark/blob/master/ledstrip.ino
uint16_t WS2812FX::mode_noise16_4() {
  CRGB fastled_col;
  uint32_t stp = (now * SEGMENT.speed) >> 7;
  for (uint16_t i = 0; i < SEGLEN; i++) {
    int16_t index = inoise16(uint32_t(i) << 12, stp);
    fastled_col = ColorFromPalette(currentPalette, index);
    setPixelColor(i, fastled_col.red, fastled_col.green, fastled_col.blue);
  }
  return FRAMETIME;
}

// based on https://gist.github.com/kriegsman/5408ecd397744ba0393e
uint16_t WS2812FX::mode_colortwinkle() {
  uint16_t dataSize = (SEGLEN + 7) >> 3;  // 1 bit per LED
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed

  CRGB fastled_col, prev;
  fract8 fadeUpAmount =
             _brightness > 28 ? 8 + (SEGMENT.speed >> 2) : 68 - _brightness,
         fadeDownAmount =
             _brightness > 28 ? 8 + (SEGMENT.speed >> 3) : 68 - _brightness;
  for (uint16_t i = 0; i < SEGLEN; i++) {
    fastled_col = col_to_crgb(getPixelColor(i));
    prev = fastled_col;
    uint16_t index = i >> 3;
    uint8_t bitNum = i & 0x07;
    bool fadeUp = bitRead(SEGENV.data[index], bitNum);

    if (fadeUp) {
      CRGB incrementalColor = fastled_col;
      incrementalColor.nscale8_video(fadeUpAmount);
      fastled_col += incrementalColor;

      if (fastled_col.red == 255 || fastled_col.green == 255 ||
          fastled_col.blue == 255) {
        bitWrite(SEGENV.data[index], bitNum, false);
      }
      setPixelColor(i, fastled_col.red, fastled_col.green, fastled_col.blue);

      if (col_to_crgb(getPixelColor(i)) == prev) {  // fix "stuck" pixels
        fastled_col += fastled_col;
        setPixelColor(i, fastled_col.red, fastled_col.green, fastled_col.blue);
      }
    } else {
      fastled_col.nscale8(255 - fadeDownAmount);
      setPixelColor(i, fastled_col.red, fastled_col.green, fastled_col.blue);
    }
  }

  for (uint16_t j = 0; j <= SEGLEN / 50; j++) {
    if (random8() <= SEGMENT.intensity) {
      for (uint8_t times = 0; times < 5;
           times++) {  // attempt to spawn a new pixel 5 times
        int i = random16(SEGLEN);
        if (getPixelColor(i) == 0) {
          fastled_col =
              ColorFromPalette(currentPalette, random8(), 64, NOBLEND);
          uint16_t index = i >> 3;
          uint8_t bitNum = i & 0x07;
          bitWrite(SEGENV.data[index], bitNum, true);
          setPixelColor(i, fastled_col.red, fastled_col.green,
                        fastled_col.blue);
          break;  // only spawn 1 new pixel per frame per 50 LEDs
        }
      }
    }
  }
  return FRAMETIME_FIXED;
}

// Calm effect, like a lake at night
uint16_t WS2812FX::mode_lake() {
  uint8_t sp = SEGMENT.speed / 10;
  int wave1 = beatsin8(sp + 2, -64, 64);
  int wave2 = beatsin8(sp + 1, -64, 64);
  uint8_t wave3 = beatsin8(sp + 2, 0, 80);
  //  CRGB fastled_col;

  for (uint16_t i = 0; i < SEGLEN; i++) {
    int index = cos8((i * 15) + wave1) / 2 + cubicwave8((i * 23) + wave2) / 2;
    uint8_t lum = (index > wave3) ? index - wave3 : 0;
    //    fastled_col = ColorFromPalette(currentPalette, map(index,0,255,0,240),
    //    lum, LINEARBLEND); setPixelColor(i, fastled_col.red,
    //    fastled_col.green, fastled_col.blue);
    setPixelColor(
        i, color_blend(SEGCOLOR(1),
                       color_from_palette(map(index, 0, 255, 0, 240), false,
                                          PALETTE_SOLID_WRAP, 0),
                       lum));  // This supports RGBW.
  }
  return FRAMETIME;
}

// meteor effect
// send a meteor from begining to to the end of the strip with a trail that
// randomly decays. adapted from
// https://www.tweaking4all.com/hardware/arduino/adruino-led-strip-effects/#LEDStripEffectMeteorRain
uint16_t WS2812FX::mode_meteor() {
  if (!SEGENV.allocateData(SEGLEN)) return mode_static();  // allocation failed

  byte* trail = SEGENV.data;

  byte meteorSize = 1 + SEGLEN / 10;
  uint16_t counter = now * ((SEGMENT.speed >> 2) + 8);
  uint16_t in = counter * SEGLEN >> 16;

  // fade all leds to colors[1] in LEDs one step
  for (uint16_t i = 0; i < SEGLEN; i++) {
    if (random8() <= 255 - SEGMENT.intensity) {
      byte meteorTrailDecay = 128 + random8(127);
      trail[i] = scale8(trail[i], meteorTrailDecay);
      setPixelColor(i, color_from_palette(trail[i], false, true, 255));
    }
  }

  // draw meteor
  for (int j = 0; j < meteorSize; j++) {
    uint16_t index = in + j;
    if (index >= SEGLEN) {
      index = (in + j - SEGLEN);
    }

    trail[index] = 240;
    setPixelColor(index, color_from_palette(trail[index], false, true, 255));
  }

  return FRAMETIME;
}

// smooth meteor effect
// send a meteor from begining to to the end of the strip with a trail that
// randomly decays. adapted from
// https://www.tweaking4all.com/hardware/arduino/adruino-led-strip-effects/#LEDStripEffectMeteorRain
uint16_t WS2812FX::mode_meteor_smooth() {
  if (!SEGENV.allocateData(SEGLEN)) return mode_static();  // allocation failed

  byte* trail = SEGENV.data;

  byte meteorSize = 1 + SEGLEN / 10;
  uint16_t in = map((SEGENV.step >> 6 & 0xFF), 0, 255, 0, SEGLEN - 1);

  // fade all leds to colors[1] in LEDs one step
  for (uint16_t i = 0; i < SEGLEN; i++) {
    if (trail[i] != 0 && random8() <= 255 - SEGMENT.intensity) {
      int change = 3 - random8(12);  // change each time between -8 and +3
      trail[i] += change;
      if (trail[i] > 245) trail[i] = 0;
      if (trail[i] > 240) trail[i] = 240;
      setPixelColor(i, color_from_palette(trail[i], false, true, 255));
    }
  }

  // draw meteor
  for (int j = 0; j < meteorSize; j++) {
    uint16_t index = in + j;
    if (in + j >= SEGLEN) {
      index = (in + j - SEGLEN);
    }
    setPixelColor(index,
                  color_blend(getPixelColor(index),
                              color_from_palette(240, false, true, 255), 48));
    trail[index] = 240;
  }

  SEGENV.step += SEGMENT.speed + 1;
  return FRAMETIME;
}

// Railway Crossing / Christmas Fairy lights
uint16_t WS2812FX::mode_railway() {
  uint16_t dur = 40 + (255 - SEGMENT.speed) * 10;
  uint16_t rampdur = (dur * SEGMENT.intensity) >> 8;
  if (SEGENV.step > dur) {
    // reverse direction
    SEGENV.step = 0;
    SEGENV.aux0 = !SEGENV.aux0;
  }
  uint8_t pos = 255;
  if (rampdur != 0) {
    uint16_t p0 = (SEGENV.step * 255) / rampdur;
    if (p0 < 255) pos = p0;
  }
  if (SEGENV.aux0) pos = 255 - pos;
  for (uint16_t i = 0; i < SEGLEN; i += 2) {
    setPixelColor(i, color_from_palette(255 - pos, false, false, 255));
    if (i < SEGLEN - 1) {
      setPixelColor(i + 1, color_from_palette(pos, false, false, 255));
    }
  }
  SEGENV.step += FRAMETIME;
  return FRAMETIME;
}

// Water ripple
// propagation velocity from speed
// drop rate from intensity

// 4 bytes
typedef struct Ripple {
  int8_t state;  // WLEDSR AC has uint8_t while value can be negative???
  uint8_t color;
  uint16_t pos;
} ripple;

#ifdef ESP8266
#define MAX_RIPPLES 56
#else
#define MAX_RIPPLES 100
#endif
uint16_t WS2812FX::ripple_base(bool rainbow) {
  uint16_t maxRipples =
      min(1 + (SEGLEN >> 2), MAX_RIPPLES);  // 56 max for 16 segment ESP8266
  uint16_t dataSize = sizeof(ripple) * maxRipples;

  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed

  Ripple* ripples = reinterpret_cast<Ripple*>(SEGENV.data);

  // ranbow background or chosen background, all very dim.
  if (rainbow) {
    if (SEGENV.call == 0) {
      SEGENV.aux0 = random8();
      SEGENV.aux1 = random8();
    }
    if (SEGENV.aux0 == SEGENV.aux1) {
      SEGENV.aux1 = random8();
    } else if (SEGENV.aux1 > SEGENV.aux0) {
      SEGENV.aux0++;
    } else {
      SEGENV.aux0--;
    }
    fill(color_blend(color_wheel(SEGENV.aux0), BLACK, 235));
  } else {
    fill(SEGCOLOR(1));
  }

  // draw wave
  for (uint16_t i = 0; i < maxRipples; i++) {
    uint16_t ripplestate = ripples[i].state;
    if (ripplestate) {
      uint8_t rippledecay =
          (SEGMENT.speed >> 4) + 1;  // faster decay if faster propagation
      uint16_t rippleorigin = ripples[i].pos;
      uint32_t col = color_from_palette(ripples[i].color, false, false, 255);
      uint16_t propagation = ((ripplestate / rippledecay - 1) * SEGMENT.speed);
      int16_t propI = propagation >> 8;
      uint8_t propF = propagation & 0xFF;
      int16_t left = rippleorigin - propI - 1;
      uint8_t amp = (ripplestate < 17) ? triwave8((ripplestate - 1) * 8)
                                       : map(ripplestate, 17, 255, 255, 2);

      for (int16_t v = left; v < left + 4; v++) {
        uint8_t mag = scale8(cubicwave8((propF >> 2) + (v - left) * 64), amp);
        if (v < SEGLEN && v >= 0) {
          setPixelColor(v, color_blend(getPixelColor(v), col, mag));
        }
        int16_t w = left + propI * 2 + 3 - (v - left);
        if (w < SEGLEN && w >= 0) {
          setPixelColor(w, color_blend(getPixelColor(w), col, mag));
        }
      }
      ripplestate += rippledecay;
      ripples[i].state = (ripplestate > 254) ? 0 : ripplestate;
    } else  // randomly create new wave
    {
      if (random16(IBN + 10000) <= SEGMENT.intensity) {
        ripples[i].state = 1;
        ripples[i].pos = random16(SEGLEN);
        ripples[i].color = random8();  // color
      }
    }
  }
  return FRAMETIME;
}
#undef MAX_RIPPLES

uint16_t WS2812FX::mode_ripple(void) { return ripple_base(false); }

uint16_t WS2812FX::mode_ripple_rainbow(void) { return ripple_base(true); }

//  TwinkleFOX by Mark Kriegsman:
//  https://gist.github.com/kriegsman/756ea6dcae8e30845b5a
//
//  TwinkleFOX: Twinkling 'holiday' lights that fade in and out.
//  Colors are chosen from a palette. Read more about this effect using the link
//  above!

// If COOL_LIKE_INCANDESCENT is set to 1, colors will
// fade out slighted 'reddened', similar to how
// incandescent bulbs change color as they get dim down.
#define COOL_LIKE_INCANDESCENT 1

CRGB IRAM_ATTR WS2812FX::twinklefox_one_twinkle(uint32_t ms, uint8_t salt,
                                                bool cat) {
  // Overall twinkle speed (changed)
  uint16_t ticks = ms / SEGENV.aux0;
  uint8_t fastcycle8 = ticks;
  uint16_t slowcycle16 = (ticks >> 8) + salt;
  slowcycle16 += sin8(slowcycle16);
  slowcycle16 = (slowcycle16 * 2053) + 1384;
  uint8_t slowcycle8 = (slowcycle16 & 0xFF) + (slowcycle16 >> 8);

  // Overall twinkle density.
  // 0 (NONE lit) to 8 (ALL lit at once).
  // Default is 5.
  uint8_t twinkleDensity = (SEGMENT.intensity >> 5) + 1;

  uint8_t bright = 0;
  if (((slowcycle8 & 0x0E) / 2) < twinkleDensity) {
    uint8_t ph = fastcycle8;
    // This is like 'triwave8', which produces a
    // symmetrical up-and-down triangle sawtooth waveform, except that this
    // function produces a triangle wave with a faster attack and a slower decay
    if (cat)  // twinklecat, variant where the leds instantly turn on
    {
      bright = 255 - ph;
    } else {  // vanilla twinklefox
      if (ph < 86) {
        bright = ph * 3;
      } else {
        ph -= 86;
        bright = 255 - (ph + (ph / 2));
      }
    }
  }

  uint8_t hue = slowcycle8 - salt;
  CRGB c;
  if (bright > 0) {
    c = ColorFromPalette(currentPalette, hue, bright, NOBLEND);
    if (COOL_LIKE_INCANDESCENT == 1) {
      // This code takes a pixel, and if its in the 'fading down'
      // part of the cycle, it adjusts the color a little bit like the
      // way that incandescent bulbs fade toward 'red' as they dim.
      if (fastcycle8 >= 128) {
        uint8_t cooling = (fastcycle8 - 128) >> 4;
        c.g = qsub8(c.g, cooling);
        c.b = qsub8(c.b, cooling * 2);
      }
    }
  } else {
    c = CRGB::Black;
  }
  return c;
}

//  This function loops over each pixel, calculates the
//  adjusted 'clock' that this pixel should use, and calls
//  "CalculateOneTwinkle" on each pixel.  It then displays
//  either the twinkle color of the background color,
//  whichever is brighter.
uint16_t WS2812FX::twinklefox_base(bool cat) {
  // "PRNG16" is the pseudorandom number generator
  // It MUST be reset to the same starting value each time
  // this function is called, so that the sequence of 'random'
  // numbers that it generates is (paradoxically) stable.
  uint16_t PRNG16 = 11337;

  // Calculate speed
  if (SEGMENT.speed > 100)
    SEGENV.aux0 = 3 + ((255 - SEGMENT.speed) >> 3);
  else
    SEGENV.aux0 = 22 + ((100 - SEGMENT.speed) >> 1);

  // Set up the background color, "bg".
  CRGB bg;
  bg = col_to_crgb(SEGCOLOR(1));
  uint8_t bglight = bg.getAverageLight();
  if (bglight > 64) {
    bg.nscale8_video(16);  // very bright, so scale to 1/16th
  } else if (bglight > 16) {
    bg.nscale8_video(64);  // not that bright, so scale to 1/4th
  } else {
    bg.nscale8_video(86);  // dim, scale to 1/3rd.
  }

  uint8_t backgroundBrightness = bg.getAverageLight();

  for (uint16_t i = 0; i < SEGLEN; i++) {
    PRNG16 = (uint16_t)(PRNG16 * 2053) + 1384;  // next 'random' number
    uint16_t myclockoffset16 = PRNG16;  // use that number as clock offset
    PRNG16 = (uint16_t)(PRNG16 * 2053) + 1384;  // next 'random' number
    // use that number as clock speed adjustment factor (in 8ths, from 8/8ths to
    // 23/8ths)
    uint8_t myspeedmultiplierQ5_3 =
        ((((PRNG16 & 0xFF) >> 4) + (PRNG16 & 0x0F)) & 0x0F) + 0x08;
    uint32_t myclock30 =
        (uint32_t)((now * myspeedmultiplierQ5_3) >> 3) + myclockoffset16;
    uint8_t myunique8 = PRNG16 >> 8;  // get 'salt' value for this pixel

    // We now have the adjusted 'clock' for this pixel, now we call
    // the function that computes what color the pixel should be based
    // on the "brightness = f( time )" idea.
    CRGB c = twinklefox_one_twinkle(myclock30, myunique8, cat);

    uint8_t cbright = c.getAverageLight();
    int16_t deltabright = cbright - backgroundBrightness;
    if (deltabright >= 32 || (!bg)) {
      // If the new pixel is significantly brighter than the background color,
      // use the new color.
      setPixelColor(i, c.red, c.green, c.blue);
    } else if (deltabright > 0) {
      // If the new pixel is just slightly brighter than the background color,
      // mix a blend of the new color and the background color
      setPixelColor(
          i, color_blend(crgb_to_col(bg), crgb_to_col(c), deltabright * 8));
    } else {
      // if the new pixel is not at all brighter than the background color,
      // just use the background color.
      setPixelColor(i, bg.r, bg.g, bg.b);
    }
  }
  return FRAMETIME;
}

uint16_t WS2812FX::mode_twinklefox() { return twinklefox_base(false); }

uint16_t WS2812FX::mode_twinklecat() { return twinklefox_base(true); }

// inspired by
// https://www.tweaking4all.com/hardware/arduino/adruino-led-strip-effects/#LEDStripEffectBlinkingHalloweenEyes
#define HALLOWEEN_EYE_SPACE 3
#define HALLOWEEN_EYE_WIDTH 1

uint16_t WS2812FX::mode_halloween_eyes() {
  uint16_t eyeLength = (2 * HALLOWEEN_EYE_WIDTH) + HALLOWEEN_EYE_SPACE;
  if (eyeLength > SEGLEN) return mode_static();  // bail if segment too short

  fill(SEGCOLOR(1));  // fill background

  uint8_t state = SEGENV.aux1 >> 8;
  uint16_t stateTime = SEGENV.call;
  if (stateTime == 0) stateTime = 2000;

  if (state == 0) {                                 // spawn eyes
    SEGENV.aux0 = random16(0, SEGLEN - eyeLength);  // start pos
    SEGENV.aux1 = random8();                        // color
    state = 1;
  }

  if (state < 2) {  // fade eyes
    uint16_t startPos = SEGENV.aux0;
    uint16_t start2ndEye = startPos + HALLOWEEN_EYE_WIDTH + HALLOWEEN_EYE_SPACE;

    uint32_t fadestage = (now - SEGENV.step) * 255 / stateTime;
    if (fadestage > 255) fadestage = 255;
    uint32_t c =
        color_blend(color_from_palette(SEGENV.aux1 & 0xFF, false, false, 0),
                    SEGCOLOR(1), fadestage);

    for (uint16_t i = 0; i < HALLOWEEN_EYE_WIDTH; i++) {
      setPixelColor(startPos + i, c);
      setPixelColor(start2ndEye + i, c);
    }
  }

  if (now - SEGENV.step > stateTime) {
    state++;
    if (state > 2) state = 0;

    if (state < 2) {
      stateTime = 100 + (255 - SEGMENT.intensity) * 10;  // eye fade time
    } else {
      uint16_t eyeOffTimeBase = (255 - SEGMENT.speed) * 10;
      stateTime = eyeOffTimeBase + random16(eyeOffTimeBase);
    }
    SEGENV.step = now;
    SEGENV.call = stateTime;
  }

  SEGENV.aux1 = (SEGENV.aux1 & 0xFF) + (state << 8);  // save state

  return FRAMETIME;
}

// Speed slider sets amount of LEDs lit, intensity sets unlit
uint16_t WS2812FX::mode_static_pattern() {
  uint16_t lit = 1 + SEGMENT.speed;
  uint16_t unlit = 1 + SEGMENT.intensity;
  bool drawingLit = true;
  uint16_t cnt = 0;

  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(i, (drawingLit)
                         ? color_from_palette(i, true, PALETTE_SOLID_WRAP, 0)
                         : SEGCOLOR(1));
    cnt++;
    if (cnt >= ((drawingLit) ? lit : unlit)) {
      cnt = 0;
      drawingLit = !drawingLit;
    }
  }

  return FRAMETIME;
}

uint16_t WS2812FX::mode_tri_static_pattern() {
  uint8_t segSize = (SEGMENT.intensity >> 5) + 1;
  uint8_t currSeg = 0;
  uint16_t currSegCount = 0;

  for (uint16_t i = 0; i < SEGLEN; i++) {
    if (currSeg % 3 == 0) {
      setPixelColor(i, SEGCOLOR(0));
    } else if (currSeg % 3 == 1) {
      setPixelColor(i, SEGCOLOR(1));
    } else {
      setPixelColor(i, (SEGCOLOR(2) > 0 ? SEGCOLOR(2) : WHITE));
    }
    currSegCount += 1;
    if (currSegCount >= segSize) {
      currSeg += 1;
      currSegCount = 0;
    }
  }

  return FRAMETIME;
}

uint16_t WS2812FX::spots_base(uint16_t threshold) {
  fill(SEGCOLOR(1));

  uint16_t maxZones = SEGLEN >> 2;
  uint16_t zones = 1 + ((SEGMENT.intensity * maxZones) >> 8);
  uint16_t zoneLen = SEGLEN / zones;
  uint16_t offset = (SEGLEN - zones * zoneLen) >> 1;

  for (uint16_t z = 0; z < zones; z++) {
    uint16_t pos = offset + z * zoneLen;
    for (uint16_t i = 0; i < zoneLen; i++) {
      uint16_t wave = triwave16((i * 0xFFFF) / zoneLen);
      if (wave > threshold) {
        uint16_t index = 0 + pos + i;
        uint8_t s = (wave - threshold) * 255 / (0xFFFF - threshold);
        setPixelColor(
            index,
            color_blend(color_from_palette(index, true, PALETTE_SOLID_WRAP, 0),
                        SEGCOLOR(1), 255 - s));
      }
    }
  }

  return FRAMETIME;
}

// Intensity slider sets number of "lights", speed sets LEDs per light
uint16_t WS2812FX::mode_spots() {
  return spots_base((255 - SEGMENT.speed) << 8);
}

// Intensity slider sets number of "lights", LEDs per light fade in and out
uint16_t WS2812FX::mode_spots_fade() {
  uint16_t counter = now * ((SEGMENT.speed >> 2) + 8);
  uint16_t t = triwave16(counter);
  uint16_t tr = (t >> 1) + (t >> 2);
  return spots_base(tr);
}

// each needs 12 bytes
typedef struct Ball {
  unsigned long lastBounceTime;
  float impactVelocity;
  float height;
} ball;

/*
 *  Bouncing Balls Effect
 */
uint16_t WS2812FX::mode_bouncing_balls(void) {
  // allocate segment data
  uint16_t maxNumBalls = 16;
  uint16_t dataSize = sizeof(ball) * maxNumBalls;
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed

  Ball* balls = reinterpret_cast<Ball*>(SEGENV.data);

  // number of balls based on intensity setting to max of 7 (cycles colors)
  // non-chosen color is a random color
  uint8_t numBalls =
      int(((SEGMENT.intensity * (maxNumBalls - 0.8f)) / 255) + 1);

  float gravity = -9.81;  // standard value of gravity
  float impactVelocityStart = sqrtf(-2 * gravity);

  unsigned long time = millis();

  if (SEGENV.call == 0) {
    for (uint8_t i = 0; i < maxNumBalls; i++) balls[i].lastBounceTime = time;
  }

  bool hasCol2 = SEGCOLOR(2);
  fill(hasCol2 ? BLACK : SEGCOLOR(1));

  for (uint8_t i = 0; i < numBalls; i++) {
    float timeSinceLastBounce = (time - balls[i].lastBounceTime) /
                                ((255 - SEGMENT.speed) * 8 / 256 + 1);
    float timeSinceLastBounceMs = timeSinceLastBounce / 1000.0f;
    balls[i].height =
        0.5 * gravity * (timeSinceLastBounceMs * timeSinceLastBounceMs) +
        balls[i].impactVelocity * timeSinceLastBounceMs;

    if (balls[i].height < 0) {  // start bounce
      balls[i].height = 0;
      // damping for better effect using multiple balls
      float dampening = 0.90 - float(i) / (numBalls * numBalls);
      balls[i].impactVelocity = dampening * balls[i].impactVelocity;
      balls[i].lastBounceTime = time;

      if (balls[i].impactVelocity < 0.015) {
        balls[i].impactVelocity = impactVelocityStart;
      }
    }

    uint32_t color = SEGCOLOR(0);
    if (SEGMENT.palette) {
      color = color_wheel(i * (256 / max(numBalls, (uint8_t)8)));
    } else if (hasCol2) {
      color = SEGCOLOR(i % NUM_COLORS);
    }

    uint16_t pos = round(balls[i].height * (SEGLEN - 1));
    setPixelColor(pos, color);
  }

  return FRAMETIME;
}

/*
 * Sinelon stolen from FASTLED examples
 */
uint16_t WS2812FX::sinelon_base(bool dual, bool rainbow = false) {
  fade_out(SEGMENT.intensity);
  uint16_t pos = beatsin16(SEGMENT.speed / 10, 0, SEGLEN - 1);
  if (SEGENV.call == 0) SEGENV.aux0 = pos;
  uint32_t color1 = color_from_palette(pos, true, false, 0);
  uint32_t color2 = SEGCOLOR(2);
  if (rainbow) {
    color1 = color_wheel((pos & 0x07) * 32);
  }
  setPixelColor(pos, color1);
  if (dual) {
    if (!color2) color2 = color_from_palette(pos, true, false, 0);
    if (rainbow) color2 = color1;  // rainbow
    setPixelColor(SEGLEN - 1 - pos, color2);
  }
  if (SEGENV.aux0 != pos) {
    if (SEGENV.aux0 < pos) {
      for (int i = SEGENV.aux0; i < pos; i++) {  // WLEDSR bugfix
        setPixelColor(i, color1);
        if (dual) setPixelColor(SEGLEN - 1 - i, color2);
      }
    } else {
      for (int i = SEGENV.aux0; i > pos; i--) {  // WLEDSR bugfix
        setPixelColor(i, color1);
        if (dual) setPixelColor(SEGLEN - 1 - i, color2);
      }
    }
    SEGENV.aux0 = pos;
  }

  return FRAMETIME;
}

uint16_t WS2812FX::mode_sinelon(void) { return sinelon_base(false); }

uint16_t WS2812FX::mode_sinelon_dual(void) { return sinelon_base(true); }

uint16_t WS2812FX::mode_sinelon_rainbow(void) {
  return sinelon_base(false, true);
}

// Rainbow with glitter, inspired by
// https://gist.github.com/kriegsman/062e10f7f07ba8518af6
uint16_t WS2812FX::mode_glitter() {
  mode_palette();

  if (SEGMENT.intensity > random8()) {
    setPixelColor(random16(SEGLEN), ULTRAWHITE);
  }

  return FRAMETIME;
}

// each needs 12 bytes
// Spark type is used for popcorn, 1D fireworks, and drip
typedef struct Spark {
  float pos;
  float vel;
  uint16_t col;
  uint8_t colIndex;
} spark;

/*
 *  POPCORN
 *  modified from
 * https://github.com/kitesurfer1404/WS2812FX/blob/master/src/custom/Popcorn.h
 */
uint16_t WS2812FX::mode_popcorn_core(bool useAudio) {
  // allocate segment data
  // constexpr uint16_t maxNumPopcorn = 21; // max 21 on 16 segment ESP8266
  constexpr uint16_t maxNumPopcorn = 29;  // WLEDSR - max 29 on 16 segment ESP32
  constexpr uint16_t dataSize = sizeof(spark) * maxNumPopcorn;
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed

  Spark* popcorn = reinterpret_cast<Spark*>(SEGENV.data);

  float gravity = -0.0001 - (SEGMENT.speed / 200000.0);  // m/s/s
  gravity *= SEGLEN;

  bool hasCol2 = SEGCOLOR(2);
  fill(hasCol2 ? BLACK : SEGCOLOR(1));
  // fade_out(253);

  uint8_t numPopcorn =
      (unsigned)SEGMENT.intensity * (unsigned)maxNumPopcorn / 255;
  if (numPopcorn == 0) numPopcorn = 1;

  for (uint8_t i = 0; i < numPopcorn; i++) {
    if (popcorn[i].pos >= 0.0f) {  // if kernel is active, update its position
      popcorn[i].pos += popcorn[i].vel;
      popcorn[i].vel += gravity;
    } else {  // if kernel is inactive, randomly pop it
      bool doPopCorn = false;
      if (!useAudio) {
        if (random8() < 2) doPopCorn = true;
      } else {
        if ((sampleAgc > 1.0)  // WLEDSR - no pops in silence
            && ((samplePeak > 0) ||
                (int(rawSampleAgc) > 128))  // WLEDSR - try to pop at onsets
            && (random8() < 4))             // WLEDSR - randomize
          doPopCorn = true;
      }

      if (doPopCorn) {  // POP!!!
        popcorn[i].pos = 0.01f;

        uint16_t peakHeight = 128 + random8(128);  // 0-255
        peakHeight = (peakHeight * (SEGLEN - 1)) >> 8;
        popcorn[i].vel = sqrtf(-2.0 * gravity * peakHeight);

        if (SEGMENT.palette) {
          popcorn[i].colIndex = random8();
        } else {
          byte col = random8(0, NUM_COLORS);
          if (!hasCol2 || !SEGCOLOR(col)) col = 0;
          popcorn[i].colIndex = col;
        }
      }
    }
    if (popcorn[i].pos >= 0.0f) {  // draw now active popcorn (either active
                                   // before or just popped)
      uint32_t col = color_wheel(popcorn[i].colIndex);
      if (!SEGMENT.palette && popcorn[i].colIndex < NUM_COLORS)
        col = SEGCOLOR(popcorn[i].colIndex);
      uint16_t ledIndex = popcorn[i].pos;
      if (ledIndex < SEGLEN) setPixelColor(ledIndex, col);
    }
  }

  return FRAMETIME;
}

uint16_t WS2812FX::mode_popcorn(void) { return (mode_popcorn_core(false)); }
uint16_t WS2812FX::mode_popcorn_audio(void) {
  return (mode_popcorn_core(true));
}

// values close to 100 produce 5Hz flicker, which looks very candle-y
// Inspired by https://github.com/avanhanegem/ArduinoCandleEffectNeoPixel
// and
// https://cpldcpu.wordpress.com/2016/01/05/reverse-engineering-a-real-candle/

uint16_t WS2812FX::candle(bool multi) {
  if (multi) {
    // allocate segment data
    uint16_t dataSize = max(1, SEGLEN - 1) * 3;  // max. 1365 pixels (ESP8266)
    if ((SEGLEN < 2) || (!SEGENV.allocateData(dataSize)))
      return candle(false);  // allocation failed
  }

  // max. flicker range controlled by intensity
  uint8_t valrange = SEGMENT.intensity;
  uint8_t rndval = valrange >> 1;  // max 127

  // step (how much to move closer to target per frame) coarsely set by speed
  uint8_t speedFactor = 4;
  if (SEGMENT.speed > 252) {  // epilepsy
    speedFactor = 1;
  } else if (SEGMENT.speed >
             99) {  // regular candle (mode called every ~25 ms, so 4 frames to
                    // have a new target every 100ms)
    speedFactor = 2;
  } else if (SEGMENT.speed > 49) {  // slower fade
    speedFactor = 3;
  }  // else 4 (slowest)

  uint16_t numCandles = (multi) ? SEGLEN : 1;

  for (uint16_t i = 0; i < numCandles; i++) {
    uint16_t d = 0;  // data location

    uint8_t s = SEGENV.aux0, s_target = SEGENV.aux1, fadeStep = SEGENV.step;
    if (i > 0) {
      d = (i - 1) * 3;
      s = SEGENV.data[d];
      s_target = SEGENV.data[d + 1];
      fadeStep = SEGENV.data[d + 2];
    }
    if (fadeStep == 0) {  // init vals
      s = 128;
      s_target = 130 + random8(4);
      fadeStep = 1;
    }

    bool newTarget = false;
    if (s_target > s) {  // fade up
      s = qadd8(s, fadeStep);
      if (s >= s_target) newTarget = true;
    } else {
      s = qsub8(s, fadeStep);
      if (s <= s_target) newTarget = true;
    }

    if (newTarget) {
      s_target =
          random8(rndval) + random8(rndval);  // between 0 and rndval*2 -2 = 252
      if (s_target < (rndval >> 1)) s_target = (rndval >> 1) + random8(rndval);
      uint8_t offset = (255 - valrange);
      s_target += offset;

      uint8_t dif = (s_target > s) ? s_target - s : s - s_target;

      fadeStep = dif >> speedFactor;
      if (fadeStep == 0) fadeStep = 1;
    }

    if (i > 0) {
      setPixelColor(
          i,
          color_blend(SEGCOLOR(1),
                      color_from_palette(i, true, PALETTE_SOLID_WRAP, 0), s));

      SEGENV.data[d] = s;
      SEGENV.data[d + 1] = s_target;
      SEGENV.data[d + 2] = fadeStep;
    } else {
      for (uint16_t j = 0; j < SEGLEN; j++) {
        setPixelColor(
            j,
            color_blend(SEGCOLOR(1),
                        color_from_palette(j, true, PALETTE_SOLID_WRAP, 0), s));
      }

      SEGENV.aux0 = s;
      SEGENV.aux1 = s_target;
      SEGENV.step = fadeStep;
    }
  }

  return FRAMETIME_FIXED;
}

uint16_t WS2812FX::mode_candle() { return candle(false); }

uint16_t WS2812FX::mode_candle_multi() { return candle(true); }

/*
/ Fireworks in starburst effect
/ based on the video:
https://www.reddit.com/r/arduino/comments/c3sd46/i_made_this_fireworks_effect_for_my_led_strips/
/ Speed sets frequency of new starbursts, intensity is the intensity of the
burst
*/
#ifdef ESP8266
#define STARBURST_MAX_FRAG 8  // 52 bytes / star
#else
#define STARBURST_MAX_FRAG 10  // 60 bytes / star
#endif
// each needs 20+STARBURST_MAX_FRAG*4 bytes
typedef struct particle {
  CRGB color;
  uint32_t birth = 0;
  uint32_t last = 0;
  float vel = 0;
  uint16_t pos = -1;
  float fragment[STARBURST_MAX_FRAG];
} star;

uint16_t WS2812FX::mode_starburst_core(bool useAudio) {
  uint16_t maxData = FAIR_DATA_PER_SEG;  // ESP8266: 256 ESP32: 640
  uint8_t segs = getActiveSegmentsNum();
  if (segs <= (MAX_NUM_SEGMENTS / 2))
    maxData *= 2;  // ESP8266: 512 if <= 8 segs ESP32: 1280 if <= 16 segs
  if (segs <= (MAX_NUM_SEGMENTS / 4))
    maxData *= 2;  // ESP8266: 1024 if <= 4 segs ESP32: 2560 if <= 8 segs
  uint16_t maxStars =
      maxData / sizeof(star);  // ESP8266: max. 4/9/19 stars/seg, ESP32: max.
                               // 10/21/42 stars/seg

  uint8_t numStars = 1 + (SEGLEN >> 3);
  if (numStars > maxStars) numStars = maxStars;
  uint16_t dataSize = sizeof(star) * numStars;

  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed

  uint32_t it = millis();

  star* stars = reinterpret_cast<star*>(SEGENV.data);

  float maxSpeed = 375.0f;           // Max velocity
  float particleIgnition = 250.0f;   // How long to "flash"
  float particleFadeTime = 1500.0f;  // Fade out time

  for (int j = 0; j < numStars; j++) {
    bool doNewStar = false;

    if (!useAudio) {
      // speed to adjust chance of a burst, max is nearly always.
      if (random8((144 - (SEGMENT.speed >> 1))) == 0)
        doNewStar = true;  // original non-audio version

    } else {  // WLEDSR audio responsive version
      int burstplus = (sampleAgc > 159) ? 128 : 0;  // high volume -> more stars
      if (rawSampleAgc <= 56) burstplus = -64;  // low volume  -> fewer stars
      int birthrate = (144 - (SEGMENT.speed >> 1)) -
                      burstplus;  // original "burstrate formula"
      birthrate = constrain(birthrate, 0, 144);
      if ((sampleAgc > 1.0)  // no bursts in silence
          && ((samplePeak > 1) ||
              (int(rawSampleAgc) > 31))  // try to burst with sound
          && (random8(birthrate) == 0))  // original random rate
        doNewStar = true;
    }

    if ((doNewStar == true) && (stars[j].birth == 0)) {
      // Pick a random color and location.
      uint16_t startPos = (SEGLEN > 1) ? random16(SEGLEN - 1) : 0;
      float multiplier = (float)(random8()) / 255.0 * 1.0;

      stars[j].color = col_to_crgb(color_wheel(random8()));
      stars[j].pos = startPos;
      stars[j].vel = maxSpeed * (float)(random8()) / 255.0 * multiplier;
      stars[j].birth = it;
      stars[j].last = it;
      // more fragments means larger burst effect
      int num = random8(3, 6 + (SEGMENT.intensity >> 5));

      for (int i = 0; i < STARBURST_MAX_FRAG; i++) {
        if (i < num)
          stars[j].fragment[i] = startPos;
        else
          stars[j].fragment[i] = -1;
      }
    }
  }

  fill(SEGCOLOR(1));

  for (int j = 0; j < numStars; j++) {
    if (stars[j].birth != 0) {
      float dt = (it - stars[j].last) / 1000.0;

      for (int i = 0; i < STARBURST_MAX_FRAG; i++) {
        int var = i >> 1;

        if (stars[j].fragment[i] > 0) {
          // all fragments travel right, will be mirrored on other side
          stars[j].fragment[i] += stars[j].vel * dt * (float)var / 3.0;
        }
      }
      stars[j].last = it;
      stars[j].vel -= 3 * stars[j].vel * dt;
    }

    CRGB c = stars[j].color;

    // If the star is brand new, it flashes white briefly.
    // Otherwise it just fades over time.
    float fade = 0.0f;
    float age = it - stars[j].birth;

    if (age < particleIgnition) {
      c = col_to_crgb(color_blend(WHITE, crgb_to_col(c),
                                  254.5f * ((age / particleIgnition))));
    } else {
      // Figure out how much to fade and shrink the star based on
      // its age relative to its lifetime
      if (age > particleIgnition + particleFadeTime) {
        fade = 1.0f;  // Black hole, all faded out
        stars[j].birth = 0;
        c = col_to_crgb(SEGCOLOR(1));
      } else {
        age -= particleIgnition;
        fade = (age / particleFadeTime);  // Fading star
        byte f = 254.5f * fade;
        c = col_to_crgb(color_blend(crgb_to_col(c), SEGCOLOR(1), f));
      }
    }

    float particleSize = (1.0 - fade) * 2;

    for (uint8_t index = 0; index < STARBURST_MAX_FRAG * 2; index++) {
      bool mirrored = index & 0x1;
      uint8_t i = index >> 1;
      if (stars[j].fragment[i] > 0) {
        float loc = stars[j].fragment[i];
        if (mirrored) loc -= (loc - stars[j].pos) * 2;
        int start = loc - particleSize;
        int end = loc + particleSize;
        if (start < 0) start = 0;
        if (start == end) end++;
        if (end > SEGLEN) end = SEGLEN;
        for (int p = start; p < end; p++) {
          setPixelColor(p, c.r, c.g, c.b);
        }
      }
    }
  }
  return FRAMETIME;
}

uint16_t WS2812FX::mode_starburst(void) { return (mode_starburst_core(false)); }
uint16_t WS2812FX::mode_starburst_audio(void) {
  return (mode_starburst_core(true));
}

#undef STARBURST_MAX_FRAG

/*
 * Exploding fireworks effect
 * adapted from: http://www.anirama.com/1000leds/1d-fireworks/
 */
uint16_t WS2812FX::mode_exploding_fireworks(void) {
  // allocate segment data
  uint16_t maxData = FAIR_DATA_PER_SEG;  // ESP8266: 256 ESP32: 640
  uint8_t segs = getActiveSegmentsNum();
  if (segs <= (MAX_NUM_SEGMENTS / 2))
    maxData *= 2;  // ESP8266: 512 if <= 8 segs ESP32: 1280 if <= 16 segs
  if (segs <= (MAX_NUM_SEGMENTS / 4))
    maxData *= 2;  // ESP8266: 1024 if <= 4 segs ESP32: 2560 if <= 8 segs
  int maxSparks =
      maxData / sizeof(spark);  // ESP8266: max. 21/42/85 sparks/seg, ESP32:
                                // max. 53/106/213 sparks/seg

  uint16_t numSparks = min(2 + (SEGLEN >> 1), maxSparks);
  uint16_t dataSize = sizeof(spark) * numSparks;
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed

  if (dataSize != SEGENV.aux1) {  // reset to flare if sparks were reallocated
    SEGENV.aux0 = 0;
    SEGENV.aux1 = dataSize;
  }

  fill(BLACK);

  bool actuallyReverse = SEGMENT.getOption(SEG_OPTION_REVERSED);
  // have fireworks start in either direction based on intensity
  SEGMENT.setOption(SEG_OPTION_REVERSED, SEGENV.step);

  Spark* sparks = reinterpret_cast<Spark*>(SEGENV.data);
  Spark* flare = sparks;  // first spark is flare data

  float gravity = -0.0004 - (SEGMENT.speed / 800000.0);  // m/s/s
  gravity *= SEGLEN;

  if (SEGENV.aux0 < 2) {     // FLARE
    if (SEGENV.aux0 == 0) {  // init flare
      flare->pos = 0;
      uint16_t peakHeight = 75 + random8(180);  // 0-255
      peakHeight = (peakHeight * (SEGLEN - 1)) >> 8;
      flare->vel = sqrtf(-2.0 * gravity * peakHeight);
      flare->col = 255;  // brightness

      SEGENV.aux0 = 1;
    }

    // launch
    if (flare->vel > 12 * gravity) {
      // flare
      setPixelColor(int(flare->pos), flare->col, flare->col, flare->col);

      flare->pos += flare->vel;
      flare->pos = constrain(flare->pos, 0, SEGLEN - 1);
      flare->vel += gravity;
      flare->col -= 2;
    } else {
      SEGENV.aux0 = 2;  // ready to explode
    }
  } else if (SEGENV.aux0 < 4) {
    /*
     * Explode!
     *
     * Explosion happens where the flare ended.
     * Size is proportional to the height.
     */
    int nSparks = flare->pos;
    nSparks = constrain(nSparks, 0, numSparks);
    static float dying_gravity;

    // initialize sparks
    if (SEGENV.aux0 == 2) {
      for (int i = 1; i < nSparks; i++) {
        sparks[i].pos = flare->pos;
        sparks[i].vel =
            (float(random16(0, 20000)) / 10000.0) - 0.9;  // from -0.9 to 1.1
        sparks[i].col = 345;  // abs(sparks[i].vel * 750.0); // set colors
                              // before scaling velocity to keep them bright
        // sparks[i].col = constrain(sparks[i].col, 0, 345);
        sparks[i].colIndex = random8();
        sparks[i].vel *= flare->pos / SEGLEN;  // proportional to height
        sparks[i].vel *= -gravity * 50;
      }
      // sparks[1].col = 345; // this will be our known spark
      dying_gravity = gravity / 2;
      SEGENV.aux0 = 3;
    }

    if (sparks[1].col > 4) {  //&& sparks[1].pos > 0) { // as long as our known
                              // spark is lit, work with all the sparks
      for (int i = 1; i < nSparks; i++) {
        sparks[i].pos += sparks[i].vel;
        sparks[i].vel += dying_gravity;
        if (sparks[i].col > 3) sparks[i].col -= 4;

        if (sparks[i].pos > 0 && sparks[i].pos < SEGLEN) {
          uint16_t prog = sparks[i].col;
          uint32_t spColor =
              (SEGMENT.palette) ? color_wheel(sparks[i].colIndex) : SEGCOLOR(0);
          CRGB c = CRGB::Black;  // HeatColor(sparks[i].col);
          if (prog > 300) {      // fade from white to spark color
            c = col_to_crgb(color_blend(spColor, WHITE, (prog - 300) * 5));
          } else if (prog > 45) {  // fade from spark color to black
            c = col_to_crgb(color_blend(BLACK, spColor, prog - 45));
            uint8_t cooling = (300 - prog) >> 5;
            c.g = qsub8(c.g, cooling);
            c.b = qsub8(c.b, cooling * 2);
          }
          setPixelColor(int(sparks[i].pos), c.red, c.green, c.blue);
        }
      }
      dying_gravity *= .99;  // as sparks burn out they fall slower
    } else {
      SEGENV.aux0 = 6 + random8(10);  // wait for this many frames
    }
  } else {
    SEGENV.aux0--;
    if (SEGENV.aux0 < 4) {
      SEGENV.aux0 = 0;  // back to flare
      SEGENV.step = actuallyReverse ^
                    (SEGMENT.intensity > random8());  // decide firing side
    }
  }

  SEGMENT.setOption(SEG_OPTION_REVERSED, actuallyReverse);

  return FRAMETIME;
}
#undef MAX_SPARKS

/*
 * Drip Effect
 * ported of: https://www.youtube.com/watch?v=sru2fXh4r7k
 */
uint16_t WS2812FX::mode_drip(void) {
  // allocate segment data
  uint8_t numDrops = 4;
  uint16_t dataSize = sizeof(spark) * numDrops;
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed

  fill(SEGCOLOR(1));

  Spark* drops = reinterpret_cast<Spark*>(SEGENV.data);

  numDrops = 1 + (SEGMENT.intensity >> 6);  // 255>>6 = 3

  float gravity = -0.0005 - (SEGMENT.speed / 50000.0);
  gravity *= SEGLEN;
  int sourcedrop = 12;

  for (uint8_t j = 0; j < numDrops; j++) {
    if (drops[j].colIndex == 0) {  // init
      drops[j].pos = SEGLEN - 1;   // start at end
      drops[j].vel = 0;            // speed
      drops[j].col = sourcedrop;   // brightness
      drops[j].colIndex =
          1;  // drop state (0 init, 1 forming, 2 falling, 5 bouncing)
    }

    setPixelColor(SEGLEN - 1,
                  color_blend(BLACK, SEGCOLOR(0), sourcedrop));  // water source
    if (drops[j].colIndex == 1) {
      if (drops[j].col > 255) drops[j].col = 255;
      setPixelColor(uint16_t(drops[j].pos),
                    color_blend(BLACK, SEGCOLOR(0), drops[j].col));

      drops[j].col += map(SEGMENT.speed, 0, 255, 1, 6);  // swelling

      if (random8() < drops[j].col / 10) {  // random drop
        drops[j].colIndex = 2;              // fall
        drops[j].col = 255;
      }
    }
    if (drops[j].colIndex > 1) {  // falling
      if (drops[j].pos > 0) {     // fall until end of segment
        drops[j].pos += drops[j].vel;
        if (drops[j].pos < 0) drops[j].pos = 0;
        drops[j].vel += gravity;  // gravity is negative

        for (uint16_t i = 1; i < 7 - drops[j].colIndex;
             i++) {  // some minor math so we don't expand bouncing droplets
          uint16_t pos = constrain(
              uint16_t(drops[j].pos) + i, 0,
              SEGLEN - 1);  // this is BAD, returns a pos >= SEGLEN occasionally
          setPixelColor(
              pos, color_blend(BLACK, SEGCOLOR(0),
                               drops[j].col /
                                   i));  // spread pixel with fade while falling
        }

        if (drops[j].colIndex >
            2) {  // during bounce, some water is on the floor
          setPixelColor(0, color_blend(SEGCOLOR(0), BLACK, drops[j].col));
        }
      } else {                        // we hit bottom
        if (drops[j].colIndex > 2) {  // already hit once, so back to forming
          drops[j].colIndex = 0;
          drops[j].col = sourcedrop;

        } else {
          if (drops[j].colIndex == 2) {        // init bounce
            drops[j].vel = -drops[j].vel / 4;  // reverse velocity with damping
            drops[j].pos += drops[j].vel;
          }
          drops[j].col = sourcedrop * 2;
          drops[j].colIndex = 5;  // bouncing
        }
      }
    }
  }
  return FRAMETIME;
}

/*
 * Tetris or Stacking (falling bricks) Effect
 * by Blaz Kristan (https://github.com/blazoncek, https://blaz.at/home)
 */
// 12 bytes
typedef struct Tetris {
  float pos;
  float speed;
  uint32_t col;
} tetris;

uint16_t WS2812FX::mode_tetrix(void) {
  uint16_t dataSize = sizeof(tetris);
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed
  Tetris* drop = reinterpret_cast<Tetris*>(SEGENV.data);

  // initialize dropping on first call or segment full
  if (SEGENV.call == 0 || SEGENV.aux1 >= SEGLEN) {
    SEGENV.aux1 = 0;  // reset brick stack size
    SEGENV.step = 0;
    fill(SEGCOLOR(1));
    return 250;  // short wait
  }

  if (SEGENV.step == 0) {  // init
    drop->speed = 0.0238 * (SEGMENT.speed ? (SEGMENT.speed >> 2) + 1
                                          : random8(6, 64));  // set speed
    drop->pos = SEGLEN;  // start at end of segment (no need to subtract 1)
    drop->col = color_from_palette(
        random8(0, 15) << 4, false, false,
        0);           // limit color choices so there is enough HUE gap
    SEGENV.step = 1;  // drop state (0 init, 1 forming, 2 falling)
    SEGENV.aux0 =
        (SEGMENT.intensity ? (SEGMENT.intensity >> 5) + 1 : random8(1, 5)) *
        (1 + (SEGLEN >> 6));  // size of brick
  }

  if (SEGENV.step == 1) {  // forming
    if (random8() >> 6) {  // random drop
      SEGENV.step = 2;     // fall
    }
  }

  if (SEGENV.step > 1) {            // falling
    if (drop->pos > SEGENV.aux1) {  // fall until top of stack
      drop->pos -= drop->speed;     // may add gravity as: speed += gravity
      if (int(drop->pos) < SEGENV.aux1) drop->pos = SEGENV.aux1;
      for (uint16_t i = int(drop->pos); i < SEGLEN; i++)
        setPixelColor(
            i, i < int(drop->pos) + SEGENV.aux0 ? drop->col : SEGCOLOR(1));
    } else {                                   // we hit bottom
      SEGENV.step = 0;                         // go back to init
      SEGENV.aux1 += SEGENV.aux0;              // increase the stack size
      if (SEGENV.aux1 >= SEGLEN) return 1000;  // wait for a second
    }
  }
  return FRAMETIME;
}

/*
/ Plasma Effect
/ adapted from
https://github.com/atuline/FastLED-Demos/blob/master/plasma/plasma.ino
*/
uint16_t WS2812FX::mode_plasma(void) {
  // initialize phases on start
  if (SEGENV.call == 0) {
    SEGENV.aux0 = random8(0, 2);  // add a bit of randomness
  }
  uint8_t thisPhase = beatsin8(6 + SEGENV.aux0, -64, 64);
  uint8_t thatPhase = beatsin8(7 + SEGENV.aux0, -64, 64);

  for (int i = 0; i < SEGLEN;
       i++) {  // For each of the LED's in the strand, set color &  brightness
               // based on a wave as follows:
    uint8_t colorIndex =
        cubicwave8((i * (2 + 3 * (SEGMENT.speed >> 5)) + thisPhase) & 0xFF) /
            2  // factor=23 // Create a wave and add a phase change and add
               // another wave with its own phase change.
        + cos8((i * (1 + 2 * (SEGMENT.speed >> 5)) + thatPhase) & 0xFF) /
              2;  // factor=15 // Hey, you can even change the frequencies if
                  // you wish.
    uint8_t thisBright =
        qsub8(colorIndex, beatsin8(7, 0, (128 - (SEGMENT.intensity >> 1))));
    //    CRGB color = ColorFromPalette(currentPalette, colorIndex, thisBright,
    //    LINEARBLEND); setPixelColor(i, color.red, color.green, color.blue);
    setPixelColor(i, color_blend(SEGCOLOR(1),
                                 color_from_palette(colorIndex, false,
                                                    PALETTE_SOLID_WRAP, 0),
                                 thisBright));  // This supports RGBW.
  }

  return FRAMETIME;
}

/*
 * Percentage display
 * Intesity values from 0-100 turn on the leds.
 */
uint16_t WS2812FX::mode_percent(void) {
  uint8_t percent = max((uint8_t)0, min((uint8_t)200, SEGMENT.intensity));
  uint16_t active_leds = (percent < 100) ? SEGLEN * percent / 100.0
                                         : SEGLEN * (200 - percent) / 100.0;

  uint8_t size = (1 + ((SEGMENT.speed * SEGLEN) >> 11));
  if (SEGMENT.speed == 255) size = 255;

  if (percent < 100) {
    for (uint16_t i = 0; i < SEGLEN; i++) {
      if (i < SEGENV.step) {
        setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 0));
      } else {
        setPixelColor(i, SEGCOLOR(1));
      }
    }
  } else {
    for (uint16_t i = 0; i < SEGLEN; i++) {
      if (i < (SEGLEN - SEGENV.step)) {
        setPixelColor(i, SEGCOLOR(1));
      } else {
        setPixelColor(i, color_from_palette(i, true, PALETTE_SOLID_WRAP, 0));
      }
    }
  }

  if (active_leds > SEGENV.step) {  // smooth transition to the target value
    SEGENV.step += size;
    if (SEGENV.step > active_leds) SEGENV.step = active_leds;
  } else if (active_leds < SEGENV.step) {
    if (SEGENV.step > size)
      SEGENV.step -= size;
    else
      SEGENV.step = 0;
    if (SEGENV.step < active_leds) SEGENV.step = active_leds;
  }

  return FRAMETIME;
}

/*
/ Modulates the brightness similar to a heartbeat
*/
uint16_t WS2812FX::mode_heartbeat(void) {
  uint8_t bpm = 40 + (SEGMENT.speed >> 4);
  uint32_t msPerBeat = (60000 / bpm);
  uint32_t secondBeat = (msPerBeat / 3);

  uint32_t bri_lower = SEGENV.aux1;
  bri_lower = bri_lower * 2042 / (2048 + SEGMENT.intensity);
  SEGENV.aux1 = bri_lower;

  unsigned long beatTimer = millis() - SEGENV.step;
  if ((beatTimer > secondBeat) && !SEGENV.aux0) {  // time for the second beat?
    SEGENV.aux1 = UINT16_MAX;                      // full bri
    SEGENV.aux0 = 1;
  }
  if (beatTimer > msPerBeat) {  // time to reset the beat timer?
    SEGENV.aux1 = UINT16_MAX;   // full bri
    SEGENV.aux0 = 0;
    SEGENV.step = millis();
  }

  for (uint16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(
        i, color_blend(color_from_palette(i, true, PALETTE_SOLID_WRAP, 0),
                       SEGCOLOR(1), 255 - (SEGENV.aux1 >> 8)));
  }

  return FRAMETIME;
}

//  "Pacifica"
//  Gentle, blue-green ocean waves.
//  December 2019, Mark Kriegsman and Mary Corey March.
//  For Dan.
//
//
// In this animation, there are four "layers" of waves of light.
//
// Each layer moves independently, and each is scaled separately.
//
// All four wave layers are added together on top of each other, and then
// another filter is applied that adds "whitecaps" of brightness where the
// waves line up with each other more.  Finally, another pass is taken
// over the led array to 'deepen' (dim) the blues and greens.
//
// The speed and scale and motion each layer varies slowly within independent
// hand-chosen ranges, which is why the code has a lot of low-speed 'beatsin8'
// functions with a lot of oddly specific numeric ranges.
//
// These three custom blue-green color palettes were inspired by the colors
// found in the waters off the southern coast of California,
// https://goo.gl/maps/QQgd97jjHesHZVxQ7
//
// Modified for WLED, based on
// https://github.com/FastLED/FastLED/blob/master/examples/Pacifica/Pacifica.ino
//
uint16_t WS2812FX::mode_pacifica() {
  uint32_t nowOld = now;

  CRGBPalette16 pacifica_palette_1 = {0x000507, 0x000409, 0x00030B, 0x00030D,
                                      0x000210, 0x000212, 0x000114, 0x000117,
                                      0x000019, 0x00001C, 0x000026, 0x000031,
                                      0x00003B, 0x000046, 0x14554B, 0x28AA50};
  CRGBPalette16 pacifica_palette_2 = {0x000507, 0x000409, 0x00030B, 0x00030D,
                                      0x000210, 0x000212, 0x000114, 0x000117,
                                      0x000019, 0x00001C, 0x000026, 0x000031,
                                      0x00003B, 0x000046, 0x0C5F52, 0x19BE5F};
  CRGBPalette16 pacifica_palette_3 = {0x000208, 0x00030E, 0x000514, 0x00061A,
                                      0x000820, 0x000927, 0x000B2D, 0x000C33,
                                      0x000E39, 0x001040, 0x001450, 0x001860,
                                      0x001C70, 0x002080, 0x1040BF, 0x2060FF};

  if (SEGMENT.palette) {
    pacifica_palette_1 = currentPalette;
    pacifica_palette_2 = currentPalette;
    pacifica_palette_3 = currentPalette;
  }

  // Increment the four "color index start" counters, one for each wave layer.
  // Each is incremented at a different speed, and the speeds vary over time.
  uint16_t sCIStart1 = SEGENV.aux0, sCIStart2 = SEGENV.aux1,
           sCIStart3 = SEGENV.step, sCIStart4 = SEGENV.step >> 16;
  // static uint16_t sCIStart1, sCIStart2, sCIStart3, sCIStart4;
  // uint32_t deltams = 26 + (SEGMENT.speed >> 3);
  uint32_t deltams = (FRAMETIME >> 2) + ((FRAMETIME * SEGMENT.speed) >> 7);
  uint64_t deltat = (now >> 2) + ((now * SEGMENT.speed) >> 7);
  now = deltat;

  uint16_t speedfactor1 = beatsin16(3, 179, 269);
  uint16_t speedfactor2 = beatsin16(4, 179, 269);
  uint32_t deltams1 = (deltams * speedfactor1) / 256;
  uint32_t deltams2 = (deltams * speedfactor2) / 256;
  uint32_t deltams21 = (deltams1 + deltams2) / 2;
  sCIStart1 += (deltams1 * beatsin88(1011, 10, 13));
  sCIStart2 -= (deltams21 * beatsin88(777, 8, 11));
  sCIStart3 -= (deltams1 * beatsin88(501, 5, 7));
  sCIStart4 -= (deltams2 * beatsin88(257, 4, 6));
  SEGENV.aux0 = sCIStart1;
  SEGENV.aux1 = sCIStart2;
  SEGENV.step = sCIStart4;
  SEGENV.step = (SEGENV.step << 16) + sCIStart3;

  // Clear out the LED array to a dim background blue-green
  // fill(132618);

  uint8_t basethreshold = beatsin8(9, 55, 65);
  uint8_t wave = beat8(7);

  for (uint16_t i = 0; i < SEGLEN; i++) {
    CRGB c = CRGB(2, 6, 10);
    // Render each of four layers, with different scales and speeds, that vary
    // over time
    c += pacifica_one_layer(i, pacifica_palette_1, sCIStart1,
                            beatsin16(3, 11 * 256, 14 * 256),
                            beatsin8(10, 70, 130), 0 - beat16(301));
    c += pacifica_one_layer(i, pacifica_palette_2, sCIStart2,
                            beatsin16(4, 6 * 256, 9 * 256),
                            beatsin8(17, 40, 80), beat16(401));
    c += pacifica_one_layer(i, pacifica_palette_3, sCIStart3, 6 * 256,
                            beatsin8(9, 10, 38), 0 - beat16(503));
    c += pacifica_one_layer(i, pacifica_palette_3, sCIStart4, 5 * 256,
                            beatsin8(8, 10, 28), beat16(601));

    // Add extra 'white' to areas where the four layers of light have lined up
    // brightly
    uint8_t threshold = scale8(sin8(wave), 20) + basethreshold;
    wave += 7;
    uint8_t l = c.getAverageLight();
    if (l > threshold) {
      uint8_t overage = l - threshold;
      uint8_t overage2 = qadd8(overage, overage);
      c += CRGB(overage, overage2, qadd8(overage2, overage2));
    }

    // deepen the blues and greens
    c.blue = scale8(c.blue, 145);
    c.green = scale8(c.green, 200);
    c |= CRGB(2, 5, 7);

    setPixelColor(i, c.red, c.green, c.blue);
  }

  now = nowOld;
  return FRAMETIME;
}

// Add one layer of waves into the led array
CRGB WS2812FX::pacifica_one_layer(uint16_t i, CRGBPalette16& p,
                                  uint16_t cistart, uint16_t wavescale,
                                  uint8_t bri, uint16_t ioff) {
  uint16_t ci = cistart;
  uint16_t waveangle = ioff;
  uint16_t wavescale_half = (wavescale >> 1) + 20;

  waveangle += ((120 + SEGMENT.intensity) * i);  // original 250 * i
  uint16_t s16 = sin16(waveangle) + 32768;
  uint16_t cs = scale16(s16, wavescale_half) + wavescale_half;
  ci += (cs * i);
  uint16_t sindex16 = sin16(ci) + 32768;
  uint8_t sindex8 = scale16(sindex16, 240);
  return ColorFromPalette(p, sindex8, bri, LINEARBLEND);
}

// Solid colour background with glitter
uint16_t WS2812FX::mode_solid_glitter() {
  fill(SEGCOLOR(0));

  if (SEGMENT.intensity > random8()) {
    setPixelColor(random16(SEGLEN), ULTRAWHITE);
  }
  return FRAMETIME;
}

/*
 * Mode simulates a gradual sunrise
 */
uint16_t WS2812FX::mode_sunrise() {
  // speed 0 - static sun
  // speed 1 - 60: sunrise time in minutes
  // speed 60 - 120 : sunset time in minutes - 60;
  // speed above: "breathing" rise and set
  if (SEGENV.call == 0 || SEGMENT.speed != SEGENV.aux0) {
    SEGENV.step = millis();  // save starting time, millis() because now can
                             // change from sync
    SEGENV.aux0 = SEGMENT.speed;
  }

  fill(0);
  uint16_t stage = 0xFFFF;

  uint32_t s10SinceStart = (millis() - SEGENV.step) / 100;  // tenths of seconds

  if (SEGMENT.speed > 120) {  // quick sunrise and sunset
    uint16_t counter = (now >> 1) * (((SEGMENT.speed - 120) >> 1) + 1);
    stage = triwave16(counter);
  } else if (SEGMENT.speed) {  // sunrise
    uint8_t durMins = SEGMENT.speed;
    if (durMins > 60) durMins -= 60;
    uint32_t s10Target = durMins * 600;
    if (s10SinceStart > s10Target) s10SinceStart = s10Target;
    stage = map(s10SinceStart, 0, s10Target, 0, 0xFFFF);
    if (SEGMENT.speed > 60) stage = 0xFFFF - stage;  // sunset
  }

  for (uint16_t i = 0; i <= SEGLEN / 2; i++) {
    // default palette is Fire
    uint32_t c = color_from_palette(0, false, true, 255);  // background

    uint16_t wave = triwave16((i * stage) / SEGLEN);

    wave = (wave >> 8) + ((wave * SEGMENT.intensity) >> 15);

    if (wave > 240) {  // clipped, full white sun
      c = color_from_palette(240, false, true, 255);
    } else {  // transition
      c = color_from_palette(wave, false, true, 255);
    }
    setPixelColor(i, c);
    setPixelColor(SEGLEN - i - 1, c);
  }

  return FRAMETIME;
}

/*
 * Effects by Andrew Tuline
 */
uint16_t WS2812FX::phased_base(
    uint8_t moder) {  // We're making sine waves here. By Andrew Tuline.

  uint8_t allfreq = 16;  // Base frequency.
  // float* phasePtr = reinterpret_cast<float*>(SEGENV.step);       // Phase
  // change value gets calculated.
  static float phase = 0;  // phasePtr[0];
  uint8_t cutOff =
      (255 - SEGMENT.intensity);  // You can change the number of pixels.  AKA
                                  // INTENSITY (was 192).
  uint8_t modVal = 5;  // SEGMENT.custom1/8+1;                         // You
                       // can change the modulus. AKA Custom1 (was 5).

  uint8_t index = now / 64;  // Set color rotation speed
  phase += SEGMENT.speed /
           32.0;  // You can change the speed of the wave. AKA SPEED (was .4)
  // phasePtr[0] = phase;

  for (int i = 0; i < SEGLEN; i++) {
    if (moder == 1)
      modVal = (inoise8(i * 10 + i * 10) /
                16);  // Let's randomize our mod length with some Perlin noise.
    uint16_t val =
        (i + 1) * allfreq;  // This sets the frequency of the waves. The +1
                            // makes sure that leds[0] is used.
    if (modVal == 0) modVal = 1;
    val += phase * (i % modVal + 1) / 2;  // This sets the varying phase change
                                          // of the waves. By Andrew Tuline.
    uint8_t b = cubicwave8(val);          // Now we make an 8 bit sinewave.
    b = (b > cutOff) ? (b - cutOff)
                     : 0;  // A ternary operator to cutoff the light.
    setPixelColor(
        i, color_blend(SEGCOLOR(1), color_from_palette(index, false, false, 0),
                       b));
    index += 256 / SEGLEN;
    if (SEGLEN > 256) index++;  // Correction for segments longer than 256 LEDs
  }

  return FRAMETIME;
}

uint16_t WS2812FX::mode_phased(void) { return phased_base(0); }

uint16_t WS2812FX::mode_phased_noise(void) { return phased_base(1); }

uint16_t WS2812FX::mode_twinkleup(
    void) {  // A very short twinkle routine with fade-in and dual controls. By
             // Andrew Tuline.
  random16_set_seed(535);  // The randomizer needs to be re-set each time
                           // through the loop in order for the same 'random'
                           // numbers to be the same each time through.

  for (int i = 0; i < SEGLEN; i++) {
    uint8_t pixBri =
        beatsin8(SEGMENT.speed / 2 + random8() / 4, SEGMENT.custom1, 255, 0,
                 random8());  // Every pixel gets a different timebase.

    /*
        if (i < SEGLEN/3) {                                 // You can use this
       to shape a 1D candle, where it's brightest at 1/3rd of SEGLEN and dull at
       both ends. pixBri = pixBri*i/(SEGLEN/3); } else { pixBri =
       pixBri*(SEGLEN-i)/SEGLEN;
        }
    */

    if (random8() > SEGMENT.intensity) pixBri = 0;
    setPixelColor(i,
                  color_blend(SEGCOLOR(1),
                              color_from_palette(random8() + now / 100, false,
                                                 PALETTE_SOLID_WRAP, 0),
                              pixBri));
  }

  return FRAMETIME;
}

// Peaceful noise that's slow and with gradually changing palettes. Does not
// support WLED palettes or default colours or controls.
uint16_t WS2812FX::mode_noisepal(
    void) {  // Slow noise palette by Andrew Tuline.
  uint16_t scale = 15 + (SEGMENT.intensity >> 2);  // default was 30
  // #define scale 30

  uint16_t dataSize =
      sizeof(CRGBPalette16) *
      2;  // allocate space for 2 Palettes (2 * 16 * 3 = 96 bytes)
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed

  CRGBPalette16* palettes = reinterpret_cast<CRGBPalette16*>(SEGENV.data);

  uint16_t changePaletteMs = 4000 + SEGMENT.speed * 10;  // between 4 - 6.5sec
  if (millis() - SEGENV.step > changePaletteMs) {
    SEGENV.step = millis();

    uint8_t baseI = random8();
    palettes[1] =
        CRGBPalette16(CHSV(baseI + random8(64), 255, random8(128, 255)),
                      CHSV(baseI + 128, 255, random8(128, 255)),
                      CHSV(baseI + random8(92), 192, random8(128, 255)),
                      CHSV(baseI + random8(92), 255, random8(128, 255)));
  }

  CRGB color;

  // EVERY_N_MILLIS(10) { //(don't have to time this, effect function is only
  // called every 24ms)
  nblendPaletteTowardPalette(
      palettes[0], palettes[1],
      48);  // Blend towards the target palette over 48 iterations.

  if (SEGMENT.palette > 0) palettes[0] = currentPalette;

  for (int i = 0; i < SEGLEN; i++) {
    uint8_t index = inoise8(
        i * scale,
        SEGENV.aux0 + i * scale);  // Get a value from the noise function. I'm
                                   // using both x and y axis.
    color = ColorFromPalette(palettes[0], index, 255,
                             LINEARBLEND);  // Use the my own palette.
    setPixelColor(i, color.red, color.green, color.blue);
  }

  SEGENV.aux0 += beatsin8(
      10, 1, 4);  // Moving along the distance. Vary it a bit with a sine wave.

  return FRAMETIME;
}

// Sine waves that have controllable phase change speed, frequency and cutoff.
// By Andrew Tuline. SEGMENT.speed ->Speed, SEGMENT.intensity -> Frequency
// (SEGMENT.custom1 -> Color change, SEGMENT.custom2 -> PWM cutoff)
//
uint16_t WS2812FX::mode_sinewave(
    void) {  // Adjustable sinewave. By Andrew Tuline
  // #define qsuba(x, b)  ((x>b)?x-b:0)               // Analog Unsigned
  // subtraction macro. if result <0, then => 0

  uint16_t colorIndex =
      now / 32;  //(256 - SEGMENT.custom1);  // Amount of colour change.

  SEGENV.step += SEGMENT.speed / 16;      // Speed of animation.
  uint16_t freq = SEGMENT.intensity / 4;  // SEGMENT.custom2/8; // Frequency of
                                          // the signal.

  for (int i = 0; i < SEGLEN;
       i++) {  // For each of the LED's in the strand, set a brightness based on
               // a wave as follows:
    int pixBri = cubicwave8(
        (i * freq) +
        SEGENV.step);  // qsuba(cubicwave8((i*freq)+SEGENV.step),
                       // (255-SEGMENT.intensity)); // qsub sets a minimum value
                       // called thiscutoff. If < thiscutoff, then bright = 0.
                       // Otherwise, bright = 128 (as defined in qsub)..
    // setPixCol(i, i*colorIndex/255, pixBri);
    setPixelColor(i, color_blend(SEGCOLOR(1),
                                 color_from_palette(i * colorIndex / 255, false,
                                                    PALETTE_SOLID_WRAP, 0),
                                 pixBri));
  }

  return FRAMETIME;
}

/*
 * Best of both worlds from Palette and Spot effects. By Aircoookie
 */
uint16_t WS2812FX::mode_flow(void) {
  uint16_t counter = 0;
  if (SEGMENT.speed != 0) {
    counter = now * ((SEGMENT.speed >> 2) + 1);
    counter = counter >> 8;
  }

  uint16_t maxZones =
      SEGLEN / 6;  // only looks good if each zone has at least 6 LEDs
  uint16_t zones = (SEGMENT.intensity * maxZones) >> 8;
  if (zones & 0x01) zones++;  // zones must be even
  if (zones < 2) zones = 2;
  uint16_t zoneLen = SEGLEN / zones;
  uint16_t offset = (SEGLEN - zones * zoneLen) >> 1;

  fill(color_from_palette(-counter, false, true, 255));

  for (uint16_t z = 0; z < zones; z++) {
    uint16_t pos = offset + z * zoneLen;
    for (uint16_t i = 0; i < zoneLen; i++) {
      uint8_t colorIndex = (i * 255 / zoneLen) - counter;
      uint16_t led = (z & 0x01) ? i : (zoneLen - 1) - i;
      if (IS_REVERSE) led = (zoneLen - 1) - led;
      setPixelColor(pos + led,
                    color_from_palette(colorIndex, false, true, 255));
    }
  }

  return FRAMETIME;
}

/*
 * Dots waving around in a sine/pendulum motion.
 * Little pixel birds flying in a circle. By Aircoookie
 */
uint16_t WS2812FX::mode_chunchun(void) {
  fill(SEGCOLOR(1));
  uint16_t counter = now * (6 + (SEGMENT.speed >> 4));
  uint16_t numBirds = 2 + (SEGLEN >> 3);  // 2 + 1/8 of a segment
  uint16_t span = (SEGMENT.intensity << 8) / numBirds;

  for (uint16_t i = 0; i < numBirds; i++) {
    counter -= span;
    uint16_t megumin = sin16(counter) + 0x8000;
    uint32_t bird = (megumin * SEGLEN) >> 16;
    uint32_t c = color_from_palette((i * 255) / numBirds, false, false,
                                    0);  // no palette wrapping
    setPixelColor(bird, c);
  }
  return FRAMETIME;
}

// 13 bytes
typedef struct Spotlight {
  float speed;
  uint8_t colorIdx;
  int16_t position;
  unsigned long lastUpdateTime;
  uint8_t width;
  uint8_t type;
} spotlight;

#define SPOT_TYPE_SOLID 0
#define SPOT_TYPE_GRADIENT 1
#define SPOT_TYPE_2X_GRADIENT 2
#define SPOT_TYPE_2X_DOT 3
#define SPOT_TYPE_3X_DOT 4
#define SPOT_TYPE_4X_DOT 5
#define SPOT_TYPES_COUNT 6
#ifdef ESP8266
#define SPOT_MAX_COUNT 17  // Number of simultaneous waves
#else
#define SPOT_MAX_COUNT 49  // Number of simultaneous waves
#endif

/*
 * Spotlights moving back and forth that cast dancing shadows.
 * Shine this through tree branches/leaves or other close-up objects that cast
 * interesting shadows onto a ceiling or tarp.
 *
 * By Steve Pomeroy @xxv
 */
uint16_t WS2812FX::mode_dancing_shadows(void) {
  uint8_t numSpotlights =
      map(SEGMENT.intensity, 0, 255, 2,
          SPOT_MAX_COUNT);  // 49 on 32 segment ESP32, 17 on 16 segment ESP8266
  bool initialize = SEGENV.aux0 != numSpotlights;
  SEGENV.aux0 = numSpotlights;

  uint16_t dataSize = sizeof(spotlight) * numSpotlights;
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed
  Spotlight* spotlights = reinterpret_cast<Spotlight*>(SEGENV.data);

  fill(BLACK);

  unsigned long time = millis();
  bool respawn = false;

  for (uint8_t i = 0; i < numSpotlights; i++) {
    if (!initialize) {
      // advance the position of the spotlight
      int16_t delta = (float)(time - spotlights[i].lastUpdateTime) *
                      (spotlights[i].speed * ((1.0 + SEGMENT.speed) / 100.0));

      if (abs(delta) >= 1) {
        spotlights[i].position += delta;
        spotlights[i].lastUpdateTime = time;
      }

      respawn = (spotlights[i].speed > 0.0 &&
                 spotlights[i].position > (SEGLEN + 2)) ||
                (spotlights[i].speed < 0.0 &&
                 spotlights[i].position < -(spotlights[i].width + 2));
    }

    if (initialize || respawn) {
      spotlights[i].colorIdx = random8();
      spotlights[i].width = random8(1, 10);

      spotlights[i].speed = 1.0 / random8(4, 50);

      if (initialize) {
        spotlights[i].position = random16(SEGLEN);
        spotlights[i].speed *= random8(2) ? 1.0 : -1.0;
      } else {
        if (random8(2)) {
          spotlights[i].position = SEGLEN + spotlights[i].width;
          spotlights[i].speed *= -1.0;
        } else {
          spotlights[i].position = -spotlights[i].width;
        }
      }

      spotlights[i].lastUpdateTime = time;
      spotlights[i].type = random8(SPOT_TYPES_COUNT);
    }

    uint32_t color =
        color_from_palette(spotlights[i].colorIdx, false, false, 0);
    int start = spotlights[i].position;

    if (spotlights[i].width <= 1) {
      if (start >= 0 && start < SEGLEN) {
        blendPixelColor(start, color, 128);
      }
    } else {
      switch (spotlights[i].type) {
        case SPOT_TYPE_SOLID:
          for (uint8_t j = 0; j < spotlights[i].width; j++) {
            if ((start + j) >= 0 && (start + j) < SEGLEN) {
              blendPixelColor(start + j, color, 128);
            }
          }
          break;

        case SPOT_TYPE_GRADIENT:
          for (uint8_t j = 0; j < spotlights[i].width; j++) {
            if ((start + j) >= 0 && (start + j) < SEGLEN) {
              blendPixelColor(
                  start + j, color,
                  cubicwave8(map(j, 0, spotlights[i].width - 1, 0, 255)));
            }
          }
          break;

        case SPOT_TYPE_2X_GRADIENT:
          for (uint8_t j = 0; j < spotlights[i].width; j++) {
            if ((start + j) >= 0 && (start + j) < SEGLEN) {
              blendPixelColor(
                  start + j, color,
                  cubicwave8(2 * map(j, 0, spotlights[i].width - 1, 0, 255)));
            }
          }
          break;

        case SPOT_TYPE_2X_DOT:
          for (uint8_t j = 0; j < spotlights[i].width; j += 2) {
            if ((start + j) >= 0 && (start + j) < SEGLEN) {
              blendPixelColor(start + j, color, 128);
            }
          }
          break;

        case SPOT_TYPE_3X_DOT:
          for (uint8_t j = 0; j < spotlights[i].width; j += 3) {
            if ((start + j) >= 0 && (start + j) < SEGLEN) {
              blendPixelColor(start + j, color, 128);
            }
          }
          break;

        case SPOT_TYPE_4X_DOT:
          for (uint8_t j = 0; j < spotlights[i].width; j += 4) {
            if ((start + j) >= 0 && (start + j) < SEGLEN) {
              blendPixelColor(start + j, color, 128);
            }
          }
          break;
      }
    }
  }

  return FRAMETIME;
}

/*
  Imitates a washing machine, rotating same waves forward, then pause, then
  backward. By Stefan Seegel
*/
uint16_t WS2812FX::mode_washing_machine(void) {
  float speed = tristate_square8(now >> 7, 90, 15);
  float quot = 32.0f - ((float)SEGMENT.speed / 16.0f);
  speed /= quot;

  SEGENV.step += (speed * 128.0f);

  for (int i = 0; i < SEGLEN; i++) {
    uint8_t col = sin8(((SEGMENT.intensity / 25 + 1) * 255 * i / SEGLEN) +
                       (SEGENV.step >> 7));
    setPixelColor(i, color_from_palette(col, false, PALETTE_SOLID_WRAP, 3));
  }

  return FRAMETIME;
}

/*
  Blends random colors across palette
  Modified, originally by Mark Kriegsman
  https://gist.github.com/kriegsman/1f7ccbbfa492a73c015e
*/
uint16_t WS2812FX::mode_blends(void) {
  uint16_t pixelLen = SEGLEN > UINT8_MAX ? UINT8_MAX : SEGLEN;
  uint16_t dataSize =
      sizeof(uint32_t) *
      (pixelLen + 1);  // max segment length of 56 pixels on 16 segment ESP8266
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed
  uint32_t* pixels = reinterpret_cast<uint32_t*>(SEGENV.data);
  uint8_t blendSpeed = map(SEGMENT.intensity, 0, UINT8_MAX, 10, 128);
  uint8_t shift = (now * ((SEGMENT.speed >> 3) + 1)) >> 8;

  for (int i = 0; i < pixelLen; i++) {
    pixels[i] = color_blend(pixels[i],
                            color_from_palette(shift + quadwave8((i + 1) * 16),
                                               false, PALETTE_SOLID_WRAP, 255),
                            blendSpeed);
    shift += 3;
  }

  uint16_t offset = 0;
  for (int i = 0; i < SEGLEN; i++) {
    setPixelColor(i, pixels[offset++]);
    if (offset > pixelLen) offset = 0;
  }

  return FRAMETIME;
}

/*
  TV Simulator
  Modified and adapted to WLED by Def3nder, based on "Fake TV Light for
  Engineers" by Phillip Burgess
  https://learn.adafruit.com/fake-tv-light-for-engineers/arduino-sketch
*/
// 43 bytes
typedef struct TvSim {
  uint32_t totalTime = 0;
  uint32_t fadeTime = 0;
  uint32_t startTime = 0;
  uint32_t elapsed = 0;
  uint32_t pixelNum = 0;
  uint16_t sliderValues = 0;
  uint32_t sceeneStart = 0;
  uint32_t sceeneDuration = 0;
  uint16_t sceeneColorHue = 0;
  uint8_t sceeneColorSat = 0;
  uint8_t sceeneColorBri = 0;
  uint8_t actualColorR = 0;
  uint8_t actualColorG = 0;
  uint8_t actualColorB = 0;
  uint16_t pr = 0;  // Prev R, G, B
  uint16_t pg = 0;
  uint16_t pb = 0;
} tvSim;

uint16_t WS2812FX::mode_tv_simulator(void) {
  uint16_t nr, ng, nb, r, g, b, i, hue;
  uint8_t sat, bri, j;

  if (!SEGENV.allocateData(sizeof(tvSim)))
    return mode_static();  // allocation failed
  TvSim* tvSimulator = reinterpret_cast<TvSim*>(SEGENV.data);

  uint8_t colorSpeed = map(SEGMENT.speed, 0, UINT8_MAX, 1, 20);
  uint8_t colorIntensity = map(SEGMENT.intensity, 0, UINT8_MAX, 10, 30);

  i = SEGMENT.speed << 8 | SEGMENT.intensity;
  if (i != tvSimulator->sliderValues) {
    tvSimulator->sliderValues = i;
    SEGENV.aux1 = 0;
  }

  // create a new sceene
  if (((millis() - tvSimulator->sceeneStart) >= tvSimulator->sceeneDuration) ||
      SEGENV.aux1 == 0) {
    tvSimulator->sceeneStart =
        millis();  // remember the start of the new sceene
    tvSimulator->sceeneDuration = random16(
        60 * 250 * colorSpeed,
        60 * 750 *
            colorSpeed);  // duration of a "movie sceene" which has similar
                          // colors (5 to 15 minutes with max speed slider)
    tvSimulator->sceeneColorHue =
        random16(0, 768);  // random start color-tone for the sceene
    tvSimulator->sceeneColorSat = random8(
        100,
        130 + colorIntensity);  // random start color-saturation for the sceene
    tvSimulator->sceeneColorBri =
        random8(200, 240);  // random start color-brightness for the sceene
    SEGENV.aux1 = 1;
    SEGENV.aux0 = 0;
  }

  // slightly change the color-tone in this sceene
  if (SEGENV.aux0 == 0) {
    // hue change in both directions
    j = random8(4 * colorIntensity);
    hue = (random8() < 128) ? ((j < tvSimulator->sceeneColorHue)
                                   ? tvSimulator->sceeneColorHue - j
                                   : 767 - tvSimulator->sceeneColorHue - j)
                            :  // negative
              ((j + tvSimulator->sceeneColorHue) < 767
                   ? tvSimulator->sceeneColorHue + j
                   : tvSimulator->sceeneColorHue + j - 767);  // positive

    // saturation
    j = random8(2 * colorIntensity);
    sat = (tvSimulator->sceeneColorSat - j) < 0
              ? 0
              : tvSimulator->sceeneColorSat - j;

    // brightness
    j = random8(100);
    bri = (tvSimulator->sceeneColorBri - j) < 0
              ? 0
              : tvSimulator->sceeneColorBri - j;

    // calculate R,G,B from HSV
    // Source:
    // https://blog.adafruit.com/2012/03/14/constant-brightness-hsb-to-rgb-algorithm/
    {  // just to create a local scope for  the variables
      uint8_t temp[5], n = (hue >> 8) % 3;
      uint8_t x = ((((hue & 255) * sat) >> 8) * bri) >> 8;
      uint8_t s = ((256 - sat) * bri) >> 8;
      temp[0] = temp[3] = s;
      temp[1] = temp[4] = x + s;
      temp[2] = bri - x;
      tvSimulator->actualColorR = temp[n + 2];
      tvSimulator->actualColorG = temp[n + 1];
      tvSimulator->actualColorB = temp[n];
    }
  }
  // Apply gamma correction, further expand to 16/16/16
  nr = (uint8_t)gamma8(tvSimulator->actualColorR) * 257;  // New R/G/B
  ng = (uint8_t)gamma8(tvSimulator->actualColorG) * 257;
  nb = (uint8_t)gamma8(tvSimulator->actualColorB) * 257;

  if (SEGENV.aux0 == 0) {  // initialize next iteration
    SEGENV.aux0 = 1;

    // randomize total duration and fade duration for the actual color
    tvSimulator->totalTime =
        random16(250, 2500);  // Semi-random pixel-to-pixel time
    tvSimulator->fadeTime =
        random16(0, tvSimulator->totalTime);  // Pixel-to-pixel transition time
    if (random8(10) < 3)
      tvSimulator->fadeTime = 0;  // Force scene cut 30% of time

    tvSimulator->startTime = millis();
  }  // end of initialization

  // how much time is elapsed ?
  tvSimulator->elapsed = millis() - tvSimulator->startTime;

  // fade from prev volor to next color
  if (tvSimulator->elapsed < tvSimulator->fadeTime) {
    r = map(tvSimulator->elapsed, 0, tvSimulator->fadeTime, tvSimulator->pr,
            nr);
    g = map(tvSimulator->elapsed, 0, tvSimulator->fadeTime, tvSimulator->pg,
            ng);
    b = map(tvSimulator->elapsed, 0, tvSimulator->fadeTime, tvSimulator->pb,
            nb);
  } else {  // Avoid divide-by-zero in map()
    r = nr;
    g = ng;
    b = nb;
  }

  // set strip color
  for (i = 0; i < SEGLEN; i++) {
    setPixelColor(i, r >> 8, g >> 8, b >> 8);  // Quantize to 8-bit
  }

  // if total duration has passed, remember last color and restart the loop
  if (tvSimulator->elapsed >= tvSimulator->totalTime) {
    tvSimulator->pr = nr;  // Prev RGB = new RGB
    tvSimulator->pg = ng;
    tvSimulator->pb = nb;
    SEGENV.aux0 = 0;
  }

  return FRAMETIME;
}

/*
  Aurora effect
*/

// CONFIG
#ifdef ESP8266
#define W_MAX_COUNT 9  // Number of simultaneous waves
#else
#define W_MAX_COUNT 20  // Number of simultaneous waves
#endif
#define W_MAX_SPEED 6     // Higher number, higher speed
#define W_WIDTH_FACTOR 6  // Higher number, smaller waves

// 24 bytes
class AuroraWave {
 private:
  uint16_t ttl;
  CRGB basecolor;
  float basealpha;
  uint16_t age;
  uint16_t width;
  float center;
  bool goingleft;
  float speed_factor;
  bool alive = true;

 public:
  void init(uint32_t segment_length, CRGB color) {
    ttl = random(500, 1501);
    basecolor = color;
    basealpha = random(60, 101) / (float)100;
    age = 0;
    width = random(
        segment_length / 20,
        segment_length / W_WIDTH_FACTOR);  // half of width to make math easier
    if (!width) width = 1;
    center = random(101) / (float)100 * segment_length;
    goingleft = random(0, 2) == 0;
    speed_factor = (random(10, 31) / (float)100 * W_MAX_SPEED / 255);
    alive = true;
  }

  CRGB getColorForLED(int ledIndex) {
    if (ledIndex < center - width || ledIndex > center + width)
      return 0;  // Position out of range of this wave

    CRGB rgb;

    // Offset of this led from center of wave
    // The further away from the center, the dimmer the LED
    float offset = ledIndex - center;
    if (offset < 0) offset = -offset;
    float offsetFactor = offset / width;

    // The age of the wave determines it brightness.
    // At half its maximum age it will be the brightest.
    float ageFactor = 0.1;
    if ((float)age / ttl < 0.5) {
      ageFactor = (float)age / (ttl / 2);
    } else {
      ageFactor = (float)(ttl - age) / ((float)ttl * 0.5);
    }

    // Calculate color based on above factors and basealpha value
    float factor = (1 - offsetFactor) * ageFactor * basealpha;
    rgb.r = basecolor.r * factor;
    rgb.g = basecolor.g * factor;
    rgb.b = basecolor.b * factor;

    return rgb;
  };

  // Change position and age of wave
  // Determine if its sill "alive"
  void update(uint32_t segment_length, uint32_t speed) {
    if (goingleft) {
      center -= speed_factor * speed;
    } else {
      center += speed_factor * speed;
    }

    age++;

    if (age > ttl) {
      alive = false;
    } else {
      if (goingleft) {
        if (center + width < 0) {
          alive = false;
        }
      } else {
        if (center - width > segment_length) {
          alive = false;
        }
      }
    }
  };

  bool stillAlive() { return alive; };
};

uint16_t WS2812FX::mode_aurora(void) {
  // aux1 = Wavecount
  // aux2 = Intensity in last loop

  AuroraWave* waves;

  if (SEGENV.aux0 != SEGMENT.intensity || SEGENV.call == 0) {
    // Intensity slider changed or first call
    SEGENV.aux1 = map(SEGMENT.intensity, 0, 255, 2, W_MAX_COUNT);
    SEGENV.aux0 = SEGMENT.intensity;

    if (!SEGENV.allocateData(
            sizeof(AuroraWave) *
            SEGENV.aux1)) {  // 26 on 32 segment ESP32, 9 on 16 segment ESP8266
      return mode_static();  // allocation failed
    }

    waves = reinterpret_cast<AuroraWave*>(SEGENV.data);

    for (int i = 0; i < SEGENV.aux1; i++) {
      waves[i].init(SEGLEN, col_to_crgb(color_from_palette(
                                random8(), false, false, random(0, 3))));
    }
  } else {
    waves = reinterpret_cast<AuroraWave*>(SEGENV.data);
  }

  for (int i = 0; i < SEGENV.aux1; i++) {
    // Update values of wave
    waves[i].update(SEGLEN, SEGMENT.speed);

    if (!(waves[i].stillAlive())) {
      // If a wave dies, reinitialize it starts over.
      waves[i].init(SEGLEN, col_to_crgb(color_from_palette(
                                random8(), false, false, random(0, 3))));
    }
  }

  uint8_t backlight = 1;  // dimmer backlight if less active colors
  if (SEGCOLOR(0)) backlight++;
  if (SEGCOLOR(1)) backlight++;
  if (SEGCOLOR(2)) backlight++;
  // Loop through LEDs to determine color
  for (int i = 0; i < SEGLEN; i++) {
    CRGB mixedRgb = CRGB(backlight, backlight, backlight);

    // For each LED we must check each wave if it is "active" at this position.
    // If there are multiple waves active on a LED we multiply their values.
    for (int j = 0; j < SEGENV.aux1; j++) {
      CRGB rgb = waves[j].getColorForLED(i);

      if (rgb != CRGB(0)) {
        mixedRgb += rgb;
      }
    }

    setPixelColor(i, mixedRgb[0], mixedRgb[1], mixedRgb[2]);
  }

  return FRAMETIME;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    Start of Audio Reactive fork (WLEDSR) //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Order of routines should be alphabetical for each type. They are:
//
// 1D non-reactive
// 2D non-reactive
//
// 1D volume reactive
// 1D frequency reactive
//
// 2D volume reactive
// 2D frequency reactive
//

// Sound reactive external variables and helper functions
/*  softhack007: moved up to make them availeable to "normal" effects, too */

////////////////////////////
//       set Pixels       //
////////////////////////////

void WS2812FX::setPixels(
    CRGB* leds) {  // ewowi20210703: use segmentToLogical (rotated and mirrored)
                   // to find the right led
  for (int i = 0; i < SEGLEN; i++) {
    setPixelColor(i, leds[segmentToLogical(i)].red,
                  leds[segmentToLogical(i)].green,
                  leds[segmentToLogical(i)].blue);
  }
}

/////////////////////////////
//  Non-Reactive Routines  //
/////////////////////////////

/////////////////////////
//     Perlin Move     //
/////////////////////////

// 16 bit perlinmove. Use Perlin Noise instead of sinewaves for movement. By
// Andrew Tuline. Controls are speed, # of pixels, faderate.

uint16_t WS2812FX::mode_perlinmove(void) {
  fade_out(255 - SEGMENT.custom1);
  for (int i = 0; i < SEGMENT.intensity / 16 + 1; i++) {
    uint16_t locn = inoise16(
        millis() * 128 / (260 - SEGMENT.speed) + i * 15000,
        millis() * 128 /
            (260 -
             SEGMENT.speed));  // Get a new pixel location from moving noise.
    uint16_t pixloc = map(locn, 50 * 256, 192 * 256, 0, SEGLEN) %
                      (SEGLEN);  // Map that to the length of the strand, and
                                 // ensure we don't go over.
    setPixelColor(
        pixloc, color_from_palette(pixloc % 255, false, PALETTE_SOLID_WRAP, 0));
  }

  return FRAMETIME;
}  // mode_perlinmove()

/////////////////////////
//     Waveins         //
/////////////////////////

uint16_t WS2812FX::mode_wavesins(
    void) {  // Uses beatsin8() + phase shifting. By: Andrew Tuline

  for (int i = 0; i < SEGLEN; i++) {
    uint8_t bri = sin8(millis() / 4 + i * (int)SEGMENT.intensity);
    //    leds[i] = CHSV(beatsin8(SEGMENT.speed, SEGMENT.custom1,
    //    SEGMENT.custom1+SEGMENT.custom2, 0, i * SEGMENT.custom3), 255, bri);
    leds[segmentToLogical(i)] = ColorFromPalette(
        currentPalette,
        beatsin8(SEGMENT.speed, SEGMENT.custom1,
                 SEGMENT.custom1 + SEGMENT.custom2, 0, i * SEGMENT.custom3),
        bri, LINEARBLEND);
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_waveins()

//////////////////////////////
//     Flow Stripe          //
//////////////////////////////

uint16_t WS2812FX::mode_FlowStripe(
    void) {  // By: ldirko
             // https://editor.soulmatelights.com/gallery/392-flow-led-stripe
             // , modifed by: Andrew Tuline

  const float hl = SEGLEN / 1.3;
  uint8_t hue = millis() / (SEGMENT.speed + 1);
  int t = millis() / (SEGMENT.intensity / 8 + 1);

  for (int i = 0; i < SEGLEN; i++) {
    int c = (abs(i - hl) / hl) * 127;
    c = sin8(c);
    c = sin8(c / 2 + t);
    byte b = sin8(c + t / 8);
    leds[segmentToLogical(i)] = CHSV(b + hue, 255, 255);
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_FlowStripe()

//////////////////////////////////////////////
//     START of 2D NON-REACTIVE ROUTINES    //
//////////////////////////////////////////////

// static uint16_t x = 0;
// static uint16_t y = 0;
// static uint16_t z = 0;
// static int speed2D = 20;

// uint8_t colorLoop = 1;

// Scale determines how far apart the pixels in our noise matrix are.  Try
// changing these values around to see how it affects the motion of the display.
// The higher the value of scale, the more "zoomed out" the noise iwll be.  A
// value of 1 will be so zoomed in, you'll mostly see solid colors. static int
// scale_2d = 30; // scale is set dynamically once we've started up

// blur1d: one-dimensional blur filter. Spreads light to 2 line neighbors.
// blur2d: two-dimensional blur filter. Spreads light to 8 XY neighbors.
//
//           0 = no spread at all
//          64 = moderate spreading
//         172 = maximum smooth, even spreading
//
//         173..255 = wider spreading, but increasing flicker
//
//         Total light is NOT entirely conserved, so many repeated
//         calls to 'blur' will also result in the light fading,
//         eventually all the way to black; this is by design so that
//         it can be used to (slowly) clear the LEDs to black.
void WS2812FX::blur1d(CRGB* leds, fract8 blur_amount) {
  uint8_t keep = 255 - blur_amount;
  uint8_t seep = blur_amount >> 1;
  CRGB carryover = CRGB::Black;
  for (uint16_t x = 0; x <= SEGMENT.width; x++)
    for (uint16_t y = 0; y <= SEGMENT.height;
         y++) {  // ewowi20210629: <= to blur all pixels
      CRGB cur = leds[XY(x, y)];
      CRGB part = cur;
      part.nscale8(seep);
      cur.nscale8(keep);
      cur += carryover;
      if (x > 0)  // ewowi20210701: need to test if y test also necessary
        leds[XY(x - 1, y)] += part;
      // else if (y)
      //   leds[XY(x,y-1)] += part;
      leds[XY(x, y)] = cur;
      carryover = part;
    }
}

void WS2812FX::blur2d(CRGB* leds, fract8 blur_amount) {
  blurRows(leds, blur_amount);
  blurColumns(leds, blur_amount);
}

// blurRows: perform a blur1d on every row of a rectangular matrix
void WS2812FX::blurRows(CRGB* leds, fract8 blur_amount) {
  blur1d(leds,
         blur_amount);  // ewowi20210629: this will do all rows of the segment
                        //  for( uint8_t row = 0; row < height; row++) {
                        //      CRGB* rowbase = leds + (row * width);
                        //      blur1d( rowbase, width, blur_amount);
                        //  }
}

// blurColumns: perform a blur1d on each column of a rectangular matrix
void WS2812FX::blurColumns(CRGB* leds, fract8 blur_amount) {
  // blur columns
  uint8_t keep = 255 - blur_amount;
  uint8_t seep = blur_amount >> 1;
  for (uint16_t col = 0; col < SEGMENT.width; col++) {
    CRGB carryover = CRGB::Black;
    for (uint16_t i = 0; i < SEGMENT.height; i++) {
      CRGB cur = leds[XY(col, i)];
      CRGB part = cur;
      part.nscale8(seep);
      cur.nscale8(keep);
      cur += carryover;
      if (i) leds[XY(col, i - 1)] += part;
      leds[XY(col, i)] = cur;
      carryover = part;
    }
  }
}

// ewowi20210628: new functions moved from colorutils: add segment awareness

void WS2812FX::fill_solid(struct CRGB* leds, const struct CRGB& color) {
  for (uint16_t x = 0; x <= SEGMENT.width; x++)
    for (uint16_t y = 0; y <= SEGMENT.height; y++) {
      leds[XY(x, y)] = color;
    }
}

void WS2812FX::fadeToBlackBy(CRGB* leds, uint8_t fadeBy) {
  nscale8(leds, 255 - fadeBy);
}

void WS2812FX::nscale8(CRGB* leds, uint8_t scale) {
  for (uint16_t x = 0; x <= SEGMENT.width; x++)
    for (uint16_t y = 0; y <= SEGMENT.height; y++) {
      leds[XY(x, y)].nscale8(scale);
    }
}

// line function
void WS2812FX::drawLine(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1,
                        uint32_t c) {
  const uint16_t cols = SEGMENT.width;
  const uint16_t rows = SEGMENT.height;
  if (x0 >= cols || x1 >= cols || y0 >= rows || y1 >= rows) return;
  const int16_t dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  const int16_t dy = abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  int16_t err = (dx > dy ? dx : -dy) / 2, e2;
  for (;;) {
    setPixelColor(XY(x0, y0), c);
    if (x0 == x1 && y0 == y1) break;
    e2 = err;
    if (e2 > -dx) {
      err -= dy;
      x0 += sx;
    }
    if (e2 < dy) {
      err += dx;
      y0 += sy;
    }
  }
}

void WS2812FX::drawArc(uint16_t x0, uint16_t y0, uint16_t radius,
                       uint32_t color, uint32_t fillColor) {
  // float step = degrees / (2.85f*MAX(radius,1));
  // for (float rad = 0.0f; rad <= degrees+step/2; rad += step) {
  //   // may want to try float version as well (with or without antialiasing)
  //   int x = roundf(sin_t(rad) * radius);
  //   int y = roundf(cos_t(rad) * radius);
  //   setPixelColorXY(x+x0, y+y0, c);
  // }
  float minradius = radius - .5;
  float maxradius = radius + .5;
  for (int x = 0; x < SEGMENT.width; x++)
    for (int y = 0; y < SEGMENT.height; y++) {
      int newX = x - x0;
      int newY = y - y0;

      if (newX * newX + newY * newY >= minradius * minradius &&
          newX * newX + newY * newY <= maxradius * maxradius)
        setPixelColor(XY(x, y), color);
      if (fillColor != 0)
        if (newX * newX + newY * newY < minradius * minradius)
          setPixelColor(XY(x, y), fillColor);
    }
}

uint16_t WS2812FX::XY(
    uint16_t x,
    uint16_t y) {  // ewowi20210703: new XY: segmentToReal: Maps XY in 2D
                   // segment to to rotated and mirrored logical index. Works
                   // for 1D strips and 2D panels
  return segmentToLogical(x % SEGMENT.width +
                          y % SEGMENT.height * SEGMENT.width);
}

// Use https://wokwi.com/arduino/projects/300565972972995085 to create layout
// examples
#define RIGHT 1
#define BOTTOM 1
#define HORIZONTAL 0
uint16_t WS2812FX::logicalToPhysical(
    uint16_t i) {  // ewowi20210624: previous XY. Maps logical led index to
                   // physical led index. Works for 1D strips and 2D panels By
                   // Sutaburosu (major and minor flip) and Ewoud Wijma (panels)

  int x = i % matrixWidth;
  int y = matrixWidth ? i / matrixWidth : 0;

  if (x >= matrixWidth || y >= matrixHeight)
    return SEGLEN + 1;  // Off the charts, so it's only useable by routines that
                        // use leds[x]!!!!
  uint16_t major, minor, sz_major, sz_minor;

  // Width, Height and Size of panel. Same as matrixWidth and Height if only one
  // panel
  uint16_t panelWidth = (matrixPanels && matrixHorizontalPanels)
                            ? (matrixWidth / matrixHorizontalPanels)
                            : matrixWidth;
  uint16_t panelHeight = (matrixPanels && matrixVerticalPanels)
                             ? (matrixHeight / matrixVerticalPanels)
                             : matrixHeight;
  uint16_t panelSize = panelWidth * panelHeight;

  // Horizontal and vertical panel number. 0 if only one panel
  uint8_t panelHorizontalNr = x / panelWidth;
  uint8_t panelVerticalNr = y / panelHeight;

  uint16_t panelFirstLed = 0;  // 0 if only one panel
  if (panelOrientationHorVert == HORIZONTAL) {
    if (matrixPanels)
      panelFirstLed = panelSize * (panelHorizontalNr +
                                   matrixHorizontalPanels * panelVerticalNr);
    major = x % panelWidth, minor = y % panelHeight, sz_major = panelWidth,
    sz_minor = panelHeight;
  } else {  // vertical
    if (matrixPanels)
      panelFirstLed = panelSize * (panelVerticalNr +
                                   matrixVerticalPanels * panelHorizontalNr);
    major = y % panelHeight, minor = x % panelWidth, sz_major = panelHeight,
    sz_minor = panelWidth;
  }

  bool flipmajor = (panelOrientationHorVert == HORIZONTAL)
                       ? panelFirstLedLeftRight == RIGHT
                       : panelFirstLedTopBottom == BOTTOM;
  bool flipminor = (panelOrientationHorVert == HORIZONTAL)
                       ? panelFirstLedTopBottom == BOTTOM
                       : panelFirstLedLeftRight == RIGHT;
  // By: Sutaburosu -  Who wrote this VERY COOL and VERY short and MUCH better
  // XY() routine. Thanks!! flip minor if needed, this needs to be done before
  // flipmajor because minor value needed to identify serpentine row
  if (flipminor) minor = sz_minor - 1 - minor;
  if (flipmajor ^ ((minor & 1) && panelSerpentine))
    major = sz_major - 1 - major;  // A line of magic.
  // &=Binary AND, minor&1 is odd rows, ^=Binary XOR => flapmajor or serpentine
  // (odd) row, but not both (XOR)

  if (panelTranspose)
    return major * (uint16_t)sz_minor + minor + panelFirstLed;
  else
    return minor * (uint16_t)sz_major + major + panelFirstLed;
}

uint16_t WS2812FX::
    mode_2DBlackHole() {  // By: Stepko
                          // https://editor.soulmatelights.com/gallery/1012
                          // , Modified by: Andrew Tuline

  fadeToBlackBy(leds, 32);
  double t = (float)(millis()) / 128;
  for (byte i = 0; i < 8; i++) {
    leds[XY(beatsin8(SEGMENT.custom1 / 8, 0, SEGMENT.width - 1, 0,
                     ((i % 2) ? 128 : 0) + t * i),
            beatsin8(10, 0, SEGMENT.height - 1, 0,
                     ((i % 2) ? 192 : 64) + t * i))] += CHSV(i * 32, 255, 255);
  }
  for (byte i = 0; i < 8; i++) {
    leds[XY(beatsin8(SEGMENT.custom2 / 8, SEGMENT.width / 4,
                     SEGMENT.width - 1 - SEGMENT.width / 4, 0,
                     ((i % 2) ? 128 : 0) + t * i),
            beatsin8(SEGMENT.custom3 / 8, SEGMENT.height / 4,
                     SEGMENT.height - 1 - SEGMENT.height / 4, 0,
                     ((i % 2) ? 192 : 64) + t * i))] += CHSV(i * 32, 255, 255);
  }
  leds[XY(SEGMENT.width / 2, SEGMENT.height / 2)] = CHSV(0, 0, 255);
  blur2d(leds, 16);

  setPixels(leds);
  return FRAMETIME;
}  // mode_2DBlackHole()

////////////////////////////
//     2D Colored Bursts  //
////////////////////////////

uint16_t WS2812FX::
    mode_2DColoredBursts() {  // By: ldirko
                              // https://editor.soulmatelights.com/gallery/819-colored-bursts
                              // , modified by: Andrew Tuline

  bool dot = false;
  bool grad = true;

  static byte hue = 0;
  static byte numLines = 10;

  hue++;
  numLines = SEGMENT.intensity / 16;
  fadeToBlackBy(leds, 40);

  for (byte i = 0; i < numLines; i++) {
    byte x1 = beatsin8(2 + SEGMENT.speed / 16, 0, (SEGMENT.width - 1));
    byte x2 = beatsin8(1 + SEGMENT.speed / 16, 0, (SEGMENT.width - 1));
    byte y1 =
        beatsin8(5 + SEGMENT.speed / 16, 0, (SEGMENT.height - 1), 0, i * 24);
    byte y2 = beatsin8(3 + SEGMENT.speed / 16, 0, (SEGMENT.height - 1), 0,
                       i * 48 + 64);
    CRGB color = ColorFromPalette(currentPalette, i * 255 / numLines + hue, 255,
                                  LINEARBLEND);

    byte xsteps = abs8(x1 - y1) + 1;
    byte ysteps = abs8(x2 - y2) + 1;
    byte steps = xsteps >= ysteps ? xsteps : ysteps;

    for (byte i = 1; i <= steps; i++) {
      byte dx = lerp8by8(x1, y1, i * 255 / steps);
      byte dy = lerp8by8(x2, y2, i * 255 / steps);
      int index = XY(dx, dy);
      leds[index] += color;  // change to += for brightness look
      if (grad) leds[index] %= (i * 255 / steps);  // Draw gradient line
    }

    if (dot) {  // add white point at the ends of line
      leds[XY(x1, x2)] += CRGB::White;
      leds[XY(y1, y2)] += CRGB::White;
    }
  }
  blur2d(leds, 4);

  setPixels(
      leds);  // Use this ONLY if we're going to display via leds[x] method.
  return FRAMETIME;
}  // mode_2DColoredBursts()

/////////////////////
//      2D DNA     //
/////////////////////

uint16_t WS2812FX::mode_2Ddna(
    void) {  // dna originally by by ldirko at https://pastebin.com/pCkkkzcs.
             // Updated by Preyy. WLED conversion by Andrew Tuline.

  fadeToBlackBy(leds, 64);

  for (int i = 0; i < SEGMENT.width;
       i++) {  // change to height if you want to re-orient, and swap the 4
               // lines below.
    //     leds[XY(beatsin8(SEGMENT.speed/8, 0, SEGMENT.width-1, 0, i*4), i)] =
    //     ColorFromPalette(currentPalette, i*5+millis()/17, beatsin8(5, 55,
    //     255, 0, i*10), LINEARBLEND); leds[XY(beatsin8(SEGMENT.speed/8, 0,
    //     SEGMENT.width-1, 0, i*4+128), i)] =
    //     ColorFromPalette(currentPalette,i*5+128+millis()/17, beatsin8(5, 55,
    //     255, 0, i*10+128), LINEARBLEND);        // 180 degrees (128) out of
    //     phase
    leds[XY(i, beatsin8(SEGMENT.speed / 8, 0, SEGMENT.height - 1, 0, i * 4))] =
        ColorFromPalette(currentPalette, i * 5 + millis() / 17,
                         beatsin8(5, 55, 255, 0, i * 10), LINEARBLEND);
    leds[XY(i, beatsin8(SEGMENT.speed / 8, 0, SEGMENT.height - 1, 0,
                        i * 4 + 128))] =
        ColorFromPalette(currentPalette, i * 5 + 128 + millis() / 17,
                         beatsin8(5, 55, 255, 0, i * 10 + 128),
                         LINEARBLEND);  // 180 degrees (128) out of phase
  }

  blur2d(leds, SEGMENT.intensity / 8);

  setPixels(leds);

  return FRAMETIME;
}  // mode_2Ddna()

/////////////////////////
//     2D DNA Spiral   //
/////////////////////////

uint16_t
WS2812FX::mode_2DDNASpiral() {  // By: ldirko
                                // https://editor.soulmatelights.com/gallery/810
                                // , modified by: Andrew Tuline

  uint8_t speeds = SEGMENT.speed / 2;
  uint8_t freq = SEGMENT.intensity / 8;

  static byte hue = 0;
  int ms = millis() / 20;
  nscale8(leds, 120);

  for (int i = 0; i < SEGMENT.height; i++) {
    int x = beatsin8(speeds, 0, SEGMENT.width - 1, 0, i * freq) +
            beatsin8(speeds - 7, 0, SEGMENT.width - 1, 0, i * freq + 128);
    int x1 = beatsin8(speeds, 0, SEGMENT.width - 1, 0, 128 + i * freq) +
             beatsin8(speeds - 7, 0, SEGMENT.width - 1, 0, 128 + 64 + i * freq);
    hue = i * 128 / SEGMENT.width +
          ms;  // ewowi20210629: not width - 1 to avoid crash if width = 1
    if ((i + ms / 8) & 3) {
      x = x / 2;
      x1 = x1 / 2;
      byte steps = abs8(x - x1) + 1;
      for (byte k = 1; k <= steps; k++) {
        byte dx = lerp8by8(x, x1, k * 255 / steps);
        int index = XY(dx, i);
        leds[index] += ColorFromPalette(currentPalette, hue, 255, LINEARBLEND);
        leds[index] %= (k * 255 / steps);  // for draw gradient line
      }
      leds[XY(x, i)] += CRGB::DarkSlateGray;
      leds[XY(x1, i)] += CRGB::White;
    }
  }

  setPixels(
      leds);  // Use this ONLY if we're going to display via leds[x] method.
  return FRAMETIME;
}  // mode_2DDNASpiral()

/////////////////////////
//     2D Drift        //
/////////////////////////

uint16_t WS2812FX::
    mode_2DDrift() {  // By: Stepko
                      // https://editor.soulmatelights.com/gallery/884-drift
                      // , Modified by: Andrew Tuline

#define CenterX ((SEGMENT.width / 2) - 0.5)
#define CenterY ((SEGMENT.height / 2) - 0.5)
  const byte maxDim = max(SEGMENT.width, SEGMENT.height);
  fadeToBlackBy(leds, 128);
  unsigned long t = millis() / (32 - SEGMENT.speed / 8);
  for (float i = 1; i < maxDim / 2; i += 0.25) {
    double angle = radians(t * (maxDim / 2 - i));
    int myX = (int)(CenterX + sinf(angle) * i);
    int myY = (int)(CenterY + cosf(angle) * i);
    leds[XY(myX, myY)] +=
        ColorFromPalette(currentPalette, (i * 20) + (t / 20), 255, LINEARBLEND);
  }
  blur2d(leds, SEGMENT.intensity / 8);

  setPixels(
      leds);  // Use this ONLY if we're going to display via leds[x] method.
  return FRAMETIME;
}  // mode_2DDrift()

/////////////////////////
//     2D Fire2012     //
/////////////////////////

uint16_t WS2812FX::mode_2Dfire2012(
    void) {  // Fire2012 by Mark Kriegsman. Converted to WLED by Andrew Tuline.

  const uint8_t COOLING = 50;
  const uint8_t SPARKING = 50;

  CRGBPalette16 currentPalette =
      CRGBPalette16(CRGB::Black, CRGB::Red, CRGB::Orange, CRGB::Yellow);

  if (millis() - SEGENV.step >= ((256 - SEGMENT.speed) >> 2)) {
    SEGENV.step = millis();
    // static byte *heat = (uint16_t *)dataStore;

    if (!SEGENV.allocateData(sizeof(byte) * 4096))
      return mode_static();  // allocation failed
    byte* heat = reinterpret_cast<byte*>(SEGENV.data);

    for (uint16_t mw = 0; mw < SEGMENT.width;
         mw++) {  // Move along the width of the flame

      uint16_t cell;
      // Step 1.  Cool down every cell a little
      for (uint16_t mh = 0; mh < SEGMENT.height; mh++) {
        cell = (mw * SEGMENT.width + mh) % 4096;
        heat[cell] = qsub8(heat[cell],
                           random16(0, ((COOLING * 10) / SEGMENT.height) + 2));
      }

      // Step 2.  Heat from each cell drifts 'up' and diffuses a little
      for (uint16_t mh = SEGMENT.height - 1; mh >= 2; mh--) {
        cell = (mw * SEGMENT.width + mh) % 4096;
        heat[cell] = (heat[cell - 1] + heat[cell - 2] + heat[cell - 2]) / 3;
      }

      // Step 3.  Randomly ignite new 'sparks' of heat near the bottom
      if (random8(0, 255) < SPARKING) {
        uint8_t mh = random8(3);
        cell = (mw * SEGMENT.width + mh) % 4096;
        heat[cell] = qadd8(heat[cell], random8(160, 255));
      }

      // Step 4.  Map from heat cells to LED colors
      for (uint16_t mh = 0; mh < SEGMENT.height; mh++) {
        cell = (mw * SEGMENT.width + mh) % 4096;
        byte colorindex = scale8(heat[cell], 240);
        uint16_t pixelnumber =
            (SEGMENT.height - 1) - mh;  // Flip it upside down.
        leds[XY(mw, pixelnumber)] =
            ColorFromPalette(currentPalette, colorindex,
                             255);  // Otherwise, it was leds[XY(mw,mh)] = . . .
      }  // for mh
    }  // for mw

    setPixels(leds);

  }  // if millis

  return FRAMETIME;
}  // mode_2Dfire2012()

//////////////////////////
//     2D Firenoise     //
//////////////////////////

uint16_t WS2812FX::mode_2Dfirenoise(
    void) {  // firenoise2d. By Andrew Tuline. Yet another short routine.

  uint16_t xscale = SEGMENT.intensity * 4;
  //  uint32_t xscale = 600;                                  // How far apart
  //  they are uint32_t yscale = 1000;                                 // How
  //  fast they move
  uint32_t yscale = SEGMENT.speed * 8;
  uint8_t indexx = 0;

  currentPalette = CRGBPalette16(
      CRGB(0, 0, 0), CRGB(0, 0, 0), CRGB(0, 0, 0), CRGB(0, 0, 0), CRGB::Red,
      CRGB::Red, CRGB::Red, CRGB::DarkOrange, CRGB::DarkOrange,
      CRGB::DarkOrange, CRGB::Orange, CRGB::Orange, CRGB::Yellow, CRGB::Orange,
      CRGB::Yellow, CRGB::Yellow);

  for (int j = 0; j < SEGMENT.width; j++) {
    for (int i = 0; i < SEGMENT.height; i++) {
      indexx = inoise8(
          j * yscale * SEGMENT.height / 255,
          i * xscale + millis() / 4);  // We're moving along our Perlin map.
      leds[XY(j, i)] = ColorFromPalette(
          currentPalette, min(i * (indexx) >> 4, 255), i * 255 / SEGMENT.width,
          LINEARBLEND);  // With that value, look up the 8 bit colour palette
                         // value and assign it to the current LED.

      // This perlin fire is by /u/ldirko
      //      int a = millis();
      //      leds[XY(i,j)] = ColorFromPalette (currentPalette, qsub8(inoise8 (i
      //      * 60 , j * 60+ a , a /3), abs8(j - (SEGMENT.height-1)) * 255 /
      //      (SEGMENT.height-1)), 255);

    }  // for i
  }  // for j

  setPixels(leds);

  return FRAMETIME;
}  // mode_2Dfirenoise()

//////////////////////////////
//     2D Frizzles          //
//////////////////////////////

uint16_t WS2812FX::mode_2DFrizzles(
    void) {  // By: Stepko
             // https://editor.soulmatelights.com/gallery/640-color-frizzles
             // , Modified by: Andrew Tuline

  fadeToBlackBy(leds, 16);
  for (int i = 8; i > 0; i--) {  // WLEDSR bugfix
    leds[XY(beatsin8(SEGMENT.speed / 8 + i, 0, SEGMENT.width - 1),
            beatsin8(SEGMENT.intensity / 8 - i, 0, SEGMENT.height - 1))] +=
        ColorFromPalette(currentPalette, beatsin8(12, 0, 255), 255,
                         LINEARBLEND);
  }
  blur2d(leds, 16);

  setPixels(leds);
  return FRAMETIME;
}  // mode_2DFrizzles()

///////////////////////////////////////////
//   2D Cellular Automata Game of life   //
///////////////////////////////////////////

typedef struct ColorCount {
  CRGB color;
  int8_t count;
} colorCount;

uint16_t WS2812FX::mode_2Dgameoflife(
    void) {  // Written by Ewoud Wijma, inspired by
             // https://natureofcode.com/book/chapter-7-cellular-automata/ and
             // https://github.com/DougHaber/nlife-color

  // slow down based on speed parameter
  if (millis() - SEGENV.step >= ((255 - SEGMENT.speed) * 4)) {
    SEGENV.step = millis();

    CRGB prevLeds[32 * 32];  // MAX_LED causes a panic, but this will do

    // array of patterns. Needed to identify repeating patterns. A pattern is
    // one iteration of leds, without the color (on/off only)
    const int patternsSize = (SEGMENT.width + SEGMENT.height) *
                             2;  // seems to be a good value to catch also
                                 // repetition in moving patterns
    if (!SEGENV.allocateData(sizeof(String) * patternsSize))
      return mode_static();  // allocation failed
    String* patterns = reinterpret_cast<String*>(SEGENV.data);

    CRGB backgroundColor = SEGCOLOR(1);

    static unsigned long
        resetMillis;  // triggers reset if more than 3 seconds from millis()

    if (SEGENV.call == 0) {  // effect starts
      // check if no pixels on screen (there could be due to previous effect,
      // which we then take as starting point)
      bool allZero = true;
      for (int x = 0; x < SEGMENT.width && allZero; x++)
        for (int y = 0; y < SEGMENT.height && allZero; y++)
          if (leds[XY(x, y)].r > 10 || leds[XY(x, y)].g > 10 ||
              leds[XY(x, y)].b >
                  10)  // looks like some pixels are not completely off
            allZero = false;
      if (!allZero) resetMillis = millis();  // avoid reset
    }

    // reset leds if effect repeats (wait 3 seconds after repetition)
    if (millis() - resetMillis > 3000) {
      resetMillis = millis();

      random16_set_seed(millis());  // seed the random generator

      // give the leds random state and colors (based on intensity, colors from
      // palette or all posible colors are chosen)
      for (int x = 0; x < SEGMENT.width; x++)
        for (int y = 0; y < SEGMENT.height; y++) {
          uint8_t state = random8() % 2;
          if (state == 0)
            leds[XY(x, y)] = backgroundColor;
          else
            leds[XY(x, y)] = SEGMENT.intensity < 128
                                 ? (CRGB)color_wheel(random8())
                                 : CRGB(random8(), random8(), random8());
        }

      // init patterns
      SEGENV.aux0 = 0;  // ewowi20210629: pka static! patternsize: round robin
                        // index of next slot to add pattern
      for (int i = 0; i < patternsSize; i++) patterns[i] = "";
    } else {
      // copy previous leds
      for (int x = 0; x < SEGMENT.width; x++)
        for (int y = 0; y < SEGMENT.height; y++)
          prevLeds[XY(x, y)] = leds[XY(x, y)];

      // calculate new leds
      for (int x = 0; x < SEGMENT.width; x++)
        for (int y = 0; y < SEGMENT.height; y++) {
          colorCount
              colorsCount[9];  // count the different colors in the 9*9 matrix
          for (int i = 0; i < 9; i++)
            colorsCount[i] = {backgroundColor, 0};  // init colorsCount

          // iterate through neighbors and count them and their different colors
          int neighbors = 0;
          for (int i = -1; i <= 1; i++)
            for (int j = -1; j <= 1; j++) {  // iterate through 9*9 matrix
              uint16_t xy = XY((x + i + SEGMENT.width) % SEGMENT.width,
                               (y + j + SEGMENT.height) %
                                   SEGMENT.height);  // cell xy to check

              // count different neighbours and colors, except the centre cell
              if (xy != XY(x, y) && prevLeds[xy] != backgroundColor) {
                neighbors++;
                bool colorFound = false;
                int i;
                for (i = 0; i < 9 && colorsCount[i].count != 0; i++)
                  if (colorsCount[i].color == prevLeds[xy]) {
                    colorsCount[i].count++;
                    colorFound = true;
                  }

                if (!colorFound)
                  colorsCount[i] = {prevLeds[xy],
                                    1};  // add new color found in the array
              }
            }  // i,j

          // Rules of Life
          if ((leds[XY(x, y)] != backgroundColor) && (neighbors < 2))
            leds[XY(x, y)] = backgroundColor;  // Loneliness
          else if ((leds[XY(x, y)] != backgroundColor) && (neighbors > 3))
            leds[XY(x, y)] = backgroundColor;  // Overpopulation
          else if ((leds[XY(x, y)] == backgroundColor) &&
                   (neighbors == 3)) {  // Reproduction
            // find dominantcolor and assign to cell
            colorCount dominantColorCount = {backgroundColor, 0};
            for (int i = 0; i < 9 && colorsCount[i].count != 0; i++)
              if (colorsCount[i].count > dominantColorCount.count)
                dominantColorCount = colorsCount[i];
            if (dominantColorCount.count > 0)
              leds[XY(x, y)] =
                  dominantColorCount.color;  // assign the dominant color
          }
          // else do nothing!
        }  // x,y

      // create new pattern
      String pattern = "";
      for (int x = 0; x < SEGMENT.width; x += max(SEGMENT.width / 8, 1))
        for (int y = 0; y < SEGMENT.height; y += max(SEGMENT.height / 8, 1))
          pattern += leds[XY(x, y)] == backgroundColor
                         ? " "
                         : "o";  // string representation if on/off

      // check if repetition of patterns occurs
      bool repetition = false;
      for (int i = 0; i < patternsSize && !repetition; i++)
        repetition =
            patterns[(SEGENV.aux0 - 1 - i + patternsSize) % patternsSize] ==
            pattern;

      // add current pattern to array and increase index (round robin)
      patterns[SEGENV.aux0] = pattern;
      SEGENV.aux0 = (SEGENV.aux0 + 1) % patternsSize;

      if (!repetition) resetMillis = millis();  // if no repetition avoid reset
    }  // not reset

    setPixels(leds);
  }  // millis

  return FRAMETIME;
}  // mode_2Dgameoflife()

/////////////////////////
//     2D Hiphotic     //
/////////////////////////

uint16_t
WS2812FX::mode_2DHiphotic() {  //  By: ldirko
                               //  https://editor.soulmatelights.com/gallery/810
                               //  , Modified by: Andrew Tuline

  int a = millis() / 8;

  for (int x = 0; x < SEGMENT.width; x++) {
    for (int y = 0; y < SEGMENT.height; y++) {
      int index = XY(x, y);
      //      leds[index].b = sin8((x - 8) * cos8((y + 20) * 4) / 4 + a);
      //      leds[index].g = (sin8(x * 16 + a / 3) + cos8(y * 8 + a / 2)) / 2;
      //      leds[index].r = sin8(cos8(x * 8 + a / 3) + sin8(y * 8 + a / 4) +
      //      a); leds[index] = ColorFromPalette(currentPalette, sin8(cos8(x * 8
      //      + a / 3) + sin8(y * 8 + a / 4) + a), 255, LINEARBLEND);
      leds[index] =
          ColorFromPalette(currentPalette,
                           sin8(cos8(x * SEGMENT.speed / 16 + a / 3) +
                                sin8(y * SEGMENT.intensity / 16 + a / 4) + a),
                           255, LINEARBLEND);
    }
  }

  setPixels(
      leds);  // Use this ONLY if we're going to display via leds[x] method.
  return FRAMETIME;
}  // mode_2DHiphotic()

/////////////////////////
//     2D Julia        //
/////////////////////////

// Sliders are:
//
// intensity = Maximum number of iterations per pixel.
// Custom1 = Location of X centerpoint
// Custom2 = Location of Y centerpoint
// Custom3 = Size of the area (small value = smaller area)

typedef struct Julia {  // We can't use the 'static' keyword for persistent
                        // variables, so we have to go the LONG route to support
                        // them.
  float xcen;
  float ycen;
  float xymag;
} julia;

uint16_t WS2812FX::mode_2DJulia(
    void) {  // An animated Julia set by Andrew Tuline.

  if (!SEGENV.allocateData(sizeof(julia)))
    return mode_static();  // We use this method for allocating memory for
                           // static variables.
  Julia* julias = reinterpret_cast<Julia*>(
      SEGENV.data);  // Because 'static' doesn't work with SEGMENTS.

  float reAl;
  float imAg;

  if (SEGENV.call ==
      0) {  // Reset the center if we've just re-started this animation.
    julias->xcen = 0.;
    julias->ycen = 0.;
    julias->xymag = 1.0;

    SEGMENT.custom1 =
        128;  // Make sure the location widgets are centered to start. Too bad
    SEGMENT.custom2 = 128;  // it doesn't show up on the UI.
    SEGMENT.custom3 = 128;
    SEGMENT.intensity = 24;
  }

  julias->xcen = julias->xcen + (float)(SEGMENT.custom1 - 128) / 100000.;
  julias->ycen = julias->ycen + (float)(SEGMENT.custom2 - 128) / 100000.;
  julias->xymag = julias->xymag + (float)(SEGMENT.custom3 - 128) / 100000.;
  if (julias->xymag < 0.01) julias->xymag = 0.01;
  if (julias->xymag > 1.0) julias->xymag = 1.0;

  float xmin = julias->xcen - julias->xymag;
  float xmax = julias->xcen + julias->xymag;
  float ymin = julias->ycen - julias->xymag;
  float ymax = julias->ycen + julias->xymag;

  // Whole set should be within -1.2,1.2 to -.8 to 1.
  xmin = constrain(xmin, -1.2, 1.2);
  xmax = constrain(xmax, -1.2, 1.2);
  ymin = constrain(ymin, -.8, 1.0);
  ymax = constrain(ymax, -.8, 1.0);

  float dx;  // Delta x is mapped to the matrix size.
  float dy;  // Delta y is mapped to the matrix size.

  int maxIterations = 15;  // How many iterations per pixel before we give up.
                           // Make it 8 bits to match our range of colours.
  float maxCalc =
      16.0;  // How big is each calculation allowed to be before we give up.

  maxIterations = SEGMENT.intensity / 2;

  // Resize section on the fly for some animaton.
  reAl = -0.94299;  // PixelBlaze example
  imAg = 0.3162;

  reAl += sinf((float)millis() / 305.) / 20.;
  imAg += sinf((float)millis() / 405.) / 20.;

  //  Serial.print(reAl,4); Serial.print("\t"); Serial.print(imAg,4);
  //  Serial.println(" ");

  dx = (xmax - xmin) /
       (SEGMENT.width);  // Scale the delta x and y values to our matrix size.
  dy = (ymax - ymin) / (SEGMENT.height);

  // Start y
  float y = ymin;
  for (int j = 0; j < SEGMENT.height; j++) {
    // Start x
    float x = xmin;
    for (int i = 0; i < SEGMENT.width; i++) {
      // Now we test, as we iterate z = z^2 + c does z tend towards infinity?
      float a = x;
      float b = y;
      int iter = 0;

      while (iter < maxIterations) {  // Here we determine whether or not we're
                                      // out of bounds.
        float aa = a * a;
        float bb = b * b;
        float len = aa + bb;
        if (len > maxCalc) {  // |z| = sqrt(a^2+b^2) OR z^2 = a^2+b^2 to save on
                              // having to perform a square root.
          break;              // Bail
        }

        // This operation corresponds to z -> z^2+c where z=a+ib c=(x,y).
        // Remember to use 'foil'.
        b = 2 * a * b + imAg;
        a = aa - bb + reAl;
        iter++;
      }  // while

      // We color each pixel based on how long it takes to get to infinity, or
      // black if it never gets there.
      if (iter == maxIterations) {
        //        leds[XY(i,j)] = CRGB::Black;            // Calculation kept on
        //        going, so it was within the set.
        setPixelColor(XY(i, j), 0);
      } else {
        //        leds[XY(i,j)] = CHSV(iter*255/maxIterations,255,255);   //
        //        Near the edge of the set.
        setPixelColor(XY(i, j),
                      color_from_palette(iter * 255 / maxIterations, false,
                                         PALETTE_SOLID_WRAP, 0));
      }
      x += dx;
    }
    y += dy;
  }

  //  blur2d( leds, 64);

  //  setPixels(leds);       // Use this ONLY if we're going to display via
  //  leds[x] method.
  return FRAMETIME;

}  // mode_2DJulia()

//////////////////////////////
//     2D Lissajous         //
//////////////////////////////

uint16_t WS2812FX::mode_2DLissajous(void) {  // By: Andrew Tuline

  uint_fast16_t cols = SEGMENT.width;
  uint_fast16_t rows = SEGMENT.height;
  uint_fast16_t phase = (millis() * (1 + SEGMENT.custom3)) /
                        256;  // allow user to control rotation speed

  fadeToBlackBy(leds, SEGMENT.intensity);

  for (int i = 0; i < 256; i++) {
    uint_fast8_t xlocn = sin8(phase / 2 + (i * SEGMENT.speed) / 64);
    uint_fast8_t ylocn = cos8(phase / 2 + i * 2);

    xlocn = (cols < 2) ? 1
                       : (map(2 * xlocn, 0, 511, 0, 2 * (cols - 1)) + 1) /
                             2;  // softhack007: "*2 +1" for proper rounding
    ylocn = (rows < 2) ? 1
                       : (map(2 * ylocn, 0, 511, 0, 2 * (rows - 1)) + 1) /
                             2;  // "rows > 2" is needed to avoid div/0 in map()
    leds[XY(xlocn, ylocn)] =
        ColorFromPalette(currentPalette, millis() / 100 + i, 255, LINEARBLEND);
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_2DLissajous()

///////////////////////
//    2D Matrix      //
///////////////////////

uint16_t WS2812FX::mode_2Dmatrix(
    void) {  // Matrix2D. By Jeremy Williams. Adapted by Andrew Tuline &
             // improved by merkisoft and ewowi.

  if (SEGENV.call == 0) fill_solid(leds, 0);

  int fade = map(SEGMENT.custom1, 0, 255, 50, 250);  // equals trail size
  int speed =
      (256 - SEGMENT.speed) >> map(min(SEGMENT.height, (uint16_t)150), 0, 150,
                                   0, 3);  // slower speeds for small displays

  CRGB spawnColor;
  CRGB trailColor;

  if (SEGMENT.custom2 > 128) {
    spawnColor = SEGCOLOR(0);
    trailColor = SEGCOLOR(1);
  } else {
    spawnColor = CRGB(175, 255, 175);
    trailColor = CRGB(27, 130, 39);
  }

  if (millis() - SEGENV.step >= speed) {
    SEGENV.step = millis();
    // if (SEGMENT.custom3 < 128) {
    // // check for orientation, slider in first quarter, default orientation
    for (int16_t row = SEGMENT.height - 1; row >= 0; row--) {
      for (int16_t col = 0; col < SEGMENT.width; col++) {
        if (leds[XY(col, row)] == spawnColor) {
          leds[XY(col, row)] = trailColor;  // create trail
          if (row < SEGMENT.height - 1) leds[XY(col, row + 1)] = spawnColor;
        }
      }
    }

    // fade all leds
    for (int x = 0; x < SEGMENT.width; x++)
      for (int y = 0; y < SEGMENT.height; y++) {
        if (leds[XY(x, y)] != spawnColor)
          leds[XY(x, y)].nscale8(fade);  // only fade trail
      }

    // check for empty screen to ensure code spawn
    bool emptyScreen = true;
    for (int x = 0; x < SEGMENT.width; x++)
      for (int y = 0; y < SEGMENT.height; y++) {
        if (leds[XY(x, y)]) {
          emptyScreen = false;
          break;
        }
      }

    // spawn new falling code
    // if (SEGMENT.custom3 <=255) {
    if (random8() < SEGMENT.intensity || emptyScreen) {
      uint8_t spawnX = random8(SEGMENT.width);
      leds[XY(spawnX, 0)] = spawnColor;
    }

    setPixels(leds);
  }  // if millis

  return FRAMETIME;
}  // mode_2Dmatrix()

/////////////////////////
//     2D Metaballs    //
/////////////////////////

uint16_t WS2812FX::mode_2Dmetaballs(
    void) {  // Metaballs by Stefan Petrick. Cannot have one of the dimensions
             // be 2 or less. Adapted by Andrew Tuline.

  float speed = 1;

  // get some 2 random moving points
  uint8_t x2 = inoise8(millis() * speed, 25355, 685) / 16;
  uint8_t y2 = inoise8(millis() * speed, 355, 11685) / 16;

  uint8_t x3 = inoise8(millis() * speed, 55355, 6685) / 16;
  uint8_t y3 = inoise8(millis() * speed, 25355, 22685) / 16;

  // and one Lissajou function
  uint8_t x1 = beatsin8(23 * speed, 0, 15);
  uint8_t y1 = beatsin8(28 * speed, 0, 15);

  for (uint16_t y = 0; y < SEGMENT.height; y++) {
    for (uint16_t x = 0; x < SEGMENT.width; x++) {
      // calculate distances of the 3 points from actual pixel
      // and add them together with weightening
      uint16_t dx = abs(x - x1);
      uint16_t dy = abs(y - y1);
      uint16_t dist = 2 * sqrtf((dx * dx) + (dy * dy));

      dx = abs(x - x2);
      dy = abs(y - y2);
      dist += sqrtf((dx * dx) + (dy * dy));

      dx = abs(x - x3);
      dy = abs(y - y3);
      dist += sqrtf((dx * dx) + (dy * dy));

      // inverse result
      byte color = 1000 / dist;  // dist=0?1000: 1000 / dist;

      // map color between thresholds
      if (color > 0 and color < 60) {
        leds[XY(x, y)] = ColorFromPalette(currentPalette, color * 9, 255);
      } else {
        leds[XY(x, y)] = ColorFromPalette(currentPalette, 0, 255);
      }
      // show the 3 points, too
      leds[XY(x1, y1)] = CRGB(255, 255, 255);
      leds[XY(x2, y2)] = CRGB(255, 255, 255);
      leds[XY(x3, y3)] = CRGB(255, 255, 255);
    }
  }

  setPixels(leds);

  return FRAMETIME;
}  // mode_2Dmetaballs()

//////////////////////
//    2D Noise      //
//////////////////////

uint16_t WS2812FX::mode_2Dnoise(void) {  // By Andrew Tuline

  uint8_t scale = SEGMENT.intensity + 2;

  for (uint16_t y = 0; y < SEGMENT.height; y++) {
    for (uint16_t x = 0; x < SEGMENT.width; x++) {
      uint8_t pixelHue8 =
          inoise8(x * scale, y * scale, millis() / (16 - SEGMENT.speed / 16));
      leds[XY(x, y)] = ColorFromPalette(currentPalette, pixelHue8);
    }
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_2Dnoise()

//////////////////////////////
//     2D Plasma Ball       //
//////////////////////////////

uint16_t WS2812FX::mode_2DPlasmaball(
    void) {  // By: Stepko
             // https://editor.soulmatelights.com/gallery/659-plasm-ball
             // , Modified by: Andrew Tuline

  fadeToBlackBy(leds, 64);
  double t = millis() / (33 - SEGMENT.speed / 8);
  for (uint16_t i = 0; i < SEGMENT.width; i++) {
    uint16_t thisVal = inoise8(i * 30, t, t);
    uint16_t thisMax = map(thisVal, 0, 255, 0, SEGMENT.width);
    for (uint16_t j = 0; j < SEGMENT.height; j++) {
      uint16_t thisVal_ = inoise8(t, j * 30, t);
      uint16_t thisMax_ = map(thisVal_, 0, 255, 0, SEGMENT.height);
      uint16_t x = (i + thisMax_ - (SEGMENT.width * 2 - SEGMENT.width) / 2);
      uint16_t y = (j + thisMax - (SEGMENT.width * 2 - SEGMENT.width) / 2);
      uint16_t cx = (i + thisMax_);
      uint16_t cy = (j + thisMax);

      leds[XY(i, j)] +=
          ((x - y > -2) && (x - y < 2)) ||
                  ((SEGMENT.width - 1 - x - y) > -2 &&
                   (SEGMENT.width - 1 - x - y < 2)) ||
                  (SEGMENT.width - cx == 0) || (SEGMENT.width - 1 - cx == 0) ||
                  ((SEGMENT.height - cy == 0) || (SEGMENT.height - 1 - cy == 0))
              ? ColorFromPalette(currentPalette, beat8(5), thisVal, LINEARBLEND)
              : CHSV(0, 0, 0);
    }
  }
  blur2d(leds, 4);

  setPixels(leds);
  return FRAMETIME;
}  // mode_2DPlasmaball()

////////////////////////////////
//  2D Polar Lights           //
////////////////////////////////

static float fmap(const float x, const float in_min, const float in_max,
                  const float out_min, const float out_max) {
  return (out_max - out_min) * (x - in_min) / (in_max - in_min) + out_min;
}

uint16_t WS2812FX::
    mode_2DPolarLights() {  // By: Kostyantyn Matviyevskyy
                            // https://editor.soulmatelights.com/gallery/762-polar-lights
                            // , Modified by: Andrew Tuline

  CRGBPalette16 currentPalette = {0x000000, 0x003300, 0x006600, 0x009900,
                                  0x00cc00, 0x00ff00, 0x33ff00, 0x66ff00,
                                  0x99ff00, 0xccff00, 0xffff00, 0xffcc00,
                                  0xff9900, 0xff6600, 0xff3300, 0xff0000};

  float adjustHeight = fmap(SEGMENT.height, 8, 32, 28, 12);

  uint16_t adjScale = map(SEGMENT.width, 8, 64, 310, 63);

  static unsigned long timer;  // Cannot be uint16_t value (aka aux0)

  if (SEGENV.aux1 !=
      SEGMENT.custom1 / 12) {  // Hacky palette rotation. We need that black.

    SEGENV.aux1 = SEGMENT.custom1;
    for (int i = 0; i < 16; i++) {
      long ilk;
      ilk = (long)currentPalette[i].r << 16;
      ilk += (long)currentPalette[i].g << 8;
      ilk += (long)currentPalette[i].b;
      ilk = (ilk << SEGENV.aux1) | (ilk >> (24 - SEGENV.aux1));
      currentPalette[i].r = ilk >> 16;
      currentPalette[i].g = ilk >> 8;
      currentPalette[i].b = ilk;
    }
  }

  uint16_t _scale = map(SEGMENT.intensity, 1, 255, 30, adjScale);
  byte _speed = map(SEGMENT.speed, 1, 255, 128, 16);

  for (uint16_t x = 0; x < SEGMENT.width; x++) {
    for (uint16_t y = 0; y < SEGMENT.height; y++) {
      timer++;
      leds[XY(x, y)] = ColorFromPalette(
          currentPalette,
          qsub8(inoise8(SEGENV.aux0 % 2 + x * _scale, y * 16 + timer % 16,
                        timer / _speed),
                fabs((float)SEGMENT.height / 2 - (float)y) * adjustHeight));
    }
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_2DPolarLights()

/////////////////////////
//     2D Pulser       //
/////////////////////////

uint16_t WS2812FX::
    mode_2DPulser() {  // By: ldirko
                       // https://editor.soulmatelights.com/gallery/878-pulse-test
                       // , modifed by: Andrew Tuline

  if (SEGENV.call == 0) FastLED.clear();

  static byte r = 16;
  uint16_t a = millis() / (18 - SEGMENT.speed / 16);
  byte x = (a / 14) % SEGMENT.width;
  byte y = (sin8(a * 5) + sin8(a * 4) + sin8(a * 2)) / 3 * r / 255;
  uint16_t index = XY(x, (SEGMENT.height / 2 - r / 2 + y) % SEGMENT.width);
  leds[index] =
      ColorFromPalette(currentPalette, y * 16 - 100, 255, LINEARBLEND);
  blur2d(leds, SEGMENT.intensity / 16);

  setPixels(
      leds);  // Use this ONLY if we're going to display via leds[x] method.
  return FRAMETIME;
}  // mode_2DPulser()

/////////////////////////
//     2D Sindots      //
/////////////////////////

uint16_t WS2812FX::
    mode_2DSindots() {  // By: ldirko
                        // https://editor.soulmatelights.com/gallery/597-sin-dots
                        // , modified by: Andrew Tuline

  fadeToBlackBy(leds, 15);
  byte t1 = millis() / (257 - SEGMENT.speed);  // 20;
  byte t2 = sin8(t1) / 4 * 2;
  for (uint16_t i = 0; i < 13; i++) {
    byte x = sin8(t1 + i * SEGMENT.intensity / 8) * (SEGMENT.width - 1) /
             255;  //   max index now 255x15/255=15!
    byte y = sin8(t2 + i * SEGMENT.intensity / 8) * (SEGMENT.height - 1) /
             255;  //  max index now 255x15/255=15!
    leds[XY(x, y)] =
        ColorFromPalette(currentPalette, i * 255 / 13, 255, LINEARBLEND);
  }
  blur2d(leds, 16);

  setPixels(
      leds);  // Use this ONLY if we're going to display via leds[x] method.
  return FRAMETIME;
}  // mode_2DSindots()

//////////////////////////////
//     2D Squared Swirl     //
//////////////////////////////

uint16_t WS2812FX::mode_2Dsquaredswirl(
    void) {  // By: Mark Kriegsman.
             // https://gist.github.com/kriegsman/368b316c55221134b160 Modifed
             // by: Andrew Tuline custom3 affects the blur amount.

  const uint8_t kBorderWidth = 2;

  fadeToBlackBy(leds, 24);
  // uint8_t blurAmount = dim8_raw( beatsin8(20,64,128) );  //3,64,192
  uint8_t blurAmount = SEGMENT.custom3;
  blur2d(leds, blurAmount);

  // Use two out-of-sync sine waves
  uint8_t i = beatsin8(19, kBorderWidth, SEGMENT.width - kBorderWidth);
  uint8_t j = beatsin8(22, kBorderWidth, SEGMENT.width - kBorderWidth);
  uint8_t k = beatsin8(17, kBorderWidth, SEGMENT.width - kBorderWidth);
  uint8_t m = beatsin8(18, kBorderWidth, SEGMENT.height - kBorderWidth);
  uint8_t n = beatsin8(15, kBorderWidth, SEGMENT.height - kBorderWidth);
  uint8_t p = beatsin8(20, kBorderWidth, SEGMENT.height - kBorderWidth);

  uint16_t ms = millis();

  leds[XY(i, m)] += ColorFromPalette(currentPalette, ms / 29, 255, LINEARBLEND);
  leds[XY(j, n)] += ColorFromPalette(currentPalette, ms / 41, 255, LINEARBLEND);
  leds[XY(k, p)] += ColorFromPalette(currentPalette, ms / 73, 255, LINEARBLEND);

  setPixels(leds);

  return FRAMETIME;
}  // mode_2Dsquaredswirl()

//////////////////////////////
//     2D Sun Radiation     //
//////////////////////////////

uint16_t WS2812FX::mode_2DSunradiation(
    void) {  // By: ldirko
             // https://editor.soulmatelights.com/gallery/599-sun-radiation  ,
             // modified by: Andrew Tuline Does not yet support segments.

  static CRGB chsvLut[256];
  static byte bump[1156];  // Don't go beyond a 32x32 matrix!!!  or
                           // (SEGMENT.width+2) * (mtrixHeight+2)

  if (SEGMENT.intensity != SEGENV.aux0) {
    SEGENV.aux0 = SEGMENT.intensity;
    for (int j = 0; j < 256; j++) {
      chsvLut[j] = HeatColor(
          j / (3.0 - (float)(SEGMENT.intensity) / 128.));  // 256 pallette color
    }
  }

  int t = millis() / 4;
  int index = 0;
  uint8_t someVal = SEGMENT.speed / 4;  // Was 25.
  for (uint16_t j = 0; j < (SEGMENT.height + 2); j++) {
    for (uint16_t i = 0; i < (SEGMENT.width + 2); i++) {
      byte col = (inoise8_raw(i * someVal, j * someVal, t)) / 2;
      bump[index++] = col;
    }
  }

  int yindex = SEGMENT.width + 3;
  int16_t vly = -(SEGMENT.height / 2 + 1);
  for (uint16_t y = 0; y < SEGMENT.height; y++) {
    ++vly;
    int16_t vlx = -(SEGMENT.width / 2 + 1);
    for (uint16_t x = 0; x < SEGMENT.width; x++) {
      ++vlx;
      int8_t nx = bump[x + yindex + 1] - bump[x + yindex - 1];
      int8_t ny = bump[x + yindex + (SEGMENT.width + 2)] -
                  bump[x + yindex - (SEGMENT.width + 2)];
      byte difx = abs8(vlx * 7 - nx);
      byte dify = abs8(vly * 7 - ny);
      int temp = difx * difx + dify * dify;
      int col = 255 - temp / 8;  // 8 its a size of effect
      if (col < 0) col = 0;
      leds[XY(x, y)] = chsvLut[col];  // thx sutubarosu ))
    }
    yindex += (SEGMENT.width + 2);
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_2DSunradiation()

/////////////////////////
//    * 2D Swirl        //
/////////////////////////

uint16_t WS2812FX::mode_2DSwirl(
    void) {  // By: Mark Kriegsman
             // https://gist.github.com/kriegsman/5adca44e14ad025e6d3b
             // , modified by Andrew Tuline

  const uint8_t borderWidth = 2;

  blur2d(leds, SEGMENT.custom1);

  uint8_t i = beatsin8(27 * SEGMENT.speed / 255, borderWidth,
                       SEGMENT.height - borderWidth);
  uint8_t j = beatsin8(41 * SEGMENT.speed / 255, borderWidth,
                       SEGMENT.width - borderWidth);
  uint8_t ni = (SEGMENT.width - 1) - i;
  uint8_t nj = (SEGMENT.width - 1) - j;
  uint16_t ms = millis();

  int tmpSound = (soundAgc) ? rawSampleAgc : sampleRaw;

  leds[XY(i, j)] += ColorFromPalette(currentPalette, (ms / 11 + sampleAvg * 4),
                                     tmpSound * SEGMENT.intensity / 64,
                                     LINEARBLEND);  // CHSV( ms / 11, 200, 255);
  leds[XY(j, i)] += ColorFromPalette(currentPalette, (ms / 13 + sampleAvg * 4),
                                     tmpSound * SEGMENT.intensity / 64,
                                     LINEARBLEND);  // CHSV( ms / 13, 200, 255);
  leds[XY(ni, nj)] +=
      ColorFromPalette(currentPalette, (ms / 17 + sampleAvg * 4),
                       tmpSound * SEGMENT.intensity / 64,
                       LINEARBLEND);  // CHSV( ms / 17, 200, 255);
  leds[XY(nj, ni)] +=
      ColorFromPalette(currentPalette, (ms / 29 + sampleAvg * 4),
                       tmpSound * SEGMENT.intensity / 64,
                       LINEARBLEND);  // CHSV( ms / 29, 200, 255);
  leds[XY(i, nj)] +=
      ColorFromPalette(currentPalette, (ms / 37 + sampleAvg * 4),
                       tmpSound * SEGMENT.intensity / 64,
                       LINEARBLEND);  // CHSV( ms / 37, 200, 255);
  leds[XY(ni, j)] +=
      ColorFromPalette(currentPalette, (ms / 41 + sampleAvg * 4),
                       tmpSound * SEGMENT.intensity / 64,
                       LINEARBLEND);  // CHSV( ms / 41, 200, 255);

  setPixels(leds);
  return FRAMETIME;
}  // mode_2DSwirl()

/////////////////////////
//     2D Tartan       //
/////////////////////////

uint16_t WS2812FX::
    mode_2Dtartan() {  // By: Elliott Kember
                       // https://editor.soulmatelights.com/gallery/3-tartan
                       // , Modified by: Andrew Tuline

  uint8_t hue;
  int offsetX = beatsin16(3, -360, 360);
  int offsetY = beatsin16(2, -360, 360);

  for (uint16_t x = 0; x < SEGMENT.width; x++) {
    for (uint16_t y = 0; y < SEGMENT.height; y++) {
      uint16_t index = XY(x, y);
      hue = x * beatsin16(10, 1, 10) + offsetY;
      leds[index] =
          ColorFromPalette(currentPalette, hue,
                           sin8(x * SEGMENT.speed + offsetX) *
                               sin8(x * SEGMENT.speed + offsetX) / 255,
                           LINEARBLEND);
      hue = y * 3 + offsetX;
      leds[index] +=
          ColorFromPalette(currentPalette, hue,
                           sin8(y * SEGMENT.intensity + offsetY) *
                               sin8(y * SEGMENT.intensity + offsetY) / 255,
                           LINEARBLEND);
    }
  }

  setPixels(
      leds);  // Use this ONLY if we're going to display via leds[x] method.
  return FRAMETIME;
}  // mode_2DTartan()

/////////////////////////
//    * 2D Waverly     //
/////////////////////////

uint16_t WS2812FX::mode_2DWaverly(
    void) {  // By: Stepko, https://editor.soulmatelights.com/gallery/652-wave ,
             // modified by Andrew Tuline

  fadeToBlackBy(leds, SEGMENT.speed);

  long t = millis() / 2;
  for (uint16_t i = 0; i < SEGMENT.width; i++) {
    //  byte thisVal = inoise8(i * 45 , t , t);
    // byte thisMax = map(thisVal, 0, 255, 0, SEGMENT.height);

    int tmpSound = (soundAgc) ? sampleAgc : sampleAvg;

    uint16_t thisVal =
        tmpSound * SEGMENT.intensity / 64 * inoise8(i * 45, t, t) / 64;
    uint16_t thisMax = map(thisVal, 0, 512, 0, SEGMENT.height);

    for (uint16_t j = 0; j < thisMax; j++) {
      leds[XY(i, j)] += ColorFromPalette(
          currentPalette, map(j, 0, thisMax, 250, 0), 255, LINEARBLEND);
      leds[XY((SEGMENT.width - 1) - i, (SEGMENT.height - 1) - j)] +=
          ColorFromPalette(currentPalette, map(j, 0, thisMax, 250, 0), 255,
                           LINEARBLEND);
    }
  }
  blur2d(leds, 16);

  setPixels(leds);
  return FRAMETIME;
}  // mode_2DWaverly()

////////////////////////////////
//   Begin volume routines    //
////////////////////////////////

///////////////////////
//   * GRAVCENTER    //
///////////////////////

typedef struct Gravity {
  int topLED;
  int gravityCounter;
} gravity;

uint16_t WS2812FX::mode_gravcenter(void) {  // Gravcenter. By Andrew Tuline.

  uint16_t dataSize = sizeof(gravity);
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed
  Gravity* gravcen = reinterpret_cast<Gravity*>(SEGENV.data);

  fade_out(240);

  float tmpSound = (soundAgc) ? sampleAgc : sampleAvg;
  float segmentSampleAvg = tmpSound * (float)SEGMENT.intensity / 255.0;
  segmentSampleAvg *=
      0.125;  // divide by 8, to compensate for later "sensitivty" upscaling

  float mySampleAvg =
      mapf(segmentSampleAvg * 2.0, 0, 32, 0,
           (float)SEGLEN / 2.0);  // map to pixels availeable in current segment
  int tempsamp = constrain(mySampleAvg, 0,
                           SEGLEN / 2);  // Keep the sample from overflowing.
  uint8_t gravity = 8 - SEGMENT.speed / 32;

  for (int i = 0; i < tempsamp; i++) {
    uint8_t index =
        inoise8(i * segmentSampleAvg + millis(), 5000 + i * segmentSampleAvg);
    setPixelColor(
        i + SEGLEN / 2,
        color_blend(SEGCOLOR(1),
                    color_from_palette(index, false, PALETTE_SOLID_WRAP, 0),
                    segmentSampleAvg * 8));
    setPixelColor(
        SEGLEN / 2 - i - 1,
        color_blend(SEGCOLOR(1),
                    color_from_palette(index, false, PALETTE_SOLID_WRAP, 0),
                    segmentSampleAvg * 8));
  }

  if (tempsamp >= gravcen->topLED)
    gravcen->topLED = tempsamp - 1;
  else if (gravcen->gravityCounter % gravity == 0)
    gravcen->topLED--;

  if (gravcen->topLED >= 0) {
    setPixelColor(gravcen->topLED + SEGLEN / 2,
                  color_from_palette(millis(), false, PALETTE_SOLID_WRAP, 0));
    setPixelColor(SEGLEN / 2 - 1 - gravcen->topLED,
                  color_from_palette(millis(), false, PALETTE_SOLID_WRAP, 0));
  }
  gravcen->gravityCounter = (gravcen->gravityCounter + 1) % gravity;

  return FRAMETIME;
}  // mode_gravcenter()

///////////////////////
//   * GRAVCENTRIC   //
///////////////////////

uint16_t WS2812FX::mode_gravcentric(void) {  // Gravcentric. By Andrew Tuline.

  uint16_t dataSize = sizeof(gravity);
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed
  Gravity* gravcen = reinterpret_cast<Gravity*>(SEGENV.data);

  // fade_out(240);
  // fade_out(240);
  fade_out(226);  // same as 2x fade_out(240)

  float tmpSound = (soundAgc) ? sampleAgc : sampleAvg;
  float segmentSampleAvg = tmpSound * (float)SEGMENT.intensity / 255.0;
  segmentSampleAvg *=
      0.125;  // divide by 8, to compensate for later "sensitivty" upscaling

  float mySampleAvg =
      mapf(segmentSampleAvg * 2.0, 0, 32, 0,
           (float)SEGLEN / 2.0);  // map to pixels availeable in current segment
  int tempsamp = constrain(mySampleAvg, 0,
                           SEGLEN / 2);  // Keep the sample from overflowing.
  uint8_t gravity = 8 - SEGMENT.speed / 32;

  for (int i = 0; i < tempsamp; i++) {
    uint8_t index = segmentSampleAvg * 24 + millis() / 200;
    setPixelColor(i + SEGLEN / 2,
                  color_from_palette(index, false, PALETTE_SOLID_WRAP, 0));
    setPixelColor(SEGLEN / 2 - 1 - i,
                  color_from_palette(index, false, PALETTE_SOLID_WRAP, 0));
  }

  if (tempsamp >= gravcen->topLED)
    gravcen->topLED = tempsamp - 1;
  else if (gravcen->gravityCounter % gravity == 0)
    gravcen->topLED--;

  if (gravcen->topLED >= 0) {
    setPixelColor(gravcen->topLED + SEGLEN / 2, CRGB::Gray);
    setPixelColor(SEGLEN / 2 - 1 - gravcen->topLED, CRGB::Gray);
  }
  gravcen->gravityCounter = (gravcen->gravityCounter + 1) % gravity;

  return FRAMETIME;
}  // mode_gravcentric()

///////////////////////
//   * GRAVIMETER    //
///////////////////////
#ifndef SR_DEBUG_AGC
uint16_t WS2812FX::mode_gravimeter(void) {  // Gravmeter. By Andrew Tuline.

  uint16_t dataSize = sizeof(gravity);
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed
  Gravity* gravcen = reinterpret_cast<Gravity*>(SEGENV.data);

  fade_out(240);

  float tmpSound = (soundAgc) ? sampleAgc : sampleAvg;
  float segmentSampleAvg = tmpSound * (float)SEGMENT.intensity / 255.0;
  segmentSampleAvg *=
      0.25;  // divide by 4, to compensate for later "sensitivty" upscaling

  float mySampleAvg =
      mapf(segmentSampleAvg * 2.0, 0, 64, 0,
           (SEGLEN - 1));  // map to pixels availeable in current segment
  int tempsamp =
      constrain(mySampleAvg, 0, SEGLEN);  // Keep the sample from overflowing.
  uint8_t gravity = 8 - SEGMENT.speed / 32;

  for (int i = 0; i < tempsamp; i++) {
    uint8_t index =
        inoise8(i * segmentSampleAvg + millis(), 5000 + i * segmentSampleAvg);
    setPixelColor(
        i, color_blend(SEGCOLOR(1),
                       color_from_palette(index, false, PALETTE_SOLID_WRAP, 0),
                       segmentSampleAvg * 8));
  }

  if (tempsamp >= gravcen->topLED)
    gravcen->topLED = max(tempsamp - 1, 0);
  else if (gravcen->gravityCounter % gravity == 0)
    gravcen->topLED--;

  if ((gravcen->topLED > 0) && (gravcen->topLED < SEGLEN - 1)) {
    setPixelColor(gravcen->topLED,
                  color_from_palette(millis(), false, PALETTE_SOLID_WRAP, 0));
  }
  gravcen->gravityCounter = (gravcen->gravityCounter + 1) % gravity;

#if 0  // WLEDSR - for peak detection debugging
  if(samplePeak > 0) setPixelColor(0, GREEN);
  //if(samplePeak > 1) setPixelColor(1, ORANGE);
  if(samplePeak > 0) setPixelColor(SEGLEN-1, GREEN);
  //if(samplePeak > 1) setPixelColor(SEGLEN-2, GREEN);
#endif

  return FRAMETIME;
}  // mode_gravimeter()

#else
// This an abuse of the gravimeter effect for AGC debugging
// instead of sound volume, it uses the AGC gain multiplier as input
uint16_t WS2812FX::mode_gravimeter(void) {  // Gravmeter. By Andrew Tuline.

  uint16_t dataSize = sizeof(gravity);
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed
  Gravity* gravcen = reinterpret_cast<Gravity*>(SEGENV.data);

  fade_out(240);

  float tmpSound = multAgc;  // AGC gain
  if (soundAgc == 0) {
    if ((sampleAvg > 1.0) && (sampleReal > 0.05))
      tmpSound = (float)sampleRaw / sampleReal;  // current non-AGC gain
    else
      tmpSound = ((float)sampleGain / 40.0 * (float)inputLevel / 128.0) +
                 1.0 / 16.0;  // non-AGC gain from presets
  }

  if (tmpSound > 2)
    tmpSound = ((tmpSound - 2.0) / 2) + 2;  // compress ranges > 2
  if (tmpSound > 1)
    tmpSound = ((tmpSound - 1.0) / 2) + 1;  // compress ranges > 1

  float segmentSampleAvg = 64.0 * tmpSound * (float)SEGMENT.intensity / 128.0;
  float mySampleAvg =
      mapf(segmentSampleAvg, 0, 128, 0,
           (SEGLEN - 1));  // map to pixels availeable in current segment
  int tempsamp =
      constrain(mySampleAvg, 0, SEGLEN);  // Keep the sample from overflowing.

  // tempsamp = SEGLEN - tempsamp;                                      //
  // uncomment to invert direction
  segmentSampleAvg =
      fmax(64.0 - fmin(segmentSampleAvg, 63), 8);  // inverted brightness

  uint8_t gravity = 8 - SEGMENT.speed / 32;

  if (sampleAvg > 1)  // disable bar "body" if below squelch
  {
    for (int i = 0; i < tempsamp; i++) {
      uint8_t index =
          inoise8(i * segmentSampleAvg + millis(), 5000 + i * segmentSampleAvg);
      setPixelColor(i, color_blend(SEGCOLOR(1),
                                   color_from_palette(index, false,
                                                      PALETTE_SOLID_WRAP, 0),
                                   segmentSampleAvg * 4.0));
    }
  }
  if (tempsamp >= gravcen->topLED)
    gravcen->topLED = tempsamp;
  else if (gravcen->gravityCounter % gravity == 0)
    gravcen->topLED--;

  if (gravcen->topLED > 0) {
    setPixelColor(gravcen->topLED,
                  color_from_palette(millis(), false, PALETTE_SOLID_WRAP, 0));
  }
  gravcen->gravityCounter = (gravcen->gravityCounter + 1) % gravity;

  return FRAMETIME;
}  // mode_gravimeter()
#endif

//////////////////////
//   * JUGGLES      //
//////////////////////

uint16_t WS2812FX::mode_juggles(void) {  // Juggles. By Andrew Tuline.

  fade_out(224);
  int my_sampleAgc = fmax(fmin(sampleAgc, 255.0), 0);

  for (int i = 0; i < SEGMENT.intensity / 32 + 1; i++) {
    setPixelColor(beatsin16(SEGMENT.speed / 4 + i * 2, 0, SEGLEN - 1),
                  color_blend(SEGCOLOR(1),
                              color_from_palette(millis() / 4 + i * 2, false,
                                                 PALETTE_SOLID_WRAP, 0),
                              my_sampleAgc));
  }

  return FRAMETIME;
}  // mode_juggles()

//////////////////////
//   * MATRIPIX     //
//////////////////////

uint16_t WS2812FX::mode_matripix(void) {  // Matripix. By Andrew Tuline.
  if (SEGENV.call == 0) fill_solid(leds, 0);

  uint8_t secondHand =
      (SEGMENT.speed < 255) ? (micros() / (256 - SEGMENT.speed) / 500 % 16) : 0;
  if ((SEGMENT.speed > 254) || (SEGENV.aux0 != secondHand)) {
    SEGENV.aux0 = secondHand;
    uint8_t tmpSound = (soundAgc) ? rawSampleAgc : sampleRaw;
    int pixBri = tmpSound * SEGMENT.intensity / 64;
    leds[segmentToLogical(SEGLEN - 1)] = color_blend(
        SEGCOLOR(1), color_from_palette(millis(), false, PALETTE_SOLID_WRAP, 0),
        pixBri);
    for (int i = 0; i < SEGLEN - 1; i++)
      leds[segmentToLogical(i)] = leds[segmentToLogical(i + 1)];
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_matripix()

//////////////////////
//   * MIDNOISE     //
//////////////////////

uint16_t WS2812FX::mode_midnoise(void) {  // Midnoise. By Andrew Tuline.

  // Changing xdist to SEGENV.aux0 and ydist to SEGENV.aux1.

  // fade_out(SEGMENT.speed);
  // fade_out(SEGMENT.speed);
  fade_out(int(SEGMENT.speed) * int(SEGMENT.speed) /
           255);  // same as two fade-out runs

  float tmpSound = (soundAgc) ? sampleAgc : sampleAvg;
  float tmpSound2 =
      tmpSound * (float)SEGMENT.intensity / 256.0;  // Too sensitive.
  tmpSound2 *= (float)SEGMENT.intensity / 128.0;    // Reduce sensitity/length.

  int maxLen = mapf(tmpSound2, 0, 127, 0, SEGLEN / 2);
  if (maxLen > SEGLEN / 2) maxLen = SEGLEN / 2;

  for (int i = (SEGLEN / 2 - maxLen); i < (SEGLEN / 2 + maxLen); i++) {
    uint8_t index = inoise8(
        i * tmpSound + SEGENV.aux0,
        SEGENV.aux1 + i * tmpSound);  // Get a value from the noise function.
                                      // I'm using both x and y axis.
    setPixelColor(i, color_from_palette(index, false, PALETTE_SOLID_WRAP, 0));
  }

  SEGENV.aux0 = SEGENV.aux0 + beatsin8(5, 0, 10);
  SEGENV.aux1 = SEGENV.aux1 + beatsin8(4, 0, 10);

  return FRAMETIME;
}  // mode_midnoise()

//////////////////////
//   * NOISEFIRE    //
//////////////////////

// I am the god of hellfire. . . Volume (only) reactive fire routine. Oh, look
// how short this is.
uint16_t WS2812FX::mode_noisefire(void) {  // Noisefire. By Andrew Tuline.

  currentPalette = CRGBPalette16(
      CHSV(0, 255, 2), CHSV(0, 255, 4), CHSV(0, 255, 8),
      CHSV(0, 255, 8),  // Fire palette definition. Lower value = darker.
      CHSV(0, 255, 16), CRGB::Red, CRGB::Red, CRGB::Red, CRGB::DarkOrange,
      CRGB::DarkOrange, CRGB::Orange, CRGB::Orange, CRGB::Yellow, CRGB::Orange,
      CRGB::Yellow, CRGB::Yellow);

  for (int i = 0; i < SEGLEN; i++) {
    uint16_t index =
        inoise8(i * SEGMENT.speed / 64,
                millis() * SEGMENT.speed / 64 * SEGLEN /
                    255);  // X location is constant, but we move along the Y at
                           // the rate of millis(). By Andrew Tuline.
    index = (255 - i * 256 / SEGLEN) * index /
            (256 -
             SEGMENT.intensity);  // Now we need to scale index so that it gets
                                  // blacker as we get close to one of the ends.
                                  // This is a simple y=mx+b equation that's
                                  // been scaled. index/128 is another scaling.

    uint8_t tmpSound = (soundAgc) ? sampleAgc : sampleAvg;

    CRGB color = ColorFromPalette(currentPalette, index, tmpSound * 2,
                                  LINEARBLEND);  // Use the my own palette.
    leds[segmentToLogical(i)] = color;
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_noisefire()

///////////////////////
//   * Noisemeter    //
///////////////////////

// uint16_t WS2812FX::mode_noisemeter(void) {
//   uint8_t fadeRate = map(SEGMENT.speed, 0, 255, 224, 255);
//   fade_out(fadeRate);

//   // Use bass intensity instead of raw sound
//   // float bassLevel = getBassIntensity();
//   float tmpSound = (soundAgc) ? rawSampleAgc : sampleRaw;
//   // float tmpSound2 = bassLevel * 2.0 * (float)SEGMENT.intensity / 255.0;
//   float tmpSound2 = tmpSound * 2.0 * (float)SEGMENT.intensity / 255.0;
//   int maxLen = mapf(tmpSound2, 0, 255, 0, SEGLEN);
//   if (maxLen > SEGLEN) maxLen = SEGLEN;

//   // Keep the original noise pattern generation
//   for (int i = 0; i < maxLen; i++) {
//     uint8_t index =
//         inoise8(i * bassLevel + SEGENV.aux0, SEGENV.aux1 + i * bassLevel);
//     setPixelColor(i, color_from_palette(index, false, PALETTE_SOLID_WRAP,
//     0));
//   }

//   SEGENV.aux0 += beatsin8(5, 0, 10);
//   SEGENV.aux1 += beatsin8(4, 0, 10);

//   return FRAMETIME;
// }  // mode_noisemeter()
uint16_t WS2812FX::mode_noisemeter(void) {
  // Speed controls both fade rate and adaptation speed
  uint8_t fadeRate = map(SEGMENT.speed, 0, 255, 224, 255);
  fade_out(fadeRate);

  static float minLevel = 0;
  static float maxLevel = 1;
  // Speed affects how quickly the meter adapts to new levels
  float adaptSpeed = map(SEGMENT.speed, 0, 255, 1, 10) * 0.001;

  float tmpSound = (soundAgc) ? sampleAgc : sampleAvg;

  // Update min/max levels with speed-dependent adaptation
  minLevel = minLevel * (1 - adaptSpeed) + tmpSound * adaptSpeed;
  if (tmpSound > maxLevel)
    maxLevel = tmpSound * 0.7 + maxLevel * 0.3;
  else
    maxLevel = maxLevel * (1 - adaptSpeed);

  if (maxLevel - minLevel < 0.1) maxLevel = minLevel + 0.1;

  float relativeLevel = (tmpSound - minLevel) / (maxLevel - minLevel);
  relativeLevel = constrain(relativeLevel, 0.0, 1.0);
  relativeLevel = powf(relativeLevel, 0.5);

  float tmpSound2 = relativeLevel * 255.0 * (float)SEGMENT.intensity / 255.0;
  int maxLen = mapf(tmpSound2, 0, 255, 0, SEGLEN);
  if (maxLen > SEGLEN) maxLen = SEGLEN;

  // Speed also affects noise pattern movement rate
  uint8_t noiseSpeed = map(SEGMENT.speed, 0, 255, 2, 8);
  for (int i = 0; i < maxLen; i++) {
    uint8_t index =
        inoise8(i * tmpSound + SEGENV.aux0, SEGENV.aux1 + i * tmpSound);
    setPixelColor(i, color_from_palette(index, false, PALETTE_SOLID_WRAP, 0));
  }

  SEGENV.aux0 += beatsin8(noiseSpeed, 0, 10);
  SEGENV.aux1 += beatsin8(noiseSpeed - 1, 0, 10);

  return FRAMETIME;
}

//////////////////////
//     * PIXELS     //
//////////////////////

uint16_t WS2812FX::mode_pixels(void) {  // Pixels. By Andrew Tuline.

  fade_out(SEGMENT.speed);

  for (int i = 0; i < SEGMENT.intensity / 16; i++) {
    uint16_t segLoc = random(SEGLEN);  // 16 bit for larger strands of LED's.
    setPixelColor(segLoc,
                  color_blend(SEGCOLOR(1),
                              color_from_palette(myVals[i % 32] + i * 4, false,
                                                 PALETTE_SOLID_WRAP, 0),
                              sampleAgc));
  }

  return FRAMETIME;
}  // mode_pixels()

//////////////////////
//   * PIXELWAVE    //
//////////////////////

uint16_t WS2812FX::mode_pixelwave(void) {  // Pixelwave. By Andrew Tuline.

  if (SEGENV.call == 0) fill_solid(leds, 0);
  uint8_t secondHand = (SEGMENT.speed < 255)
                           ? (micros() / (256 - SEGMENT.speed) / 500 + 1 % 16)
                           : 0;

  if ((SEGMENT.speed > 254) || (SEGENV.aux0 != secondHand)) {
    SEGENV.aux0 = secondHand;

    uint8_t tmpSound = (soundAgc) ? rawSampleAgc : sampleRaw;
    int pixBri = tmpSound * SEGMENT.intensity / 64;
    leds[segmentToLogical(SEGLEN / 2)] = color_blend(
        SEGCOLOR(1), color_from_palette(millis(), false, PALETTE_SOLID_WRAP, 0),
        pixBri);

    for (int i = SEGLEN - 1; i > SEGLEN / 2; i--) {  // Move to the right.
      leds[segmentToLogical(i)] = leds[segmentToLogical(i - 1)];
    }
    for (int i = 0; i < SEGLEN / 2; i++) {  // Move to the left.
      leds[segmentToLogical(i)] = leds[segmentToLogical(i + 1)];
    }
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_pixelwave()

//////////////////////
//   * PLASMOID     //
//////////////////////

typedef struct Plasphase {
  int16_t thisphase;
  int16_t thatphase;
} plasphase;

uint16_t WS2812FX::mode_plasmoid(void) {  // Plasmoid. By Andrew Tuline.

  uint16_t dataSize = sizeof(plasphase);
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed
  Plasphase* plasmoip = reinterpret_cast<Plasphase*>(SEGENV.data);

  fadeToBlackBy(leds, 64);

  plasmoip->thisphase +=
      beatsin8(6, -4, 4);  // You can change direction and speed individually.
  plasmoip->thatphase += beatsin8(
      7, -4,
      4);  // Two phase values to make a complex pattern. By Andrew Tuline.

  for (int i = 0; i < SEGLEN;
       i++) {  // For each of the LED's in the strand, set a brightness based on
               // a wave as follows.
    // updated, similar to "plasma" effect - softhack007
    uint8_t thisbright = cubicwave8(((i * (1 + (3 * SEGMENT.speed / 32))) +
                                     plasmoip->thisphase) &
                                    0xFF) /
                         2;
    thisbright +=
        cos8(((i * (97 + (5 * SEGMENT.speed / 32))) + plasmoip->thatphase) &
             0xFF) /
        2;  // Let's munge the brightness a bit and animate it all with the
            // phases.

    uint8_t colorIndex = thisbright;
    int tmpSound = (soundAgc) ? sampleAgc : sampleAvg;
    if (tmpSound * SEGMENT.intensity / 64 < thisbright) {
      thisbright = 0;
    }

    leds[segmentToLogical(i)] += color_blend(
        SEGCOLOR(1),
        color_from_palette(colorIndex, false, PALETTE_SOLID_WRAP, 0),
        thisbright);
  }

  setPixels(leds);

  return FRAMETIME;
}  // mode_plasmoid()

///////////////////////
//   * PUDDLEPEAK    //
///////////////////////

// Andrew's crappy peak detector. If I were 40+ years younger, I'd learn signal
// processing.
uint16_t WS2812FX::mode_puddlepeak(void) {  // Puddlepeak. By Andrew Tuline.

  uint16_t size = 0;
  uint8_t fadeVal = map(SEGMENT.speed, 0, 255, 224, 255);
  uint16_t pos = random(SEGLEN);  // Set a random starting position.

  binNum = SEGMENT.custom2;      // Select a bin.
  maxVol = SEGMENT.custom3 / 4;  // Our volume comparator.

  fade_out(fadeVal);

  if (samplePeak > 0) {
    size = sampleAgc * SEGMENT.intensity / 256 / 4 +
           1;  // Determine size of the flash based on the volume.
    if (pos + size >= SEGLEN) size = SEGLEN - pos;
  }

  for (int i = 0; i < size; i++) {  // Flash the LED's.
    setPixelColor(pos + i,
                  color_from_palette(millis(), false, PALETTE_SOLID_WRAP, 0));
  }

  return FRAMETIME;
}  // mode_puddlepeak()

//////////////////////
//   * PUDDLES      //
//////////////////////

uint16_t WS2812FX::mode_puddles(void) {  // Puddles. By Andrew Tuline.

  uint16_t size = 0;
  uint8_t fadeVal = map(SEGMENT.speed, 0, 255, 224, 255);
  uint16_t pos = random(SEGLEN);  // Set a random starting position.

  fade_out(fadeVal);

  float tmpSound = (soundAgc) ? rawSampleAgc : sampleRaw;

  if (tmpSound > 1) {
    size = tmpSound * SEGMENT.intensity / 256 / 8 +
           1;  // Determine size of the flash based on the volume.
    if (pos + size >= SEGLEN) size = SEGLEN - pos;
  }

  for (int i = 0; i < size; i++) {  // Flash the LED's.
    setPixelColor(pos + i,
                  color_from_palette(millis(), false, PALETTE_SOLID_WRAP, 0));
  }

  return FRAMETIME;
}  // mode_puddles()

/////////////////////////////////
//     * Ripple Peak           //
/////////////////////////////////

uint16_t WS2812FX::mode_ripplepeak(void) {  // * Ripple peak. By Andrew Tuline.

  // This currently has no controls.
#define maxsteps 16  // Case statement wouldn't allow a variable.

  uint16_t maxRipples = 16;
  uint16_t dataSize = sizeof(ripple) * maxRipples;

  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed

  Ripple* ripples = reinterpret_cast<Ripple*>(SEGENV.data);

  //  static uint8_t colour;                                  // Ripple colour
  //  is randomized. static uint16_t centre;                                 //
  //  Center of the current ripple. static int8_t steps = -1; // -1 is the
  //  initializing step.

  //  static uint8_t ripFade = 255;                           // Starting
  //  brightness, which we'll say is SEGENV.aux0.
  if (SEGENV.call == 0) SEGENV.aux0 = 255;

  binNum = SEGMENT.custom2;      // Select a bin.
  maxVol = SEGMENT.custom3 / 2;  // Our volume comparator.

  // fade_out(240);                                        // Lower frame rate
  // means less effective fading then FastLED fade_out(240);
  fade_out(226);

  for (uint16_t i = 0; i < SEGMENT.intensity / 16;
       i++) {  // Limit the number of ripples.

    if (samplePeak > 0) {
      ripples[i].state = -1;
    }

    switch (ripples[i].state) {
      case -2:  // Inactive mode
        break;

      case -1:  // Initialize ripple variables.
        ripples[i].pos = random16(SEGLEN);

#ifdef ESP32
        ripples[i].color = (int)(log10f(FFT_MajorPeak) * 128);
#else
        ripples[i].color = random8();
#endif

        ripples[i].state = 0;
        break;

      case 0:
        setPixelColor(ripples[i].pos,
                      color_blend(SEGCOLOR(1),
                                  color_from_palette(ripples[i].color, false,
                                                     PALETTE_SOLID_WRAP, 0),
                                  SEGENV.aux0));
        ripples[i].state++;
        break;

      case maxsteps:  // At the end of the ripples. -2 is an inactive mode.
        ripples[i].state = -2;
        break;

      default:  // Middle of the ripples.

        setPixelColor((ripples[i].pos + ripples[i].state + SEGLEN) % SEGLEN,
                      color_blend(SEGCOLOR(1),
                                  color_from_palette(ripples[i].color, false,
                                                     PALETTE_SOLID_WRAP, 0),
                                  SEGENV.aux0 / ripples[i].state * 2));
        setPixelColor((ripples[i].pos - ripples[i].state + SEGLEN) % SEGLEN,
                      color_blend(SEGCOLOR(1),
                                  color_from_palette(ripples[i].color, false,
                                                     PALETTE_SOLID_WRAP, 0),
                                  SEGENV.aux0 / ripples[i].state * 2));
        ripples[i].state++;  // Next step.
        break;
    }  // switch step
  }  // for i

  return FRAMETIME;
}  // mode_ripplepeak()

///////////////////////////////
//     BEGIN FFT ROUTINES    //
///////////////////////////////

double mapf(double x, double in_min, double in_max, double out_min,
            double out_max) {              // for double
  if (in_max == in_min) return (out_min);  // to avoid division by zero
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

static float mapff(float x, float in_min, float in_max, float out_min,
                   float out_max) {  // for float
  if (fabs(in_max - in_min) < 0.000001)
    return (out_min);  // to avoid division by zero
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

////////////////////
//    ** Binmap   //
////////////////////

uint16_t WS2812FX::mode_binmap(
    void) {  // Binmap. Scale raw fftBin[] values to SEGLEN. Shows just how
             // noisy those bins are.

#define FIRSTBIN 3  // The first 3 bins are garbage.
#define LASTBIN \
  255  // Don't use the highest bins, as they're (almost) a mirror of the first
       // 256.

  float maxVal = 512;  // Kind of a guess as to the maximum output value per
                       // combined logarithmic bins.

  float binScale = (((float)sampleGain / 40.0) + 1.0 / 16) *
                   ((float)inputLevel / 128.0);  // non-AGC gain multiplier
  if (soundAgc) binScale = multAgc;              // AGC gain
  if (sampleAvg < 1) binScale = 0.001;           // silentium!

#if 0
  //The next lines are good for debugging, however too much flickering for non-developers ;-)
  float my_magnitude = FFT_Magnitude / 16.0;    // scale magnitude to be aligned with scaling of FFT bins
  my_magnitude *= binScale;                     // apply gain
  maxVal = fmax(64, my_magnitude);              // set maxVal = max FFT result
#endif

  for (int i = 0; i < SEGLEN; i++) {
    uint16_t startBin =
        FIRSTBIN +
        i * (LASTBIN - FIRSTBIN) /
            SEGLEN;  // This is the START bin for this particular pixel.
    uint16_t endBin =
        FIRSTBIN +
        (i + 1) * (LASTBIN - FIRSTBIN) /
            SEGLEN;  // This is the END bin for this particular pixel.
    if (endBin > startBin) endBin--;  // avoid overlapping

    float sumBin = 0;

    for (int j = startBin; j <= endBin; j++) {
      sumBin += (fftBin[j] < soundSquelch * 1.75)
                    ? 0
                    : fftBin[j];  // We need some sound temporary squelch for
                                  // fftBin, because we didn't do it for the raw
                                  // bins in audio_reactive.h
    }

    sumBin = sumBin / (endBin - startBin + 1);  // Normalize it.
    sumBin = sumBin * (i + 5) /
             (endBin - startBin +
              5);  // Disgusting frequency adjustment calculation. Lows were too
                   // bright. Am open to quick 'n dirty alternatives.

    sumBin =
        sumBin * 8;  // Need to use the 'log' version for this. Why " * 8" ??
    sumBin *= binScale;  // apply gain

    if (sumBin > maxVal)
      sumBin = maxVal;  // Make sure our bin isn't higher than the max . . which
                        // we capped earlier.

    uint8_t bright = constrain(
        mapff(sumBin, 0, maxVal, 0, 255), 0,
        255);  // Map the brightness in relation to maxVal and crunch to 8 bits.

    setPixelColor(
        i, color_blend(SEGCOLOR(1),
                       color_from_palette(i * 8 + millis() / 50, false,
                                          PALETTE_SOLID_WRAP, 0),
                       bright));  // 'i' is just an index in the palette. The
                                  // FFT value, bright, is the intensity.

  }  // for i

  return FRAMETIME;
}  // mode_binmap()

//////////////////////
//    ** Blurz       //
//////////////////////

uint16_t WS2812FX::mode_blurz(void) {  // Blurz. By Andrew Tuline.

  if (SEGENV.call == 0) {
    fill_solid(leds, 0);
    SEGENV.aux0 = 0;
  }

  uint8_t blurAmt = SEGMENT.intensity;

  fade_out(SEGMENT.speed);

  uint16_t segLoc = random(SEGLEN);
  leds[segmentToLogical(segLoc)] =
      color_blend(SEGCOLOR(1),
                  color_from_palette((2 * fftResult[SEGENV.aux0 % 16] * 240) /
                                         max(1, SEGLEN - 1),
                                     false, PALETTE_SOLID_WRAP, 0),
                  2 * fftResult[SEGENV.aux0 % 16]);
  SEGENV.aux0++;
  SEGENV.aux0 = SEGENV.aux0 % 16;

  blur1d(leds, blurAmt);

  setPixels(leds);
  return FRAMETIME;
}  // mode_blurz()

/////////////////////////
//   ** DJLight        //
/////////////////////////

uint16_t WS2812FX::mode_DJLight(
    void) {               // Written by ??? Adapted by Will Tatam.
  int NUM_LEDS = SEGLEN;  // aka SEGLEN
  int mid = NUM_LEDS / 2;

  uint8_t secondHand = (SEGMENT.speed < 255)
                           ? (micros() / (256 - SEGMENT.speed) / 500 + 1 % 64)
                           : 0;

  if ((SEGMENT.speed > 254) ||
      (SEGENV.aux0 != secondHand)) {  // Triggered millis timing.
    SEGENV.aux0 = secondHand;

    leds[segmentToLogical(mid)] =
        CRGB(fftResult[15] / 2, fftResult[5] / 2,
             fftResult[0] / 2);  // 16-> 15 as 16 is out of bounds
    leds[segmentToLogical(mid)].fadeToBlackBy(
        map(fftResult[1 * 4], 0, 255, 255, 10));  // TODO - Update

    // move to the left
    for (int i = NUM_LEDS - 1; i > mid; i--) {
      leds[segmentToLogical(i)] = leds[segmentToLogical(i - 1)];
    }
    // move to the right
    for (int i = 0; i < mid; i++) {
      leds[segmentToLogical(i)] = leds[segmentToLogical(i + 1)];
    }
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_DJLight()

////////////////////
//   ** Freqmap   //
////////////////////

uint16_t WS2812FX::mode_freqmap(void) {  // Map FFT_MajorPeak to SEGLEN. Would
                                         // be better if a higher framerate.
  // Start frequency = 60 Hz and log10(60) = 1.78
  // End frequency = 5120 Hz and lo10(5120) = 3.71

  float my_magnitude = FFT_Magnitude / 4.0;
  if (soundAgc) my_magnitude *= multAgc;
  if (sampleAvg < 1) my_magnitude = 0.001;  // noise gate closed - mute

  fade_out(SEGMENT.speed);

  int locn = (log10f(FFT_MajorPeak) - 1.78) * (float)SEGLEN /
             (3.71 - 1.78);  // log10 frequency range is from 1.78 to 3.71.
                             // Let's scale to SEGLEN.

  if (locn >= SEGLEN) locn = SEGLEN - 1;
  if (locn < 1) locn = 0;
  uint16_t pixCol =
      (log10f(FFT_MajorPeak) - 1.78) * 255.0 /
      (3.71 -
       1.78);  // Scale log10 of frequency values to the 255 colour index.
  uint16_t bright = (int)my_magnitude;

  setPixelColor(
      locn, color_blend(SEGCOLOR(1),
                        color_from_palette(SEGMENT.intensity + pixCol, false,
                                           PALETTE_SOLID_WRAP, 0),
                        bright));

  return FRAMETIME;
}  // mode_freqmap()

///////////////////////
//   ** Freqmatrix   //
///////////////////////

uint16_t WS2812FX::mode_freqmatrix(void) {  // Freqmatrix. By Andreas Pleschung.

  uint8_t secondHand =
      (SEGMENT.speed < 255) ? (micros() / (256 - SEGMENT.speed) / 500 % 16) : 0;

  if ((SEGMENT.speed > 254) || (SEGENV.aux0 != secondHand)) {
    SEGENV.aux0 = secondHand;

    float sensitivity = mapff(SEGMENT.custom3, 1, 255, 1, 10);
    int pixVal = sampleAgc * SEGMENT.intensity / 256 * sensitivity;
    if (pixVal > 255) pixVal = 255;

    float intensity = mapff(pixVal, 0, 255, 0, 100) /
                      100.0;  // make a brightness from the last avg

    CRGB color = 0;
    CHSV c;

    if (FFT_MajorPeak > 5120) FFT_MajorPeak = 1.0f;
    // MajorPeak holds the freq. value which is most abundant in the last
    // sample. With our sampling rate of 10240Hz we have a usable freq range
    // from roughtly 80Hz to 10240/2 Hz we will treat everything with less than
    // 65Hz as 0
    // Serial.printf("%5d ", FFT_MajorPeak, 0);
    if (FFT_MajorPeak < 80) {
      color = CRGB::Black;
    } else {
      int upperLimit = 20 * SEGMENT.custom2;
      int lowerLimit = 2 * SEGMENT.custom1;
      int i = lowerLimit != upperLimit
                  ? mapff(FFT_MajorPeak, lowerLimit, upperLimit, 0, 255)
                  : FFT_MajorPeak;
      uint16_t b = 255 * intensity;
      if (b > 255) b = 255;
      c = CHSV(i, 240, (uint8_t)b);
      color = c;  // implicit conversion to RGB supplied by FastLED
    }

    // Serial.println(color);
    leds[segmentToLogical(0)] = color;

    // shift the pixels one pixel up
    for (int i = SEGLEN; i > 0; i--) {  // Move up
      leds[segmentToLogical(i)] = leds[segmentToLogical(i - 1)];
    }

    // fadeval = fade;

    // DISPLAY ARRAY
    setPixels(leds);
  }

  return FRAMETIME;
}  // mode_freqmatrix()

//////////////////////
//   ** Freqpixels  //
//////////////////////

// Start frequency = 60 Hz and log10(60) = 1.78
// End frequency = 5120 Hz and lo10(5120) = 3.71

//  SEGMENT.speed select faderate
//  SEGMENT.intensity select colour index

uint16_t WS2812FX::mode_freqpixels(void) {  // Freqpixel. By Andrew Tuline.

  uint16_t fadeRate =
      2 * SEGMENT.speed -
      SEGMENT.speed * SEGMENT.speed / 255;  // Get to 255 as quick as you can.

  float my_magnitude = FFT_Magnitude / 16.0;
  if (soundAgc) my_magnitude *= multAgc;
  if (sampleAvg < 1) my_magnitude = 0.001;  // noise gate closed - mute

  fade_out(fadeRate);

  for (int i = 0; i < SEGMENT.intensity / 32 + 1; i++) {
    uint16_t locn = random16(0, SEGLEN);
    uint8_t pixCol =
        (log10f(FFT_MajorPeak) - 1.78) * 255.0 /
        (3.71 -
         1.78);  // Scale log10 of frequency values to the 255 colour index.
    setPixelColor(
        locn, color_blend(SEGCOLOR(1),
                          color_from_palette(SEGMENT.intensity + pixCol, false,
                                             PALETTE_SOLID_WRAP, 0),
                          (int)my_magnitude));
  }
  return FRAMETIME;
}  // mode_freqpixels()

//////////////////////
//   ** Freqwave    //
//////////////////////

// Assign a color to the central (starting pixels) based on the predominant
// frequencies and the volume. The color is being determined by mapping the
// MajorPeak from the FFT and then mapping this to the HSV color circle.
// Currently we are sampling at 10240 Hz, so the highest frequency we can look
// at is 5120Hz.
//
// SEGMENT.custom1: the lower cut off point for the FFT. (many, most time the
// lowest values have very little information since they are FFT conversion
// artifacts. Suggested value is close to but above 0 SEGMENT.custom2: The high
// cut off point. This depends on your sound profile. Most music looks good when
// this slider is between 50% and 100%. SEGMENT.custom3: "preamp" for the audio
// signal for audio10.
//
// I suggest that for this effect you turn the brightness to 95%-100% but again
// it depends on your soundprofile you find yourself in. Instead of using
// colorpalettes, This effect works on the HSV color circle with red being the
// lowest frequency
//
// As a compromise between speed and accuracy we are currently sampling with
// 10240Hz, from which we can then determine with a 512bin FFT our max frequency
// is 5120Hz. Depending on the music stream you have you might find it useful to
// change the frequency mapping.

uint16_t WS2812FX::mode_freqwave(void) {  // Freqwave. By Andreas Pleschung.

  // Instead of using colorpalettes, This effect works on the HSV color circle
  // with red being the lowest frequency
  //
  // As a compromise between speed and accuracy we are currently sampling with
  // 10240Hz, from which we can then determine with a 512bin FFT our max
  // frequency is 5120Hz. Depending on the music stream you have you might find
  // it useful to change the frequency mapping.

  uint8_t secondHand =
      (SEGMENT.speed < 255) ? (micros() / (256 - SEGMENT.speed) / 500 % 16) : 0;

  if ((SEGMENT.speed > 254) ||
      (SEGENV.aux0 != secondHand)) {  // Triggered millis timing.
    SEGENV.aux0 = secondHand;

    // uint8_t fade = SEGMENT.custom3;
    // uint8_t fadeval;

    float tmpSound = (soundAgc) ? sampleAgc : sampleAvg;

    float sensitivity = mapff(SEGMENT.custom3, 1, 255, 1, 10);
    float pixVal = tmpSound * (float)SEGMENT.intensity / 256.0 * sensitivity;
    if (pixVal > 255) pixVal = 255;

    float intensity = mapff(pixVal, 0, 255, 0, 100) /
                      100.0;  // make a brightness from the last avg

    CRGB color = 0;
    CHSV c;

    if (FFT_MajorPeak > 5120) FFT_MajorPeak = 1.0f;
    // MajorPeak holds the freq. value which is most abundant in the last
    // sample. With our sampling rate of 10240Hz we have a usable freq range
    // from roughtly 80Hz to 10240/2 Hz we will treat everything with less than
    // 65Hz as 0
    // Serial.printf("%5d ", FFT_MajorPeak, 0);
    if (FFT_MajorPeak < 80) {
      color = CRGB::Black;
    } else {
      int upperLimit = 20 * SEGMENT.custom2;
      int lowerLimit = 2 * SEGMENT.custom1;
      int i = lowerLimit != upperLimit
                  ? mapff(FFT_MajorPeak, lowerLimit, upperLimit, 0, 255)
                  : FFT_MajorPeak;
      if (i < 0) i = 0;
      uint16_t b = 255.0 * intensity;
      if (b > 255) b = 255;
      c = CHSV(i, 240, (uint8_t)b);
      color = c;  // implicit conversion to RGB supplied by FastLED
    }

    // Serial.println(color);
    leds[segmentToLogical(SEGLEN / 2)] = color;

    // shift the pixels one pixel outwards
    for (int i = SEGLEN; i > SEGLEN / 2; i--) {  // Move to the right.
      leds[segmentToLogical(i)] = leds[segmentToLogical(i - 1)];
    }
    for (int i = 0; i < SEGLEN / 2; i++) {  // Move to the left.
      leds[segmentToLogical(i)] = leds[segmentToLogical(i + 1)];
    }

    // DISPLAY ARRAY
    setPixels(leds);
  }

  return FRAMETIME;
}  // mode_freqwave()

///////////////////////
//    ** Gravfreq    //
///////////////////////

uint16_t WS2812FX::mode_gravfreq(void) {  // Gravfreq. By Andrew Tuline.

  uint16_t dataSize = sizeof(gravity);
  if (!SEGENV.allocateData(dataSize))
    return mode_static();  // allocation
                           // failed
  Gravity* gravcen = reinterpret_cast<Gravity*>(SEGENV.data);

  fade_out(240);

  float tmpSound = (soundAgc) ? sampleAgc : sampleAvg;
  float segmentSampleAvg = tmpSound * (float)SEGMENT.intensity / 255.0;
  segmentSampleAvg *=
      0.125;  // divide by 8,  to compensate for later "sensitivty" upscaling

  float mySampleAvg = mapff(
      segmentSampleAvg * 2.0, 0, 32, 0,
      (float)SEGLEN / 2.0);  // map to pixels availeable in current segment
  int tempsamp = constrain(mySampleAvg, 0,
                           SEGLEN / 2);  // Keep the sample from overflowing.
  uint8_t gravity = 8 - SEGMENT.speed / 32;

  for (int i = 0; i < tempsamp; i++) {
    int index = (log10f(FFT_MajorPeak) - (3.71 - 1.78)) * 255;
    if (index < 0) index = 0;

    setPixelColor(i + SEGLEN / 2,
                  color_from_palette(index, false, PALETTE_SOLID_WRAP, 0));
    setPixelColor(SEGLEN / 2 - i - 1,
                  color_from_palette(index, false, PALETTE_SOLID_WRAP, 0));
  }

  if (tempsamp >= gravcen->topLED)
    gravcen->topLED = tempsamp - 1;
  else if (gravcen->gravityCounter % gravity == 0)
    gravcen->topLED--;

  if (gravcen->topLED >= 0) {
    setPixelColor(gravcen->topLED + SEGLEN / 2, CRGB::Gray);
    setPixelColor(SEGLEN / 2 - 1 - gravcen->topLED, CRGB::Gray);
  }
  gravcen->gravityCounter = (gravcen->gravityCounter + 1) % gravity;

  return FRAMETIME;
}  // mode_gravfreq()

//////////////////////
//   ** Noisemove   //
//////////////////////

uint16_t WS2812FX::mode_noisemove(void) {  // Noisemove.    By: Andrew Tuline

  fade_out(224);  // Just in case something doesn't get faded.

  uint8_t numBins =
      map(SEGMENT.intensity, 0, 255, 0, 16);  // Map slider to fftResult bins.

  for (int i = 0; i < numBins; i++) {  // How many active bins are we using.
    uint16_t locn = inoise16(
        millis() * SEGMENT.speed + i * 50000,
        millis() *
            SEGMENT.speed);  // Get a new pixel location from moving noise.

    locn = map(locn, 7500, 58000, 0,
               SEGLEN - 1);  // Map that to the length of the strand, and ensure
                             // we don't go over.
    locn = locn % SEGLEN;    // Just to be bloody sure.

    setPixelColor(locn, color_blend(SEGCOLOR(1),
                                    color_from_palette(i * 64, false,
                                                       PALETTE_SOLID_WRAP, 0),
                                    fftResult[i % 16] * 4));
  }

  return FRAMETIME;
}  // mode_noisemove()

//////////////////////
//   ** Rocktaves   //
//////////////////////

uint16_t WS2812FX::mode_rocktaves(
    void) {  // Rocktaves. Same note from each octave is same colour.    By:
             // Andrew Tuline

  fadeToBlackBy(leds, 64);  // Just in case something doesn't get faded.

  float frTemp = FFT_MajorPeak;
  uint8_t octCount = 0;  // Octave counter.
  uint8_t volTemp = 0;

  float my_magnitude =
      FFT_Magnitude /
      16.0;  // scale magnitude to be aligned with scaling of FFT bins
  if (soundAgc) my_magnitude *= multAgc;    // apply gain
  if (sampleAvg < 1) my_magnitude = 0.001;  // mute

  if (my_magnitude > 32)
    volTemp = 255;  // We need to squelch out the background noise.

  while (frTemp > 249) {
    octCount++;  // This should go up to 5.
    frTemp = frTemp / 2;
  }

  frTemp -= 132;                // This should give us a base musical note of C3
  frTemp = fabs(frTemp * 2.1);  // Fudge factors to compress octave range
                                // starting at 0 and going to 255;

  // Serial.print(frTemp); Serial.print("\t"); Serial.print(volTemp);
  // Serial.print("\t");Serial.print(octCount); Serial.print("\t");
  // Serial.println(FFT_Magnitude);

  //    leds[beatsin8(8+octCount*4,0,SEGLEN-1,0,octCount*8)] +=
  //    CHSV((uint8_t)frTemp,255,volTemp);                 // Back and forth
  //    with different frequencies and phase shift depending on current octave.

  leds[segmentToLogical(mapff(
      beatsin8(8 + octCount * 4, 0, 255, 0, octCount * 8), 0, 255, 0,
      SEGLEN - 1))] += color_blend(SEGCOLOR(1),
                                   color_from_palette((uint8_t)frTemp, false,
                                                      PALETTE_SOLID_WRAP, 0),
                                   volTemp);

  setPixels(leds);
  return FRAMETIME;
}  // mode_rockdaves()

///////////////////////
//   ** Waterfall    //
///////////////////////

// Combines peak detection with FFT_MajorPeak and FFT_Magnitude.

uint16_t WS2812FX::mode_waterfall(void) {  // Waterfall. By: Andrew Tuline

  if (SEGENV.call == 0) fill_solid(leds, 0);

  binNum = SEGMENT.custom2;      // Select a bin.
  maxVol = SEGMENT.custom3 / 2;  // Our volume comparator.

  uint8_t secondHand = (SEGMENT.speed < 255)
                           ? (micros() / (256 - SEGMENT.speed) / 500 + 1 % 16)
                           : 0;

  if ((SEGMENT.speed > 254) ||
      (SEGENV.aux0 != secondHand)) {  // Triggered millis timing.
    SEGENV.aux0 = secondHand;

    float my_magnitude = FFT_Magnitude / 8.0;
    if (soundAgc) my_magnitude *= multAgc;
    if (sampleAvg < 1) my_magnitude = 0.001;  // noise gate closed - mute

    int pixCol = (FFT_MajorPeak > 1.0)
                     ? ((log10f(FFT_MajorPeak) - 2.26) * 177)
                     : 0;  // log10 frequency range is from 2.26 to 3.7. Let's
                           // scale accordingly.
    if (pixCol < 0) pixCol = 0;

    if (sampleAvg > 1) {
      if (samplePeak > 0) {
        leds[segmentToLogical(SEGLEN - 1)] = CHSV(92, 92, 92);
      } else {
        leds[segmentToLogical(SEGLEN - 1)] =
            color_blend(SEGCOLOR(1),
                        color_from_palette(pixCol + SEGMENT.intensity, false,
                                           PALETTE_SOLID_WRAP, 0),
                        (int)my_magnitude);
      }
    } else
      leds[segmentToLogical(SEGLEN - 1)] = SEGCOLOR(1);
    for (int i = 0; i < SEGLEN - 1; i++)
      leds[segmentToLogical(i)] = leds[segmentToLogical(i + 1)];
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_waterfall()

//////////////////////////////////////////////
//       START of 2D REACTIVE ROUTINES      //
//////////////////////////////////////////////

/////////////////////////
//     ** 2D GEQ       //
/////////////////////////

uint16_t WS2812FX::GEQ_base(
    bool centered_horizontal, bool centered_vertical,
    bool color_vertical) {  // By Will Tatam. Refactor by Ewoud Wijma.
  fadeToBlackBy(leds, SEGMENT.speed);

  bool rippleTime;
  if (millis() - SEGENV.step >= 255 - SEGMENT.intensity) {
    SEGENV.step = millis();
    rippleTime = true;
  } else
    rippleTime = false;

  static int previousBarHeight[64];  // array of previous bar heights per
                                     // frequency band

  int xCount = SEGMENT.width;
  if (centered_vertical) xCount /= 2;

  for (int x = 0; x < xCount; x++) {
    int band = map(x, 0, xCount - 1, 0, 15);
    int barHeight = map(fftResult[band], 0, 255, 0, SEGMENT.height);
    if ((barHeight % 2 == 1) && centered_horizontal)
      barHeight++;  // get an even barHeight if centered_horizontal
    int yStartBar = centered_horizontal
                        ? (SEGMENT.height - barHeight) / 2
                        : 0;  // lift up the bar if centered_horizontal
    int yStartPeak = centered_horizontal
                         ? (SEGMENT.height - previousBarHeight[x]) / 2
                         : 0;  // lift up the peaks if centered_horizontal

    for (int y = 0; y < SEGMENT.height; y++) {
      CRGB heightColor = CRGB::Black;
      uint16_t colorIndex;
      if (color_vertical) {
        if (centered_horizontal)
          colorIndex = map(abs(y - (SEGMENT.height - 1) / 2.0), 0,
                           SEGMENT.height / 2 - 1, 0, 255);
        else
          colorIndex = map(y, 0, SEGMENT.height - 1, 0, 255);
      } else
        colorIndex = band * 17;
      heightColor =
          color_from_palette(colorIndex, false, PALETTE_SOLID_WRAP, 0);

      CRGB ledColor = CRGB::Black;  // if not part of bars or peak, make black
                                    // (not fade to black)

      // bar
      if (y >= yStartBar && y < yStartBar + barHeight) ledColor = heightColor;

      // low and high peak (must exist && on peak position && only below if
      // centered_horizontal effect)
      if ((previousBarHeight[x] > 0) && (SEGMENT.intensity < 255) &&
          (y == yStartPeak || y == yStartPeak + previousBarHeight[x] - 1) &&
          (centered_horizontal || y != yStartPeak))
        ledColor = SEGCOLOR(2) == CRGB::Black ? heightColor
                                              : CRGB(SEGCOLOR(2));  // low peak

      if (centered_vertical) {
        leds[XY(SEGMENT.width / 2 + x, SEGMENT.height - 1 - y)] = ledColor;
        leds[XY(SEGMENT.width / 2 - 1 - x, SEGMENT.height - 1 - y)] = ledColor;
      } else
        leds[XY(x, SEGMENT.height - 1 - y)] = ledColor;
    }

    if (rippleTime)
      previousBarHeight[x] -=
          centered_horizontal ? 2 : 1;  // delay/ripple effect
    if (barHeight > previousBarHeight[x])
      previousBarHeight[x] = barHeight;  // drive the peak up
  }

  setPixels(leds);
  return FRAMETIME;
}  // GEQ_base

uint16_t WS2812FX::mode_2DGEQ(
    void) {  // By Will Tatam. Code reduction by Ewoud Wijma.
  return GEQ_base(false, false, false);
}  // mode_2DGEQ()

/////////////////////////
//   ** 2D CenterBars  //
/////////////////////////

uint16_t WS2812FX::mode_2DCenterBars(
    void) {  // Written by Scott Marley Adapted by  Spiro-C..
  return GEQ_base(SEGMENT.custom1 > 128, SEGMENT.custom2 > 128,
                  SEGMENT.custom3 > 128);
}  // mode_2DCenterBars()

/////////////////////////
//  ** 2D Funky plank  //
/////////////////////////

uint16_t WS2812FX::mode_2DFunkyPlank(
    void) {  // Written by ??? Adapted by Will Tatam.

  int NUMB_BANDS = map(SEGMENT.custom1, 0, 255, 1, 16);
  int barWidth = (SEGMENT.width / NUMB_BANDS);
  int bandInc = 1;
  if (barWidth == 0) {
    // Matrix narrower than fft bands
    barWidth = 1;
    bandInc = (NUMB_BANDS / SEGMENT.width);
  }

  uint8_t secondHand = (SEGMENT.speed < 255)
                           ? (micros() / (256 - SEGMENT.speed) / 500 + 1 % 64)
                           : 0;

  if ((SEGMENT.speed > 254) ||
      (SEGENV.aux0 != secondHand)) {  // Triggered millis timing.
    SEGENV.aux0 = secondHand;

    // display values of
    int b = 0;
    for (int band = 0; band < NUMB_BANDS; band += bandInc) {
      int hue = fftResult[band];
      int v = map(fftResult[band], 0, 255, 10, 255);
      //     if(hue > 0) Serial.printf("Band: %u Value: %u\n", band, hue);
      for (int w = 0; w < barWidth; w++) {
        int xpos = (barWidth * b) + w;
        leds[XY(xpos, 0)] = CHSV(hue, 255, v);
      }
      b++;
    }

    // Update the display:
    for (int i = (SEGMENT.height - 1); i > 0; i--) {
      for (int j = (SEGMENT.width - 1); j >= 0; j--) {
        int src = XY(j, (i - 1));
        int dst = XY(j, i);
        leds[dst] = leds[src];
      }
    }
  }

  setPixels(leds);
  return FRAMETIME;
}  // mode_2DFunkyPlank

uint16_t WS2812FX::mode_2DAkemi(void) {
  uint16_t counter = (now * ((SEGMENT.speed >> 2) + 2)) & 0xFFFF;
  counter = counter >> 8;

  // Akemi
  uint8_t akemi[32][32] = {
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2,
       2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 3, 3,
       3, 3, 3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 3, 0, 0, 0,
       0, 0, 0, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 6, 5,
       5, 4, 0, 0, 0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 6, 6, 5, 5,
       5, 5, 4, 4, 0, 0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 6, 5, 5, 5, 5,
       5, 5, 5, 5, 4, 0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 6, 5, 5, 5, 5, 5,
       5, 5, 5, 5, 5, 4, 0, 3, 2, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 6, 5, 5, 5, 5, 5,
       5, 5, 5, 5, 5, 4, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 3, 2, 3, 6, 5, 5, 7, 7, 5, 5,
       5, 5, 7, 7, 5, 5, 4, 3, 2, 3, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 2, 3, 1, 3, 6, 5, 1, 7, 7, 7, 5,
       5, 1, 7, 7, 7, 5, 4, 3, 1, 3, 2, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 8, 3, 1, 3, 6, 5, 1, 7, 7, 7, 5,
       5, 1, 7, 7, 7, 5, 4, 3, 1, 3, 8, 9, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 8, 3, 1, 3, 6, 5, 5, 1, 1, 5, 5,
       5, 5, 1, 1, 5, 5, 4, 3, 1, 3, 8, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 2, 3, 1, 3, 6, 5, 5, 5, 5, 5, 5,
       5, 5, 5, 5, 5, 5, 4, 3, 1, 3, 2, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 3, 2, 3, 6, 5, 5, 5, 5, 5, 5,
       5, 5, 5, 5, 5, 5, 4, 3, 2, 3, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 5, 5, 5, 5, 7,
       7, 5, 5, 5, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 5, 5, 5, 5, 5,
       5, 5, 5, 5, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {1, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 5, 5, 5, 5, 5,
       5, 5, 5, 5, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 2},
      {0, 2, 2, 2, 0, 0, 0, 0, 0, 6, 5, 5, 5, 5, 5, 5,
       5, 5, 5, 5, 5, 5, 4, 0, 0, 0, 0, 0, 2, 2, 2, 0},
      {0, 0, 0, 3, 2, 0, 0, 0, 6, 5, 4, 4, 4, 4, 4, 4,
       4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 2, 2, 0, 0, 0},
      {0, 0, 0, 3, 2, 0, 0, 0, 6, 5, 5, 5, 5, 5, 5, 5,
       5, 5, 5, 5, 5, 5, 5, 4, 0, 0, 0, 2, 3, 0, 0, 0},
      {0, 0, 0, 0, 3, 2, 0, 0, 0, 0, 3, 3, 0, 3, 3, 0,
       0, 3, 3, 0, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0},
      {0, 0, 0, 0, 3, 2, 0, 0, 0, 0, 3, 2, 0, 3, 2, 0,
       0, 3, 2, 0, 3, 2, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 3, 2, 0, 0, 3, 2, 0, 0, 3, 2, 0,
       0, 3, 2, 0, 0, 3, 2, 0, 0, 2, 3, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 3, 2, 2, 2, 2, 0, 0, 0, 3, 2, 0,
       0, 3, 2, 0, 0, 0, 3, 2, 2, 2, 3, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 3, 2, 0,
       0, 3, 2, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0,
       0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0,
       0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0,
       0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0,
       0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  };

  // draw and color Akemi
  for (int y = 0; y < SEGMENT.height; y++)
    for (int x = 0; x < SEGMENT.width; x++) {
      CRGB color = BLACK;
      CRGB faceColor = color_wheel(counter);
      CRGB armsAndLegsColor =
          SEGCOLOR(1) > 0
              ? SEGCOLOR(1)
              : 0xFFE0A0;  // default warmish white 0xABA8FF; //0xFF52e5;//
      CRGB soundColor = ORANGE;
      double lightFactor = 0.15;
      double normalFactor = 0.4;
      double base = fftResult[0] / 255.0;
      switch (akemi[y * 32 / SEGMENT.height][x * 32 / SEGMENT.width]) {
        case 0:
          color = BLACK;
          break;
        case 3:
          armsAndLegsColor.r *= lightFactor;
          armsAndLegsColor.g *= lightFactor;
          armsAndLegsColor.b *= lightFactor;
          color = armsAndLegsColor;
          break;  // light arms and legs 0x9B9B9B
        case 2:
          armsAndLegsColor.r *= normalFactor;
          armsAndLegsColor.g *= normalFactor;
          armsAndLegsColor.b *= normalFactor;
          color = armsAndLegsColor;
          break;  // normal arms and legs 0x888888
        case 1:
          color = armsAndLegsColor;
          break;  // dark arms and legs 0x686868
        case 6:
          faceColor.r *= lightFactor;
          faceColor.g *= lightFactor;
          faceColor.b *= lightFactor;
          color = faceColor;
          break;  // light face 0x31AAFF
        case 5:
          faceColor.r *= normalFactor;
          faceColor.g *= normalFactor;
          faceColor.b *= normalFactor;
          color = faceColor;
          break;  // normal face 0x0094FF
        case 4:
          color = faceColor;
          break;  // dark face 0x007DC6
        case 7:
          color = SEGCOLOR(2) > 0 ? SEGCOLOR(2) : 0xFFFFFF;
          break;  // eyes and mouth default white
        case 8:
          if (base > 0.4) {
            soundColor.r *= base;
            soundColor.g *= base;
            soundColor.b *= base;
            color = soundColor;
          } else
            color = armsAndLegsColor;
          break;
        default:
          color = BLACK;
      }

      if (SEGMENT.intensity > 128 &&
          fftResult[0] > 128)  // dance if base is high
      {
        leds[XY(x, 0)] = BLACK;
        leds[XY(x, y + 1)] = color;
      } else
        leds[XY(x, y)] = color;
    }

  // add geq left and right
  for (int x = 0; x < SEGMENT.width / 8; x++) {
    int band = x * SEGMENT.width / 8;
    int barHeight = map(fftResult[band], 0, 255, 0, 17 * SEGMENT.height / 32);
    CRGB color = color_from_palette((band * 35), false, PALETTE_SOLID_WRAP, 0);

    for (int y = 0; y < barHeight; y++) {
      leds[XY(x, SEGMENT.height / 2 - y)] = color;
      leds[XY(SEGMENT.width - 1 - x, SEGMENT.height / 2 - y)] = color;
    }
  }

  setPixels(leds);

  return FRAMETIME;
}  // mode_2DAkemi

// 3D !!!!!!!!!!

float distance(uint16_t x1, uint16_t y1, uint16_t z1, uint16_t x2, uint16_t y2,
               uint16_t z2) {
  return sqrtf((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) +
               (z1 - z2) * (z1 - z2));
}

uint16_t WS2812FX::mode_3DRipples(void) {
  float ripple_interval = 1.3 * (SEGMENT.intensity / 128.0);

  fill(CRGB::Black);

  // workaround to get width, height and depth
  uint16_t mW = strip.matrixWidth;
  uint16_t mH = 1;
  uint16_t mD = 1;
  // balance dimensions
  while (mW > mH) {
    if (mH < mD)
      mH++;
    else
      mD++;
    mW = strip.matrixWidth / mH / mD;
  }

  for (int z = 0; z < mD; z++) {
    for (int x = 0; x < mW; x++) {
      float d = distance(3.5, 3.5, 0, x, z, 0) / 9.899495 * mH;
      uint16_t height = floor(
          mH / 2.0 + sinf(d / ripple_interval +
                          SEGENV.call / ((256.0 - SEGMENT.speed) / 20.0)) *
                         mH / 2.0);  // between 0 and 8

      setPixelColor(
          x + height * mW + z * mW * mH,
          color_from_palette(SEGENV.call, true, PALETTE_SOLID_WRAP, 0));
    }
  }

  return FRAMETIME;
}  // mode_3DRipples

uint16_t WS2812FX::mode_3DSphereMove(void) {
  uint16_t origin_x, origin_y, origin_z, d;
  float diameter;

  fill(CRGB::Black);

  uint32_t interval = SEGENV.call / ((256.0 - SEGMENT.speed) / 20.0);

  // workaround to get width, height and depth
  uint16_t mW = strip.matrixWidth;
  uint16_t mH = 1;
  uint16_t mD = 1;
  // balance dimensions
  while (mW > mH) {
    if (mH < mD)
      mH++;
    else
      mD++;
    mW = strip.matrixWidth / mH / mD;
  }

  origin_x = 3.5 + sinf(interval) * 2.5;
  origin_y = 3.5 + cosf(interval) * 2.5;
  origin_z = 3.5 + cosf(interval) * 2.0;

  diameter = 2.0 + sinf(interval / 3.0);

  for (int x = 0; x < mW; x++) {
    for (int y = 0; y < mH; y++) {
      for (int z = 0; z < mD; z++) {
        d = distance(x, y, z, origin_x, origin_y, origin_z);

        if (d > diameter && d < diameter + 1) {
          setPixelColor(
              x + y * mW + z * mW * mH,
              color_from_palette(SEGENV.call, true, PALETTE_SOLID_WRAP, 0));
        }
      }
    }
  }

  return FRAMETIME;
}  // mode_3DSphereMove

=== ./FX.h ===

/*
  WS2812FX.h - Library for WS2812 LED effects.
  Harm Aldick - 2016
  www.aldick.org
  LICENSE
  The MIT License (MIT)
  Copyright (c) 2016  Harm Aldick
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.

  Modified for WLED
*/

#ifndef WS2812FX_h
#define WS2812FX_h

#include "const.h"

#define FASTLED_INTERNAL //remove annoying pragma messages
#define USE_GET_MILLISECOND_TIMER
#include "FastLED.h"

#define DEFAULT_BRIGHTNESS (uint8_t)127
#define DEFAULT_MODE       (uint8_t)0
#define DEFAULT_SPEED      (uint8_t)128
#define DEFAULT_INTENSITY  (uint8_t)128
#define DEFAULT_COLOR      (uint32_t)0xFFAA00

#ifndef MIN
#define MIN(a,b) ((a)<(b)?(a):(b))
#endif
#ifndef MAX
#define MAX(a,b) ((a)>(b)?(a):(b))
#endif

//color mangling macros
#ifndef RGBW32
#define RGBW32(r,g,b,w) (uint32_t((byte(w) << 24) | (byte(r) << 16) | (byte(g) << 8) | (byte(b))))
#endif

/* Not used in all effects yet */
#define WLED_FPS         42
#define FRAMETIME_FIXED  (1000/WLED_FPS)
#define FRAMETIME        _frametime

/* each segment uses 52 bytes of SRAM memory, so if you're application fails because of
  insufficient memory, decreasing MAX_NUM_SEGMENTS may help */
#ifdef ESP8266
  #define MAX_NUM_SEGMENTS    16
  /* How many color transitions can run at once */
  #define MAX_NUM_TRANSITIONS  8
  /* How much data bytes all segments combined may allocate */
  #define MAX_SEGMENT_DATA  4096
#else
  #ifndef MAX_NUM_SEGMENTS
    #define MAX_NUM_SEGMENTS  32
  #endif
  #define MAX_NUM_TRANSITIONS 24
  #define MAX_SEGMENT_DATA  20480
#endif

/* How much data bytes each segment should max allocate to leave enough space for other segments,
  assuming each segment uses the same amount of data. 256 for ESP8266, 640 for ESP32. */
#define FAIR_DATA_PER_SEG (MAX_SEGMENT_DATA / MAX_NUM_SEGMENTS)

// NEED WORKAROUND TO ACCESS PRIVATE CLASS VARIABLE '_frametime'
#define MIN_SHOW_DELAY   (_frametime < 16 ? (_frametime <8? (_frametime <7? (_frametime <6 ? 2 :3) :4) : 8) : 15)    // WLEDSR support higher framerates (up to 250fps)

#define NUM_COLORS       3 /* number of colors per segment */
#define SEGMENT          strip._segments[strip.getCurrSegmentId()]
#define SEGCOLOR(x)      strip._colors_t[x]
#define SEGENV           strip._segment_runtimes[strip.getCurrSegmentId()]
#define SEGPALETTE       strip._currentPalette
#define SEGLEN           strip._virtualSegmentLength
#define SEGACT           SEGMENT.stop
#define SPEED_FORMULA_L  5U + (50U*(255U - SEGMENT.speed))/SEGLEN

// some common colors
#define RED        (uint32_t)0xFF0000
#define GREEN      (uint32_t)0x00FF00
#define BLUE       (uint32_t)0x0000FF
#define WHITE      (uint32_t)0xFFFFFF
#define BLACK      (uint32_t)0x000000
#define YELLOW     (uint32_t)0xFFFF00
#define CYAN       (uint32_t)0x00FFFF
#define MAGENTA    (uint32_t)0xFF00FF
#define PURPLE     (uint32_t)0x400080
#define ORANGE     (uint32_t)0xFF3000
#define PINK       (uint32_t)0xFF1493
#define ULTRAWHITE (uint32_t)0xFFFFFFFF

// options
// bit    7: segment is in transition mode
// bits 4-6: See WLEDSR below
// bit    3: mirror effect within segment
// bit    2: segment is on
// bit    1: reverse segment
// bit    0: segment is selected
#define NO_OPTIONS   (uint8_t)0x00
#define TRANSITIONAL (uint8_t)0x80
#define MIRROR       (uint8_t)0x08
#define SEGMENT_ON   (uint8_t)0x04
#define REVERSE      (uint8_t)0x02
#define SELECTED     (uint8_t)0x01
#define IS_TRANSITIONAL ((SEGMENT.options & TRANSITIONAL) == TRANSITIONAL)
#define IS_MIRROR       ((SEGMENT.options & MIRROR      ) == MIRROR      )
#define IS_SEGMENT_ON   ((SEGMENT.options & SEGMENT_ON  ) == SEGMENT_ON  )
#define IS_REVERSE      ((SEGMENT.options & REVERSE     ) == REVERSE     )
#define IS_SELECTED     ((SEGMENT.options & SELECTED    ) == SELECTED    )

#define MODE_COUNT 195 // WLEDSR: First 128 for AC (incl reserved), rest for SR

#define FX_MODE_STATIC                   0
#define FX_MODE_BLINK                    1
#define FX_MODE_BREATH                   2
#define FX_MODE_COLOR_WIPE               3
#define FX_MODE_COLOR_WIPE_RANDOM        4
#define FX_MODE_RANDOM_COLOR             5
#define FX_MODE_COLOR_SWEEP              6
#define FX_MODE_DYNAMIC                  7
#define FX_MODE_RAINBOW                  8
#define FX_MODE_RAINBOW_CYCLE            9
#define FX_MODE_SCAN                    10
#define FX_MODE_DUAL_SCAN               11
#define FX_MODE_FADE                    12
#define FX_MODE_THEATER_CHASE           13
#define FX_MODE_THEATER_CHASE_RAINBOW   14
#define FX_MODE_RUNNING_LIGHTS          15
#define FX_MODE_SAW                     16
#define FX_MODE_TWINKLE                 17
#define FX_MODE_DISSOLVE                18
#define FX_MODE_DISSOLVE_RANDOM         19
#define FX_MODE_SPARKLE                 20
#define FX_MODE_FLASH_SPARKLE           21
#define FX_MODE_HYPER_SPARKLE           22
#define FX_MODE_STROBE                  23
#define FX_MODE_STROBE_RAINBOW          24
#define FX_MODE_MULTI_STROBE            25
#define FX_MODE_BLINK_RAINBOW           26
#define FX_MODE_ANDROID                 27
#define FX_MODE_CHASE_COLOR             28
#define FX_MODE_CHASE_RANDOM            29
#define FX_MODE_CHASE_RAINBOW           30
#define FX_MODE_CHASE_FLASH             31
#define FX_MODE_CHASE_FLASH_RANDOM      32
#define FX_MODE_CHASE_RAINBOW_WHITE     33
#define FX_MODE_COLORFUL                34
#define FX_MODE_TRAFFIC_LIGHT           35
#define FX_MODE_COLOR_SWEEP_RANDOM      36
#define FX_MODE_RUNNING_COLOR           37
#define FX_MODE_AURORA                  38
#define FX_MODE_RUNNING_RANDOM          39
#define FX_MODE_LARSON_SCANNER          40
#define FX_MODE_COMET                   41
#define FX_MODE_FIREWORKS               42
#define FX_MODE_RAIN                    43
#define FX_MODE_TETRIX                  44  //was Merry Christmas prior to 0.12.0 (use "Chase 2" with Red/Green)
#define FX_MODE_FIRE_FLICKER            45
#define FX_MODE_GRADIENT                46
#define FX_MODE_LOADING                 47
#define FX_MODE_POLICE                  48  // candidate for removal (after below three)
#define FX_MODE_FAIRY                   49  //was Police All prior to 0.13.0-b6 (use "Two Dots" with Red/Blue and full intensity)
#define FX_MODE_TWO_DOTS                50
#define FX_MODE_FAIRYTWINKLE            51  //was Two Areas prior to 0.13.0-b6 (use "Two Dots" with full intensity)
#define FX_MODE_RUNNING_DUAL            52
#define FX_MODE_HALLOWEEN               53  // candidate for removal
#define FX_MODE_TRICOLOR_CHASE          54
#define FX_MODE_TRICOLOR_WIPE           55
#define FX_MODE_TRICOLOR_FADE           56
#define FX_MODE_LIGHTNING               57
#define FX_MODE_ICU                     58
#define FX_MODE_MULTI_COMET             59
#define FX_MODE_DUAL_LARSON_SCANNER     60
#define FX_MODE_RANDOM_CHASE            61
#define FX_MODE_OSCILLATE               62
#define FX_MODE_PRIDE_2015              63
#define FX_MODE_JUGGLE                  64
#define FX_MODE_PALETTE                 65
#define FX_MODE_FIRE_2012               66
#define FX_MODE_COLORWAVES              67
#define FX_MODE_BPM                     68
#define FX_MODE_FILLNOISE8              69
#define FX_MODE_NOISE16_1               70
#define FX_MODE_NOISE16_2               71
#define FX_MODE_NOISE16_3               72
#define FX_MODE_NOISE16_4               73
#define FX_MODE_COLORTWINKLE            74
#define FX_MODE_LAKE                    75
#define FX_MODE_METEOR                  76
#define FX_MODE_METEOR_SMOOTH           77
#define FX_MODE_RAILWAY                 78
#define FX_MODE_RIPPLE                  79
#define FX_MODE_TWINKLEFOX              80
#define FX_MODE_TWINKLECAT              81
#define FX_MODE_HALLOWEEN_EYES          82
#define FX_MODE_STATIC_PATTERN          83
#define FX_MODE_TRI_STATIC_PATTERN      84
#define FX_MODE_SPOTS                   85
#define FX_MODE_SPOTS_FADE              86
#define FX_MODE_GLITTER                 87
#define FX_MODE_CANDLE                  88
#define FX_MODE_STARBURST               89
#define FX_MODE_EXPLODING_FIREWORKS     90
#define FX_MODE_BOUNCINGBALLS           91
#define FX_MODE_SINELON                 92
#define FX_MODE_SINELON_DUAL            93
#define FX_MODE_SINELON_RAINBOW         94
#define FX_MODE_POPCORN                 95
#define FX_MODE_DRIP                    96
#define FX_MODE_PLASMA                  97
#define FX_MODE_PERCENT                 98
#define FX_MODE_RIPPLE_RAINBOW          99
#define FX_MODE_HEARTBEAT              100
#define FX_MODE_PACIFICA               101
#define FX_MODE_CANDLE_MULTI           102
#define FX_MODE_SOLID_GLITTER          103
#define FX_MODE_SUNRISE                104
#define FX_MODE_PHASED                 105
#define FX_MODE_TWINKLEUP              106
#define FX_MODE_NOISEPAL               107
#define FX_MODE_SINEWAVE               108
#define FX_MODE_PHASEDNOISE            109
#define FX_MODE_FLOW                   110
#define FX_MODE_CHUNCHUN               111
#define FX_MODE_DANCING_SHADOWS        112
#define FX_MODE_WASHING_MACHINE        113
#define FX_MODE_CANDY_CANE             114  // candidate for removal
#define FX_MODE_BLENDS                 115
#define FX_MODE_TV_SIMULATOR           116
#define FX_MODE_DYNAMIC_SMOOTH         117

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    Start of Audio Reactive fork (WLEDSR)                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define DEFAULT_Custom1       (uint8_t)128
#define DEFAULT_Custom2       (uint8_t)128
#define DEFAULT_Custom3       (uint8_t)128

// bits 4-6: WLEDSR: used for rotation and reverse
#define ROTATED2D     (uint8_t)0x10 //0x01, 0x02, 0x04, 0x08, 0x0F, 0x10, 0x20, 0x40, 0x80, 0xF0
#define REVERSE2D     (uint8_t)0x40 //0x01, 0x02, 0x04, 0x08, 0x0F, 0x10, 0x20, 0x40, 0x80, 0xF0
#define IS_REVERSE2D     ((SEGMENT.options & REVERSE2D    ) == REVERSE2D    )
#define IS_ROTATED2D      ((SEGMENT.options & ROTATED2D     ) == ROTATED2D     )

//these id's should never change as they are saved in api commands of presets
//currently 118 to 127 is reserved for future AC effects (use Reserved keyword in Json)
//they must match the order of the effects in JSON_mode_names (if unused, use Reserved keyword in Json)
#define FX_MODE_PIXELS                 128
#define FX_MODE_PIXELWAVE              129
#define FX_MODE_JUGGLES                130
#define FX_MODE_MATRIPIX               131
#define FX_MODE_GRAVIMETER             132
#define FX_MODE_PLASMOID               133
#define FX_MODE_PUDDLES                134
#define FX_MODE_MIDNOISE               135
#define FX_MODE_NOISEMETER             136
#define FX_MODE_FREQWAVE               137
#define FX_MODE_FREQMATRIX             138
#define FX_MODE_2DGEQ                  139
#define FX_MODE_WATERFALL              140
#define FX_MODE_FREQPIXELS             141
#define FX_MODE_BINMAP                 142
#define FX_MODE_NOISEFIRE              143
#define FX_MODE_PUDDLEPEAK             144
#define FX_MODE_NOISEMOVE              145
#define FX_MODE_2DNOISE                146
#define FX_MODE_PERLINMOVE             147
#define FX_MODE_RIPPLEPEAK             148
#define FX_MODE_2DFIRENOISE            149
#define FX_MODE_2DSQUAREDSWIRL         150
#define FX_MODE_2DFIRE2012             151
#define FX_MODE_2DDNA                  152
#define FX_MODE_2DMATRIX               153
#define FX_MODE_2DMETABALLS            154
#define FX_MODE_FREQMAP                155
#define FX_MODE_GRAVCENTER             156
#define FX_MODE_GRAVCENTRIC            157
#define FX_MODE_GRAVFREQ               158
#define FX_MODE_DJLIGHT                159
#define FX_MODE_2DFUNKYPLANK           160
#define FX_MODE_2DCENTERBARS           161
#define FX_MODE_2DPULSER               162
#define FX_MODE_BLURZ                  163
#define FX_MODE_2DDRIFT                 164
#define FX_MODE_2DWAVERLY               165
#define FX_MODE_2DSUNRADIATION          166
#define FX_MODE_2DCOLOREDBURSTS         167
#define FX_MODE_2DJULIA                 168
#define FX_MODE_2DPOOLNOISE            169 //reserved in JSON_mode_names
#define FX_MODE_2DTWISTER              170 //reserved in JSON_mode_names
#define FX_MODE_2DCAELEMENTATY         171 //reserved in JSON_mode_names
#define FX_MODE_2DGAMEOFLIFE           172
#define FX_MODE_2DTARTAN               173
#define FX_MODE_2DPOLARLIGHTS          174
#define FX_MODE_2DSWIRL                175
#define FX_MODE_2DLISSAJOUS            176
#define FX_MODE_2DFRIZZLES             177
#define FX_MODE_2DPLASMABALL           178
#define FX_MODE_FLOWSTRIPE             179
#define FX_MODE_2DHIPHOTIC             180
#define FX_MODE_2DSINDOTS              181
#define FX_MODE_2DDNASPIRAL            182
#define FX_MODE_2DBLACKHOLE            183
#define FX_MODE_WAVESINS               184
#define FX_MODE_ROCKTAVES              185
#define FX_MODE_2DAKEMI                186
#define FX_MODE_ARTIFX                 187 //WLEDSR ARTI-FX
#define FX_MODE_3DRIPPLES              188
#define FX_MODE_3DSphereMove        189

// Experimental Audioresponsive modes
#define FX_MODE_POPCORN_AR             190
#define FX_MODE_MULTI_COMET_AR         191
#define FX_MODE_STARBURST_AR           192
#define FX_MODE_PALETTE_AR             193
#define FX_MODE_FIREWORKS_AR           194

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    End of Audio Reactive fork (WLEDSR)                                                                                                //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class WS2812FX {
  typedef uint16_t (WS2812FX::*mode_ptr)(void);

  // pre show callback
  typedef void (*show_callback) (void);

  static WS2812FX* instance;

  // segment parameters
  public:

    // FastLED array, so we can refer to leds[i] instead of getPixel() and setPixel()
    CRGB leds[MAX_LEDS+1];                      // See const.h for a value of 1500. The plus 1 is just in case we go over with XY().

    typedef struct Segment { // 31 (32 in memory) bytes
      uint16_t start;
      uint16_t stop;    //segment invalid if stop == 0
      uint16_t offset;
      uint8_t speed;
      uint8_t intensity;
      uint8_t custom1;  // WLEDSR
      uint8_t custom2;  // WLEDSR
      uint8_t custom3;  // WLEDSR
      uint8_t palette;
      uint8_t mode;
      uint8_t options;  //bit pattern: msb first: transitional needspixelstate tbd tbd (paused) on reverse selected
      uint8_t grouping, spacing;
      uint8_t opacity;
      uint32_t colors[NUM_COLORS];
      uint8_t  cct;     //0==1900K, 255==10091K
      uint8_t  _capabilities;
      uint16_t width;   // WLEDSR ewowi20210624: add width/height and startX/Y stopX/Y for 2D segments
      uint16_t height;  // WLEDSR
      uint16_t startX;  // WLEDSR
      uint16_t startY;  // WLEDSR
      uint16_t stopX;   // WLEDSR
      uint16_t stopY;   // WLEDSR

      char *name;
      bool setColor(uint8_t slot, uint32_t c, uint8_t segn) { //returns true if changed
        if (slot >= NUM_COLORS || segn >= MAX_NUM_SEGMENTS) return false;
        if (c == colors[slot]) return false;
        uint8_t b = (slot == 1) ? cct : opacity;
        ColorTransition::startTransition(b, colors[slot], instance->_transitionDur, segn, slot);
        colors[slot] = c; return true;
      }
      void setCCT(uint16_t k, uint8_t segn) {
        if (segn >= MAX_NUM_SEGMENTS) return;
        if (k > 255) { //kelvin value, convert to 0-255
          if (k < 1900)  k = 1900;
          if (k > 10091) k = 10091;
          k = (k - 1900) >> 5;
        }
        if (cct == k) return;
        ColorTransition::startTransition(cct, colors[1], instance->_transitionDur, segn, 1);
        cct = k;
      }
      void setOpacity(uint8_t o, uint8_t segn) {
        if (segn >= MAX_NUM_SEGMENTS) return;
        if (opacity == o) return;
        ColorTransition::startTransition(opacity, colors[0], instance->_transitionDur, segn, 0);
        opacity = o;
      }
      void setOption(uint8_t n, bool val, uint8_t segn = 255)
      {
        bool prevOn = false;
        if (n == SEG_OPTION_ON) {
          prevOn = getOption(SEG_OPTION_ON);
          if (!val && prevOn) { //fade off
            ColorTransition::startTransition(opacity, colors[0], instance->_transitionDur, segn, 0);
          }
        }

        if (val) {
          options |= 0x01 << n;
        } else
        {
          options &= ~(0x01 << n);
        }

        if (n == SEG_OPTION_ON && val && !prevOn) { //fade on
          ColorTransition::startTransition(0, colors[0], instance->_transitionDur, segn, 0);
        }
      }
      bool getOption(uint8_t n)
      {
        return ((options >> n) & 0x01);
      }
      inline bool isSelected()
      {
        return getOption(0);
      }
      inline bool isActive()
      {
        return stop > start;
      }
      inline uint16_t length()
      {
        if ((stopX < startX) || (stopY < startY)) return 0;      //WLEDSR: avoid unsigned underflow (stop = 0 is allowed)
        else return (stopX - startX + 1) * (stopY - startY + 1); //WLEDSR: calculate length using SEGMENT x/y. Used by SEGLEN
      }
      inline uint16_t groupLength()
      {
        return grouping + spacing;
      }
      uint16_t virtualLength()
      {
        uint16_t groupLen = groupLength();
        uint16_t vLength = (groupLen > 0) ? ((length() + groupLen - 1) / groupLen) : 0; //WLEDSR avoid division by zero
        if (options & MIRROR)
          vLength = (vLength + 1) /2;  // divide by 2 if mirror, leave at least a single LED
        return vLength;
      }
      uint8_t differs(Segment& b);
      inline uint8_t getLightCapabilities() {return _capabilities;}
      void refreshLightCapabilities();
    } segment;

  // segment runtime parameters
    typedef struct Segment_runtime { // 28 bytes
      unsigned long next_time;  // millis() of next update
      uint32_t step;  // custom "step" var
      uint32_t call;  // call counter
      uint16_t aux0;  // custom var
      uint16_t aux1;  // custom var
      byte* data = nullptr;
      bool allocateData(uint16_t len){
        if (data && _dataLen == len) return true; //already allocated
        deallocateData();
        if (WS2812FX::instance->_usedSegmentData + len > MAX_SEGMENT_DATA) return false; //not enough memory
        // if possible use SPI RAM on ESP32
        #if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_PSRAM)
        if (psramFound())
          data = (byte*) ps_malloc(len);
        else
        #endif
          data = (byte*) malloc(len);
        if (!data) return false; //allocation failed
        WS2812FX::instance->_usedSegmentData += len;
        _dataLen = len;
        memset(data, 0, len);
        return true;
      }
      void deallocateData(){
        free(data);
        data = nullptr;
        WS2812FX::instance->_usedSegmentData -= _dataLen;
        _dataLen = 0;
      }

      /**
       * If reset of this segment was request, clears runtime
       * settings of this segment.
       * Must not be called while an effect mode function is running
       * because it could access the data buffer and this method
       * may free that data buffer.
       */
      void resetIfRequired() {
        if (_requiresReset) {
          next_time = 0; step = 0; call = 0; aux0 = 0; aux1 = 0;
          deallocateData();
          _requiresReset = false;
        }
      }

      /**
       * Flags that before the next effect is calculated,
       * the internal segment state should be reset.
       * Call resetIfRequired before calling the next effect function.
       * Safe to call from interrupts and network requests.
       */
      inline void markForReset() { _requiresReset = true; }
      private:
        uint16_t _dataLen = 0;
        bool _requiresReset = false;
    } segment_runtime;

    typedef struct ColorTransition { // 12 bytes
      uint32_t colorOld = 0;
      uint32_t transitionStart;
      uint16_t transitionDur;
      uint8_t segment = 0xFF; //lower 6 bits: the segment this transition is for (255 indicates transition not in use/available) upper 2 bits: color channel
      uint8_t briOld = 0;
      static void startTransition(uint8_t oldBri, uint32_t oldCol, uint16_t dur, uint8_t segn, uint8_t slot) {
        if (segn >= MAX_NUM_SEGMENTS || slot >= NUM_COLORS || dur == 0) return;
        if (instance->_brightness == 0) return; //do not need transitions if master bri is off
        if (!instance->_segments[segn].getOption(SEG_OPTION_ON)) return; //not if segment is off either
        uint8_t tIndex = 0xFF; //none found
        uint16_t tProgression = 0;
        uint8_t s = segn + (slot << 6); //merge slot and segment into one byte

        for (uint8_t i = 0; i < MAX_NUM_TRANSITIONS; i++) {
          uint8_t tSeg = instance->transitions[i].segment;
          //see if this segment + color already has a running transition
          if (tSeg == s) {
            tIndex = i; break;
          }
          if (tSeg == 0xFF) { //free transition
            tIndex = i; tProgression = 0xFFFF;
          }
        }

        if (tIndex == 0xFF) { //no slot found yet
          for (uint8_t i = 0; i < MAX_NUM_TRANSITIONS; i++) {
            //find most progressed transition to overwrite
            uint16_t prog = instance->transitions[i].progress();
            if (prog > tProgression) {
              tIndex = i; tProgression = prog;
            }
          }
        }

        ColorTransition& t = instance->transitions[tIndex];
        if (t.segment == s) //this is an active transition on the same segment+color
        {
          bool wasTurningOff = (oldBri == 0);
          t.briOld = t.currentBri(wasTurningOff, slot);
          t.colorOld = t.currentColor(oldCol);
        } else {
          t.briOld = oldBri;
          t.colorOld = oldCol;
          uint8_t prevSeg = t.segment & 0x3F;
          if (prevSeg < MAX_NUM_SEGMENTS) instance->_segments[prevSeg].setOption(SEG_OPTION_TRANSITIONAL, false);
        }
        t.transitionDur = dur;
        t.transitionStart = millis();
        t.segment = s;
        instance->_segments[segn].setOption(SEG_OPTION_TRANSITIONAL, true);
        //refresh immediately, required for Solid mode
        if (instance->_segment_runtimes[segn].next_time > t.transitionStart + 22) instance->_segment_runtimes[segn].next_time = t.transitionStart;
      }
      uint16_t progress(bool allowEnd = false) { //transition progression between 0-65535
        uint32_t timeNow = millis();
        if (timeNow - transitionStart > transitionDur) {
          if (allowEnd) {
            uint8_t segn = segment & 0x3F;
            if (segn < MAX_NUM_SEGMENTS) instance->_segments[segn].setOption(SEG_OPTION_TRANSITIONAL, false);
            segment = 0xFF;
          }
          return 0xFFFF;
        }
        uint32_t elapsed = timeNow - transitionStart;
        uint32_t prog = elapsed * 0xFFFF / transitionDur;
        return (prog > 0xFFFF) ? 0xFFFF : prog;
      }
      uint32_t currentColor(uint32_t colorNew) {
        return instance->color_blend(colorOld, colorNew, progress(true), true);
      }
      uint8_t currentBri(bool turningOff = false, uint8_t slot = 0) {
        uint8_t segn = segment & 0x3F;
        if (segn >= MAX_NUM_SEGMENTS) return 0;
        uint8_t briNew = instance->_segments[segn].opacity;
        if (slot == 0) {
          if (!instance->_segments[segn].getOption(SEG_OPTION_ON) || turningOff) briNew = 0;
        } else { //transition slot 1 brightness for CCT transition
          briNew = instance->_segments[segn].cct;
        }
        uint32_t prog = progress() + 1;
        return ((briNew * prog) + (briOld * (0x10000 - prog))) >> 16;
      }
    } color_transition;

    WS2812FX() {
      WS2812FX::instance = this;
      //assign each member of the _mode[] array to its respective function reference
      _mode[FX_MODE_STATIC]                  = &WS2812FX::mode_static;
      _mode[FX_MODE_BLINK]                   = &WS2812FX::mode_blink;
      _mode[FX_MODE_COLOR_WIPE]              = &WS2812FX::mode_color_wipe;
      _mode[FX_MODE_COLOR_WIPE_RANDOM]       = &WS2812FX::mode_color_wipe_random;
      _mode[FX_MODE_RANDOM_COLOR]            = &WS2812FX::mode_random_color;
      _mode[FX_MODE_COLOR_SWEEP]             = &WS2812FX::mode_color_sweep;
      _mode[FX_MODE_DYNAMIC]                 = &WS2812FX::mode_dynamic;
      _mode[FX_MODE_RAINBOW]                 = &WS2812FX::mode_rainbow;
      _mode[FX_MODE_RAINBOW_CYCLE]           = &WS2812FX::mode_rainbow_cycle;
      _mode[FX_MODE_SCAN]                    = &WS2812FX::mode_scan;
      _mode[FX_MODE_DUAL_SCAN]               = &WS2812FX::mode_dual_scan;
      _mode[FX_MODE_FADE]                    = &WS2812FX::mode_fade;
      _mode[FX_MODE_THEATER_CHASE]           = &WS2812FX::mode_theater_chase;
      _mode[FX_MODE_THEATER_CHASE_RAINBOW]   = &WS2812FX::mode_theater_chase_rainbow;
      _mode[FX_MODE_SAW]                     = &WS2812FX::mode_saw;
      _mode[FX_MODE_TWINKLE]                 = &WS2812FX::mode_twinkle;
      _mode[FX_MODE_DISSOLVE]                = &WS2812FX::mode_dissolve;
      _mode[FX_MODE_DISSOLVE_RANDOM]         = &WS2812FX::mode_dissolve_random;
      _mode[FX_MODE_SPARKLE]                 = &WS2812FX::mode_sparkle;
      _mode[FX_MODE_FLASH_SPARKLE]           = &WS2812FX::mode_flash_sparkle;
      _mode[FX_MODE_HYPER_SPARKLE]           = &WS2812FX::mode_hyper_sparkle;
      _mode[FX_MODE_STROBE]                  = &WS2812FX::mode_strobe;
      _mode[FX_MODE_STROBE_RAINBOW]          = &WS2812FX::mode_strobe_rainbow;
      _mode[FX_MODE_MULTI_STROBE]            = &WS2812FX::mode_multi_strobe;
      _mode[FX_MODE_BLINK_RAINBOW]           = &WS2812FX::mode_blink_rainbow;
      _mode[FX_MODE_ANDROID]                 = &WS2812FX::mode_android;
      _mode[FX_MODE_CHASE_COLOR]             = &WS2812FX::mode_chase_color;
      _mode[FX_MODE_CHASE_RANDOM]            = &WS2812FX::mode_chase_random;
      _mode[FX_MODE_CHASE_RAINBOW]           = &WS2812FX::mode_chase_rainbow;
      _mode[FX_MODE_CHASE_FLASH]             = &WS2812FX::mode_chase_flash;
      _mode[FX_MODE_CHASE_FLASH_RANDOM]      = &WS2812FX::mode_chase_flash_random;
      _mode[FX_MODE_CHASE_RAINBOW_WHITE]     = &WS2812FX::mode_chase_rainbow_white;
      _mode[FX_MODE_COLORFUL]                = &WS2812FX::mode_colorful;
      _mode[FX_MODE_TRAFFIC_LIGHT]           = &WS2812FX::mode_traffic_light;
      _mode[FX_MODE_COLOR_SWEEP_RANDOM]      = &WS2812FX::mode_color_sweep_random;
      _mode[FX_MODE_RUNNING_COLOR]           = &WS2812FX::mode_running_color;
      _mode[FX_MODE_AURORA]                  = &WS2812FX::mode_aurora;
      _mode[FX_MODE_RUNNING_RANDOM]          = &WS2812FX::mode_running_random;
      _mode[FX_MODE_LARSON_SCANNER]          = &WS2812FX::mode_larson_scanner;
      _mode[FX_MODE_COMET]                   = &WS2812FX::mode_comet;
      _mode[FX_MODE_FIREWORKS]               = &WS2812FX::mode_fireworks;
      _mode[FX_MODE_RAIN]                    = &WS2812FX::mode_rain;
      _mode[FX_MODE_TETRIX]                  = &WS2812FX::mode_tetrix;
      _mode[FX_MODE_FIRE_FLICKER]            = &WS2812FX::mode_fire_flicker;
      _mode[FX_MODE_GRADIENT]                = &WS2812FX::mode_gradient;
      _mode[FX_MODE_LOADING]                 = &WS2812FX::mode_loading;
      _mode[FX_MODE_POLICE]                  = &WS2812FX::mode_police;
      _mode[FX_MODE_FAIRY]                   = &WS2812FX::mode_fairy;
      _mode[FX_MODE_TWO_DOTS]                = &WS2812FX::mode_two_dots;
      _mode[FX_MODE_FAIRYTWINKLE]            = &WS2812FX::mode_fairytwinkle;
      _mode[FX_MODE_RUNNING_DUAL]            = &WS2812FX::mode_running_dual;
      _mode[FX_MODE_HALLOWEEN]               = &WS2812FX::mode_halloween;
      _mode[FX_MODE_TRICOLOR_CHASE]          = &WS2812FX::mode_tricolor_chase;
      _mode[FX_MODE_TRICOLOR_WIPE]           = &WS2812FX::mode_tricolor_wipe;
      _mode[FX_MODE_TRICOLOR_FADE]           = &WS2812FX::mode_tricolor_fade;
      _mode[FX_MODE_BREATH]                  = &WS2812FX::mode_breath;
      _mode[FX_MODE_RUNNING_LIGHTS]          = &WS2812FX::mode_running_lights;
      _mode[FX_MODE_LIGHTNING]               = &WS2812FX::mode_lightning;
      _mode[FX_MODE_ICU]                     = &WS2812FX::mode_icu;
      _mode[FX_MODE_MULTI_COMET]             = &WS2812FX::mode_multi_comet;
      _mode[FX_MODE_DUAL_LARSON_SCANNER]     = &WS2812FX::mode_dual_larson_scanner;
      _mode[FX_MODE_RANDOM_CHASE]            = &WS2812FX::mode_random_chase;
      _mode[FX_MODE_OSCILLATE]               = &WS2812FX::mode_oscillate;
      _mode[FX_MODE_FIRE_2012]               = &WS2812FX::mode_fire_2012;
      _mode[FX_MODE_PRIDE_2015]              = &WS2812FX::mode_pride_2015;
      _mode[FX_MODE_BPM]                     = &WS2812FX::mode_bpm;
      _mode[FX_MODE_JUGGLE]                  = &WS2812FX::mode_juggle;
      _mode[FX_MODE_PALETTE]                 = &WS2812FX::mode_palette;
      _mode[FX_MODE_COLORWAVES]              = &WS2812FX::mode_colorwaves;
      _mode[FX_MODE_FILLNOISE8]              = &WS2812FX::mode_fillnoise8;
      _mode[FX_MODE_NOISE16_1]               = &WS2812FX::mode_noise16_1;
      _mode[FX_MODE_NOISE16_2]               = &WS2812FX::mode_noise16_2;
      _mode[FX_MODE_NOISE16_3]               = &WS2812FX::mode_noise16_3;
      _mode[FX_MODE_NOISE16_4]               = &WS2812FX::mode_noise16_4;
      _mode[FX_MODE_COLORTWINKLE]            = &WS2812FX::mode_colortwinkle;
      _mode[FX_MODE_LAKE]                    = &WS2812FX::mode_lake;
      _mode[FX_MODE_METEOR]                  = &WS2812FX::mode_meteor;
      _mode[FX_MODE_METEOR_SMOOTH]           = &WS2812FX::mode_meteor_smooth;
      _mode[FX_MODE_RAILWAY]                 = &WS2812FX::mode_railway;
      _mode[FX_MODE_RIPPLE]                  = &WS2812FX::mode_ripple;
      _mode[FX_MODE_HALLOWEEN_EYES]          = &WS2812FX::mode_halloween_eyes;
      _mode[FX_MODE_STATIC_PATTERN]          = &WS2812FX::mode_static_pattern;
      _mode[FX_MODE_TRI_STATIC_PATTERN]      = &WS2812FX::mode_tri_static_pattern;
      _mode[FX_MODE_SPOTS]                   = &WS2812FX::mode_spots;
      _mode[FX_MODE_SPOTS_FADE]              = &WS2812FX::mode_spots_fade;
      _mode[FX_MODE_GLITTER]                 = &WS2812FX::mode_glitter;
      _mode[FX_MODE_CANDLE]                  = &WS2812FX::mode_candle;
      _mode[FX_MODE_STARBURST]               = &WS2812FX::mode_starburst;
      _mode[FX_MODE_EXPLODING_FIREWORKS]     = &WS2812FX::mode_exploding_fireworks;
      _mode[FX_MODE_BOUNCINGBALLS]           = &WS2812FX::mode_bouncing_balls;
      _mode[FX_MODE_SINELON]                 = &WS2812FX::mode_sinelon;
      _mode[FX_MODE_SINELON_DUAL]            = &WS2812FX::mode_sinelon_dual;
      _mode[FX_MODE_SINELON_RAINBOW]         = &WS2812FX::mode_sinelon_rainbow;
      _mode[FX_MODE_POPCORN]                 = &WS2812FX::mode_popcorn;
      _mode[FX_MODE_DRIP]                    = &WS2812FX::mode_drip;
      _mode[FX_MODE_PLASMA]                  = &WS2812FX::mode_plasma;
      _mode[FX_MODE_PERCENT]                 = &WS2812FX::mode_percent;
      _mode[FX_MODE_RIPPLE_RAINBOW]          = &WS2812FX::mode_ripple_rainbow;
      _mode[FX_MODE_HEARTBEAT]               = &WS2812FX::mode_heartbeat;
      _mode[FX_MODE_PACIFICA]                = &WS2812FX::mode_pacifica;
      _mode[FX_MODE_CANDLE_MULTI]            = &WS2812FX::mode_candle_multi;
      _mode[FX_MODE_SOLID_GLITTER]           = &WS2812FX::mode_solid_glitter;
      _mode[FX_MODE_SUNRISE]                 = &WS2812FX::mode_sunrise;
      _mode[FX_MODE_PHASED]                  = &WS2812FX::mode_phased;
      _mode[FX_MODE_TWINKLEUP]               = &WS2812FX::mode_twinkleup;
      _mode[FX_MODE_NOISEPAL]                = &WS2812FX::mode_noisepal;
      _mode[FX_MODE_SINEWAVE]                = &WS2812FX::mode_sinewave;
      _mode[FX_MODE_PHASEDNOISE]             = &WS2812FX::mode_phased_noise;
      _mode[FX_MODE_FLOW]                    = &WS2812FX::mode_flow;
      _mode[FX_MODE_CHUNCHUN]                = &WS2812FX::mode_chunchun;
      _mode[FX_MODE_DANCING_SHADOWS]         = &WS2812FX::mode_dancing_shadows;
      _mode[FX_MODE_WASHING_MACHINE]         = &WS2812FX::mode_washing_machine;
      _mode[FX_MODE_CANDY_CANE]              = &WS2812FX::mode_candy_cane;
      _mode[FX_MODE_BLENDS]                  = &WS2812FX::mode_blends;
      _mode[FX_MODE_TV_SIMULATOR]            = &WS2812FX::mode_tv_simulator;
      _mode[FX_MODE_DYNAMIC_SMOOTH]          = &WS2812FX::mode_dynamic_smooth;

// Technical notes
// ===============
// Defines which effects are incuded in the build. Currently only WLEDSR_LARGE used.
// It is possible to just comment any effect you don't like, but it is recommended to use the ifdefs.
// Note that this is the only place to activate or de-activate effects. No need to (un)comment anything else then
      // _mode[<Effect>]          = &WS2812FX::mode_<effect>;
// in this version, commented effects will show in the UI but will not be executed / compiled,
// instead of that, the blink effect will be shown. This is done in WS2812FX::service() in fx_fcn.cpp
// to do: find out if the effect list can only be loaded with effects which are uncommented here.
// Note: as in this version, numbering is made future prove (e.g. range for AC, range for SR, fixed numbering).
//       If you have old presets, they need to be converted to the new numbering.
//       Harry Baas made a VB script to convert them.
// Note: If all SR effects are disabled: 2.5% of 1.310.720 bytes = 32.768 bytes are saved.
// Note: the order of numbering is based on the order in which effects are added, so newer effects get higher numbers

#define WLEDSR_SMALL  1
#define WLEDSR_MEDIUM 1
#define WLEDSR_LARGE  1

//WLED AC effects disabled by WLEDSR setting
#ifdef WLEDSR_LARGE
      _mode[FX_MODE_TWINKLEFOX]              = &WS2812FX::mode_twinklefox;
      _mode[FX_MODE_TWINKLECAT]              = &WS2812FX::mode_twinklecat;
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    Start of Audio Reactive fork (WLEDSR)                                                                                              //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      _mode[FX_MODE_PIXELS]                  = &WS2812FX::mode_pixels;
      _mode[FX_MODE_PIXELWAVE]               = &WS2812FX::mode_pixelwave;
      _mode[FX_MODE_JUGGLES]                 = &WS2812FX::mode_juggles;
      _mode[FX_MODE_MATRIPIX]                = &WS2812FX::mode_matripix;
      _mode[FX_MODE_GRAVIMETER]              = &WS2812FX::mode_gravimeter;
      _mode[FX_MODE_PLASMOID]                = &WS2812FX::mode_plasmoid;
      _mode[FX_MODE_PUDDLES]                 = &WS2812FX::mode_puddles;
      _mode[FX_MODE_MIDNOISE]                = &WS2812FX::mode_midnoise;
      _mode[FX_MODE_NOISEMETER]              = &WS2812FX::mode_noisemeter;
      _mode[FX_MODE_FREQWAVE]                = &WS2812FX::mode_freqwave;
      _mode[FX_MODE_FREQMATRIX]              = &WS2812FX::mode_freqmatrix;
      _mode[FX_MODE_2DGEQ]                   = &WS2812FX::mode_2DGEQ;
      _mode[FX_MODE_WATERFALL]               = &WS2812FX::mode_waterfall;
      _mode[FX_MODE_FREQPIXELS]              = &WS2812FX::mode_freqpixels;
      _mode[FX_MODE_BINMAP]                  = &WS2812FX::mode_binmap;
      _mode[FX_MODE_NOISEFIRE]               = &WS2812FX::mode_noisefire;
      _mode[FX_MODE_PUDDLEPEAK]              = &WS2812FX::mode_puddlepeak;
      _mode[FX_MODE_NOISEMOVE]               = &WS2812FX::mode_noisemove;
      _mode[FX_MODE_2DNOISE]                 = &WS2812FX::mode_2Dnoise;
      _mode[FX_MODE_PERLINMOVE]              = &WS2812FX::mode_perlinmove;
      _mode[FX_MODE_RIPPLEPEAK]              = &WS2812FX::mode_ripplepeak;
      _mode[FX_MODE_2DFIRENOISE]             = &WS2812FX::mode_2Dfirenoise;
      _mode[FX_MODE_2DSQUAREDSWIRL]          = &WS2812FX::mode_2Dsquaredswirl;
      _mode[FX_MODE_2DFIRE2012]              = &WS2812FX::mode_2Dfire2012;
      _mode[FX_MODE_2DDNA]                   = &WS2812FX::mode_2Ddna;
      _mode[FX_MODE_2DMATRIX]                = &WS2812FX::mode_2Dmatrix;
      _mode[FX_MODE_2DMETABALLS]             = &WS2812FX::mode_2Dmetaballs;
      _mode[FX_MODE_FREQMAP]                 = &WS2812FX::mode_freqmap;
      _mode[FX_MODE_GRAVCENTER]              = &WS2812FX::mode_gravcenter;
      _mode[FX_MODE_GRAVCENTRIC]             = &WS2812FX::mode_gravcentric;
      _mode[FX_MODE_GRAVFREQ]                = &WS2812FX::mode_gravfreq;
      _mode[FX_MODE_DJLIGHT]                 = &WS2812FX::mode_DJLight;
      _mode[FX_MODE_2DFUNKYPLANK]            = &WS2812FX::mode_2DFunkyPlank;
      _mode[FX_MODE_2DCENTERBARS]            = &WS2812FX::mode_2DCenterBars;
      _mode[FX_MODE_2DPULSER]                = &WS2812FX::mode_2DPulser;
      _mode[FX_MODE_BLURZ]                   = &WS2812FX::mode_blurz;
      _mode[FX_MODE_2DSUNRADIATION]          = &WS2812FX::mode_2DSunradiation;
      _mode[FX_MODE_2DWAVERLY]               = &WS2812FX::mode_2DWaverly;
      _mode[FX_MODE_2DDRIFT]                 = &WS2812FX::mode_2DDrift;
      _mode[FX_MODE_2DCOLOREDBURSTS]         = &WS2812FX::mode_2DColoredBursts;
      _mode[FX_MODE_2DTARTAN]                = &WS2812FX::mode_2Dtartan;
      _mode[FX_MODE_2DPOLARLIGHTS]           = &WS2812FX::mode_2DPolarLights;
      _mode[FX_MODE_2DSWIRL]                 = &WS2812FX::mode_2DSwirl;
      _mode[FX_MODE_2DLISSAJOUS]             = &WS2812FX::mode_2DLissajous;
      _mode[FX_MODE_2DFRIZZLES]              = &WS2812FX::mode_2DFrizzles;
      _mode[FX_MODE_2DPLASMABALL]            = &WS2812FX::mode_2DPlasmaball;
      _mode[FX_MODE_FLOWSTRIPE]              = &WS2812FX::mode_FlowStripe;
      _mode[FX_MODE_2DHIPHOTIC]              = &WS2812FX::mode_2DHiphotic;
      _mode[FX_MODE_2DSINDOTS]               = &WS2812FX::mode_2DSindots;
      _mode[FX_MODE_2DDNASPIRAL]             = &WS2812FX::mode_2DDNASpiral;
      _mode[FX_MODE_2DBLACKHOLE]             = &WS2812FX::mode_2DBlackHole;
      _mode[FX_MODE_WAVESINS]                = &WS2812FX::mode_wavesins;
      _mode[FX_MODE_ROCKTAVES]               = &WS2812FX::mode_rocktaves;
      _mode[FX_MODE_2DAKEMI]                 = &WS2812FX::mode_2DAkemi;
#ifdef USERMOD_ARTIFX
      _mode[FX_MODE_ARTIFX]                  = &WS2812FX::mode_ARTIFX; //WLEDMM ARTI-FX
#endif      
      _mode[FX_MODE_3DRIPPLES]               = &WS2812FX::mode_3DRipples;
      _mode[FX_MODE_3DSphereMove]            = &WS2812FX::mode_3DSphereMove;

#ifdef WLEDSR_LARGE
    // _mode[FX_MODE_2DPOOLNOISE]              = &WS2812FX::mode_2DPoolnoise; //code not in fx.cpp
    // _mode[FX_MODE_2DTWISTER]                = &WS2812FX::mode_2DTwiser; //code not in fx.cpp
    // _mode[FX_MODE_2DCAElementary]                = &WS2812FX::mode_2DCAElementary; //code not in fx.cpp

     _mode[FX_MODE_2DJULIA]                  = &WS2812FX::mode_2DJulia;
     _mode[FX_MODE_2DGAMEOFLIFE]             = &WS2812FX::mode_2Dgameoflife;

     _mode[FX_MODE_POPCORN_AR]                = &WS2812FX::mode_popcorn_audio;
     _mode[FX_MODE_MULTI_COMET_AR]            = &WS2812FX::mode_multi_comet_audio;
     _mode[FX_MODE_STARBURST_AR]              = &WS2812FX::mode_starburst_audio;
     _mode[FX_MODE_PALETTE_AR]                = &WS2812FX::mode_palette_audio;
     _mode[FX_MODE_FIREWORKS_AR]              = &WS2812FX::mode_fireworks_audio;
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    End of Audio Reactive fork (WLEDSR)                                                                                                //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


      _brightness = DEFAULT_BRIGHTNESS;
      currentPalette = CRGBPalette16(CRGB::Black);
      targetPalette = CloudColors_p;
      ablMilliampsMax = ABL_MILLIAMPS_DEFAULT;
      currentMilliamps = 0;
      timebase = 0;
      resetSegments();
    }

    void
      finalizeInit(),
      service(void),
      blur(uint8_t),
      fill(uint32_t),
      fade_out(uint8_t r),
      setMode(uint8_t segid, uint8_t m),
      setColor(uint8_t slot, uint8_t r, uint8_t g, uint8_t b, uint8_t w = 0),
      setColor(uint8_t slot, uint32_t c),
      setCCT(uint16_t k),
      setBrightness(uint8_t b, bool direct = false),
      setRange(uint16_t i, uint16_t i2, uint32_t col),
      setShowCallback(show_callback cb),
      setTransition(uint16_t t),
      setTransitionMode(bool t),
      calcGammaTable(float),
      trigger(void),
      setReset(uint8_t n),
      setSegment(uint8_t n, uint16_t start, uint16_t stop, uint8_t grouping = 0, uint8_t spacing = 0, uint16_t offset = UINT16_MAX),
      setMainSegmentId(uint8_t n),
      restartRuntime(),
      resetSegments(),
      makeAutoSegments(bool forceReset = false),
      fixInvalidSegments(),
      setPixelColor(int n, uint8_t r, uint8_t g, uint8_t b, uint8_t w = 0),
      show(void),
			setTargetFps(uint8_t fps),
      deserializeMap(uint8_t n=0);

    inline void setPixelColor(int n, uint32_t c) {setPixelColor(n, byte(c>>16), byte(c>>8), byte(c), byte(c>>24));}

    bool
      gammaCorrectBri = false,
      gammaCorrectCol = true,
      // REMOVED IN 7b969bb
      // applyToAllSelected = true,
      // setEffectConfig(uint8_t m, uint8_t s, uint8_t i, uint8_t c1, uint8_t c2, uint8_t c3, uint8_t p), //WLEDSR: add c1,c2,c3
      checkSegmentAlignment(void),
      hasRGBWBus(void),
      hasCCTBus(void),
      // return true if the strip is being sent pixel updates
      isUpdating(void);

    uint8_t
      paletteFade = 0,
      paletteBlend = 0,
      milliampsPerLed = 55,
      autoWhiteMode = RGBW_MODE_DUAL,
      cctBlending = 0,
      getBrightness(void),
      getModeCount(void),
      getPaletteCount(void),
      getMaxSegments(void),
      getActiveSegmentsNum(void),
      getFirstSelectedSegId(void),
      getMainSegmentId(void),
      getLastActiveSegmentId(void),
      getTargetFps(void),
      setPixelSegment(uint8_t n),
      gamma8(uint8_t),
      gamma8_cal(uint8_t, float),
      get_random_wheel_index(uint8_t);

    inline uint8_t getCurrSegmentId(void) { return _segment_index; }

    inline uint8_t sin_gap(uint16_t in) {
      if (in & 0x100) return 0;
      return sin8(in + 192); // correct phase shift of sine so that it starts and stops at 0
    }

    int8_t
      tristate_square8(uint8_t x, uint8_t pulsewidth, uint8_t attdec);

    uint16_t
      ablMilliampsMax,
      currentMilliamps,
      triwave16(uint16_t),
      getLengthTotal(void),
      getLengthPhysical(void),
      getFps(),
      getMinShowDelay(); // Fixes private class variable compiler error. Unsure if this is the correct way of fixing the root problem. -THATDONFC

    uint32_t
      now,
      timebase,
      color_wheel(uint8_t),
      color_from_palette(uint16_t, bool mapping, bool wrap, uint8_t mcol, uint8_t pbri = 255),
      color_blend(uint32_t,uint32_t,uint16_t,bool b16=false),
      currentColor(uint32_t colorNew, uint8_t tNr),
      gamma32(uint32_t),
      getLastShow(void),
      getPixelColor(uint16_t);

    WS2812FX::Segment
      &getSegment(uint8_t n),
      &getFirstSelectedSeg(void),
      &getMainSegment(void);

    WS2812FX::Segment*
      getSegments(void);

    // builtin modes
    uint16_t
      mode_static(void),
      mode_blink(void),
      mode_blink_rainbow(void),
      mode_strobe(void),
      mode_strobe_rainbow(void),
      mode_color_wipe(void),
      mode_color_sweep(void),
      mode_color_wipe_random(void),
      mode_color_sweep_random(void),
      mode_random_color(void),
      mode_dynamic(void),
      mode_breath(void),
      mode_fade(void),
      mode_scan(void),
      mode_dual_scan(void),
      mode_theater_chase(void),
      mode_theater_chase_rainbow(void),
      mode_rainbow(void),
      mode_rainbow_cycle(void),
      mode_running_lights(void),
      mode_saw(void),
      mode_twinkle(void),
      mode_dissolve(void),
      mode_dissolve_random(void),
      mode_sparkle(void),
      mode_flash_sparkle(void),
      mode_hyper_sparkle(void),
      mode_multi_strobe(void),
      mode_android(void),
      mode_chase_color(void),
      mode_chase_random(void),
      mode_chase_rainbow(void),
      mode_chase_flash(void),
      mode_chase_flash_random(void),
      mode_chase_rainbow_white(void),
      mode_colorful(void),
      mode_traffic_light(void),
      mode_running_color(void),
      mode_aurora(void),
      mode_running_random(void),
      mode_larson_scanner(void),
      mode_comet(void),
      mode_fireworks_core(bool useAudio),       // WLEDSR
      mode_fireworks(void),
      mode_fireworks_audio(void),               // WLEDSR
      mode_rain(void),
      mode_tetrix(void),
      mode_halloween(void),
      mode_fire_flicker(void),
      mode_gradient(void),
      mode_loading(void),
      mode_police(void),
      mode_fairy(void),
      mode_two_dots(void),
      mode_fairytwinkle(void),
      mode_running_dual(void),
      mode_bicolor_chase(void),
      mode_tricolor_chase(void),
      mode_tricolor_wipe(void),
      mode_tricolor_fade(void),
      mode_lightning(void),
      mode_icu(void),
      mode_multi_comet_core(bool useAudio),    // WLEDSR
      mode_multi_comet(void),
      mode_multi_comet_audio(void),            // WLEDSR
      mode_dual_larson_scanner(void),
      mode_random_chase(void),
      mode_oscillate(void),
      mode_fire_2012(void),
      mode_pride_2015(void),
      mode_bpm(void),
      mode_juggle(void),
      mode_palette_core(bool useAudio),        // WLEDSR
      mode_palette(void),
      mode_palette_audio(void),                // WLEDSR
      mode_colorwaves(void),
      mode_fillnoise8(void),
      mode_noise16_1(void),
      mode_noise16_2(void),
      mode_noise16_3(void),
      mode_noise16_4(void),
      mode_colortwinkle(void),
      mode_lake(void),
      mode_meteor(void),
      mode_meteor_smooth(void),
      mode_railway(void),
      mode_ripple(void),
      mode_twinklefox(void),
      mode_twinklecat(void),
      mode_halloween_eyes(void),
      mode_static_pattern(void),
      mode_tri_static_pattern(void),
      mode_spots(void),
      mode_spots_fade(void),
      mode_glitter(void),
      mode_candle(void),
      mode_starburst_core(bool useAudio),  // WLEDSR
      mode_starburst(void),
      mode_starburst_audio(void),          // WLEDSR
      mode_exploding_fireworks(void),
      mode_bouncing_balls(void),
      mode_sinelon(void),
      mode_sinelon_dual(void),
      mode_sinelon_rainbow(void),
      mode_popcorn_core(bool useAudio),    // WLEDSR
      mode_popcorn(void),
      mode_popcorn_audio(void),            // WLEDSR
      mode_drip(void),
      mode_plasma(void),
      mode_percent(void),
      mode_ripple_rainbow(void),
      mode_heartbeat(void),
      mode_pacifica(void),
      mode_candle_multi(void),
      mode_solid_glitter(void),
      mode_sunrise(void),
      mode_phased(void),
      mode_twinkleup(void),
      mode_noisepal(void),
      mode_sinewave(void),
      mode_phased_noise(void),
      mode_flow(void),
      mode_chunchun(void),
      mode_dancing_shadows(void),
      mode_washing_machine(void),
      mode_candy_cane(void),
      mode_blends(void),
      mode_tv_simulator(void),
      mode_dynamic_smooth(void);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    Start of Audio Reactive fork (WLEDSR)                                                                                              //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    void
      fade2black(uint8_t r),
      set2DSegment(uint8_t n),
      setStripOrPanelWidthAndHeight(),
      noise8_help(uint8_t),
      mapNoiseToLEDsUsingPalette(),
      blur1d( CRGB* leds, fract8 blur_amount),
      blur2d( CRGB* leds, fract8 blur_amount),
      blurRows( CRGB* leds, fract8 blur_amount),
      blurColumns(CRGB* leds, fract8 blur_amount),
      fill_solid( struct CRGB * leds, const struct CRGB& color),
      fadeToBlackBy( CRGB* leds, uint8_t fadeBy),
      nscale8(       CRGB* leds, uint8_t scale),
      setPixels(CRGB* leds);

    bool
      segmentsAreIdentical(Segment* a, Segment* b);

    uint16_t
      XY(uint16_t, uint16_t),            // ewowi20210624: new XY: segmentToLogical: Maps XY in 2D segment to logical index. Works for 1D strips and 2D panels
      logicalToPhysical(uint16_t); // ewowi20210624: previous XY. Maps logical led index to physical led index. Works for 1D strips and 2D panels

    uint16_t
      matrixWidth = 30,
      matrixHeight = 1;

    uint8_t
      matrixPanels,
      matrixHorizontalPanels = 1,
      matrixVerticalPanels = 1,
      stripOrMatrixPanel = 0;

    uint8_t
      panelFirstLedTopBottom,
      panelFirstLedLeftRight,
      panelOrientationHorVert,
      panelSerpentine,
      panelTranspose;

    uint16_t
      mode_pixels(void),
      mode_pixelwave(void),
      mode_juggles(void),
      mode_matripix(void),
      mode_gravimeter(void),
      mode_plasmoid(void),
      mode_puddles(void),
      mode_midnoise(void),
      mode_noisemeter(void),
      mode_freqwave(void),
      mode_freqmatrix(void),
      mode_2DGEQ(void),
      mode_waterfall(void),
      mode_freqpixels(void),
      mode_binmap(void),
      mode_noisefire(void),
      mode_puddlepeak(void),
      mode_noisemove(void),
      mode_2Dnoise(void),
      mode_perlinmove(void),
      mode_ripplepeak(void),
      mode_2Dfirenoise(void),
      mode_2Dsquaredswirl(void),
      mode_2Dfire2012(void),
      mode_2Ddna(void),
      mode_2Dmatrix(void),
      mode_2Dmetaballs(void),
      mode_freqmap(void),
      mode_gravcenter(void),
      mode_gravcentric(void),
      mode_gravfreq(void),
      mode_DJLight(void),
      mode_2DFunkyPlank(void),
      mode_2DCenterBars(void),
      mode_2DPulser(void),
      mode_blurz(void),
      mode_2Dgameoflife(void),
      mode_2Dtartan(void),
      mode_2DPolarLights(void),
      mode_2DSwirl(void),
      mode_2DLissajous(void),
      mode_2DFrizzles(void),
      mode_2DPlasmaball(void),
      mode_FlowStripe(void),
      mode_2DHiphotic(void),
      mode_2DSindots(void),
      mode_2DDNASpiral(void),
      mode_2DBlackHole(void),
      mode_wavesins(void),
      mode_rocktaves(void),
      mode_2DAkemi(void),
      mode_2DSunradiation(void),
      mode_2DWaverly(void),
      mode_2DDrift(void),
      mode_2DColoredBursts(void),
      mode_2DJulia(void),
#ifdef USERMOD_ARTIFX
      mode_ARTIFX(void),     //WLEDMM ARTI-FX
#endif
      mode_3DRipples(void),
      mode_3DSphereMove(void);
    //  mode_2DPoolnoise(void),
    //  mode_2DTwister(void);
    //  mode_2DCAElementary(void);

    uint16_t
      GEQ_base(bool, bool, bool); //private???

    uint16_t
      _lengthRaw; //private? not in AC (anymore)

    bool
      _skipFirstMode; //private? not in AC (anymore)

    void drawLine(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint32_t c);
    void drawLine(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, CRGB c) { drawLine(x0, y0, x1, y1, RGBW32(c.r,c.g,c.b,0)); } // automatic inline
    void drawArc(uint16_t x0, uint16_t y0, uint16_t radius, uint32_t color, uint32_t fillColor = 0);
    void drawArc(uint16_t x0, uint16_t y0, uint16_t radius, CRGB color, CRGB fillColor = BLACK) { drawArc(x0, y0, radius, RGBW32(color.r,color.g,color.b,0), RGBW32(fillColor.r,fillColor.g,fillColor.b,0)); } // automatic inline

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    End of Audio Reactive fork (WLEDSR)                                                                                                //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    CRGBPalette16 currentPalette;
    uint32_t _colors_t[3];
    uint16_t _virtualSegmentLength;
    segment _segments[MAX_NUM_SEGMENTS] = { // SRAM footprint: 27 bytes per element
      //WLEDSR: add f1,2,3
      // start, stop, offset, speed, intensity, custom1, custom2, custom3, palette, mode, options, grouping, spacing, opacity (unused), color[], capabilities
      {0, 7, 0, DEFAULT_SPEED, DEFAULT_INTENSITY, DEFAULT_Custom1, DEFAULT_Custom2, DEFAULT_Custom3, 0, DEFAULT_MODE, NO_OPTIONS, 1, 0, 255, {DEFAULT_COLOR}, 0}
    };
    uint8_t _segment_index = 0;
    friend class Segment;
    segment_runtime _segment_runtimes[MAX_NUM_SEGMENTS]; // SRAM footprint: 28 bytes per element
    friend class Segment_runtime;

  private:
    uint32_t crgb_to_col(CRGB fastled);
    CRGB col_to_crgb(uint32_t);
    CRGBPalette16 targetPalette;

    uint16_t _length;
    uint16_t _rand16seed;
    uint8_t _brightness;
    uint16_t _usedSegmentData = 0;
    uint16_t _transitionDur = 750;

		uint8_t _targetFps = WLED_FPS;
		uint16_t _frametime = FRAMETIME_FIXED;
    uint16_t _cumulativeFps = 2;

    bool
      _isOffRefreshRequired = false, //periodic refresh is required for the strip to remain off.
      _hasWhiteChannel = false,
      _triggered;

    mode_ptr _mode[MODE_COUNT]; // SRAM footprint: 4 bytes per element

    show_callback _callback = nullptr;

    // mode helper functions
    uint16_t
      blink(uint32_t, uint32_t, bool strobe, bool),
      candle(bool),
      color_wipe(bool, bool),
      dynamic(bool),
      scan(bool),
      running_base(bool,bool),
      larson_scanner(bool),
      sinelon_base(bool,bool),
      dissolve(uint32_t),
      chase(uint32_t, uint32_t, uint32_t, bool),
      gradient_base(bool),
      ripple_base(bool),
      police_base(uint32_t, uint32_t),
      running(uint32_t, uint32_t, bool theatre=false),
      tricolor_chase(uint32_t, uint32_t),
      twinklefox_base(bool),
      spots_base(uint16_t),
      phased_base(uint8_t);

    CRGB twinklefox_one_twinkle(uint32_t ms, uint8_t salt, bool cat);
    CRGB pacifica_one_layer(uint16_t i, CRGBPalette16& p, uint16_t cistart, uint16_t wavescale, uint8_t bri, uint16_t ioff);

    void
      blendPixelColor(uint16_t n, uint32_t color, uint8_t blend),
      startTransition(uint8_t oldBri, uint32_t oldCol, uint16_t dur, uint8_t segn, uint8_t slot),
      estimateCurrentAndLimitBri(void),
      load_gradient_palette(uint8_t),
      handle_palette(void);

    CRGBPalette16 getAudioPalette(int pal);

    uint16_t* customMappingTable = nullptr;
    uint16_t  customMappingSize  = 0;

    uint32_t _lastPaletteChange = 0;
    uint32_t _lastShow = 0;

    uint8_t _bri_t;

    bool _no_rgb = false;

    uint8_t _segment_index_palette_last = 99;
    uint8_t _mainSegment;

    ColorTransition transitions[MAX_NUM_TRANSITIONS]; //12 bytes per element
    friend class ColorTransition;

    uint16_t
      segmentToLogical(uint16_t i),
      transitionProgress(uint8_t tNr);
  public:
    inline bool hasWhiteChannel(void) {return _hasWhiteChannel;}
    inline bool isOffRefreshRequired(void) {return _isOffRefreshRequired;}
};

//10 names per line
// WLEDSR: second part
// Technical notes
// ===============
// If an effect name is followed by an @, slider and color control is effective.
// See setEffectParameters in index.js for implementation
// If not effective then:
//      - For AC effects (id<128) 2 sliders and 3 colors and the palette will be shown
//      - For SR effects (id>128) 5 sliders and 3 colors and the palette will be shown
// If effective (@)
//      - a ; seperates slider controls (left) from color controls (middle) and palette control (right)
//      - if left, middle or right is empty no controls are shown
//      - a , seperates slider controls (max 5) or color controls (max 3). Palette has only one value
//      - a ! means that the default is used.
//             - For sliders: Effect speeds, Effect intensity, Custom 1, Custom 2, Custom 3
//               - Blazoncek default values: e.g. Sensitivity=128
//             - For colors: Fx color, Background color, Custom
//             - For palette: prompt Color palette
//
// Note: In this version only SR-effects have been specified.
// Note: If palette is on and no colors are specified 1,2 and 3 is shown in each color circle.
//       If a color is specified, the 1,2 or 3 is replaced by that specification.
// Note: Effects can override default pattern behaviour
//       - FadeToBlack can override the background setting
//       - Defining SEGCOL(<i>) can override a specific palette using these values (e.g. Color Gradient)

const char JSON_mode_names[] PROGMEM = R"=====([
"Solid@;!;",
"Blink@!,;!,!,;!",
"Breathe@!,;!,!;!",
"Wipe@!,!;!,!,;!",
"Wipe Random@!,;1,2,3;!",
"Random Colors@!,Fade time;1,2,3;!",
"Sweep@!,!;!,!,;!",
"Dynamic@!,!;1,2,3;!",
"Colorloop@!,Saturation;1,2,3;!",
"Rainbow@!,Size;1,2,3;!",
"Scan@!,# of dots;!,!,;!",
"Scan Dual@!,# of dots;!,!,;!",
"Fade@!,;!,!,;!",
"Theater@!,Gap size;!,!,;!",
"Theater Rainbow@!,Gap size;1,2,3;!",
"Running@!,Wave width;!,!,;!",
"Saw@!,Width;!,!,;!",
"Twinkle@!,;!,!,;!",
"Dissolve@Repeat speed,Dissolve speed;!,!,;!",
"Dissolve Rnd@Repeat speed,Dissolve speed;,!,;!",
"Sparkle@!,;!,!,;!",
"Sparkle Dark@!,!;Bg,Fx,;!",
"Sparkle+@!,!;Bg,Fx,;!",
"Strobe@!,;!,!,;!",
"Strobe Rainbow@!,;,!,;!",
"Strobe Mega@!,!;!,!,;!",
"Blink Rainbow@Frequency,Blink duration;!,!,;!",
"Android@!,Width;!,!,;!",
"Chase@!,Width;!,!,!;!",
"Chase Random@!,Width;!,,!;!",
"Chase Rainbow@!,Width;!,!,;0",
"Chase Flash@!,;Bg,Fx,!;!",
"Chase Flash Rnd@!,;,Fx,;!",
"Rainbow Runner@!,Size;Bg,,;!",
"Colorful@!,Saturation;1,2,3;!",
"Traffic Light@!,;,!,;!",
"Sweep Random",
"Chase 2@!,Width;!,!,;!",
"Aurora@!=24,!;1,2,3;!=50",
"Stream",
"Scanner",
"Lighthouse",
"Fireworks@Sharpness=96,Frequency=192;!,2,;!=11",
"Rain@Fade rate=128,Frequency=128;!,2,;!",
"Tetrix@!=224,Width=0;!,!,;!=11",
"Fire Flicker@!,!;!,,;!",
"Gradient@!,Spread=16;!,!,;!",
"Loading@!,Fade=16;!,!,;!",
"Police@!,Width;,Bg,;0",
"Fairy",
"Two Dots@!,Dot size;1,2,Bg;!",
"Fairy Twinkle",
"Running Dual",
"Halloween",
"Tri Chase@!,Size;1,2,3;0",
"Tri Wipe@!,Width;1,2,3;0",
"Tri Fade",
"Lightning",
"ICU",
"Multi Comet",
"Scanner Dual",
"Stream 2",
"Oscillate",
"Pride 2015@!,;;",
"Juggle@!=16,Trail=240;!,!,;!",
"Palette@!,;1,2,3;!",
"Fire 2012@Spark rate=120,Decay=64;1,2,3;!",
"Colorwaves",
"Bpm@!=64,;1,2,3;!",
"Fill Noise",
"Noise 1",
"Noise 2",
"Noise 3",
"Noise 4",
"Colortwinkles@Fade speed,Spawn speed;1,2,3;!",
"Lake@!,;1,2,3;!",
"Meteor@!,Trail length;!,!,;!",
"Meteor Smooth@!,Trail length;!,!,;!",
"Railway",
"Ripple",
"Twinklefox",
"Twinklecat",
"Halloween Eyes",
"Solid Pattern@Fg size,Bg size;Fg,Bg,;!=0",
"Solid Pattern Tri@,Size;1,2,3;!=0",
"Spots@Spread,Width;!,!,;!",
"Spots Fade@Spread,Width;!,!,;!",
"Glitter",
"Candle@Flicker rate=96,Flicker intensity=224;!,!,;0",
"Fireworks Starburst",
"Fireworks 1D@Gravity,Firing side;!,!,;!",
"Bouncing Balls@Gravity,# of balls;!,!,;!",
"Sinelon",
"Sinelon Dual",
"Sinelon Rainbow",
"Popcorn",
"Drip@Gravity,# of drips;!,!;!",
"Plasma@Phase,;1,2,3;!",
"Percent@,% of fill;!,!,;!",
"Ripple Rainbow",
"Heartbeat@!,!;!,!,;!",
"Pacifica",
"Candle Multi@Flicker rate=96,Flicker intensity=224;!,!,;0",
"Solid Glitter@,!;!,,;0",
"Sunrise@Time [min]=60,;;0",
"Phased",
"Twinkleup@!,Intensity;!,!,;!",
"Noise Pal",
"Sine",
"Phased Noise",
"Flow",
"Chunchun@!,Gap size;!,!,;!",
"Dancing Shadows@!,# of shadows;!,,;!",
"Washing Machine",
"Candy Cane@!,Width;;",
"Blends@Shift speed,Blend speed;1,2,3,!",
"TV Simulator",
"Dynamic Smooth",
"Reserved0",
"Reserved1",
"Reserved2",
"Reserved3",
"Reserved4",
"Reserved5",
"Reserved6",
"Reserved7",
"Reserved8",
"Reserved9",
"  Pixels@Fade rate,# of pixels;,!;!",
"  Pixelwave@!,Sensitivity=64;!,!;!",
"  Juggles@!,# of balls;,!;!",
"  Matripix@!,Brightness=64;,!;!",
"  Gravimeter@Rate of fall,Sensitivity=130;,!;!",
"  Plasmoid@Phase=128,# of pixels=128;,!;!",
"  Puddles@Fade rate,Puddle size;!,!;!",
"  Midnoise@Fade rate,Maximum length=128;,!;!",
"  Noisemeter@Fade rate,Width=128;!,!;!",
"  Freqwave@Time delay,Sound effect,Low bin,High bin,Pre-amp;;",
"  Freqmatrix@Time delay,Sound effect,Low bin,High bin,Sensivity;;",
"  2D GEQ@Bar speed,Ripple decay;,,Peak Color;!",
"  Waterfall@!,Adjust color,,Select bin=14, Volume (minimum)=62;!,!;!",
"  Freqpixels@Fade rate,Starting colour and # of pixels;;",
"  Binmap@;!,!;!",
"  Noisefire@!,!;;",
"  Puddlepeak@Fade rate,Puddle size,,Select bin=14,Volume (minimum)=96;!,!;!",
"  Noisemove@Speed of perlin movement,Fade rate;,!;!",
"2D Noise@Speed,Scale;;!",
"Perlin Move@!,# of pixels,fade rate;,!;!",
"  Ripple Peak@Fade rate,Max # of ripples,,Select bin=14,Volume (minimum)=62;!,!;!",
"2D FireNoise@X scale,Y scale;;",
"2D Squared Swirl@,,,,Blur;,,;!",
"2D Fire2012@Speed;;",
"2D DNA@Scroll speed,Blur;;!",
"2D Matrix@Falling speed,Spawning rate,Trail,Custom color ;Spawn,Trail;",
"2D Metaballs@;;",
"  Freqmap@Fade rate,Starting color;,!;!",
"  Gravcenter@Rate of fall,Sensitivity=128;,!;!",
"  Gravcentric@Rate of fall,Sensitivity=128;!;!",
"  Gravfreq@Rate of fall,Sensivity=128;,!;!",
"  DJ Light@Speed;;",
"  2D Funky Plank@Scroll speed,,# of bands;;",
"  2D CenterBars@Bar speed=250,Ripple decay=250,Center  =192,Center  =192, Color  =192;,,Peak Color;!=11",
"2D Pulser@Speed,Blur;;!",
"  Blurz@Fade rate,Blur amount;,Color mix;!",
"2D Drift@Rotation speed,Blur amount;;!",
"  2D Waverly@Amplification,Sensitivity=64;;!",
"2D Sun Radiation@Variance,Brightness;;",
"2D Colored Bursts@Speed,Number of lines;;!",
"2D Julia@,Max iterations per pixel,X center,Y center,Area size;;!",
"Reserved for PoolNoise",
"Reserved for Twister",
"Reserved for Elementary",
"2D Game Of Life@!,Use Palette ;!,!;!",
"2D Tartan@X scale,Y scale;;!",
"2D Polar Lights@Speed,X scale,Palette;;",
"  2D Swirl@!,Sensitivity=64,Blur;,Bg Swirl;!",
"2D Lissajous@X frequency=64,Fadetime,,,Speed;;!",
"2D Frizzles@X frequency,Y frequency;;!",
"2D Plasma Ball@Speed;;!",
"Flow Stripe@Hue speed,Effect speed;;",
"2D Hiphotic@X scale,Y scale;;!",
"2D Sindots@Speed,Dot distance;;!",
"2D DNA Spiral@Speed,Frequency;;!",
"2D Black Hole@Outer X frequency,Inner X frequency,Inner Y frequency;;",
"Wavesins@Speed,Brightness variation,Starting Color,Range of Colors,Color variation;;!",
"  Rocktaves@;,!;!",
"  2D Akemi@Color speed,Dance ;Head palette,Arms & Legs,Eyes & Mouth;Face palette",
"  ARTI-FX@Speed,Intensity,Custom 1, Custom 2, Custom 3;!;!",
"3D Ripples@Speed=128,Interval=128;!;!",
"3D Sphere Move@Speed=128,Interval=128;!;!",
"  audio Popcorn@Gravity=128,Intensity=200;!;!",
"  audio Comets@Speed=228,Intensity=240;!;!",
"  audio Fw Starburst@Speed=128,Intensity=128;!;!",
"  beat Palette@Speed=164;!;!",
"  audio Fireworks@Intensity=96;!;!"
])=====";

//WLEDSR: second part (not SR specific, but in latest SR, not in AC (Pallettes added in WLEDSR from Retro Clown->END))
const char JSON_palette_names[] PROGMEM = R"=====([
"Default","* Random Cycle","* Color 1","* Colors 1&2","* Color Gradient","* Colors Only","Party","Cloud","Lava","Ocean",
"Forest","Rainbow","Rainbow Bands","Sunset","Rivendell","Breeze","Red & Blue","Yellowout","Analogous","Splash",
"Pastel","Sunset 2","Beech","Vintage","Departure","Landscape","Beach","Sherbet","Hult","Hult 64",
"Drywet","Jul","Grintage","Rewhi","Tertiary","Fire","Icefire","Cyane","Light Pink","Autumn",
"Magenta","Magred","Yelmag","Yelblu","Orange & Teal","Tiamat","April Night","Orangery","C9","Sakura",
"Aurora","Atlantica","C9 2","C9 New","Temperature","Aurora 2","Retro Clown","Candy","Toxy Reaf","Fairy Reaf",
"Semi Blue","Pink Candy","Red Reaf","Aqua Flash","Yelblu Hot","Lite Light","Red Flash","Blink Red","Red Shift","Red Tide",
"Candy2","Audio Responsive Ratio","Audio Responsive Hue"
])=====";

#endif

=== ./FX_fcn.cpp ===

/*
  WS2812FX_fcn.cpp contains all utility functions
  Harm Aldick - 2016
  www.aldick.org
  LICENSE
  The MIT License (MIT)
  Copyright (c) 2016  Harm Aldick
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.

  Modified heavily for WLED
*/
#include "wled.h"
#include "FX.h"
#include "palettes.h"

/*
  Custom per-LED mapping has moved!

  Create a file "ledmap.json" using the edit page.

  this is just an example (30 LEDs). It will first set all even, then all uneven LEDs.
  {"map":[
  0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28,
  1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29]}

  another example. Switches direction every 5 LEDs.
  {"map":[
  0, 1, 2, 3, 4, 9, 8, 7, 6, 5, 10, 11, 12, 13, 14,
  19, 18, 17, 16, 15, 20, 21, 22, 23, 24, 29, 28, 27, 26, 25]}
*/

//factory defaults LED setup
//#define PIXEL_COUNTS 30, 30, 30, 30
//#define DATA_PINS 16, 1, 3, 4
//#define DEFAULT_LED_TYPE TYPE_WS2812_RGB

#ifndef PIXEL_COUNTS
  #define PIXEL_COUNTS DEFAULT_LED_COUNT
#endif

#ifndef DATA_PINS
  #define DATA_PINS LEDPIN
#endif

#ifndef DEFAULT_LED_TYPE
  #define DEFAULT_LED_TYPE TYPE_WS2812_RGB
#endif

#ifndef DEFAULT_LED_COLOR_ORDER
  #define DEFAULT_LED_COLOR_ORDER COL_ORDER_GRB  //default to GRB
#endif


#if MAX_NUM_SEGMENTS < WLED_MAX_BUSSES
  #error "Max segments must be at least max number of busses!"
#endif

//do not call this method from system context (network callback)
void WS2812FX::finalizeInit(void)
{
  //reset segment runtimes
  for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++) {
    _segment_runtimes[i].markForReset();
    _segment_runtimes[i].resetIfRequired();
  }

  _hasWhiteChannel = _isOffRefreshRequired = false;

  //if busses failed to load, add default (fresh install, FS issue, ...)
  if (busses.getNumBusses() == 0) {
    DEBUG_PRINTLN(F("No busses, init default"));
    const uint8_t defDataPins[] = {DATA_PINS};
    const uint16_t defCounts[] = {PIXEL_COUNTS};
    const uint8_t defNumBusses = ((sizeof defDataPins) / (sizeof defDataPins[0]));
    const uint8_t defNumCounts = ((sizeof defCounts)   / (sizeof defCounts[0]));
    uint16_t prevLen = 0;
    for (uint8_t i = 0; i < defNumBusses && i < WLED_MAX_BUSSES; i++) {
      uint8_t defPin[] = {defDataPins[i]};
      uint16_t start = prevLen;
      uint16_t count = defCounts[(i < defNumCounts) ? i : defNumCounts -1];
      prevLen += count;
      BusConfig defCfg = BusConfig(DEFAULT_LED_TYPE, defPin, start, count, DEFAULT_LED_COLOR_ORDER);
      busses.add(defCfg);
    }
  }

  _length = 0;
  for (uint8_t i=0; i<busses.getNumBusses(); i++) {
    Bus *bus = busses.getBus(i);
    if (bus == nullptr) continue;
    if (bus->getStart() + bus->getLength() > MAX_LEDS) break;
    //RGBW mode is enabled if at least one of the strips is RGBW
    _hasWhiteChannel |= bus->isRgbw();
    //refresh is required to remain off if at least one of the strips requires the refresh.
    _isOffRefreshRequired |= bus->isOffRefreshRequired();
    uint16_t busEnd = bus->getStart() + bus->getLength();
    if (busEnd > _length) _length = busEnd;
    #ifdef ESP8266
    if ((!IS_DIGITAL(bus->getType()) || IS_2PIN(bus->getType()))) continue;
    uint8_t pins[5];
    if (!bus->getPins(pins)) continue;
    BusDigital* bd = static_cast<BusDigital*>(bus);
    if (pins[0] == 3) bd->reinit();
    #endif
  }

  setStripOrPanelWidthAndHeight();
  set2DSegment(0); // ewowi20210629: initialize 2D segment variables

  //segments are created in makeAutoSegments();

  setBrightness(_brightness);
}

void WS2812FX::service() {
  uint32_t nowUp = millis(); // Be aware, millis() rolls over every 49 days
  now = nowUp + timebase;
  if (nowUp - _lastShow < MIN_SHOW_DELAY) return;
  bool doShow = false;

  for(uint8_t i=0; i < MAX_NUM_SEGMENTS; i++)
  {
    //if (realtimeMode && useMainSegmentOnly && i == getMainSegmentId()) continue;

    _segment_index = i;

    // reset the segment runtime data if needed, called before isActive to ensure deleted
    // segment's buffers are cleared
    SEGENV.resetIfRequired();

    if (!SEGMENT.isActive()) continue;

    // last condition ensures all solid segments are updated at the same time
    if(nowUp > SEGENV.next_time || _triggered || (doShow && SEGMENT.mode == 0))
    {
      if (SEGMENT.grouping == 0) SEGMENT.grouping = 1; //sanity check
      doShow = true;
      uint16_t delay = FRAMETIME;

      if (!SEGMENT.getOption(SEG_OPTION_FREEZE)) { //only run effect function if not frozen
        _virtualSegmentLength = SEGMENT.virtualLength();
        _bri_t = SEGMENT.opacity; _colors_t[0] = SEGMENT.colors[0]; _colors_t[1] = SEGMENT.colors[1]; _colors_t[2] = SEGMENT.colors[2];
        uint8_t _cct_t = SEGMENT.cct;
        if (!IS_SEGMENT_ON) _bri_t = 0;
        for (uint8_t t = 0; t < MAX_NUM_TRANSITIONS; t++) {
          if ((transitions[t].segment & 0x3F) != i) continue;
          uint8_t slot = transitions[t].segment >> 6;
          if (slot == 0) _bri_t = transitions[t].currentBri();
          if (slot == 1) _cct_t = transitions[t].currentBri(false, 1);
          _colors_t[slot] = transitions[t].currentColor(SEGMENT.colors[slot]);
        }
        if (!cctFromRgb || correctWB) busses.setSegmentCCT(_cct_t, correctWB);
        for (uint8_t c = 0; c < NUM_COLORS; c++) {
          _colors_t[c] = gamma32(_colors_t[c]);
        }
        handle_palette();
        //WLEDSR: swap width and height if rotated  // softhack first check for stop >= start, to avoid underflow
        if (IS_ROTATED2D && stripOrMatrixPanel == 1) {//matrix
          SEGMENT.height = (SEGMENT.stopX >= SEGMENT.startX) ? (SEGMENT.stopX - SEGMENT.startX + 1) : 0;
          SEGMENT.width  = (SEGMENT.stopY >= SEGMENT.startY) ? (SEGMENT.stopY - SEGMENT.startY + 1) : 0;
        }
        else {
          SEGMENT.width  = (SEGMENT.stopX >= SEGMENT.startX) ? (SEGMENT.stopX - SEGMENT.startX + 1) : 0;
          SEGMENT.height = (SEGMENT.stopY >= SEGMENT.startY) ? (SEGMENT.stopY - SEGMENT.startY + 1) : 0;
        }
        if (_mode[SEGMENT.mode] != nullptr)
          delay = (this->*_mode[SEGMENT.mode])(); //effect function
        else
          delay = (this->*_mode[FX_MODE_BLINK])(); //WLEDSR: blink if mode has not been activated

        // if segment is not RGB capable, force None auto white mode
        // If not RGB capable, also treat palette as if default (0), as palettes set white channel to 0
        _no_rgb = !(SEGMENT.getLightCapabilities() & 0x01);
        if (_no_rgb) Bus::setAutoWhiteMode(RGBW_MODE_MANUAL_ONLY);
        delay = (this->*_mode[SEGMENT.mode])(); //effect function
        if (SEGMENT.mode != FX_MODE_HALLOWEEN_EYES) SEGENV.call++;
        Bus::setAutoWhiteMode(strip.autoWhiteMode);
      }

      SEGENV.next_time = nowUp + delay;
    }
  }
  _virtualSegmentLength = 0;
  busses.setSegmentCCT(-1);
  if(doShow) {
    yield();
    show();
  }
  _triggered = false;
}

// WLEDSR used to map from segment index to logical pixel, taking into account grouping, offsets, reverse and mirroring
uint16_t IRAM_ATTR WS2812FX::segmentToLogical(uint16_t i) { // ewowi20210703: will not map to physical pixel index but to rotated and mirrored logical pixel index as matrix panels will require mapping.
                                                // Mapping is done in logicalToPhysical below. 
  int16_t iGroup = i * SEGMENT.groupLength();

  /* reverse just an individual segment */
  int16_t logicalIndex = iGroup;
  if (IS_REVERSE && stripOrMatrixPanel != 1) { // in case of 1D or 3D
    if (IS_MIRROR) {
      logicalIndex = (SEGMENT.length() -1) / 2 - iGroup;  // only need to index half the pixels
    } else {
      logicalIndex = (SEGMENT.length() - 1) - iGroup;
    }
  }

  // segment index to segment XY
  uint16_t x = logicalIndex;
  uint16_t y = 0;
  if (SEGMENT.width) { // ewowi20210624: in case of 2D: index needs to be mapped from segment index to matrix index. Also works for 1D strips
                        // need to check SEGMENT.width as it looks like Peek is using segment 15 with Width=0
    x = logicalIndex % SEGMENT.width;
    y = logicalIndex / SEGMENT.width;
  }

  // ewowi20210703: apply rotation, mirrorX and mirrorY.
  uint16_t newX=x;
  uint16_t newY=y;

  if (stripOrMatrixPanel == 1) // in case of 2D
  {
    if (!IS_ROTATED2D) {
      if (!IS_REVERSE && !IS_REVERSE2D) { newX = x; newY = y; }                                               // 000      -       -           -         (rotate 0)
      else if (!IS_REVERSE && IS_REVERSE2D) { newX = x; newY = SEGMENT.height - 1 - y; }                      // 001      -       -           MirrorY   (rotate 180+MirrorX)
      else if (IS_REVERSE && !IS_REVERSE2D) { newX = SEGMENT.width - 1 - x; newY = y; }                       // 010      -       MirrorX     -         (rotate 0 + MirrorX)
      else if (IS_REVERSE && IS_REVERSE2D) { newX = SEGMENT.width - 1 - x; newY = SEGMENT.height - 1 - y; }   // 011      -       MirrorX     MirrorY   (rotate 180)
    }
    else {
      if (!IS_REVERSE && !IS_REVERSE2D) { newX = SEGMENT.height - 1 - y; newY = x; }                          // 100      90      -           -         (rotate 90)
      else if (!IS_REVERSE && IS_REVERSE2D) { newX = SEGMENT.height - 1 - y; newY = SEGMENT.width - 1 - x; }  // 101      90      -           MirrorY   (rotate 270 + mirrorX)
      else if (IS_REVERSE && !IS_REVERSE2D) { newX = y; newY = x;  }                                          // 110      90      MirrorX     -         (rotate 90 + mirrorX)
      else if (IS_REVERSE && IS_REVERSE2D) { newX = y; newY = SEGMENT.width - 1 - x; }                        // 111      90      MirrorX     MirrorY   (rotate 270)
    }
  }

  // segment XY to rotated and mirrored logical index
  logicalIndex = newX + SEGMENT.startX + (newY + SEGMENT.startY) * matrixWidth;

  return logicalIndex;
}

void IRAM_ATTR WS2812FX::setPixelColor(int i, byte r, byte g, byte b, byte w)
{
  uint8_t segIdx;

  //if ((i<0) || (i>=SEGMENT.virtualLength())) return;  // if pixel would fall out of segment just exit - some effects, like bouncing balls, get negative values resulting at i =  maxint - something
  // softhack007: full check disabled, as it seems to cause problems with DDP
  if (i<0) return;  // some effects, like bouncing balls, produce negative values

  if (SEGLEN) { // SEGLEN!=0 -> from segment/FX
    //color_blend(getpixel, col, _bri_t); (pseudocode for future blending of segments)
    if (_bri_t < 255) {
      r = scale8(r, _bri_t);
      g = scale8(g, _bri_t);
      b = scale8(b, _bri_t);
      w = scale8(w, _bri_t);
    }
    segIdx = _segment_index;
  } else // from live/realtime
    segIdx = _mainSegment;

  if (SEGLEN || (realtimeMode && useMainSegmentOnly)) {
    uint32_t col = RGBW32(r, g, b, w);
    uint16_t len = _segments[segIdx].length();
    uint16_t logicalIndex = segmentToLogical(i); // ewowi20210624: from segment index to logical index

    // get physical pixel address (taking into account start, grouping, spacing [and offset])
    i = i * _segments[segIdx].groupLength();
    if (_segments[segIdx].options & REVERSE) { // is segment reversed?
      if (_segments[segIdx].options & MIRROR) { // is segment mirrored?
        i = (len - 1) / 2 - i;  //only need to index half the pixels
      } else {
        i = (len - 1) - i;
      }
    }
    i += _segments[segIdx].start;

    /* Set all the pixels in the group */
    for (uint_fast16_t j = 0; j < SEGMENT.grouping; j++) {
      int indexSet = logicalIndex + (IS_REVERSE ? -j : j);
      if (indexSet >= SEGMENT.start && indexSet < SEGMENT.stop) {
        if (IS_MIRROR) { // set the corresponding mirrored pixel
          int indexMir = SEGMENT.stop - indexSet + SEGMENT.start - 1;
          /* offset/phase */
          indexMir += SEGMENT.offset;
          if (indexMir >= SEGMENT.stop) indexMir -= len;
          if (indexMir < SEGMENT.start) indexMir += len; // softhack007: wrap around on both sides

          if (indexMir >= _segments[segIdx].stop) indexMir -= len;
          if (indexMir < customMappingSize) indexMir = customMappingTable[indexMir];
          //busses.setPixelColor(logicalToPhysical(indexSet), col); // softhack007: wrong pixel position, and not needed here
          busses.setPixelColor(logicalToPhysical(indexMir), col); // ewowi20210624: logicalToPhysical: Maps logical led index to physical led index.
        }
        indexSet += _segments[segIdx].offset; // offset/phase
        if ((SEGMENT.stop > 0) && (indexSet >= SEGMENT.stop)) indexSet -= len;     // softhack007: wrap around when offset != 0  (stop == 0 means "segment invalid")

        if (indexSet < customMappingSize) indexSet = customMappingTable[indexSet]; // This line is also on L292
        busses.setPixelColor(logicalToPhysical(indexSet), col);
      }
    }
  } else {
    if (i < customMappingSize) i = customMappingTable[i];
    // busses.setPixelColor(i, RGBW32(r, g, b, w));
    busses.setPixelColor(logicalToPhysical(i), RGBW32(r, g, b, w)); // ewowi20210624: logicalToPhysical: Maps logical led index to physical led index.
  }
}


// DISCLAIMER
// The following function attemps to calculate the current LED power usage,
// and will limit the brightness to stay below a set amperage threshold.
// It is NOT a measurement and NOT guaranteed to stay within the ablMilliampsMax margin.
// Stay safe with high amperage and have a reasonable safety margin!
// I am NOT to be held liable for burned down garages!

// fine tune power estimation constants for your setup
#define MA_FOR_ESP        100 // how much mA does the ESP use (Wemos D1 about 80mA, ESP32 about 120mA)
                              // you can set it to 0 if the ESP is powered by USB and the LEDs by external

void WS2812FX::estimateCurrentAndLimitBri() {
  //power limit calculation
  //each LED can draw up 195075 "power units" (approx. 53mA)
  //one PU is the power it takes to have 1 channel 1 step brighter per brightness step
  //so A=2,R=255,G=0,B=0 would use 510 PU per LED (1mA is about 3700 PU)
  bool useWackyWS2815PowerModel = false;
  byte actualMilliampsPerLed = milliampsPerLed;

  if(milliampsPerLed == 255) {
    useWackyWS2815PowerModel = true;
    actualMilliampsPerLed = 12; // from testing an actual strip
  }

  if (ablMilliampsMax < 150 || actualMilliampsPerLed == 0) { //0 mA per LED and too low numbers turn off calculation
    currentMilliamps = 0;
    busses.setBrightness(_brightness);
    return;
  }

  uint16_t pLen = getLengthPhysical();
  uint32_t puPerMilliamp = 195075 / actualMilliampsPerLed;
  uint32_t powerBudget = (ablMilliampsMax - MA_FOR_ESP) * puPerMilliamp; //100mA for ESP power
  if (powerBudget > puPerMilliamp * pLen) { //each LED uses about 1mA in standby, exclude that from power budget
    powerBudget -= puPerMilliamp * pLen;
  } else {
    powerBudget = 0;
  }

  uint32_t powerSum = 0;

  for (uint8_t b = 0; b < busses.getNumBusses(); b++) {
    Bus *bus = busses.getBus(b);
    if (bus->getType() >= TYPE_NET_DDP_RGB) continue; //exclude non-physical network busses
    uint16_t len = bus->getLength();
    uint32_t busPowerSum = 0;
    for (uint16_t i = 0; i < len; i++) { //sum up the usage of each LED
      uint32_t c = bus->getPixelColor(i);
      byte r = R(c), g = G(c), b = B(c), w = W(c);

      if(useWackyWS2815PowerModel) { //ignore white component on WS2815 power calculation
        busPowerSum += (MAX(MAX(r,g),b)) * 3;
      } else {
        busPowerSum += (r + g + b + w);
      }
    }

    if (bus->isRgbw()) { //RGBW led total output with white LEDs enabled is still 50mA, so each channel uses less
      busPowerSum *= 3;
      busPowerSum = busPowerSum >> 2; //same as /= 4
    }
    powerSum += busPowerSum;
  }

  uint32_t powerSum0 = powerSum;
  powerSum *= _brightness;

  if (powerSum > powerBudget) //scale brightness down to stay in current limit
  {
    float scale = (float)powerBudget / (float)powerSum;
    uint16_t scaleI = scale * 255;
    uint8_t scaleB = (scaleI > 255) ? 255 : scaleI;
    uint8_t newBri = scale8(_brightness, scaleB);
    busses.setBrightness(newBri); //to keep brightness uniform, sets virtual busses too
    currentMilliamps = (powerSum0 * newBri) / puPerMilliamp;
  } else {
    currentMilliamps = powerSum / puPerMilliamp;
    busses.setBrightness(_brightness);
  }
  currentMilliamps += MA_FOR_ESP; //add power of ESP back to estimate
  currentMilliamps += pLen; //add standby power back to estimate
}

void WS2812FX::show(void) {

  // avoid race condition, caputre _callback value
  show_callback callback = _callback;
  if (callback) callback();

  estimateCurrentAndLimitBri();

  // some buses send asynchronously and this method will return before
  // all of the data has been sent.
  // See https://github.com/Makuna/NeoPixelBus/wiki/ESP32-NeoMethods#neoesp32rmt-methods
  busses.show();
  unsigned long now = millis();
  unsigned long diff = now - _lastShow;
  uint16_t fpsCurr = 200;
  if (diff > 0) fpsCurr = 1000 / diff;
  _cumulativeFps = (3 * _cumulativeFps + fpsCurr +2) >> 2;   // "+2" for proper rounding (2/4 = 0.5)
  _lastShow = now;
}

/**
 * Returns a true value if any of the strips are still being updated.
 * On some hardware (ESP32), strip updates are done asynchronously.
 */
bool WS2812FX::isUpdating() {
  return !busses.canAllShow();
}

/**
 * Returns the refresh rate of the LED strip. Useful for finding out whether a given setup is fast enough.
 * Only updates on show() or is set to 0 fps if last show is more than 2 secs ago, so accurary varies
 */
uint16_t WS2812FX::getFps() {
  if (millis() - _lastShow > 2000) return 0;
  return _cumulativeFps +1;
}

uint8_t WS2812FX::getTargetFps() {
	return _targetFps;
}

void WS2812FX::setTargetFps(uint8_t fps) {
	if (fps > 0 && fps <= 250) _targetFps = fps; // WLEDSR accept up to 250 fps target
	_frametime = 1000 / _targetFps;
  if (_frametime < 2) _frametime = 2; // WLEDSR 
}

// Fixes private class variable compiler error. Unsure if this is the correct way of fixing the root problem. -THATDONFC
uint16_t WS2812FX::getMinShowDelay() {
  return MIN_SHOW_DELAY;
}

/**
 * Forces the next frame to be computed on all active segments.
 */
void WS2812FX::trigger() {
  _triggered = true;
}

void WS2812FX::setMode(uint8_t segid, uint8_t m) {
  if (segid >= MAX_NUM_SEGMENTS) return;

  if (m >= MODE_COUNT) m = MODE_COUNT - 1;

  // WLEDSR: check that mode is valid
  char lineBuffer[12] = { '\0' };
  extractModeName(m, JSON_mode_names, lineBuffer, 11);
  if(strncmp_P("Reserved", lineBuffer, 8) == 0) {
      DEBUG_PRINTF("setMode: invalid mode %d\n", m);
      m = FX_MODE_RANDOM_COLOR;
  }
  // WLEDSR end

  if (_segments[segid].mode != m)
  {
    _segment_runtimes[segid].markForReset();
    _segments[segid].mode = m;
  }
}

uint8_t WS2812FX::getModeCount()
{
  return MODE_COUNT;
}

uint8_t WS2812FX::getPaletteCount()
{
  return 13 + GRADIENT_PALETTE_COUNT;
}

// REMOVED IN 7b969bb
/* //TODO effect transitions

bool WS2812FX::setEffectConfig(uint8_t m, uint8_t s, uint8_t in, uint8_t c1, uint8_t c2, uint8_t c3, uint8_t p) {
  Segment& seg = _segments[getMainSegmentId()];
  uint8_t modePrev = seg.mode, speedPrev = seg.speed, intensityPrev = seg.intensity, custom1Prev = seg.custom1, custom2Prev = seg.custom2, custom3Prev = seg.custom3, palettePrev = seg.palette;

  bool applied = false;

  if (applyToAllSelected) {
    for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++)
    {
      if (_segments[i].isSelected())
      {
        _segments[i].speed = s;
        _segments[i].intensity = in;
        _segments[i].custom1 = c1;
        _segments[i].custom2 = c2;
        _segments[i].custom3 = c3;
        _segments[i].palette = p;
        setMode(i, m);
        applied = true;
      }
    }
  }

  if (!applyToAllSelected || !applied) {
    seg.speed = s;
    seg.intensity = in;
    seg.custom1 = c1;
    seg.custom2 = c2;
    seg.custom3 = c3;
    seg.palette = p;
    setMode(mainSegment, m);
  }

  if (seg.mode != modePrev || seg.speed != speedPrev || seg.intensity != intensityPrev || seg.custom1 != custom1Prev || seg.custom2 != custom2Prev || seg.custom3 != custom3Prev || seg.palette != palettePrev) return true;
  return false;
} */

void WS2812FX::setColor(uint8_t slot, uint8_t r, uint8_t g, uint8_t b, uint8_t w) {
  setColor(slot, RGBW32(r, g, b, w));
}

//applies to all active and selected segments
void WS2812FX::setColor(uint8_t slot, uint32_t c) {
  if (slot >= NUM_COLORS) return;

  for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++)
  {
    if (_segments[i].isActive() && _segments[i].isSelected()) {
      _segments[i].setColor(slot, c, i);
    }
  }
}

void WS2812FX::setCCT(uint16_t k) {
  for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++)
  {
    if (_segments[i].isActive() && _segments[i].isSelected()) {
      _segments[i].setCCT(k, i);
    }
  }
}

void WS2812FX::setBrightness(uint8_t b, bool direct) {
  if (gammaCorrectBri) b = gamma8(b);
  if (_brightness == b) return;
  _brightness = b;
  if (_brightness == 0) { //unfreeze all segments on power off
    for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++)
    {
      _segments[i].setOption(SEG_OPTION_FREEZE, false);
    }
  }
  if (direct) {
    // would be dangerous if applied immediately (could exceed ABL), but will not output until the next show()
    busses.setBrightness(b);
  } else {
	  unsigned long t = millis();
    if (_segment_runtimes[0].next_time > t + 22 && t - _lastShow > MIN_SHOW_DELAY) show(); //apply brightness change immediately if no refresh soon
  }
}

uint8_t WS2812FX::getBrightness(void) {
  return _brightness;
}

uint8_t WS2812FX::getMaxSegments(void) {
  return MAX_NUM_SEGMENTS;
}

uint8_t WS2812FX::getFirstSelectedSegId(void)
{
  for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++)
  {
    if (_segments[i].isActive() && _segments[i].isSelected()) return i;
  }
  // if none selected, use the main segment
  return getMainSegmentId();
}

void WS2812FX::setMainSegmentId(uint8_t n) {
  if (n >= MAX_NUM_SEGMENTS) return;
  //use supplied n if active, or first active
  if (_segments[n].isActive()) {
    _mainSegment = n; return;
  }
  for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++)
  {
    if (_segments[i].isActive()) {
      _mainSegment = i; return;
    }
  }
  _mainSegment = 0;
  return;
}

uint8_t WS2812FX::getMainSegmentId(void) {
  return _mainSegment;
}

uint8_t WS2812FX::getLastActiveSegmentId(void) {
  for (uint8_t i = MAX_NUM_SEGMENTS -1; i > 0; i--) {
    if (_segments[i].isActive()) return i;
  }
  return 0;
}

uint8_t WS2812FX::getActiveSegmentsNum(void) {
  uint8_t c = 0;
  for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++)
  {
    if (_segments[i].isActive()) c++;
  }
  return c;
}

uint32_t WS2812FX::getPixelColor(uint16_t i)
{
  // get physical pixel
  i = i * SEGMENT.groupLength();;
  if (IS_REVERSE) {
    if (IS_MIRROR) i = (SEGMENT.length() - 1) / 2 - i;  //only need to index half the pixels
    else           i = (SEGMENT.length() - 1) - i;
  }
  i += SEGMENT.start;

  if (SEGLEN) {
    /* offset/phase */
    i += SEGMENT.offset;
    if (i >= SEGMENT.stop) i -= SEGMENT.length();
  }

  if (i < customMappingSize) i = customMappingTable[i];
  if (i >= _length) return 0;

  return busses.getPixelColor(logicalToPhysical(i)); // ewowi20210624: logicalToPhysical: Maps logical led index to physical led index.
}

WS2812FX::Segment& WS2812FX::getSegment(uint8_t id) {
  if (id >= MAX_NUM_SEGMENTS) return _segments[getMainSegmentId()];
  return _segments[id];
}

WS2812FX::Segment& WS2812FX::getFirstSelectedSeg(void) {
  return _segments[getFirstSelectedSegId()];
}

WS2812FX::Segment& WS2812FX::getMainSegment(void) {
  return _segments[getMainSegmentId()];
}

WS2812FX::Segment* WS2812FX::getSegments(void) {
  return _segments;
}

uint32_t WS2812FX::getLastShow(void) {
  return _lastShow;
}

uint16_t WS2812FX::getLengthTotal(void) {
  return _length;
}

uint16_t WS2812FX::getLengthPhysical(void) {
  uint16_t len = 0;
  for (uint8_t b = 0; b < busses.getNumBusses(); b++) {
    Bus *bus = busses.getBus(b);
    if (bus->getType() >= TYPE_NET_DDP_RGB) continue; //exclude non-physical network busses
    len += bus->getLength();
  }
  return len;
}

uint8_t WS2812FX::Segment::differs(Segment& b) {
  uint8_t d = 0;
  if (start != b.start)         d |= SEG_DIFFERS_BOUNDS;
  if (stop != b.stop)           d |= SEG_DIFFERS_BOUNDS;
  if (offset != b.offset)       d |= SEG_DIFFERS_GSO;
  if (grouping != b.grouping)   d |= SEG_DIFFERS_GSO;
  if (spacing != b.spacing)     d |= SEG_DIFFERS_GSO;
  if (opacity != b.opacity)     d |= SEG_DIFFERS_BRI;
  if (mode != b.mode)           d |= SEG_DIFFERS_FX;
  if (speed != b.speed)         d |= SEG_DIFFERS_FX;
  if (intensity != b.intensity) d |= SEG_DIFFERS_FX;
  if (palette != b.palette)     d |= SEG_DIFFERS_FX;

  if ((options & 0b00101110) != (b.options & 0b00101110)) d |= SEG_DIFFERS_OPT;
  if ((options & 0x01) != (b.options & 0x01)) d |= SEG_DIFFERS_SEL;
  for (uint8_t i = 0; i < NUM_COLORS; i++)
  {
    if (colors[i] != b.colors[i]) d |= SEG_DIFFERS_COL;
  }

  return d;
}

void WS2812FX::Segment::refreshLightCapabilities() {
  if (!isActive()) {
    _capabilities = 0; return;
  }
  uint8_t capabilities = 0;
  uint8_t awm = instance->autoWhiteMode;
  bool whiteSlider = (awm == RGBW_MODE_DUAL || awm == RGBW_MODE_MANUAL_ONLY);
  bool segHasValidBus = false;

  for (uint8_t b = 0; b < busses.getNumBusses(); b++) {
    Bus *bus = busses.getBus(b);
    if (bus == nullptr || bus->getLength()==0) break;
    if (bus->getStart() >= stop) continue;
    if (bus->getStart() + bus->getLength() <= start) continue;

    segHasValidBus = true;
    uint8_t type = bus->getType();
    if (type != TYPE_ANALOG_1CH && (cctFromRgb || type != TYPE_ANALOG_2CH))
    {
      capabilities |= 0x01; // segment supports RGB (full color)
    }
    if (bus->isRgbw() && whiteSlider) capabilities |= 0x02; // segment supports white channel
    if (!cctFromRgb) {
      switch (type) {
        case TYPE_ANALOG_5CH:
        case TYPE_ANALOG_2CH:
          capabilities |= 0x04; //segment supports white CCT
      }
    }
    if (correctWB && type != TYPE_ANALOG_1CH) capabilities |= 0x04; //white balance correction (uses CCT slider)
  }
  // if seg has any bus, but no bus has RGB, it by definition supports white (at least for now)
  // In case of no RGB, disregard auto white mode and always show a white slider
  if (segHasValidBus && !(capabilities & 0x01)) capabilities |= 0x02; // segment supports white channel
  _capabilities = capabilities;
}

//used for JSON API info.leds.rgbw. Little practical use, deprecate with info.leds.rgbw.
//returns if there is an RGBW bus (supports RGB and White, not only white)
//not influenced by auto-white mode, also true if white slider does not affect output white channel
bool WS2812FX::hasRGBWBus(void) {
	for (uint8_t b = 0; b < busses.getNumBusses(); b++) {
    Bus *bus = busses.getBus(b);
    if (bus == nullptr || bus->getLength()==0) break;
    switch (bus->getType()) {
      case TYPE_SK6812_RGBW:
      case TYPE_TM1814:
      case TYPE_ANALOG_4CH:
        return true;
    }
  }
	return false;
}

// WLEDSR: calculate 2D segment variables using start/stop of segment using the x/y coordinnates of start and stop to determine topleft (startX/Y) and bottomright (stopXY) of the segment
void WS2812FX::set2DSegment(uint8_t n) {
  Segment& seg = _segments[n];

  uint16_t startX = seg.start%matrixWidth;
  uint16_t startY= matrixWidth?(seg.start / matrixWidth):0;
  uint16_t stopX = (seg.stop-1)%matrixWidth;
  uint16_t stopY= matrixWidth?((seg.stop-1) / matrixWidth):0;
  seg.startX = MIN(startX, stopX);
  seg.startY= MIN(startY, stopY);
  seg.stopX = MAX(startX, stopX);
  seg.stopY= MAX(startY, stopY);
}

//WLEDSR, for strips we need ledCountx1 dimension
void WS2812FX::setStripOrPanelWidthAndHeight() {
  if (stripOrMatrixPanel != 1) { //strip or 3D cube
    // ledCount was removed, replaced by strip.getLengthTotal()
    matrixWidth = strip.getLengthTotal();
    matrixHeight = 1;

    //following code commented, in case we need it in the future
    // uint8_t deltaLedCount = 0;
    // bool found = false;
    // while (!found && deltaLedCount < 10) {
    //   uint16_t width = ledCount;
    //   uint16_t height = 1;
    //   // matrixWidth = width;
    //   // matrixHeight = height;
    //   uint16_t deltaHeightWidth = -1;
    //   // Serial.printf("A lc=%d: %d x %d = %d (deltaHW %d, deltaLC %d)", ledCount, width, height, width * height, deltaHeightWidth, deltaLedCount); Serial.println();
    //   while (width > 0 && abs(width - height) < deltaHeightWidth) { // as long as there are width/heights smaller then the current smallest deltaHW
    //     height = (ledCount + deltaLedCount) / width;
    //     if (width * height == ledCount + deltaLedCount) { // if width*height
    //       if (abs(width - height) < deltaHeightWidth) {
    //         deltaHeightWidth = abs(width - height);
    //         if ((ledCount < 16 || (width >= 4 && height >= 4)) && width <= 256 && height <= 256) {
    //           // Serial.printf("B lc=%d: %d x %d = %d (deltaHW %d, deltaLC %d)", ledCount, width, height, width * height, deltaHeightWidth, deltaLedCount); Serial.println();
    //           found = true;
    //           matrixWidth = width;
    //           matrixHeight = height;
    //         }
    //       }
    //     }
    //     width--;
    //   }
    //   deltaLedCount ++;
    // }
    // Serial.printf("C lc=%d: %d x %d = %d (deltaHW %d, deltaLC %d)", ledCount, matrixWidth, matrixHeight, matrixWidth * matrixHeight, abs(matrixWidth - matrixHeight), matrixWidth * matrixHeight - ledCount); Serial.println();

    // panelFirstLedLeftRight = 0; //left
    // panelFirstLedTopBottom = 0; //top
    // panelOrientationHorVert = 0; //horizontal
    // panelSerpentine = 1; //serpentine on
    // panelTranspose = 0; //

  }
}

bool WS2812FX::hasCCTBus(void) {
	if (cctFromRgb && !correctWB) return false;
	for (uint8_t b = 0; b < busses.getNumBusses(); b++) {
    Bus *bus = busses.getBus(b);
    if (bus == nullptr || bus->getLength()==0) break;
    switch (bus->getType()) {
      case TYPE_ANALOG_5CH:
      case TYPE_ANALOG_2CH:
        return true;
    }
  }
	return false;
}

void WS2812FX::setSegment(uint8_t n, uint16_t i1, uint16_t i2, uint8_t grouping, uint8_t spacing, uint16_t offset) {
  if (n >= MAX_NUM_SEGMENTS) return;
  Segment& seg = _segments[n];

  //return if neither bounds nor grouping have changed
  bool boundsUnchanged = (seg.start == i1 && seg.stop == i2);
  if (boundsUnchanged
			&& (!grouping || (seg.grouping == grouping && seg.spacing == spacing))
			&& (offset == UINT16_MAX || offset == seg.offset)) return;

  if (seg.stop) setRange(seg.start, seg.stop -1, 0); // turn old segment range off
  if (i2 <= i1) // disable segment
  {
    seg.stop = 0;
    if (seg.name) {
      delete[] seg.name;
      seg.name = nullptr;
    }
    // if main segment is deleted, set first active as main segment
    if (n == _mainSegment) setMainSegmentId(0);
    return;
  }
  if (i1 < _length) seg.start = i1;
  seg.stop = i2;
  if (i2 > _length) seg.stop = _length;

  set2DSegment(n); // ewowi20210629: initialize 2D segment variables

  if (grouping) {
    seg.grouping = grouping;
    seg.spacing = spacing;
  }
	if (offset < UINT16_MAX) seg.offset = offset;
  _segment_runtimes[n].markForReset();
  if (!boundsUnchanged) seg.refreshLightCapabilities();
}

void WS2812FX::restartRuntime() {
  for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++) {
    _segment_runtimes[i].markForReset();
  }
}

void WS2812FX::setReset(uint8_t n) {
  _segment_runtimes[n].markForReset();
}

void WS2812FX::resetSegments() {
  for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++) if (_segments[i].name) delete[] _segments[i].name;
  _mainSegment = 0;
  memset(_segments, 0, sizeof(_segments));
  //memset(_segment_runtimes, 0, sizeof(_segment_runtimes));
  _segment_index = 0;
  _segments[0].mode = DEFAULT_MODE;
  _segments[0].colors[0] = DEFAULT_COLOR;
  _segments[0].start = 0;
  _segments[0].speed = DEFAULT_SPEED;
  _segments[0].intensity = DEFAULT_INTENSITY;
  _segments[0].stop = _length;
  _segments[0].grouping = 1;
  _segments[0].setOption(SEG_OPTION_SELECTED, 1);
  _segments[0].setOption(SEG_OPTION_ON, 1);
  _segments[0].opacity = 255;
  _segments[0].cct = 127;

  for (uint16_t i = 1; i < MAX_NUM_SEGMENTS; i++)
  {
    _segments[i].colors[0] = color_wheel(i*51);
    _segments[i].grouping = 1;
    _segments[i].setOption(SEG_OPTION_ON, 1);
    _segments[i].opacity = 255;
    _segments[i].cct = 127;
    _segments[i].speed = DEFAULT_SPEED;
    _segments[i].intensity = DEFAULT_INTENSITY;
    _segment_runtimes[i].markForReset();
  }
  _segment_runtimes[0].markForReset();
}

void WS2812FX::makeAutoSegments(bool forceReset) {
  if (autoSegments) { //make one segment per bus
    uint16_t segStarts[MAX_NUM_SEGMENTS] = {0};
    uint16_t segStops [MAX_NUM_SEGMENTS] = {0};
    uint8_t s = 0;
    for (uint8_t i = 0; i < busses.getNumBusses(); i++) {
      Bus* b = busses.getBus(i);

      segStarts[s] = b->getStart();
      segStops[s] = segStarts[s] + b->getLength();

      //check for overlap with previous segments
      for (uint8_t j = 0; j < s; j++) {
        if (segStops[j] > segStarts[s] && segStarts[j] < segStops[s]) {
          //segments overlap, merge
          segStarts[j] = min(segStarts[s],segStarts[j]);
          segStops [j] = max(segStops [s],segStops [j]); segStops[s] = 0;
          s--;
        }
      }
      s++;
    }
    for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++) {
      setSegment(i, segStarts[i], segStops[i]);
    }
  } else {
    //expand the main seg to the entire length, but only if there are no other segments, or reset is forced
    uint8_t mainSeg = getMainSegmentId();

    if (forceReset) {
      for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++) {
        setSegment(i, 0, 0);
      }
    }
    if (getActiveSegmentsNum() < 2) {
      setSegment(mainSeg, 0, _length);
    }
  }

  fixInvalidSegments();
}

void WS2812FX::fixInvalidSegments() {
  //make sure no segment is longer than total (sanity check)
  for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++)
  {
    if (_segments[i].start >= _length) setSegment(i, 0, 0);
    if (_segments[i].stop  >  _length) setSegment(i, _segments[i].start, _length);
    // this is always called as the last step after finalizeInit(), update covered bus types
    getSegment(i).refreshLightCapabilities();
  }
}

//true if all segments align with a bus, or if a segment covers the total length
bool WS2812FX::checkSegmentAlignment() {
  for (uint8_t i = 0; i < MAX_NUM_SEGMENTS; i++)
  {
    if (_segments[i].start >= _segments[i].stop) continue; //inactive segment
    bool aligned = false;
    for (uint8_t b = 0; b<busses.getNumBusses(); b++) {
      Bus *bus = busses.getBus(b);
      if (_segments[i].start == bus->getStart() && _segments[i].stop == bus->getStart() + bus->getLength()) aligned = true;
    }
    if (_segments[i].start == 0 && _segments[i].stop == _length) aligned = true;
    if (!aligned) return false;
  }
  return true;
}

//After this function is called, setPixelColor() will use that segment (offsets, grouping, ... will apply)
//Note: If called in an interrupt (e.g. JSON API), original segment must be restored,
//otherwise it can lead to a crash on ESP32 because _segment_index is modified while in use by the main thread
uint8_t WS2812FX::setPixelSegment(uint8_t n)
{
  uint8_t prevSegId = _segment_index;
  if (n < MAX_NUM_SEGMENTS) {
    _segment_index = n;
    _virtualSegmentLength = SEGMENT.virtualLength();
  }
  return prevSegId;
}

void WS2812FX::setRange(uint16_t i, uint16_t i2, uint32_t col)
{
  if (i2 >= i)
  {
    for (uint16_t x = i; x <= i2; x++) setPixelColor(x, col);
  } else
  {
    for (uint16_t x = i2; x <= i; x++) setPixelColor(x, col);
  }
}

void WS2812FX::setShowCallback(show_callback cb)
{
  _callback = cb;
}

void WS2812FX::setTransition(uint16_t t)
{
  _transitionDur = t;
}

void WS2812FX::setTransitionMode(bool t)
{
	unsigned long waitMax = millis() + 20; //refresh after 20 ms if transition enabled
  for (uint16_t i = 0; i < MAX_NUM_SEGMENTS; i++)
  {
    _segments[i].setOption(SEG_OPTION_TRANSITIONAL, t);

    if (t && _segments[i].mode == FX_MODE_STATIC && _segment_runtimes[i].next_time > waitMax)
			_segment_runtimes[i].next_time = waitMax;
  }
}

/*
 * color blend function
 */
uint32_t IRAM_ATTR WS2812FX::color_blend(uint32_t color1, uint32_t color2, uint16_t blend, bool b16) {
  if(blend == 0)   return color1;
  uint16_t blendmax = b16 ? 0xFFFF : 0xFF;
  if(blend == blendmax) return color2;
  uint8_t shift = b16 ? 16 : 8;

  uint32_t w1 = W(color1);
  uint32_t r1 = R(color1);
  uint32_t g1 = G(color1);
  uint32_t b1 = B(color1);

  uint32_t w2 = W(color2);
  uint32_t r2 = R(color2);
  uint32_t g2 = G(color2);
  uint32_t b2 = B(color2);

  uint32_t w3 = ((w2 * blend) + (w1 * (blendmax - blend))) >> shift;
  uint32_t r3 = ((r2 * blend) + (r1 * (blendmax - blend))) >> shift;
  uint32_t g3 = ((g2 * blend) + (g1 * (blendmax - blend))) >> shift;
  uint32_t b3 = ((b2 * blend) + (b1 * (blendmax - blend))) >> shift;

  return RGBW32(r3, g3, b3, w3);
}

/*
 * Fills segment with color
 */
void WS2812FX::fill(uint32_t c) {
  for(uint_fast16_t i = 0; i < SEGLEN; i++) {
    setPixelColor(i, c);
  }
}

/*
 * Blends the specified color with the existing pixel color.
 */
void WS2812FX::blendPixelColor(uint16_t n, uint32_t color, uint8_t blend)
{
  setPixelColor(n, color_blend(getPixelColor(n), color, blend));
}

/*
 * fade out function, higher rate = quicker fade
 */
void WS2812FX::fade2black(uint8_t rate) {
  uint32_t color;

  //rate = rate >> 1;
  float mappedRate = (float) map(rate, 0, 255, 1, 100) ;

  mappedRate = mappedRate / 100;

  for(uint_fast16_t i = 0; i < SEGLEN; i++) {
    color = getPixelColor(i);
    int w1 = W(color);
    int r1 = R(color);
    int g1 = G(color);
    int b1 = B(color);

    int w = w1 * mappedRate;
    int r = r1 * (mappedRate * 1.05);      // acount for the fact that leds stay red on much lower intensities
    int g = g1 * mappedRate;
    int b = b1 * mappedRate;

    setPixelColor(i, r, g, b, w);
  }
}

/*
 * fade out function, higher rate = quicker fade
 */
void WS2812FX::fade_out(uint8_t rate) {
  rate = (255-rate) >> 1;
  float mappedRate = float(rate) +1.1;

  uint32_t color = SEGCOLOR(1); // target color
  int w2 = W(color);
  int r2 = R(color);
  int g2 = G(color);
  int b2 = B(color);

  for(uint_fast16_t i = 0; i < SEGLEN; i++) {
    color = getPixelColor(i);
    int w1 = W(color);
    int r1 = R(color);
    int g1 = G(color);
    int b1 = B(color);

    int wdelta = (w2 - w1) / mappedRate;
    int rdelta = (r2 - r1) / mappedRate;
    int gdelta = (g2 - g1) / mappedRate;
    int bdelta = (b2 - b1) / mappedRate;

    // if fade isn't complete, make sure delta is at least 1 (fixes rounding issues)
    wdelta += (w2 == w1) ? 0 : (w2 > w1) ? 1 : -1;
    rdelta += (r2 == r1) ? 0 : (r2 > r1) ? 1 : -1;
    gdelta += (g2 == g1) ? 0 : (g2 > g1) ? 1 : -1;
    bdelta += (b2 == b1) ? 0 : (b2 > b1) ? 1 : -1;

    setPixelColor(i, r1 + rdelta, g1 + gdelta, b1 + bdelta, w1 + wdelta);
  }
}

/*
 * blurs segment content, source: FastLED colorutils.cpp
 */
void WS2812FX::blur(uint8_t blur_amount)
{
  uint8_t keep = 255 - blur_amount;
  uint8_t seep = blur_amount >> 1;
  CRGB carryover = CRGB::Black;
  for(uint_fast16_t i = 0; i < SEGLEN; i++)
  {
    CRGB cur = col_to_crgb(getPixelColor(i));
    CRGB part = cur;
    part.nscale8(seep);
    cur.nscale8(keep);
    cur += carryover;
    if(i > 0) {
      uint32_t c = getPixelColor(i-1);
      uint8_t r = R(c);
      uint8_t g = G(c);
      uint8_t b = B(c);
      setPixelColor(i-1, qadd8(r, part.red), qadd8(g, part.green), qadd8(b, part.blue));
    }
    setPixelColor(i,cur.red, cur.green, cur.blue);
    carryover = part;
  }
}

uint16_t IRAM_ATTR WS2812FX::triwave16(uint16_t in)
{
  if (in < 0x8000) return in *2;
  return 0xFFFF - (in - 0x8000)*2;
}

/*
 * Generates a tristate square wave w/ attac & decay
 * @param x input value 0-255
 * @param pulsewidth 0-127
 * @param attdec attac & decay, max. pulsewidth / 2
 * @returns signed waveform value
 */
int8_t WS2812FX::tristate_square8(uint8_t x, uint8_t pulsewidth, uint8_t attdec) {
  int8_t a = 127;
  if (x > 127) {
    a = -127;
    x -= 127;
  }

  if (x < attdec) { //inc to max
    return (int16_t) x * a / attdec;
  }
  else if (x < pulsewidth - attdec) { //max
    return a;
  }
  else if (x < pulsewidth) { //dec to 0
    return (int16_t) (pulsewidth - x) * a / attdec;
  }
  return 0;
}

/*
 * Put a value 0 to 255 in to get a color value.
 * The colours are a transition r -> g -> b -> back to r
 * Inspired by the Adafruit examples.
 */
uint32_t WS2812FX::color_wheel(uint8_t pos) {
  if (SEGMENT.palette) return color_from_palette(pos, false, true, 0);
  pos = 255 - pos;
  if(pos < 85) {
    return ((uint32_t)(255 - pos * 3) << 16) | ((uint32_t)(0) << 8) | (pos * 3);
  } else if(pos < 170) {
    pos -= 85;
    return ((uint32_t)(0) << 16) | ((uint32_t)(pos * 3) << 8) | (255 - pos * 3);
  } else {
    pos -= 170;
    return ((uint32_t)(pos * 3) << 16) | ((uint32_t)(255 - pos * 3) << 8) | (0);
  }
}

/*
 * Returns a new, random wheel index with a minimum distance of 42 from pos.
 */
uint8_t WS2812FX::get_random_wheel_index(uint8_t pos) {
  uint8_t r = 0, x = 0, y = 0, d = 0;

  while(d < 42) {
    r = random8();
    x = abs(pos - r);
    y = 255 - x;
    d = MIN(x, y);
  }
  return r;
}


uint32_t IRAM_ATTR WS2812FX::crgb_to_col(CRGB fastled)
{
  return RGBW32(fastled.red, fastled.green, fastled.blue, 0);
}


CRGB IRAM_ATTR WS2812FX::col_to_crgb(uint32_t color)
{
  CRGB fastled_col;
  fastled_col.red =   R(color);
  fastled_col.green = G(color);
  fastled_col.blue =  B(color);
  return fastled_col;
}


void WS2812FX::load_gradient_palette(uint8_t index)
{
  byte i = constrain(index, 0, GRADIENT_PALETTE_COUNT -1);
  byte tcp[76] = {255}; //support gradient palettes with up to 18 entries  // WLEDSR with safety margin
  memcpy_P(tcp, (byte*)pgm_read_dword(&(gGradientPalettes[i])), 72);
  targetPalette.loadDynamicGradientPalette(tcp);
}


/*
 * FastLED palette modes helper function. Limitation: Due to memory reasons, multiple active segments with FastLED will disable the Palette transitions
 */
void WS2812FX::handle_palette(void)
{
  bool singleSegmentMode = (_segment_index == _segment_index_palette_last);
  _segment_index_palette_last = _segment_index;

  byte paletteIndex = SEGMENT.palette;
  if (paletteIndex == 0) //default palette. Differs depending on effect
  {
    switch (SEGMENT.mode)
    {
      case FX_MODE_FIRE_2012  : paletteIndex = 35; break; //heat palette
      case FX_MODE_COLORWAVES : paletteIndex = 26; break; //landscape 33
      case FX_MODE_FILLNOISE8 : paletteIndex =  9; break; //ocean colors
      case FX_MODE_NOISE16_1  : paletteIndex = 20; break; //Drywet
      case FX_MODE_NOISE16_2  : paletteIndex = 43; break; //Blue cyan yellow
      case FX_MODE_NOISE16_3  : paletteIndex = 35; break; //heat palette
      case FX_MODE_NOISE16_4  : paletteIndex = 26; break; //landscape 33
      case FX_MODE_GLITTER    : paletteIndex = 11; break; //rainbow colors
      case FX_MODE_SUNRISE    : paletteIndex = 35; break; //heat palette
      case FX_MODE_FLOW       : paletteIndex =  6; break; //party
    }
  }
  if (SEGMENT.mode >= FX_MODE_METEOR && paletteIndex == 0) paletteIndex = 4;

  switch (paletteIndex)
  {
    case 0: //default palette. Exceptions for specific effects above
      targetPalette = PartyColors_p; break;
    case 1: {//periodically replace palette with a random one. Doesn't work with multiple FastLED segments
      if (!singleSegmentMode)
      {
        targetPalette = PartyColors_p; break; //fallback
      }
      if (millis() - _lastPaletteChange > 1000 + ((uint32_t)(255-SEGMENT.intensity))*100)
      {
        targetPalette = CRGBPalette16(
                        CHSV(random8(), 255, random8(128, 255)),
                        CHSV(random8(), 255, random8(128, 255)),
                        CHSV(random8(), 192, random8(128, 255)),
                        CHSV(random8(), 255, random8(128, 255)));
        _lastPaletteChange = millis();
      } break;}
    case 2: {//primary color only
      CRGB prim = col_to_crgb(SEGCOLOR(0));
      targetPalette = CRGBPalette16(prim); break;}
    case 3: {//primary + secondary
      CRGB prim = col_to_crgb(SEGCOLOR(0));
      CRGB sec  = col_to_crgb(SEGCOLOR(1));
      targetPalette = CRGBPalette16(prim,prim,sec,sec); break;}
    case 4: {//primary + secondary + tertiary
      CRGB prim = col_to_crgb(SEGCOLOR(0));
      CRGB sec  = col_to_crgb(SEGCOLOR(1));
      CRGB ter  = col_to_crgb(SEGCOLOR(2));
      targetPalette = CRGBPalette16(ter,sec,prim); break;}
    case 5: {//primary + secondary (+tert if not off), more distinct
      CRGB prim = col_to_crgb(SEGCOLOR(0));
      CRGB sec  = col_to_crgb(SEGCOLOR(1));
      if (SEGCOLOR(2)) {
        CRGB ter = col_to_crgb(SEGCOLOR(2));
        targetPalette = CRGBPalette16(prim,prim,prim,prim,prim,sec,sec,sec,sec,sec,ter,ter,ter,ter,ter,prim);
      } else {
        targetPalette = CRGBPalette16(prim,prim,prim,prim,prim,prim,prim,prim,sec,sec,sec,sec,sec,sec,sec,sec);
      }
      break;}
    case 6: //Party colors
      targetPalette = PartyColors_p; break;
    case 7: //Cloud colors
      targetPalette = CloudColors_p; break;
    case 8: //Lava colors
      targetPalette = LavaColors_p; break;
    case 9: //Ocean colors
      targetPalette = OceanColors_p; break;
    case 10: //Forest colors
      targetPalette = ForestColors_p; break;
    case 11: //Rainbow colors
      targetPalette = RainbowColors_p; break;
    case 12: //Rainbow stripe colors
      targetPalette = RainbowStripeColors_p; break;
    case 71: //WLEDMM netmindz ar palette +1
    case 72: //WLEDMM netmindz ar palette +1
      targetPalette = getAudioPalette(paletteIndex);
      break; 
    default: //progmem palettes
      load_gradient_palette(paletteIndex -13);
  }

  if (singleSegmentMode && paletteFade && SEGENV.call > 0) //only blend if just one segment uses FastLED mode
  {
    nblendPaletteTowardPalette(currentPalette, targetPalette, 48);
  } else
  {
    currentPalette = targetPalette;
  }
}

// WLEDMM netmindz ar palette
CRGBPalette16 WS2812FX::getAudioPalette(int pal) {
  // https://forum.makerforums.info/t/hi-is-it-possible-to-define-a-gradient-palette-at-runtime-the-define-gradient-palette-uses-the/63339

  uint8_t xyz[16];  // Needs to be 4 times however many colors are being used.
                    // 3 colors = 12, 4 colors = 16, etc.

  xyz[0] = 0;  // anchor of first color - must be zero
  xyz[1] = 0;
  xyz[2] = 0;
  xyz[3] = 0;

  CRGB rgb = getCRGBForBand(1, pal);
  
  xyz[4] = 1;  // anchor of first color
  xyz[5] = rgb.r;
  xyz[6] = rgb.g;
  xyz[7] = rgb.b;

  rgb = getCRGBForBand(128, pal);
  xyz[8] = 128;
  xyz[9] = rgb.r;
  xyz[10] = rgb.g;
  xyz[11] = rgb.b;
  
  rgb = getCRGBForBand(255, pal);
  xyz[12] = 255;  // anchor of last color - must be 255
  xyz[13] = rgb.r;
  xyz[14] = rgb.g;
  xyz[15] = rgb.b;

  return CRGBPalette16(xyz);
}



/*
 * Gets a single color from the currently selected palette.
 * @param i Palette Index (if mapping is true, the full palette will be SEGLEN long, if false, 255). Will wrap around automatically.
 * @param mapping if true, LED position in segment is considered for color
 * @param wrap FastLED palettes will usally wrap back to the start smoothly. Set false to get a hard edge
 * @param mcol If the default palette 0 is selected, return the standard color 0, 1 or 2 instead. If >2, Party palette is used instead
 * @param pbri Value to scale the brightness of the returned color by. Default is 255. (no scaling)
 * @returns Single color from palette
 */
uint32_t IRAM_ATTR WS2812FX::color_from_palette(uint16_t i, bool mapping, bool wrap, uint8_t mcol, uint8_t pbri)
{
  if ((SEGMENT.palette == 0 && mcol < 3) || _no_rgb) {
    uint32_t color = SEGCOLOR(mcol);
    if (pbri == 255) return color;
    return RGBW32(scale8_video(R(color),pbri), scale8_video(G(color),pbri), scale8_video(B(color),pbri), scale8_video(W(color),pbri));
  }

  uint8_t paletteIndex = i;
  if (mapping && SEGLEN > 1) paletteIndex = (i*255)/(SEGLEN -1);
  if (!wrap) paletteIndex = scale8(paletteIndex, 240); //cut off blend at palette "end"
  CRGB fastled_col;
  fastled_col = ColorFromPalette(currentPalette, paletteIndex, pbri, (paletteBlend == 3)? NOBLEND:LINEARBLEND);

  return crgb_to_col(fastled_col);
}


//load custom mapping table from JSON file (called from finalizeInit() or deserializeState())
void WS2812FX::deserializeMap(uint8_t n) {
  char fileName[32];
  strcpy_P(fileName, PSTR("/ledmap"));
  if (n) sprintf(fileName +7, "%d", n);
  strcat(fileName, ".json");
  bool isFile = WLED_FS.exists(fileName);

  if (!isFile) {
    // erase custom mapping if selecting nonexistent ledmap.json (n==0)
    if (!n && customMappingTable != nullptr) {
      customMappingSize = 0;
      delete[] customMappingTable;
      customMappingTable = nullptr;
    }
    return;
  }

  #ifdef WLED_USE_DYNAMIC_JSON
  DynamicJsonDocument doc(JSON_BUFFER_SIZE);
  #else
  if (!requestJSONBufferLock(7)) return;
  #endif

  DEBUG_PRINT(F("Reading LED map from "));
  DEBUG_PRINTLN(fileName);

  if (!readObjectFromFile(fileName, nullptr, &doc)) {
    releaseJSONBufferLock();
    return; //if file does not exist just exit
  }

  // erase old custom ledmap
  if (customMappingTable != nullptr) {
    customMappingSize = 0;
    delete[] customMappingTable;
    customMappingTable = nullptr;
  }

  JsonArray map = doc[F("map")];
  if (!map.isNull() && map.size()) {  // not an empty map
    customMappingSize  = map.size();
    customMappingTable = new uint16_t[customMappingSize];
    for (uint16_t i=0; i<customMappingSize; i++) {
      customMappingTable[i] = (uint16_t) map[i];
    }
  }

  releaseJSONBufferLock();
}

#if !defined(WLED_USE_CIE_BRIGHTNESS_TABLE)
//gamma 2.8 lookup table used for color correction
byte gammaT[] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,
    2,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  5,  5,  5,
    5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9, 10,
   10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16,
   17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25,
   25, 26, 27, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 35, 35, 36,
   37, 38, 39, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 50,
   51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 66, 67, 68,
   69, 70, 72, 73, 74, 75, 77, 78, 79, 81, 82, 83, 85, 86, 87, 89,
   90, 92, 93, 95, 96, 98, 99,101,102,104,105,107,109,110,112,114,
  115,117,119,120,122,124,126,127,129,131,133,135,137,138,140,142,
  144,146,148,150,152,154,156,158,160,162,164,167,169,171,173,175,
  177,180,182,184,186,189,191,193,196,198,200,203,205,208,210,213,
  215,218,220,223,225,228,231,233,236,239,241,244,247,249,252,255 };
#else
// experimental
// CIE 1931 lookup table (8bit->8bit) that was proposed during discussion of issue #2767
// https://github.com/Aircoookie/WLED/issues/2767#issuecomment-1310961308
// unfortunately NepixelsBu has its own internal table, that kills low brightness values similar to the original WLED table.
//   see https://github.com/Makuna/NeoPixelBus/blob/master/src/internal/NeoGamma.h
static const byte gammaT[256] = {
  0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 
  2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4,
  4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 
  7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 
  11, 11, 12, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 16, 16, 17, 
  17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 
  25, 25, 26, 27, 27, 28, 28, 29, 30, 30, 31, 31, 32, 33, 33, 34, 
  35, 35, 36, 37, 38, 38, 39, 40, 41, 41, 42, 43, 44, 44, 45, 46, 
  47, 48, 49, 50, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 
  62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 74, 75, 76, 77, 78, 
  79, 81, 82, 83, 84, 85, 87, 88, 89, 91, 92, 93, 94, 96, 97, 99, 
  100, 101, 103, 104, 106, 107, 109, 110, 111, 113, 115, 116, 118, 119, 121, 
  122, 124, 126, 127, 129, 130, 132, 134, 135, 137, 139, 141, 142, 144, 146, 
  148, 150, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 170, 172, 174, 
  177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 198, 200, 202, 204, 207, 
  209, 211, 213, 216, 218, 220, 223, 225, 227, 230, 232, 235, 237, 240, 242, 
  245, 247, 250, 252, 255 };
#endif

uint8_t WS2812FX::gamma8_cal(uint8_t b, float gamma) {
  return (int)(pow((float)b / 255.0, gamma) * 255 + 0.5);
}

void WS2812FX::calcGammaTable(float gamma)
{
#if !defined(WLED_USE_CIE_BRIGHTNESS_TABLE)
  for (uint16_t i = 0; i < 256; i++) {
    gammaT[i] = gamma8_cal(i, gamma);
  }
#endif
}

uint8_t WS2812FX::gamma8(uint8_t b)
{
  return gammaT[b];
}

uint32_t WS2812FX::gamma32(uint32_t color)
{
  if (!gammaCorrectCol) return color;
  uint8_t w = W(color);
  uint8_t r = R(color);
  uint8_t g = G(color);
  uint8_t b = B(color);
  w = gammaT[w];
  r = gammaT[r];
  g = gammaT[g];
  b = gammaT[b];
  return RGBW32(r, g, b, w);
}

WS2812FX* WS2812FX::instance = nullptr;

//Bus static member definition, would belong in bus_manager.cpp
int16_t Bus::_cct = -1;
uint8_t Bus::_cctBlend = 0;
uint8_t Bus::_autoWhiteMode = RGBW_MODE_DUAL;

=== ./NodeStruct.h ===

#ifndef WLED_NODESTRUCT_H
#define WLED_NODESTRUCT_H

/*********************************************************************************************\
* NodeStruct from the ESP Easy project (https://github.com/letscontrolit/ESPEasy)
\*********************************************************************************************/

#include <map>
#include <IPAddress.h>

#define NODE_TYPE_ID_UNDEFINED        0
#define NODE_TYPE_ID_ESP8266         82
#define NODE_TYPE_ID_ESP32           32

/*********************************************************************************************\
* NodeStruct
\*********************************************************************************************/
struct NodeStruct
{
  String    nodeName;
  IPAddress ip;
  uint8_t   unit;
  uint8_t   age;
  uint8_t   nodeType;
  uint32_t  build;

  NodeStruct() : age(0), nodeType(0), build(0)
  {
    for (uint8_t i = 0; i < 4; ++i) { ip[i] = 0; }
  }
};
typedef std::map<uint8_t, NodeStruct> NodesMap;

#endif // WLED_NODESTRUCT_H

=== ./alexa.cpp ===

#include "wled.h"

/*
 * Alexa Voice On/Off/Brightness/Color Control. Emulates a Philips Hue bridge to Alexa.
 * 
 * This was put together from these two excellent projects:
 * https://github.com/kakopappa/arduino-esp8266-alexa-wemo-switch
 * https://github.com/probonopd/ESP8266HueEmulator
 */
#include "src/dependencies/espalexa/EspalexaDevice.h"

#ifndef WLED_DISABLE_ALEXA
#warning Alexa enabled. Alexa is not officially supported in WLED-SR

void onAlexaChange(EspalexaDevice* dev);

void alexaInit()
{
  if (alexaEnabled && WLED_CONNECTED)
  {
    if (espalexaDevice == nullptr) //only init once
    {
      espalexaDevice = new EspalexaDevice(alexaInvocationName, onAlexaChange, EspalexaDeviceType::extendedcolor);
      espalexa.addDevice(espalexaDevice);
      espalexa.begin(&server);
    } else {
      espalexaDevice->setName(alexaInvocationName);
    }
  }
}

void handleAlexa()
{
  if (!alexaEnabled || !WLED_CONNECTED) return;
  espalexa.loop();
}

void onAlexaChange(EspalexaDevice* dev)
{
  EspalexaDeviceProperty m = espalexaDevice->getLastChangedProperty();
  
  if (m == EspalexaDeviceProperty::on)
  {
    if (!macroAlexaOn)
    {
      if (bri == 0)
      {
        bri = briLast;
        stateUpdated(CALL_MODE_ALEXA);
      }
    } else {
      applyPreset(macroAlexaOn, CALL_MODE_ALEXA);
      if (bri == 0) espalexaDevice->setValue(briLast); //stop Alexa from complaining if macroAlexaOn does not actually turn on
    }
  } else if (m == EspalexaDeviceProperty::off)
  {
    if (!macroAlexaOff)
    {
      if (bri > 0)
      {
        briLast = bri;
        bri = 0;
        stateUpdated(CALL_MODE_ALEXA);
      }
    } else {
      applyPreset(macroAlexaOff, CALL_MODE_ALEXA);
      if (bri != 0) espalexaDevice->setValue(0); //stop Alexa from complaining if macroAlexaOff does not actually turn off
    }
  } else if (m == EspalexaDeviceProperty::bri)
  {
    bri = espalexaDevice->getValue();
    stateUpdated(CALL_MODE_ALEXA);
  } else //color
  {
    if (espalexaDevice->getColorMode() == EspalexaColorMode::ct) //shade of white
    {
      byte rgbw[4];
      uint16_t ct = espalexaDevice->getCt();
			if (!ct) return;
			uint16_t k = 1000000 / ct; //mireds to kelvin
			
			if (strip.hasCCTBus()) {
				strip.setCCT(k);
				rgbw[0]= 0; rgbw[1]= 0; rgbw[2]= 0; rgbw[3]= 255;
			} else if (strip.hasWhiteChannel()) {
        switch (ct) { //these values empirically look good on RGBW
          case 199: rgbw[0]=255; rgbw[1]=255; rgbw[2]=255; rgbw[3]=255; break;
          case 234: rgbw[0]=127; rgbw[1]=127; rgbw[2]=127; rgbw[3]=255; break;
          case 284: rgbw[0]=  0; rgbw[1]=  0; rgbw[2]=  0; rgbw[3]=255; break;
          case 350: rgbw[0]=130; rgbw[1]= 90; rgbw[2]=  0; rgbw[3]=255; break;
          case 383: rgbw[0]=255; rgbw[1]=153; rgbw[2]=  0; rgbw[3]=255; break;
					default : colorKtoRGB(k, rgbw);
        }
      } else {
        colorKtoRGB(k, rgbw);
      }
      strip.setColor(0, rgbw[0], rgbw[1], rgbw[2], rgbw[3]);
    } else {
      uint32_t color = espalexaDevice->getRGB();
      strip.setColor(0, color);
    }
    stateUpdated(CALL_MODE_ALEXA);
  }
}


#else
 void alexaInit(){}
 void handleAlexa(){}
#endif

=== ./audio_reactive.h ===

/*
 * This file allows you to add own functionality to WLED more easily
 * See: https://github.com/Aircoookie/WLED/wiki/Add-own-functionality
 * EEPROM bytes 2750+ are reserved for your custom use case. (if you extend
 * #define EEPSIZE in const.h) bytes 2400+ are currently ununsed, but might be
 * used for future wled features
 */

// WARNING Sound reactive variables that are used by the animations or other
// asynchronous routines must NOT have interim values, but only updated in a
// single calculation. These are:
//
// sample     sampleAvg     sampleAgc       samplePeak    myVals[]
//
// fftBin[]   fftResult[]   FFT_MajorPeak   FFT_Magnitude
//
// Otherwise, the animations may asynchronously read interim values of these
// variables.
//

#include <driver/i2s.h>

#include "audio_source.h"
#include "wled.h"

static AudioSource *audioSource;
static volatile bool disableSoundProcessing =
    false;  // if true, sound processing (FFT, filters, AGC) will be suspended.
            // "volatile" as its shared between tasks.
static unsigned useInputFilter =
    0;  // if >0 , enables a bandpass filter 80Hz-8Khz to remove noise. Applies
        // before FFT.

// ALL AUDIO INPUT PINS DEFINED IN wled.h AND CONFIGURABLE VIA UI

// Comment/Uncomment to toggle usb serial debugging
// #define MIC_LOGGER                   // MIC sampling & sound input debugging
// (serial plotter) #define FFT_SAMPLING_LOG             // FFT result debugging
// #define SR_DEBUG                     // generic SR DEBUG messages

#ifdef SR_DEBUG
#define DEBUGSR_PRINT(x) Serial.print(x)
#define DEBUGSR_PRINTLN(x) Serial.println(x)
#define DEBUGSR_PRINTF(x...) Serial.printf(x)
#else
#define DEBUGSR_PRINT(x)
#define DEBUGSR_PRINTLN(x)
#define DEBUGSR_PRINTF(x...)
#endif

// legacy support
// #if defined(SR_DEBUG) && !defined(MIC_LOGGER) && !defined(NO_MIC_LOGGER)
// #define MIC_LOGGER
// #endif

// hackers corner
// #define SOUND_DYNAMICS_LIMITER        // experimental: define to enable a
// dynamics limiter that avoids "sudden flashes" at onsets. Make some effects
// look more "smooth and fluent"

constexpr i2s_port_t I2S_PORT = I2S_NUM_0;
constexpr int BLOCK_SIZE = 128;
constexpr int SAMPLE_RATE = 10240;  // Base sample rate in Hz - standard.
                                    // Physical sample time -> 50ms
// constexpr int SAMPLE_RATE = 20480;            // Base sample rate in Hz -
// 20Khz is experimental.    Physical sample time -> 25ms constexpr int
// SAMPLE_RATE = 22050;            // Base sample rate in Hz - 22Khz is a
// standard rate. Physical sample time -> 23ms

#define FFT_MIN_CYCLE \
  45  // minimum time before FFT task is repeated. Must be less than time for
      // reading 512 samples at SAMPLE_RATE.

// Use userVar0 and userVar1 (API calls &U0=,&U1=, uint16_t)

#define UDP_SYNC_HEADER "00001"
#define UDP_SYNC_HEADER_V2 "00002"

uint8_t maxVol = 31;  // (was 10) Reasonable value for constant volume for 'peak
                      // detector', as it won't always trigger
uint8_t binNum = 14;  // (was 8)  Used to select the bin for FFT based beat
                      // detection. 14 = 280Hz

//
// AGC presets
//  Note: in C++, "const" implies "static" - no need to explicitly declare
//  everything as "static const"
//
#define AGC_NUM_PRESETS 3  // AGC currently has 3 presets: normal, vivid, lazy

// Normal, Vivid,    Lazy
const double
    agcSampleDecay[AGC_NUM_PRESETS] =  // decay factor for sampleMax, in case
                                       // the current sample is below sampleMax
    {0.9994, 0.9985, 0.9997};

const float agcZoneLow[AGC_NUM_PRESETS] =  // low volume emergency zone
    {32, 28, 36};
const float agcZoneHigh[AGC_NUM_PRESETS] =  // high volume emergency zone
    {240, 240, 248};
const float agcZoneStop[AGC_NUM_PRESETS] =  // disable AGC integrator if we get
                                            // above this level
    {336, 448, 304};

const float
    agcTarget0[AGC_NUM_PRESETS] =  // first AGC setPoint -> between 40% and 65%
    {112, 144, 164};
const float agcTarget0Up[AGC_NUM_PRESETS] =  // setpoint switching value (a poor
                                             // man's bang-bang)
    {88, 64, 116};
const float agcTarget1[AGC_NUM_PRESETS] =  // second AGC setPoint -> around 85%
    {220, 224, 216};

const double
    agcFollowFast[AGC_NUM_PRESETS] =  // quickly follow setpoint - ~0.15 sec
    {1.0 / 192.0, 1.0 / 128.0, 1.0 / 256.0};
const double
    agcFollowSlow[AGC_NUM_PRESETS] =  // slowly follow setpoint  - ~2-15 secs
    {1.0 / 6144.0, 1.0 / 4096.0, 1.0 / 8192.0};

const double agcControlKp[AGC_NUM_PRESETS] =  // AGC - PI control, proportional
                                              // gain parameter
    {0.6, 1.5, 0.65};
const double agcControlKi[AGC_NUM_PRESETS] =  // AGC - PI control, integral gain
                                              // parameter
    {1.7, 1.85, 1.2};

const float
    agcSampleSmooth[AGC_NUM_PRESETS] =  // smoothing factor for sampleAgc (use
                                        // rawSampleAgc if you want the
                                        // non-smoothed value)
    {1.0 / 12.0, 1.0 / 6.0, 1.0 / 16.0};
//
// AGC presets end
//

double sampleMax =
    0;  // Max sample over a few seconds. Needed for AGC controler.

uint8_t myVals[32];  // Used to store a pile of samples because WLED frame rate
                     // and WLED sample rate are not synchronized. Frame rate is
                     // too low.
uint8_t samplePeak = 0;  // Flag for peak. 0 = no peak, 1 = possible peak
                         // (often), 2=sure peak (every 1-2seconds)
uint8_t udpSamplePeak =
    0;  // Set at the same tiem as samplePeak, but reset by transmitAudioData
constexpr int delayMs =
    10;                  // I don't want to sample too often and overload WLED
static int micIn = 0.0;  // Current sample starts with negative values and large
                         // values, which is why it's 16 bit signed
int sampleRaw;           // Current sample. Must only be updated ONCE!!!
float sampleReal = 0.0;  // "sample" as float, to provide bits that are lost
                         // otherwise. Needed for AGC.
static float tmpSample;  // An interim sample variable used for calculations.
static float sampleAdj;  // Gain adjusted sample value
int rawSampleAgc = 0;    // Our AGC sample - raw
float sampleAgc = 0.0;   // AGC sample, smoothed
uint16_t micData;        // Analog input for FFT
uint16_t micDataSm;      // Smoothed mic data, as it's a bit twitchy
float micDataReal = 0.0;  // future support - this one has the full 24bit MicIn
                          // data - lowest 8bit after decimal point
static unsigned long timeOfPeak = 0;
static unsigned long lastTime = 0;
static double micLev =
    0.0;  // Used to convert returned value to have '0' as minimum. A leveller
float multAgc = 1.0;  // sample * multAgc = sampleAgc. Our multiplier
float sampleAvg = 0;  // Smoothed Average
// double beat = 0;                              // beat Detection

static float expAdjF;   // Used for exponential filter.
float weighting = 0.2;  // Exponential filter weighting. Will be adjustable in a
                        // future release.

// FFT Variables
constexpr uint16_t samplesFFT =
    512;  // Samples in an FFT batch - This value MUST ALWAYS be a power of 2
unsigned int sampling_period_us;
unsigned long microseconds;

float FFT_MajorPeak = 1.0f;
float FFT_Magnitude = 0.0001;

// These are the input and output vectors.  Input vectors receive computed
// results from FFT.
static float vReal[samplesFFT];
static float vImag[samplesFFT];
static float windowWeighingFactors[samplesFFT];
float fftBin[samplesFFT];

// Try and normalize fftBin values to a max of 4096, so that 4096/16 = 256.
// Oh, and bins 0,1,2 are no good, so we'll zero them out.
float fftCalc[16];
int fftResult[16];       // Our calculated result table, which we feed to the
                         // animations.
float fftResultMax[16];  // A table used for testing to determine how our
                         // post-processing is working.
float fftAvg[16];

#define FFTBIN_DOWNSCALE \
  0.65  // scale down FFT results, so we end up at ~128 average

// Table of linearNoise results to be multiplied by soundSquelch in order to
// reduce squelch across fftResult bins.
// TODO // Consider reducing the first few values if bass detection is too
// sensitive
static int linearNoise[16] = {34, 28, 26, 25, 20, 12, 9, 6,
                              4,  4,  3,  2,  2,  2,  2, 2};

// Table of multiplication factors so that we can even out the frequency
// response.
static float fftResultPink[16] = {1.70, 1.71, 1.73, 1.78, 1.68, 1.56,
                                  1.55, 1.63, 1.79, 1.62, 1.80, 2.06,
                                  2.47, 3.35, 6.83, 9.55};

// shared vars for debugging
#ifdef MIC_LOGGER
static volatile float micReal_min =
    0.0f;  // MicIn data min from last batch of samples
static volatile float micReal_avg =
    0.0f;  // MicIn data average (from last batch of samples)
static volatile float micReal_max =
    0.0f;  // MicIn data max from last batch of samples
#endif

// default "V1" SR 0.13.x audiosync struct - 83 Bytes
struct audioSyncPacket {
  char header[6] = UDP_SYNC_HEADER;
  uint8_t myVals[32];     //  32 Bytes
  int sampleAgc;          //  04 Bytes
  int sampleRaw;          //  04 Bytes
  float sampleAvg;        //  04 Bytes
  bool samplePeak;        //  01 Bytes
  uint8_t fftResult[16];  //  16 Bytes
  double FFT_Magnitude;   //  08 Bytes
  double FFT_MajorPeak;   //  08 Bytes
};

// new "V2" AC 0.14.0 audiosync struct - 40 Bytes
struct audioSyncPacket_v2 {
  char header[6] = UDP_SYNC_HEADER_V2;  // 06 bytes
  float sampleRaw;   //  04 Bytes  - either "sampleRaw" or "rawSampleAgc"
                     //  depending on soundAgc setting
  float sampleSmth;  //  04 Bytes  - either "sampleAvg" or "sampleAgc" depending
                     //  on soundAgc setting
  uint8_t samplePeak;  //  01 Bytes  - 0 no peak; >=1 peak detected. In future,
                       //  this will also provide peak Magnitude
  uint8_t
      reserved1;  //  01 Bytes  - reserved for future extensions like loudness
  uint8_t fftResult[16];  //  16 Bytes  - FFT results
  float FFT_Magnitude;    //  04 Bytes
  float FFT_MajorPeak;    //  04 Bytes
};

#define UDPSOUND_MAX_PACKET \
  96  // max packet size for audiosync, with a bit of "headroom"

bool isValidUdpSyncVersion(char header[6]) {
  if (strncmp(header, UDP_SYNC_HEADER, 5) == 0) {
    return true;
  } else {
    return false;
  }
}

bool isValidUdpSyncVersion2(char header[6]) {
  if (strncmp(header, UDP_SYNC_HEADER_V2, 5) == 0) {
    return true;
  } else {
    return false;
  }
}

/* get current max sample ("published" by the I2S and FFT thread) and perform
 * some sound processing */
void getSample() {
  const int AGC_preset =
      (soundAgc > 0) ? (soundAgc - 1)
                     : 0;  // make sure the _compiler_ knows this value will not
                           // change while we are inside the function
  static unsigned long lastSoundTime = 0;  // for delaying noise gate
  constexpr long MinTimeSilence = 1600;    // 1600ms "grace time" before closing
                                           // noise gate - to avoid chattering

#ifdef WLED_DISABLE_SOUND
  micIn = inoise8(millis(), millis());  // Simulated analog read
  micDataReal = micIn;                  // Simulated I2S read
#else
  micIn = micDataSm;
#endif

  // remove remaining DC offset from sound signal
  micLev = ((micLev * 8191.0) + micDataReal) /
           8192.0;  // takes a few seconds to "catch up" with the Mic Input
  // if(micIn < micLev) micLev = ((micLev * 31.0) + micDataReal) / 32.0; //
  // align MicLev to lowest input signal
  if (micDataReal < (micLev - 1.2))
    micLev = ((micLev * 31.0) + micDataReal) /
             32.0;  // align with lowest input, but allow some "overlap" to
                    // stabilize the filter
  micIn -= micLev;  // Let's center it to 0 now

  // Using an exponential filter to smooth out the signal. We'll add controls
  // for this in a future release.
  float micInNoDC = fabsf(micDataReal - micLev);
  expAdjF = weighting * micInNoDC + ((1.0 - weighting) * expAdjF);
  expAdjF = fabsf(expAdjF);  // Now (!) take the absolute value

  // expAdjF = (expAdjF <= soundSquelch) ? 0: expAdjF; // super simple noise
  // gate if ((soundSquelch == 0) && (expAdjF < 0.25f)) expAdjF = 0;
  if ((expAdjF <= soundSquelch) ||
      ((soundSquelch == 0) &&
       (expAdjF < 0.25f))) {  // noise gate with "closing delay"
    if ((millis() - lastSoundTime) > MinTimeSilence) expAdjF = 0.0;
  } else {
    lastSoundTime = millis();
  }

  tmpSample = expAdjF;
  micIn = abs(micIn);  // And get the absolute value of each sample

  sampleAdj = tmpSample * sampleGain / 40 * inputLevel / 128 +
              tmpSample / 16;  // Adjust the gain. with inputLevel adjustment
  sampleReal = tmpSample;

  sampleAdj = fmax(fmin(sampleAdj, 255),
                   0);  // Question: why are we limiting the value to 8 bits ???
  sampleRaw = (int)sampleAdj;  // ONLY update sample ONCE!!!!

  // keep "peak" sample, but decay value if current sample is below peak
  if ((sampleMax < sampleReal) && (sampleReal > 0.5)) {
    sampleMax =
        sampleMax +
        0.5 * (sampleReal - sampleMax);  // new peak - with some filtering
    // if (((maxVol < 6) || (binNum < 9)) && (millis() - timeOfPeak > 80) &&
    // (sampleAvg > 1)) {              // another simple way to detect
    // samplePeak
    if ((millis() - timeOfPeak > 80) && (sampleAvg > 1)) {  // no iffs-n-butts
      samplePeak = 2;
      timeOfPeak = millis();
      udpSamplePeak = 2;
      userVar1 = samplePeak;
    }
  } else {
    if ((multAgc * sampleMax > agcZoneStop[AGC_preset]) && (soundAgc > 0))
      sampleMax =
          sampleMax +
          0.5 * (sampleReal - sampleMax);  // over AGC Zone - get back quickly
    else
      sampleMax =
          sampleMax * agcSampleDecay[AGC_preset];  // signal to zero --> 5-8sec
  }
  if (sampleMax < 0.5) sampleMax = 0.0;

  sampleAvg = ((sampleAvg * 15.0) + sampleAdj) /
              16.0;              // Smooth it out over the last 16 samples.
  sampleAvg = fabsf(sampleAvg);  // make sure we have a positive value

  // Fixes private class variable compiler error. Unsure if this is the correct
  // way of fixing the root problem. -THATDONFC
  uint16_t MinShowDelay = max((uint16_t)33, strip.getMinShowDelay());

  if (millis() - timeOfPeak > MinShowDelay) {  // Auto-reset of samplePeak after
                                               // a complete frame has passed.
    samplePeak = 0;
    udpSamplePeak = 0;
  }

  if (userVar1 == 0) samplePeak = 0;
  // Poor man's beat detection by seeing if sample > Average + some value.
  if ((maxVol > 1) && (binNum > 6) && (fftBin[binNum] > maxVol) &&
      (millis() - timeOfPeak > 100) &&
      (sampleAvg > 1)) {  // This goes through ALL of the 255 bins - but ignores
                          // stupid settings
    //  if (sample > (sampleAvg + maxVol) && millis() > (peakTime + 200)) {
    // Then we got a peak, else we don't. The peak has to time out on its own in
    // order to support UDP sound sync.
    samplePeak = max(uint8_t(1), samplePeak);  // ignore this peak if we already
                                               // have an active "good peak"
    if (samplePeak == 1) timeOfPeak = millis();
    udpSamplePeak = max(uint8_t(1), udpSamplePeak);
    userVar1 = samplePeak;
  }
}  // getSample()

/*
 * A "PI control" multiplier to automatically adjust sound sensitivity.
 *
 * A few tricks are implemented so that sampleAgc does't only utilize 0% and
 * 100%: 0. don't amplify anything below squelch (but keep previous gain)
 * 1. gain input = maximum signal observed in the last 5-10 seconds
 * 2. we use two setpoints, one at ~60%, and one at ~80% of the maximum signal
 * 3. the amplification depends on signal level:
 *    a) normal zone - very slow adjustment
 *    b) emergency zome (<10% or >90%) - very fast adjustment
 */
void agcAvg(unsigned long the_time) {
  const int AGC_preset =
      (soundAgc > 0) ? (soundAgc - 1)
                     : 0;  // make sure the _compiler_ knows this value will not
                           // change while we are inside the function
  static int last_soundAgc = -1;

  float lastMultAgc = multAgc;          // last muliplier used
  float multAgcTemp = multAgc;          // new multiplier
  float tmpAgc = sampleReal * multAgc;  // what-if amplified signal

  float control_error;  // "control error" input for PI control
  static double control_integrated =
      0.0;  // "integrator control" = accumulated error

  if (last_soundAgc != soundAgc)
    control_integrated = 0.0;  // new preset - reset integrator

  // For PI control, we need to have a contant "frequency"
  // so let's make sure that the control loop is not running at insane speed
  static unsigned long last_time = 0;
  unsigned long time_now = millis();
  if ((the_time > 0) && (the_time < time_now))
    time_now = the_time;  // allow caller to override my clock

  if (time_now - last_time > 2) {
    last_time = time_now;

    if ((fabsf(sampleReal) < 2.0) || (sampleMax < 1.0)) {
      // MIC signal is "squelched" - deliver silence
      multAgcTemp = multAgc;  // keep old control value (no change)
      tmpAgc = 0;
      // we need to "spin down" the intgrated error buffer
      if (fabs(control_integrated) < 0.01)
        control_integrated = 0.0;
      else
        control_integrated = control_integrated * 0.91;
    } else {
      // compute new setpoint
      if (tmpAgc <= agcTarget0Up[AGC_preset])
        multAgcTemp = agcTarget0[AGC_preset] /
                      sampleMax;  // Make the multiplier so that sampleMax *
                                  // multiplier = first setpoint
      else
        multAgcTemp = agcTarget1[AGC_preset] /
                      sampleMax;  // Make the multiplier so that sampleMax *
                                  // multiplier = second setpoint
    }
    // limit amplification
    if (multAgcTemp > 32.0) multAgcTemp = 32.0;
    if (multAgcTemp < 1.0 / 64.0) multAgcTemp = 1.0 / 64.0;

    // compute error terms
    control_error = multAgcTemp - lastMultAgc;

    if (((multAgcTemp > 0.085) &&
         (multAgcTemp < 6.5))  // integrator anti-windup by clamping
        && (multAgc * sampleMax <
            agcZoneStop[AGC_preset]))  // integrator ceiling (>140% of max)
      control_integrated += control_error * 0.002 *
                            0.25;  // 2ms = intgration time; 0.25 for damping
    else
      control_integrated *= 0.9;  // spin down that beasty integrator

    // apply PI Control
    tmpAgc = sampleReal *
             lastMultAgc;  // check "zone" of the signal using previous gain
    if ((tmpAgc > agcZoneHigh[AGC_preset]) ||
        (tmpAgc <
         soundSquelch + agcZoneLow[AGC_preset])) {  // upper/lower emergy zone
      multAgcTemp = lastMultAgc + agcFollowFast[AGC_preset] *
                                      agcControlKp[AGC_preset] * control_error;
      multAgcTemp += agcFollowFast[AGC_preset] * agcControlKi[AGC_preset] *
                     control_integrated;
    } else {  // "normal zone"
      multAgcTemp = lastMultAgc + agcFollowSlow[AGC_preset] *
                                      agcControlKp[AGC_preset] * control_error;
      multAgcTemp += agcFollowSlow[AGC_preset] * agcControlKi[AGC_preset] *
                     control_integrated;
    }

    // limit amplification again - PI controler sometimes "overshoots"
    if (multAgcTemp > 32.0) multAgcTemp = 32.0;
    if (multAgcTemp < 1.0 / 64.0) multAgcTemp = 1.0 / 64.0;
  }

  // NOW finally amplify the signal
  tmpAgc = sampleReal * multAgcTemp;        // apply gain to signal
  if (fabsf(sampleReal) < 2.0) tmpAgc = 0;  // apply squelch threshold
  if (tmpAgc > 255) tmpAgc = 255;           // limit to 8bit
  if (tmpAgc < 1) tmpAgc = 0;               // just to be sure

  // update global vars ONCE - multAgc, sampleAGC, rawSampleAgc
  multAgc = multAgcTemp;
  rawSampleAgc = 0.8 * tmpAgc + 0.2 * (float)rawSampleAgc;

  // update smoothed AGC sample
  if (fabsf(tmpAgc) < 1.0)
    sampleAgc = 0.5 * tmpAgc + 0.5 * sampleAgc;  // fast path to zero
  else
    sampleAgc = sampleAgc + agcSampleSmooth[AGC_preset] *
                                (tmpAgc - sampleAgc);  // smooth path

  sampleAgc = fabsf(sampleAgc);
  userVar0 = sampleAvg * 4;
  if (userVar0 > 255) userVar0 = 255;

  last_soundAgc = soundAgc;
}  // agcAvg()

/* limit sound dynamics by contraining "attack" and "decay" times */
constexpr float bigChange =
    196;  // just a representative number - a large, expected sample value
/* values below will be made user-configurable later */
constexpr float attackTime = 800;  // attack time -> 0.8sec
constexpr float decayTime = 2800;  // decay time  -> 2.8sec

/* This fuctions limits the dynamics of sampleAvg and sampleAgc. It does not
 * affect FFTResult[] or raw samples (sample, rawSampleAgc) */
// effects: Gravimeter, Gravcenter, Gravcentric, Noisefire, Plasmoid,
// Freqpixels, Freqwave, Gravfreq, (2D Swirl, 2D Waverly) experimental, as it
// still has side-effects on AGC - AGC detects "silence" to late (due to long
// decay time) and ditches up the gain multiplier.
void limitSampleDynamics(void) {
#ifdef SOUND_DYNAMICS_LIMITER
  static unsigned long last_time = 0;
  static float last_sampleAvg = 0.0f;
  static float last_sampleAgc = 0.0f;

  long delta_time = millis() - last_time;
  delta_time = constrain(
      delta_time, 1, 1000);  // below 1ms -> 1ms; above 1sec -> sily lil hick-up
  float maxAttack = bigChange * float(delta_time) / attackTime;
  float maxDecay = -bigChange * float(delta_time) / decayTime;
  float deltaSample;

  // non-AGC sample
  if ((attackTime > 0) && (decayTime > 0)) {
    deltaSample = sampleAvg - last_sampleAvg;
    if (deltaSample > maxAttack) deltaSample = maxAttack;
    if (deltaSample < maxDecay) deltaSample = maxDecay;
    sampleAvg = last_sampleAvg + deltaSample;
  }
  // same for AGC sample
  if ((attackTime > 0) && (decayTime > 0)) {
    deltaSample = sampleAgc - last_sampleAgc;
    if (deltaSample > maxAttack) deltaSample = maxAttack;
    if (deltaSample < maxDecay) deltaSample = maxDecay;
    sampleAgc = last_sampleAgc + deltaSample;
  }

  last_sampleAvg = sampleAvg;
  last_sampleAgc = sampleAgc;
  last_time = millis();
#endif
}

////////////////////
// Begin FFT Code //
////////////////////

// using latest AruinoFFT lib, because it supports float and its much faster!
// lib_deps += https://github.com/kosme/arduinoFFT#develop @ 1.9.2

// The following optimizations seem to be optimal on ESP32 (~1.5ms per FFT run)
// #define FFT_SPEED_OVER_PRECISION     // enables use of reciprocals (1/x etc),
// and an a few other speedups - WLEDMM not faster on ESP32 #define
// FFT_SQRT_APPROXIMATION       // enables "quake3" style inverse sqrt - WLEDMM
// slower on ESP32
#define sqrt(x) \
  sqrtf(x)  // little hack that reduces FFT time by 10-50% on ESP32 (as
            // alternative to FFT_SQRT_APPROXIMATION)
#define sqrt_internal sqrtf  // see https://github.com/kosme/arduinoFFT/pull/83

#include "arduinoFFT.h"

void transmitAudioData() {
  if (!udpSyncConnected) return;
  static audioSyncPacket transmitData;  // softhack007: added "static"

  strncpy(transmitData.header, UDP_SYNC_HEADER,
          6);  // softhack007: I don't trust in type initialization
  for (int i = 0; i < 32; i++) {
    transmitData.myVals[i] = myVals[i];
  }

  transmitData.sampleAgc = sampleAgc;
  transmitData.sampleRaw = sampleRaw;
  transmitData.sampleAvg = sampleAvg;
  transmitData.samplePeak = udpSamplePeak;
  udpSamplePeak = 0;  // Reset udpSamplePeak after we've transmitted it

  for (int i = 0; i < 16; i++) {
    transmitData.fftResult[i] = (uint8_t)constrain(fftResult[i], 0, 254);
  }

  transmitData.FFT_Magnitude = FFT_Magnitude;
  transmitData.FFT_MajorPeak = FFT_MajorPeak;

  if (sampleAvg < 1) {  // silence - noise gate closed
    transmitData.samplePeak =
        false;  // don't claim "peak" where we have silence.
  }

  fftUdp.beginMulticastPacket();
  fftUdp.write(reinterpret_cast<uint8_t *>(&transmitData),
               sizeof(transmitData));
  fftUdp.endPacket();
  return;
}  // transmitAudioData()

static void extract_v2_packet(int packetSize, uint8_t *fftBuff) {
  // extract v2 packet - assuming a valid packet, as this check was checked
  // alreaedy done in userloop()
  static audioSyncPacket_v2 receivedPacket;
  memcpy(
      &receivedPacket, fftBuff,
      MIN(sizeof(receivedPacket),
          packetSize));  // don't copy more that what fits into audioSyncPacket
  receivedPacket.header[5] = '\0';  // ensure string termination

  // update samples for effects
  float my_volumeSmth = receivedPacket.sampleSmth;
  float my_volumeRaw = receivedPacket.sampleRaw;
  if (my_volumeSmth < 0) my_volumeSmth = 0.0f;
  if (my_volumeRaw < 0) my_volumeRaw = 0;
  // update internal samples
  sampleRaw = my_volumeRaw;
  sampleAvg = my_volumeSmth;
  rawSampleAgc = my_volumeRaw;
  sampleAgc = my_volumeSmth;
  multAgc = 1.0f;

  // auto-reset sample peak. Need to do it here, because getSample() is not
  // running
  uint16_t MinShowDelay = max((uint16_t)33, strip.getMinShowDelay());
  if (millis() - timeOfPeak > MinShowDelay) {  // Auto-reset of samplePeak after
                                               // a complete frame has passed.
    samplePeak = 0;
    udpSamplePeak = 0;
  }
  if (userVar1 == 0) samplePeak = 0;
  // Only change samplePeak IF it's currently false.
  // If it's true already, then the animation still needs to respond.
  if (samplePeak == 0) {
    samplePeak = receivedPacket.samplePeak;
    if (samplePeak > 0) timeOfPeak = millis();
    udpSamplePeak = samplePeak;
    userVar1 = samplePeak;
  }
  // These values are only available on the ESP32
  for (int i = 0; i < 16; i++) fftResult[i] = receivedPacket.fftResult[i];
  FFT_Magnitude = fabsf(receivedPacket.FFT_Magnitude);
  FFT_MajorPeak =
      constrain(receivedPacket.FFT_MajorPeak, 1.0f,
                5120.0f);  // restrict value to range expected by effects

  // fake myVals
  static unsigned int myvals_index = 0;
  myVals[myvals_index] = receivedPacket.sampleRaw;
  myvals_index = (myvals_index + 1) % 32;
  myVals[myvals_index] = receivedPacket.sampleSmth;
  myvals_index = (myvals_index + 1) % 32;
  myVals[random8() % 32] = receivedPacket.sampleSmth;
  myVals[random8() % 32] = receivedPacket.fftResult[2];
  myVals[random8() % 32] = receivedPacket.fftResult[7];
  myVals[random8() % 32] = receivedPacket.fftResult[12];
}

// Create FFT object
static ArduinoFFT<float> FFT = ArduinoFFT<float>(
    vReal, vImag, samplesFFT, SAMPLE_RATE, windowWeighingFactors);

float fftAdd(int from, int to) {
  int i = from;
  float result = 0;
  while (i <= to) {
    result += fftBin[i++];
  }
  return result;
}

// Bandpass filter for PDM microphones
static void runMicFilter(
    uint16_t numSamples,
    float *sampleBuffer) {  // pre-filtering of raw samples (band-pass)
  // band pass filter - can reduce noise floor by a factor of 50
  // downside: frequencies below 60Hz will be ignored

  // low frequency cutoff parameter - see
  // https://dsp.stackexchange.com/questions/40462/exponential-moving-average-cut-off-frequency
  // constexpr float alpha = 0.062f;   // 100Hz
  constexpr float alpha = 0.04883f;  //  80Hz
  // constexpr float alpha = 0.03662f; //  60Hz
  // constexpr float alpha = 0.0225f;  //  40Hz
  //  high frequency cutoff  parameter
  // constexpr float beta1 = 0.75;    //  5Khz
  // constexpr float beta1 = 0.82;    //  7Khz
  constexpr float beta1 = 0.8285;  //  8Khz
  // constexpr float beta1 = 0.85;    // 10Khz

  constexpr float beta2 = (1.0f - beta1) / 2.0;
  static float last_vals[2] = {0.0f};  // FIR high freq cutoff filter
  static float lowfilt = 0.0f;         // IIR low frequency cutoff filter

  for (int i = 0; i < numSamples; i++) {
    // FIR lowpass, to remove high frequency noise
    float highFilteredSample;
    if (i < (numSamples - 1))
      highFilteredSample = beta1 * sampleBuffer[i] + beta2 * last_vals[0] +
                           beta2 * sampleBuffer[i + 1];  // smooth out spikes
    else
      highFilteredSample =
          beta1 * sampleBuffer[i] + beta2 * last_vals[0] +
          beta2 * last_vals[1];  // spcial handling for last sample in array
    last_vals[1] = last_vals[0];
    last_vals[0] = sampleBuffer[i];
    sampleBuffer[i] = highFilteredSample;
    // IIR highpass, to remove low frequency noise
    lowfilt += alpha * (sampleBuffer[i] - lowfilt);
    sampleBuffer[i] = sampleBuffer[i] - lowfilt;
  }
}

// sample smoothing, by using a sliding average FIR highpass filter (first half
// of MicFilter from above)
static void runMicSmoothing(uint16_t numSamples, float *sampleBuffer) {
  constexpr float beta1 = 0.8285;  //  ~8Khz
  constexpr float beta2 =
      (1.0f - beta1) / 2.0;            // note to self: better use biquad ?
  static float last_vals[2] = {0.0f};  // FIR filter buffer

  for (int i = 0; i < numSamples; i++) {
    float highFilteredSample;
    if (i < (numSamples - 1))
      highFilteredSample = beta1 * sampleBuffer[i] + beta2 * last_vals[0] +
                           beta2 * sampleBuffer[i + 1];  // smooth out spikes
    else
      highFilteredSample =
          beta1 * sampleBuffer[i] + beta2 * last_vals[0] +
          beta2 * last_vals[1];  // spcial handling for last sample in array
    last_vals[1] = last_vals[0];
    last_vals[0] = sampleBuffer[i];
    sampleBuffer[i] = highFilteredSample;
  }
}

// a variation of above, with higher cut-off frequency
static void runMicSmoothing_v2(uint16_t numSamples, float *sampleBuffer) {
  constexpr float beta1 = 0.85;  // ~10Khz
  constexpr float beta2 =
      (1.0f - beta1) / 2.0;            // note to self: better use biquad ?
  static float last_vals[2] = {0.0f};  // FIR filter buffer

  for (int i = 0; i < numSamples; i++) {
    float highFilteredSample;
    if (i < (numSamples - 1))
      highFilteredSample = beta1 * sampleBuffer[i] + beta2 * last_vals[0] +
                           beta2 * sampleBuffer[i + 1];  // smooth out spikes
    else
      highFilteredSample =
          beta1 * sampleBuffer[i] + beta2 * last_vals[0] +
          beta2 * last_vals[1];  // spcial handling for last sample in array
    last_vals[1] = last_vals[0];
    last_vals[0] = sampleBuffer[i];
    sampleBuffer[i] = highFilteredSample;
  }
}

// High-Pass filter, 6db per octave
static void runHighFilter6db(const float filter, uint16_t numSamples,
                             float *sampleBuffer) {
  static float lowfilt = 0.0f;  // IIR low frequency cutoff filter
  for (int i = 0; i < numSamples; i++) {
    lowfilt += filter * (sampleBuffer[i] - lowfilt);  // lowpass
    sampleBuffer[i] = sampleBuffer[i] - lowfilt;      // lowpass --> highpass
  }
}

// High-Pass filter, 12db per octave
static void runHighFilter12db(const float filter, uint16_t numSamples,
                              float *sampleBuffer) {
  static float lowfilt1 =
      0.0f;  // IIR low frequency cutoff filter - first pass = 6db
  static float lowfilt2 =
      0.0f;  // IIR low frequency cutoff filter - second pass = 12db
  for (int i = 0; i < numSamples; i++) {
    lowfilt1 += filter * (sampleBuffer[i] - lowfilt1);  // first lowpass 6db
    // lowfilt2 += filter * (lowfilt1 - lowfilt2);     // second lowpass +6db
    // sampleBuffer[i] = sampleBuffer[i] - lowfilt2;   // lowpass --> highpass
    // implementation below has better results, compared to the code above
    float pass1Out =
        sampleBuffer[i] -
        lowfilt1;  // output from first stage (lowpass --> highpass)
    lowfilt2 += filter * (pass1Out - lowfilt2);  // second lowpass +6db
    sampleBuffer[i] = pass1Out - lowfilt2;       // lowpass --> highpass
  }
}

// FFT main code
void FFTcode(void *parameter) {
  DEBUG_PRINT("FFT running on core: ");
  DEBUG_PRINTLN(xPortGetCoreID());

  // see https://www.freertos.org/vtaskdelayuntil.html
  // constexpr TickType_t xFrequency = FFT_MIN_CYCLE * portTICK_PERIOD_MS;
  constexpr TickType_t xFrequency_2 = (FFT_MIN_CYCLE * portTICK_PERIOD_MS) / 2;

  for (;;) {
    TickType_t xLastWakeTime = xTaskGetTickCount();
    delay(1);  // DO NOT DELETE THIS LINE! It is needed to give the IDLE(0) task
               // enough time and to keep the watchdog happy. taskYIELD(),
               // yield(), vTaskDelay() and esp_task_wdt_feed() didn't seem to
               // work.

    // Only run the FFT computing code if we're not in "realime mode" or in
    // Receive mode
    if (disableSoundProcessing || (audioSyncEnabled & (1 << 1))) {
      // delay(7);   // release CPU - delay is implemeted using vTaskDelay()
      vTaskDelayUntil(&xLastWakeTime, xFrequency_2);  // release CPU
      continue;
    }

#if !defined(I2S_GRAB_ADC1_COMPLETELY)
    if (dmType > 0)  // the "delay trick" does not help for analog, because I2S
                     // ADC is disabled outside of getSamples()
#endif
      vTaskDelayUntil(&xLastWakeTime,
                      xFrequency_2);  // release CPU, and give I2S some time to
                                      // fill its buffers. Might not work well
                                      // with ADC analog sources.

    audioSource->getSamples(vReal, samplesFFT);

    xLastWakeTime =
        xTaskGetTickCount();  // update "last unblocked time" for vTaskDelay
// old code - Last sample in vReal is our current mic sample
// micDataSm = (uint16_t)vReal[samples - 1]; // will do a this a bit later

// micDataSm = ((micData * 3) + micData)/4;
#ifdef MIC_LOGGER
    float datMin = 0.0f;
    float datMax = 0.0f;
    double datAvg = 0.0f;
    for (int i = 0; i < samplesFFT; i++) {
      if (i == 0) {
        datMin = datMax = vReal[i];
      } else {
        if (datMin > vReal[i]) datMin = vReal[i];
        if (datMax < vReal[i]) datMax = vReal[i];
      }
      datAvg += vReal[i];
    }
#endif

    // input filters applied before FFT
    if (useInputFilter > 0) {
      // filter parameter - we use constexpr as it does not need any RAM
      // (evaluted at compile time) value = 1 - exp(-2*PI * FFilter / FSample);
      // // FFilter: filter cutoff frequency; FSample: sampling frequency
      constexpr float filter30Hz = 0.01823938f;  // rumbling = 10-25hz
      constexpr float filter70Hz = 0.04204211f;  // mains hum = 50-60hz
      constexpr float filter120Hz =
          0.07098564f;  // bad microphones deliver noise below 120Hz
      constexpr float filter185Hz =
          0.10730882f;  // environmental noise is strongest below 180hz: wind,
                        // engine noise, ...
      switch (useInputFilter) {
        case 1:
          runMicFilter(samplesFFT, vReal);
          break;  // PDM microphone bandpass
        case 2:
          runHighFilter12db(filter30Hz, samplesFFT, vReal);
          break;  // rejects rumbling noise
        case 3:
          runMicSmoothing_v2(
              samplesFFT,
              vReal);  // slightly reduce high frequency noise and artefacts
          runHighFilter12db(filter70Hz, samplesFFT,
                            vReal);  // rejects rumbling + mains hum
          break;
        case 4:
          runMicSmoothing_v2(
              samplesFFT,
              vReal);  // slightly reduce high frequency noise and artefacts
          runHighFilter6db(filter120Hz, samplesFFT,
                           vReal);  // rejects everything below 110Hz
          break;
        case 5:
          runMicSmoothing(samplesFFT,
                          vReal);  // reduce high frequency noise and artefacts
          runHighFilter6db(filter185Hz, samplesFFT,
                           vReal);  // reject low frequency noise
          break;
      }
    }

    // find highest sample in the batch
    const int halfSamplesFFT = samplesFFT / 2;  // samplesFFT divided by 2
    float maxSample1 = 0.0;  // max sample from first half of FFT batch
    float maxSample2 = 0.0;  // max sample from second half of FFT batch
    for (int i = 0; i < samplesFFT; i++) {
      // set imaginary parts to 0
      vImag[i] = 0;
      // pick our  our current mic sample - we take the max value from all
      // samples that go into FFT
      if ((vReal[i] <= (INT16_MAX - 1024)) &&
          (vReal[i] >=
           (INT16_MIN +
            1024)))  // skip extreme values - normally these are artefacts
      {
        if (i <= halfSamplesFFT) {
          if (fabsf(vReal[i]) > maxSample1) maxSample1 = fabsf(vReal[i]);
        } else {
          if (fabsf(vReal[i]) > maxSample2) maxSample2 = fabsf(vReal[i]);
        }
      }
    }
    // release first sample to volume reactive effects
    micDataSm = (uint16_t)maxSample1;
    micDataReal = maxSample1;
#ifdef MIC_LOGGER
    micReal_min = datMin;
    micReal_max = datMax;
    micReal_avg = datAvg / samplesFFT;
#endif

    FFT.dcRemoval();  // remove DC offset
    // FFT.windowing(FFTWindow::Flat_top, FFTDirection::Forward);  // Weigh data
    // using "Flat Top" window - better amplitude accuracy
    FFT.windowing(FFTWindow::Blackman_Harris,
                  FFTDirection::Forward);  // Weigh data using "Blackman-
                                           // Harris" window - sharp peaks due
                                           // to excellent sideband rejection
    FFT.compute(FFTDirection::Forward);    // Compute FFT
    FFT.complexToMagnitude();              // Compute magnitudes
    //
    // vReal[3 .. 255] contain useful data, each a 20Hz interval (60Hz -
    // 5120Hz). There could be interesting data at bins 0 to 2, but there are
    // too many artifacts.
    //

    FFT.majorPeak(vReal, samplesFFT, SAMPLE_RATE, &FFT_MajorPeak,
                  &FFT_Magnitude);
    FFT_MajorPeak =
        constrain(FFT_MajorPeak, 1.0f,
                  5120.0f);  // restrict value to range expected by effects
    FFT_Magnitude = fabsf(FFT_Magnitude);

    for (int i = 0; i < samplesFFT;
         i++) {  // Values for bins 0 and 1 are WAY too large. Might as well
                 // start at 3.
      float t = 0.0;
      t = fabsf(vReal[i]);  // just to be sure - values in fft bins should be
                            // positive any way
      t = t / 16.0f;  // Reduce magnitude. Want end result to be linear and
                      // ~4096 max.
      fftBin[i] = t;
    }  // for()

    /* This FFT post processing is a DIY endeavour. What we really need is
     * someone with sound engineering expertise to do a great job here AND most
     * importantly, that the animations look GREAT as a result.
     *
     *
     * Andrew's updated mapping of 256 bins down to the 16 result bins with
     * Sample Freq = 10240, samplesFFT = 512 and some overlap. Based on testing,
     * the lowest/Start frequency is 60 Hz (with bin 3) and a highest/End
     * frequency of 5120 Hz in bin 255. Now, Take the 60Hz and multiply
     * by 1.320367784 to get the next frequency and so on until the end. Then
     * detetermine the bins. End frequency = Start frequency * multiplier ^ 16
     * Multiplier = (End frequency/ Start frequency) ^ 1/16
     * Multiplier = 1.320367784
     */

    //                                               Range
    fftCalc[0] = (fftAdd(3, 4)) / 2;        // 60 - 100
    fftCalc[1] = (fftAdd(4, 5)) / 2;        // 80 - 120
    fftCalc[2] = (fftAdd(5, 7)) / 3;        // 100 - 160
    fftCalc[3] = (fftAdd(7, 9)) / 3;        // 140 - 200
    fftCalc[4] = (fftAdd(9, 12)) / 4;       // 180 - 260
    fftCalc[5] = (fftAdd(12, 16)) / 5;      // 240 - 340
    fftCalc[6] = (fftAdd(16, 21)) / 6;      // 320 - 440
    fftCalc[7] = (fftAdd(21, 28)) / 8;      // 420 - 600
    fftCalc[8] = (fftAdd(28, 37)) / 10;     // 580 - 760
    fftCalc[9] = (fftAdd(37, 48)) / 12;     // 740 - 980
    fftCalc[10] = (fftAdd(48, 64)) / 17;    // 960 - 1300
    fftCalc[11] = (fftAdd(64, 84)) / 21;    // 1280 - 1700
    fftCalc[12] = (fftAdd(84, 111)) / 28;   // 1680 - 2240
    fftCalc[13] = (fftAdd(111, 147)) / 37;  // 2220 - 2960
    fftCalc[14] = (fftAdd(147, 194)) / 48;  // 2940 - 3900
    fftCalc[15] = (fftAdd(194, 255)) / 62;  // 3880 - 5120

    //   Noise supression of fftCalc bins using soundSquelch adjustment for
    //   different input types.
    for (int i = 0; i < 16; i++) {
      fftCalc[i] =
          fftCalc[i] - (float)soundSquelch * (float)linearNoise[i] / 4.0 <= 0
              ? 0
              : fftCalc[i];
    }

    // Adjustment for frequency curves.
    for (int i = 0; i < 16; i++) {
      fftCalc[i] = fftCalc[i] * fftResultPink[i];
      // fftCalc[i] *= FFTBIN_DOWNSCALE;   // correct magnitutude to fit into [0
      // ... 255]
    }

    // Manual linear adjustment of gain using sampleGain adjustment for
    // different input types.
    for (int i = 0; i < 16; i++) {
      if (soundAgc)
        fftCalc[i] = fftCalc[i] * multAgc;
      else
        fftCalc[i] = fftCalc[i] * (float)sampleGain / 40.0 * inputLevel / 128 +
                     (float)fftCalc[i] / 16.0;  // with inputLevel adjustment
    }

    // Now, let's dump it all into fftResult. Need to do this, otherwise other
    // routines might grab fftResult values prematurely.
    for (int i = 0; i < 16; i++) {
      // fftResult[i] = (int)fftCalc[i];
      fftResult[i] = constrain(
          (int)fftCalc[i], 0,
          254);  // question: why do we constrain values to 8bit here ???
      fftAvg[i] = (float)fftResult[i] * .05 + (1 - .05) * fftAvg[i];
    }

#if !defined(I2S_GRAB_ADC1_COMPLETELY)
    if (dmType > 0)  // the "delay trick" does not help for analog
#endif
      vTaskDelayUntil(
          &xLastWakeTime,
          xFrequency_2);  // release CPU, by waiting until FFT_MIN_CYCLE is over

    // release second sample to volume reactive effects.
    // Releasing a second sample now effectively doubles the "sample rate"
    micDataSm = (uint16_t)maxSample2;
    micDataReal = maxSample2;

    // Looking for fftResultMax for each bin using Pink Noise
    //      for (int i=0; i<16; i++) {
    //          fftResultMax[i] = ((fftResultMax[i] * 63.0) + fftResult[i])
    //          / 64.0;
    //         Serial.print(fftResultMax[i]*fftResultPink[i]);
    //         Serial.print("\t");
    //        }
    //      Serial.println(" ");

  }  // for(;;)
}  // FFTcode()

void logAudio() {
#ifdef MIC_LOGGER
  // Debugging functions for audio input and sound processing. Comment out the
  // values you want to see
  Serial.print("micMin:");
  Serial.print(0.5f * micReal_min);
  Serial.print("\t");
  Serial.print("micMax:");
  Serial.print(0.5f * micReal_max);
  Serial.print("\t");
  Serial.print("micReal:");
  Serial.print(micDataReal + 256.0f);
  Serial.print("\t");
  // Serial.print("micData:");    Serial.print(micData);     Serial.print("\t");
  // Serial.print("micDataSm:");  Serial.print(micDataSm);   Serial.print("\t");
  // Serial.print("micIn:");      Serial.print(micIn);       Serial.print("\t");
  // Serial.print("micLev:");     Serial.print(micLev + 256.0f);
  // Serial.print("\t"); Serial.print("sampleReal:"); Serial.print(sampleReal);
  // Serial.print("\t"); Serial.print("sample:");     Serial.print(sample);
  // Serial.print("\t"); Serial.print("sampleAvg:");  Serial.print(sampleAvg);
  // Serial.print("\t"); Serial.print("sampleMax:");  Serial.print(sampleMax);
  // Serial.print("\t"); Serial.print("samplePeak:");
  // Serial.print((samplePeak!=0) ? 128:0);   Serial.print("\t");
  // Serial.print("multAgc:");    Serial.print(multAgc, 4);  Serial.print("\t");
  Serial.print("sampleAgc:");
  Serial.print(sampleAgc + 256.0f);
  Serial.print("\t");
  Serial.println(" ");
  Serial.flush();

#endif

#ifdef FFT_SAMPLING_LOG
#if 0
    for(int i=0; i<16; i++) {
      Serial.print(fftResult[i]);
      Serial.print("\t");
    }
    Serial.println("");
#endif

  // OPTIONS are in the following format: Description \n Option
  //
  // Set true if wanting to see all the bands in their own vertical space on the
  // Serial Plotter, false if wanting to see values in Serial Monitor
  const bool mapValuesToPlotterSpace = false;
  // Set true to apply an auto-gain like setting to to the data (this hasn't
  // been tested recently)
  const bool scaleValuesFromCurrentMaxVal = false;
  // prints the max value seen in the current data
  const bool printMaxVal = false;
  // prints the min value seen in the current data
  const bool printMinVal = false;
  // if !scaleValuesFromCurrentMaxVal, we scale values from
  // [0..defaultScalingFromHighValue] to [0..scalingToHighValue], lower this if
  // you want to see smaller values easier
  const int defaultScalingFromHighValue = 256;
  // Print values to terminal in range of [0..scalingToHighValue] if
  // !mapValuesToPlotterSpace, or
  // [(i)*scalingToHighValue..(i+1)*scalingToHighValue] if
  // mapValuesToPlotterSpace
  const int scalingToHighValue = 256;
  // set higher if using scaleValuesFromCurrentMaxVal and you want a small value
  // that's also the current maxVal to look small on the plotter (can't be 0 to
  // avoid divide by zero error)
  const int minimumMaxVal = 1;

  int maxVal = minimumMaxVal;
  int minVal = 0;
  for (int i = 0; i < 16; i++) {
    if (fftResult[i] > maxVal) maxVal = fftResult[i];
    if (fftResult[i] < minVal) minVal = fftResult[i];
  }
  for (int i = 0; i < 16; i++) {
    Serial.print(i);
    Serial.print(":");
    Serial.printf(
        "%04d ",
        map(fftResult[i], 0,
            (scaleValuesFromCurrentMaxVal ? maxVal
                                          : defaultScalingFromHighValue),
            (mapValuesToPlotterSpace * i * scalingToHighValue) + 0,
            (mapValuesToPlotterSpace * i * scalingToHighValue) +
                scalingToHighValue - 1));
  }
  if (printMaxVal) {
    Serial.printf("maxVal:%04d ",
                  maxVal + (mapValuesToPlotterSpace ? 16 * 256 : 0));
  }
  if (printMinVal) {
    Serial.printf("%04d:minVal ",
                  minVal);  // printed with value first, then label, so negative
                            // values can be seen in Serial Monitor but don't
                            // throw off y axis in Serial Plotter
  }
  if (mapValuesToPlotterSpace)
    Serial.printf("max:%04d ",
                  (printMaxVal ? 17 : 16) *
                      256);  // print line above the maximum value we expect to
                             // see on the plotter to avoid autoscaling y axis
  else
    Serial.printf("max:%04d ", 256);
  Serial.println();
#endif  // FFT_SAMPLING_LOG
}  // logAudio()

=== ./audio_source.h ===

#pragma once

#include <Wire.h>
#include "wled.h"
#include <driver/i2s.h>
#include <driver/adc.h>
#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0)
#include <driver/adc_deprecated.h>
#include <driver/adc_types_deprecated.h>
#endif

//#include <driver/i2s_std.h>
//#include <driver/i2s_pdm.h>
//#include <driver/gpio.h>

/* ToDo: remove. ES7243 is controlled via compiler defines
   Until this configuration is moved to the webinterface
*/


// data type requested from the I2S driver - currently we always use 32bit
//#define I2S_USE_16BIT_SAMPLES    // (experimental) define this to request 16bit - more efficient but possibly less compatible

// if you have problems to get your microphone work on the left channel, uncomment the following line
//#define I2S_USE_RIGHT_CHANNEL    // (experimental) define this to use right channel (digital mics only)

// Uncomment the line below to utilize ADC1 _exclusively_ for I2S sound input.
// benefit: analog mic inputs will be sampled contiously -> better response times and less "glitches"
// WARNING: this option WILL lock-up your device in case that any other analogRead() operation is performed; 
//          for example if you want to read "analog buttons"
//#define I2S_GRAB_ADC1_COMPLETELY // (experimental) continously sample analog ADC microphone. WARNING will cause analogRead() lock-up 


#ifdef I2S_USE_16BIT_SAMPLES
#define I2S_SAMPLE_RESOLUTION I2S_BITS_PER_SAMPLE_16BIT
#define I2S_datatype int16_t
#define I2S_unsigned_datatype uint16_t
#undef  I2S_SAMPLE_DOWNSCALE_TO_16BIT
#else
#define I2S_SAMPLE_RESOLUTION I2S_BITS_PER_SAMPLE_32BIT
#define I2S_datatype int32_t
#define I2S_unsigned_datatype uint32_t
#define I2S_SAMPLE_DOWNSCALE_TO_16BIT
#endif

#ifdef I2S_USE_RIGHT_CHANNEL
#define I2S_MIC_CHANNEL I2S_CHANNEL_FMT_ONLY_RIGHT
#define I2S_MIC_CHANNEL_TEXT "right channel only."
#else
#define I2S_MIC_CHANNEL I2S_CHANNEL_FMT_ONLY_LEFT
#define I2S_MIC_CHANNEL_TEXT "left channel only."
#endif


#ifndef ES7243_ADDR
    static int addr_ES7243 = 0x13;
#else
    static int addr_ES7243 =  ES7243_ADDR;
#endif

#ifndef ES7243_SDAPIN
    int pin_ES7243_SDA = 18;
#else
    int pin_ES7243_SDA =  ES7243_SDAPIN;
#endif

#ifndef ES7243_SDAPIN
    static int pin_ES7243_SCL = 23;
#else
    static int pin_ES7243_SCL =  ES7243_SCLPIN;
#endif

/* Interface class
   AudioSource serves as base class for all microphone types
   This enables accessing all microphones with one single interface
   which simplifies the caller code
*/
class AudioSource {
public:
    /* All public methods are virtual, so they can be overridden
       Everything but the destructor is also removed, to make sure each mic
       Implementation provides its version of this function
    */
    virtual ~AudioSource() {};

    /* Initialize
       This function needs to take care of anything that needs to be done
       before samples can be obtained from the microphone.
    */
    virtual void initialize() = 0;

    /* Deinitialize
       Release all resources and deactivate any functionality that is used
       by this microphone
    */
    virtual void deinitialize() = 0;

    /* getSamples
       Read num_samples from the microphone, and store them in the provided
       buffer
    */
    virtual void getSamples(float *buffer, uint16_t num_samples) = 0;

    /* Get an up-to-date sample without DC offset */
    virtual int getSampleWithoutDCOffset() = 0;

    /* check if the audio source driver was initialized successfully */
    virtual bool isInitialized(void) {return(_initialized);}

protected:
    // Private constructor, to make sure it is not callable except from derived classes
    AudioSource(int sampleRate, int blockSize, int16_t lshift, uint32_t mask, float sampleScale) : 
        _sampleRate(sampleRate), _blockSize(blockSize), _sampleNoDCOffset(0), _dcOffset(0.0f), 
        _shift(lshift), _mask(mask), _sampleScale(sampleScale), 
        _initialized(false), _myADCchannel(0x0F), _lastADCsample(0), _broken_samples_counter(0) 
    {};

    int _sampleRate;                /* Microphone sampling rate (from uint16_t to int to suppress warning)*/ 
    int _blockSize;                 /* I2S block size */
    volatile int _sampleNoDCOffset; /* Up-to-date sample without DCOffset */
    float _dcOffset;                /* Rolling average DC offset */
    int16_t _shift;                /* Shift obtained samples to the right (positive) or left(negative) by this amount */
    uint32_t _mask;                 /* Bitmask for sample data after shifting. Bitmask 0X0FFF means that we need to convert 12bit ADC samples from unsigned to signed*/
    float _sampleScale;             // pre-scaling factor for I2S samples
    bool _initialized;              /* Gets set to true if initialization is successful */
    int8_t _myADCchannel;           /* current ADC channel, in case of analog input. 0x0F if undefined */
    I2S_datatype _lastADCsample;    /* last sample from ADC */
    I2S_datatype decodeADCsample(I2S_unsigned_datatype rawData); /* function to handle ADC samples */
    unsigned int _broken_samples_counter; /* counts number of broken (and fixed) ADC samples */
};

/* Basic I2S microphone source
   All functions are marked virtual, so derived classes can replace them
*/
class I2SSource : public AudioSource {
public:
    I2SSource(int sampleRate, int blockSize, int16_t lshift, uint32_t mask, float sampleScale = 1.0f) :
        AudioSource(sampleRate, blockSize, lshift, mask, sampleScale) {
        _config = {
            .mode = i2s_mode_t(I2S_MODE_MASTER | I2S_MODE_RX),
            .sample_rate = _sampleRate,                       // "narrowing conversion" warning can be ignored here - our _sampleRate is never bigger that INT32_MAX
            .bits_per_sample = I2S_SAMPLE_RESOLUTION,
            .channel_format = I2S_MIC_CHANNEL,
#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0)
            .communication_format = i2s_comm_format_t(I2S_COMM_FORMAT_STAND_I2S),
#else
            .communication_format = i2s_comm_format_t(I2S_COMM_FORMAT_I2S | I2S_COMM_FORMAT_I2S_MSB),
#endif
            .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
            .dma_buf_count = 8,
            .dma_buf_len = _blockSize
        };

        _pinConfig = {
            #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0)
            .mck_io_num = I2S_PIN_NO_CHANGE, // needed, otherwise i2s_set_pin() will fail in IDF >=4.4.x
            #endif
            .bck_io_num = i2sckPin,
            .ws_io_num = i2swsPin,
            .data_out_num = I2S_PIN_NO_CHANGE,
            .data_in_num = i2ssdPin
        };
    };




    virtual void initialize() {

        if (!pinManager.allocatePin(i2swsPin, true, PinOwner::DigitalMic) ||
            !pinManager.allocatePin(i2ssdPin, false, PinOwner::DigitalMic) ||
            (i2ssdPin < 0) || (i2swsPin < 0)) {
                if (serialTxAvaileable) Serial.printf("Failed to set I2S GPIO pins: SD=%d WS=%d \n", i2ssdPin, i2swsPin);
                return;
        }

        // i2ssckPin needs special treatment, since it might be unused on PDM mics
        if (i2sckPin != -1) {
            if (!pinManager.allocatePin(i2sckPin, true, PinOwner::DigitalMic)) {
                if (serialTxAvaileable) Serial.printf("Failed to allocate I2S GPIO pin: SCK=%d \n", i2sckPin);
                return;
            }
        }

        #if defined(ARDUINO_ARCH_ESP32) && !defined(CONFIG_IDF_TARGET_ESP32S3) && !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
        if (ESP.getChipRevision() == 0) _config.use_apll = false; // APLL is broken on ESP32 revision 0, so we disable it on rev0 chips
        #endif

        esp_err_t err = i2s_driver_install(I2S_NUM_0, &_config, 0, nullptr);
        if (err != ESP_OK) {
            if (serialTxAvaileable) Serial.printf("Failed to install i2s driver: %d\n", err);
            return;
        }

        err = i2s_set_pin(I2S_NUM_0, &_pinConfig);
        if (err != ESP_OK) {
            if (serialTxAvaileable) Serial.printf("Failed to set i2s pin config: %d\n", err);
            return;
        }

        _initialized = true;
    }

    virtual void deinitialize() {
        if (_initialized) {
            _initialized = false;
            esp_err_t err = i2s_driver_uninstall(I2S_NUM_0);
            if (err != ESP_OK) {
                if (serialTxAvaileable) Serial.printf("Failed to uninstall i2s driver: %d\n", err);
                return;
            }
        }
        pinManager.deallocatePin(i2swsPin, PinOwner::DigitalMic);
        pinManager.deallocatePin(i2ssdPin, PinOwner::DigitalMic);
        // i2ssckPin needs special treatment, since it might be unused on PDM mics
        if (i2sckPin != -1) {
            pinManager.deallocatePin(i2sckPin, PinOwner::DigitalMic);
        }
    }

    virtual void getSamples(float *buffer, uint16_t num_samples) {
        if(_initialized) {
            esp_err_t err;
            size_t bytes_read = 0;        /* Counter variable to check if we actually got enough data */
            I2S_datatype newSamples[num_samples]; /* Intermediary sample storage */
           
            _dcOffset = 0.0f;              // Reset dc offset
            _broken_samples_counter = 0;   // Reset ADC broken samples counter

            // get fresh samples
            err = i2s_read(I2S_NUM_0, (void *)newSamples, sizeof(newSamples), &bytes_read, portMAX_DELAY);
            if ((err != ESP_OK)) {
                if (serialTxAvaileable) Serial.printf("Failed to get samples: %d\n", err);
                return;
            }

            // For correct operation, we need to read exactly sizeof(samples) bytes from i2s
            if(bytes_read != sizeof(newSamples)) {
                if (serialTxAvaileable) Serial.printf("Failed to get enough samples: wanted: %d read: %d\n", sizeof(newSamples), bytes_read);
                return;
            }

            // Store samples in sample buffer and update DC offset
            for (int i = 0; i < num_samples; i++) {

                if (_mask == 0x0FFF) {  // mask = 0x0FFF means we are in I2SAdcSource
                    I2S_unsigned_datatype rawData = * reinterpret_cast<I2S_unsigned_datatype *> (newSamples + i); // C++ acrobatics to get sample as "unsigned"
                    I2S_datatype sampleNoFilter = decodeADCsample(rawData);
                    if (_broken_samples_counter >= num_samples-1) {             // kill-switch: ADC sample correction off when all samples in a batch were "broken"
                        _myADCchannel = 0x0F;
                        if (serialTxAvaileable) Serial.println("AS: too many broken audio samples from ADC - sample correction switched off.");
                    }

                    newSamples[i] = (3 * sampleNoFilter + _lastADCsample) / 4;  // apply low-pass filter (2-tap FIR)
                    //newSamples[i] = (sampleNoFilter + lastADCsample) / 2;      // apply stronger low-pass filter (2-tap FIR)
                    _lastADCsample = sampleNoFilter;                            // update ADC last sample
                }

                // pre-shift samples down to 16bit
#ifdef I2S_SAMPLE_DOWNSCALE_TO_16BIT
                if (_shift != 0)
                    newSamples[i] >>= 16;
#endif
                float currSample = 0.0;
                if(_shift > 0)
                  currSample = (float) (newSamples[i] >> _shift);
                else {
                  if(_shift < 0)
                    currSample = (float) (newSamples[i] << (- _shift)); // need to "pump up" 12bit ADC to full 16bit as delivered by other digital mics
                  else
#ifdef I2S_SAMPLE_DOWNSCALE_TO_16BIT
                    currSample = (float) newSamples[i] / 65536.0f;        // _shift == 0 -> use the chance to keep lower 16bits
#else
                    currSample = (float) newSamples[i];
#endif
                }
                buffer[i] = currSample;                                   // store sample
                buffer[i] *= _sampleScale;                                // scale sample
                _dcOffset = ((_dcOffset * 31) + currSample) / 32;
            }

            // Update no-DC sample
            _sampleNoDCOffset = buffer[num_samples - 1] - _dcOffset;
        }
    }

    // function to handle ADC samples
    I2S_datatype decodeADCsample(I2S_unsigned_datatype rawData) {
#ifndef I2S_USE_16BIT_SAMPLES
        rawData = (rawData >> 16) & 0xFFFF;                        // scale input down from 32bit -> 16bit
        I2S_datatype lastGoodSample = _lastADCsample / 16384 ;     // 26bit-> 12bit with correct sign handling
#else
        rawData = rawData & 0xFFFF;                                // input is already in 16bit, just mask off possible junk
        I2S_datatype lastGoodSample = _lastADCsample * 4;          // 10bit-> 12bit
#endif
        // decode ADC sample
        uint16_t the_channel = (rawData >> 12) & 0x000F;           // upper 4 bit = ADC channel
        uint16_t the_sample  =  rawData & 0x0FFF;                  // lower 12bit -> ADC sample (unsigned)
        I2S_datatype finalSample = (int(the_sample) - 2048);       // convert to signed (centered at 0);

        // fix bad samples
        if ((the_channel != _myADCchannel) && (_myADCchannel != 0x0F)) { // 0x0F means "don't know what my channel is" 
            finalSample = lastGoodSample;                         // replace with the last good ADC sample
            _broken_samples_counter ++;
            //Serial.print("\n!ADC rogue sample 0x"); Serial.print(rawData, HEX); Serial.print("\tchannel:");Serial.println(the_channel);
        }
#ifndef I2S_USE_16BIT_SAMPLES
        finalSample = finalSample << 16;    // scale up from 16bit -> 32bit;
#endif
        finalSample = finalSample / 4;      // mimic old analog driver behaviour (12bit -> 10bit)
        return(finalSample);
    }

    virtual int getSampleWithoutDCOffset() {
        return _sampleNoDCOffset;
    }

protected:
    i2s_config_t _config;
    i2s_pin_config_t _pinConfig;
};

/* I2S microphone with master clock
   Our version of the IDF does not support setting master clock
   routing via the provided API, so we have to do it by hand
*/
class I2SSourceWithMasterClock : public I2SSource {
public:
    I2SSourceWithMasterClock(int sampleRate, int blockSize, int16_t lshift, uint32_t mask, float sampleScale = 1.0f) :
        I2SSource(sampleRate, blockSize, lshift, mask, sampleScale) {
    };

    virtual void initialize() {
        // Reserve the master clock pin
        if(!pinManager.allocatePin(mclkPin, true, PinOwner::DigitalMic)) {
            if (serialTxAvaileable) Serial.printf("Failed to allocate I2S GPIO pin: MCLK=%d \n", mclkPin);
            return;
        }
        if ((mclkPin != GPIO_NUM_0) && (mclkPin != GPIO_NUM_1) && (mclkPin != GPIO_NUM_3)) {
            if (serialTxAvaileable) Serial.printf("Failed to set gpio %d as i2s MCLK pin. Only GPIO0, GPIO1 or GPIO3 are possible on ESP32\n", mclkPin);
            return;
        }
        if (i2sckPin < 0) {
            if (serialTxAvaileable) Serial.printf("Failed to set gpio %d as i2s SCK pin.\n", i2sckPin);
            return;
        }
        _routeMclk();
        I2SSource::initialize();

    }

    virtual void deinitialize() {
        // Release the master clock pin
        pinManager.deallocatePin(mclkPin, PinOwner::DigitalMic);
        I2SSource::deinitialize();
    }
protected:
    void _routeMclk() {
        /* Enable the mclk routing depending on the selected mclk pin
           Only I2S_NUM_0 is supported
        */
        if (mclkPin == GPIO_NUM_0) {
            PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U, FUNC_GPIO0_CLK_OUT1);
            WRITE_PERI_REG(PIN_CTRL,0xFFF0);
        } else if (mclkPin == GPIO_NUM_1) {
            PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0TXD_U, FUNC_U0TXD_CLK_OUT3);
            WRITE_PERI_REG(PIN_CTRL, 0xF0F0);
        } else {
            PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0RXD_U, FUNC_U0RXD_CLK_OUT2);
            WRITE_PERI_REG(PIN_CTRL, 0xFF00);
        }
    }
};

/* ES7243 Microphone
   This is an I2S microphone that requires ininitialization over
   I2C before I2S data can be received
*/
class ES7243 : public I2SSourceWithMasterClock {

private:
    // I2C initialization functions for ES7243
    void _es7243I2cBegin() {
        Wire.begin(pin_ES7243_SDA, pin_ES7243_SCL, 100000U);
    }

    void _es7243I2cWrite(uint8_t reg, uint8_t val) {
        Wire.beginTransmission(addr_ES7243);
        Wire.write((uint8_t)reg);
        Wire.write((uint8_t)val);
        uint8_t i2cErr = Wire.endTransmission();  // i2cErr == 0 means OK
        if ((i2cErr != 0) && serialTxAvaileable) Serial.printf("ES7243: I2C write failed with error=%d  (reg 0x%X, val 0x%X).\n", i2cErr, reg, val);
    }

    void _es7243InitAdc() {
        _es7243I2cBegin();
        _es7243I2cWrite(0x00, 0x01);
        _es7243I2cWrite(0x06, 0x00);
        _es7243I2cWrite(0x05, 0x1B);
        _es7243I2cWrite(0x01, 0x00); // 0x00 for 24 bit to match INMP441 - not sure if this needs adjustment to get 16bit samples from I2S
        _es7243I2cWrite(0x08, 0x43);
        _es7243I2cWrite(0x05, 0x13);
    }

public:

    ES7243(int sampleRate, int blockSize, int16_t lshift, uint32_t mask, float sampleScale = 1.0f) :
        I2SSourceWithMasterClock(sampleRate, blockSize, lshift, mask, sampleScale) {
        _config.channel_format = I2S_CHANNEL_FMT_ONLY_RIGHT;
    };
    void initialize() {
        if ((pin_ES7243_SDA < 0) || (pin_ES7243_SCL < 0)) {
            if (serialTxAvaileable) Serial.printf("ES7243: invalid i2c GPIO pins: SDA=%d SCL=%d \n", pin_ES7243_SDA, pin_ES7243_SCL);
            return;
        }
        // Reserve SDA and SCL pins of the I2C interface
        if (!pinManager.allocatePin(pin_ES7243_SDA, true, PinOwner::DigitalMic) ||
            !pinManager.allocatePin(pin_ES7243_SCL, true, PinOwner::DigitalMic)) {
                if (serialTxAvaileable) Serial.printf("ES7243: failed to allocate i2c GPIO pins: SDA=%d SCL=%d \n", pin_ES7243_SDA, pin_ES7243_SCL);
                return;
            }

        // First route mclk, then configure ADC over I2C, then configure I2S
        _es7243InitAdc();
        I2SSourceWithMasterClock::initialize();
    }

    void deinitialize() {
        // Release SDA and SCL pins of the I2C interface
        pinManager.deallocatePin(pin_ES7243_SDA, PinOwner::DigitalMic);
        pinManager.deallocatePin(pin_ES7243_SCL, PinOwner::DigitalMic);
        I2SSourceWithMasterClock::deinitialize();
    }
};

/* ADC over I2S Microphone
   This microphone is an ADC pin sampled via the I2S interval
   This allows to use the I2S API to obtain ADC samples with high sample rates
   without the need of manual timing of the samples
*/
class I2SAdcSource : public I2SSource {
public:
    I2SAdcSource(int sampleRate, int blockSize, int16_t lshift, uint32_t mask, float sampleScale = 1.0f) :
        I2SSource(sampleRate, blockSize, lshift, mask, sampleScale){
        _config = {
            .mode = i2s_mode_t(I2S_MODE_MASTER | I2S_MODE_RX | I2S_MODE_ADC_BUILT_IN),
            .sample_rate = _sampleRate,                       // "narrowing conversion" warning can be ignored here - our _sampleRate is never bigger that INT32_MAX
            .bits_per_sample = I2S_SAMPLE_RESOLUTION,
            .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0)
            .communication_format = i2s_comm_format_t(I2S_COMM_FORMAT_STAND_I2S),
#else
            .communication_format = i2s_comm_format_t(I2S_COMM_FORMAT_I2S | I2S_COMM_FORMAT_I2S_MSB),
#endif
            .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
            .dma_buf_count = 8,
            .dma_buf_len = _blockSize,
            .use_apll    = false, // must be disabled for analog microphone
            .tx_desc_auto_clear = false,
            .fixed_mclk = 0
        };
    }

    void initialize() {

        // check if "analog buttons" are configured for ADC1, and issue warning
        for (int b=0; b<WLED_MAX_BUTTONS; b++) {
            //if ((btnPin[b] >= 0) && (buttonType[b] == BTN_TYPE_ANALOG || buttonType[b] == BTN_TYPE_ANALOG_INVERTED) && (digitalPinToAnalogChannel(btnPin[b]) < 10)) {
            if ((btnPin[b] >= 0) && (buttonType[b] == BTN_TYPE_ANALOG || buttonType[b] == BTN_TYPE_ANALOG_INVERTED) && (digitalPinToAnalogChannel(btnPin[b]) >= 0)) {
              if (serialTxAvaileable) {
                Serial.println("AS: Analog Microphone does not work reliably when analog buttons are configured on ADC1.");
                Serial.printf( "    Button %d GPIO %d\n", b, btnPin[b]);
                Serial.println("    To recover, please disable any analog button in LED preferences, then restart your device.");
                Serial.flush();
              }
#ifdef I2S_GRAB_ADC1_COMPLETELY
                if (serialTxAvaileable) Serial.println("AS: Analog Microphone initialization aborted. Cannot use ADC1 exclusively");
                return;
#endif
            }
        }

        if(!pinManager.allocatePin(audioPin, false, PinOwner::AnalogMic)) {
            if (serialTxAvaileable) Serial.printf("AS: failed to allocate GPIO pin %d.\n", audioPin);
            return;
        }
        // Determine Analog channel. Only Channels on ADC1 are supported
        int8_t channel = digitalPinToAnalogChannel(audioPin);
        if ((channel < 0) || (channel > 9)) {  // channel == -1 means "not an ADC pin"
            if (serialTxAvaileable) Serial.printf("Incompatible GPIO used for audio in: %d\n", audioPin);
            return;
        } else {
            adc_gpio_init(ADC_UNIT_1, adc_channel_t(channel));
        }
        _myADCchannel = channel;
        _lastADCsample = 0;

        // Install Driver
        esp_err_t err = i2s_driver_install(I2S_NUM_0, &_config, 0, nullptr);
        if (err != ESP_OK) {
            if (serialTxAvaileable) Serial.printf("Failed to install i2s driver: %d\n", err);
            return;
        }

       //adc1_config_width(ADC_WIDTH_BIT_12);   // ensure that ADC1 runs at 12bit resolution - should not be needed, because i2s_set_adc_mode does that anyway

        // Enable I2S mode of ADC
        err = i2s_set_adc_mode(ADC_UNIT_1, adc1_channel_t(channel));
        if (err != ESP_OK) {
            if (serialTxAvaileable) Serial.printf("Failed to set i2s adc mode: %d\n", err);
            return;

        }

        // see example in https://github.com/espressif/arduino-esp32/blob/master/libraries/ESP32/examples/I2S/HiFreq_ADC/HiFreq_ADC.ino
        adc1_config_channel_atten(adc1_channel_t(channel), ADC_ATTEN_DB_11);   // configure ADC input amplification

#if defined(I2S_GRAB_ADC1_COMPLETELY)
        // according to docs from espressif, the ADC needs to be started explicitly
        // fingers crossed
        err = i2s_adc_enable(I2S_NUM_0);
        if (err != ESP_OK) {
            if (serialTxAvaileable) Serial.printf("Failed to enable i2s adc: %d\n", err);
            //return;
        }
#else
        //err = i2s_adc_disable(I2S_NUM_0); // seems that disable without previous enable causes a crash/bootloop on some boards
		//err = i2s_stop(I2S_NUM_0);
        if (err != ESP_OK) {
            if (serialTxAvaileable) Serial.printf("Failed to initially disable i2s adc: %d\n", err);
        }
#endif
        _initialized = true;
    }

    void getSamples(float *buffer, uint16_t num_samples) {

    /* Enable ADC. This has to be enabled and disabled directly before and
    after sampling, otherwise Wifi dies and analogRead() hangs
    */
        if (_initialized) {
#if !defined(I2S_GRAB_ADC1_COMPLETELY)
			//esp_err_t err = i2s_start(I2S_NUM_0);
            esp_err_t err = i2s_adc_enable(I2S_NUM_0);
            if (err != ESP_OK) {
                if (serialTxAvaileable) Serial.printf("Failed to enable i2s adc: %d\n", err);
                return;
            }
#endif
            I2SSource::getSamples(buffer, num_samples);

#if !defined(I2S_GRAB_ADC1_COMPLETELY)
            err = i2s_adc_disable(I2S_NUM_0);
			//err = i2s_stop(I2S_NUM_0);
            if (err != ESP_OK) {
                if (serialTxAvaileable) Serial.printf("Failed to disable i2s adc: %d\n", err);
                return;
            }
#endif
        }
    }

    void deinitialize() {
        pinManager.deallocatePin(audioPin, PinOwner::AnalogMic);
        esp_err_t err;
        if (_initialized) {
            _initialized = false;
#if defined(I2S_GRAB_ADC1_COMPLETELY)
            // according to docs from espressif, the ADC needs to be stopped explicitly
            // fingers crossed
            err = i2s_adc_disable(I2S_NUM_0);
            if (err != ESP_OK) {
                if (serialTxAvaileable) Serial.printf("Failed to disable i2s adc: %d\n", err);
                //return;
            }
#endif
            i2s_adc_disable(I2S_NUM_0);     // just to be sure
            i2s_stop(I2S_NUM_0);
            err = i2s_driver_uninstall(I2S_NUM_0);
            if (err != ESP_OK) {
                if (serialTxAvaileable) Serial.printf("Failed to uninstall i2s driver: %d\n", err);
                return;
            }
        }
        _myADCchannel = 0x0F;
        _lastADCsample = 0;
    }
};

/* SPH0645 Microphone
   This is an I2S microphone with some timing quirks that need
   special consideration.
*/
class SPH0654 : public I2SSource {

public:
    SPH0654(int sampleRate, int blockSize, int16_t lshift, uint32_t mask, float sampleScale = 1.0f) :
        I2SSource(sampleRate, blockSize, lshift, mask, sampleScale){}

    void initialize() {
        I2SSource::initialize();
        REG_SET_BIT(I2S_TIMING_REG(I2S_NUM_0), BIT(9));
        REG_SET_BIT(I2S_CONF_REG(I2S_NUM_0), I2S_RX_MSB_SHIFT);
    }
};

/* I2S PDM Microphone
   This is an I2S PDM microphone, these microphones only use a clock and
   data line, to make it simpler to debug, use the WS pin as CLK and SD
   pin as DATA
*/

class I2SPdmSource : public I2SSource {

public:
    I2SPdmSource(int sampleRate, int blockSize, int16_t lshift, uint32_t mask, float sampleScale = 1.0f) :
        I2SSource(sampleRate, blockSize, lshift, mask, sampleScale) {

        _config.mode = i2s_mode_t(I2S_MODE_MASTER | I2S_MODE_RX | I2S_MODE_PDM); // Change mode to pdm
        _config.use_apll = 1;

        _pinConfig = {
            #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0)
            .mck_io_num = I2S_PIN_NO_CHANGE, // needed, otherwise i2s_set_pin() will fail in IDF >=4.4.x
            #endif
            .bck_io_num = I2S_PIN_NO_CHANGE, // bck is unused in PDM mics
            .ws_io_num = i2swsPin, // clk pin for PDM mic
            .data_out_num = I2S_PIN_NO_CHANGE,
            .data_in_num = i2ssdPin
        };
    }
};

=== ./bus_manager.h ===

#ifndef BusManager_h
#define BusManager_h

/*
 * Class for addressing various light types
 */

#include "const.h"
#include "pin_manager.h"
#include "bus_wrapper.h"
#include <Arduino.h>

//colors.cpp
uint32_t colorBalanceFromKelvin(uint16_t kelvin, uint32_t rgb);
void colorRGBtoRGBW(byte* rgb);

// enable additional debug output
#ifdef WLED_DEBUG
  #ifndef ESP8266
  #include <rom/rtc.h>
  #endif
  #define DEBUG_PRINT(x) Serial.print(x)
  #define DEBUG_PRINTLN(x) Serial.println(x)
  #define DEBUG_PRINTF(x...) Serial.printf(x)
#else
  #define DEBUG_PRINT(x)
  #define DEBUG_PRINTLN(x)
  #define DEBUG_PRINTF(x...)
#endif

#define GET_BIT(var,bit)    (((var)>>(bit))&0x01)
#define SET_BIT(var,bit)    ((var)|=(uint16_t)(0x0001<<(bit)))
#define UNSET_BIT(var,bit)  ((var)&=(~(uint16_t)(0x0001<<(bit))))

//color mangling macros
#define RGBW32(r,g,b,w) (uint32_t((byte(w) << 24) | (byte(r) << 16) | (byte(g) << 8) | (byte(b))))
#define R(c) (byte((c) >> 16))
#define G(c) (byte((c) >> 8))
#define B(c) (byte(c))
#define W(c) (byte((c) >> 24))

//temporary struct for passing bus configuration to bus
struct BusConfig {
  uint8_t type = TYPE_WS2812_RGB;
  uint16_t count;
  uint16_t start;
  uint8_t colorOrder;
  bool reversed;
  uint8_t skipAmount;
  bool refreshReq;
  uint8_t pins[5] = {LEDPIN, 255, 255, 255, 255};
  BusConfig(uint8_t busType, uint8_t* ppins, uint16_t pstart, uint16_t len = 1, uint8_t pcolorOrder = COL_ORDER_GRB, bool rev = false, uint8_t skip = 0) {
    refreshReq = (bool) GET_BIT(busType,7);
    type = busType & 0x7F;  // bit 7 may be/is hacked to include refresh info (1=refresh in off state, 0=no refresh)
    count = len; start = pstart; colorOrder = pcolorOrder; reversed = rev; skipAmount = skip;
    uint8_t nPins = 1;
    if (type >= TYPE_NET_DDP_RGB && type < 96) nPins = 4; //virtual network bus. 4 "pins" store IP address
    else if (type > 47) nPins = 2;
    else if (type > 40 && type < 46) nPins = NUM_PWM_PINS(type);
    for (uint8_t i = 0; i < nPins; i++) pins[i] = ppins[i];
  }

  //validates start and length and extends total if needed
  bool adjustBounds(uint16_t& total) {
    if (!count) count = 1;
    if (count > MAX_LEDS_PER_BUS) count = MAX_LEDS_PER_BUS;
    if (start >= MAX_LEDS) return false;
    //limit length of strip if it would exceed total permissible LEDs
    if (start + count > MAX_LEDS) count = MAX_LEDS - start;
    //extend total count accordingly
    if (start + count > total) total = start + count;
    return true;
  }
};

// Defines an LED Strip and its color ordering.
struct ColorOrderMapEntry {
  uint16_t start;
  uint16_t len;
  uint8_t colorOrder;
};

struct ColorOrderMap {
  void add(uint16_t start, uint16_t len, uint8_t colorOrder) {
    if (_count >= WLED_MAX_COLOR_ORDER_MAPPINGS) {
      return;
    }
    if (len == 0) {
      return;
    }
    if (colorOrder > COL_ORDER_MAX) {
      return;
    }
    _mappings[_count].start = start;
    _mappings[_count].len = len;
    _mappings[_count].colorOrder = colorOrder;
    _count++;
  }

  uint8_t count() const {
    return _count;
  }

  void reset() {
    _count = 0;
    memset(_mappings, 0, sizeof(_mappings));
  }

  const ColorOrderMapEntry* get(uint8_t n) const {
    if (n > _count) {
      return nullptr;
    }
    return &(_mappings[n]);
  }

  inline uint8_t IRAM_ATTR getPixelColorOrder(uint16_t pix, uint8_t defaultColorOrder) const {
    if (_count == 0) return defaultColorOrder;

    for (uint8_t i = 0; i < _count; i++) {
      if (pix >= _mappings[i].start && pix < (_mappings[i].start + _mappings[i].len)) {
        return _mappings[i].colorOrder;
      }
    }
    return defaultColorOrder;
  }

  private:
  uint8_t _count;
  ColorOrderMapEntry _mappings[WLED_MAX_COLOR_ORDER_MAPPINGS];
};

//parent class of BusDigital, BusPwm, and BusNetwork
class Bus {
  public:
    Bus(uint8_t type, uint16_t start) {
      _type = type;
      _start = start;
    };

    virtual ~Bus() {} //throw the bus under the bus

    virtual void     show() {}
    virtual bool     canShow() { return true; }
		virtual void     setStatusPixel(uint32_t c) {}
    virtual void     setPixelColor(uint16_t pix, uint32_t c) {}
    virtual uint32_t getPixelColor(uint16_t pix) { return 0; }
    virtual void     setBrightness(uint8_t b) {}
    virtual void     cleanup() {}
    virtual uint8_t  getPins(uint8_t* pinArray) { return 0; }
    virtual uint16_t getLength() { return _len; }
    virtual void     setColorOrder() {}
    virtual uint8_t  getColorOrder() { return COL_ORDER_RGB; }
    virtual uint8_t  skippedLeds() { return 0; }
    inline  uint16_t getStart() { return _start; }
    inline  void     setStart(uint16_t start) { _start = start; }
    inline  uint8_t  getType() { return _type; }
    inline  bool     isOk() { return _valid; }
    inline  bool     isOffRefreshRequired() { return _needsRefresh; }
            bool     containsPixel(uint16_t pix) { return pix >= _start && pix < _start+_len; }

    virtual bool isRgbw() { return Bus::isRgbw(_type); }
    static  bool isRgbw(uint8_t type) {
      if (type == TYPE_SK6812_RGBW || type == TYPE_TM1814) return true;
      if (type > TYPE_ONOFF && type <= TYPE_ANALOG_5CH && type != TYPE_ANALOG_3CH) return true;
      return false;
    }
    static void setCCT(uint16_t cct) {
      _cct = cct;
    }
		static void setCCTBlend(uint8_t b) {
			if (b > 100) b = 100;
			_cctBlend = (b * 127) / 100;
			//compile-time limiter for hardware that can't power both white channels at max
			#ifdef WLED_MAX_CCT_BLEND
				if (_cctBlend > WLED_MAX_CCT_BLEND) _cctBlend = WLED_MAX_CCT_BLEND;
			#endif
		}
		inline static void    setAutoWhiteMode(uint8_t m) { if (m < 4) _autoWhiteMode = m; }
		inline static uint8_t getAutoWhiteMode() { return _autoWhiteMode; }

    bool reversed = false;

  protected:
    uint8_t  _type = TYPE_NONE;
    uint8_t  _bri = 255;
    uint16_t _start = 0;
    uint16_t _len = 1;
    bool     _valid = false;
    bool     _needsRefresh = false;
    static uint8_t _autoWhiteMode;
    static int16_t _cct;
		static uint8_t _cctBlend;
    uint32_t autoWhiteCalc(uint32_t c) {
      if (_autoWhiteMode == RGBW_MODE_MANUAL_ONLY) return c;
      uint8_t w = W(c);
      //ignore auto-white calculation if w>0 and mode DUAL (DUAL behaves as BRIGHTER if w==0)
      if (w > 0 && _autoWhiteMode == RGBW_MODE_DUAL) return c;
      uint8_t r = R(c);
      uint8_t g = G(c);
      uint8_t b = B(c);
      w = r < g ? (r < b ? r : b) : (g < b ? g : b);
      if (_autoWhiteMode == RGBW_MODE_AUTO_ACCURATE) { r -= w; g -= w; b -= w; } //subtract w in ACCURATE mode
      return RGBW32(r, g, b, w);
    }
};


class BusDigital : public Bus {
  public:
  BusDigital(BusConfig &bc, uint8_t nr, const ColorOrderMap &com) : Bus(bc.type, bc.start), _colorOrderMap(com) {
    if (!IS_DIGITAL(bc.type) || !bc.count) return;
    if (!pinManager.allocatePin(bc.pins[0], true, PinOwner::BusDigital)) return;
    _pins[0] = bc.pins[0];
    if (IS_2PIN(bc.type)) {
      if (!pinManager.allocatePin(bc.pins[1], true, PinOwner::BusDigital)) {
        cleanup(); return;
      }
      _pins[1] = bc.pins[1];
    }
    reversed = bc.reversed;
    _needsRefresh = bc.refreshReq || bc.type == TYPE_TM1814;
    _skip = bc.skipAmount;    //sacrificial pixels
    _len = bc.count + _skip;
    _iType = PolyBus::getI(bc.type, _pins, nr);
    if (_iType == I_NONE) return;
    _busPtr = PolyBus::create(_iType, _pins, _len, nr);
    _valid = (_busPtr != nullptr);
    _colorOrder = bc.colorOrder;
    DEBUG_PRINTF("Successfully inited strip %u (len %u) with type %u and pins %u,%u (itype %u)\n",nr, _len, bc.type, _pins[0],_pins[1],_iType);
  };

  inline void show() {
    PolyBus::show(_busPtr, _iType);
  }

  inline bool canShow() {
    return PolyBus::canShow(_busPtr, _iType);
  }

  void setBrightness(uint8_t b) {
    //Fix for turning off onboard LED breaking bus
    #ifdef LED_BUILTIN
    if (_bri == 0 && b > 0) {
      if (_pins[0] == LED_BUILTIN || _pins[1] == LED_BUILTIN) PolyBus::begin(_busPtr, _iType, _pins);
    }
    #endif
    _bri = b;
    PolyBus::setBrightness(_busPtr, _iType, b);
  }

	//If LEDs are skipped, it is possible to use the first as a status LED.
	//TODO only show if no new show due in the next 50ms
	void setStatusPixel(uint32_t c) {
    if (_skip && canShow()) {
      PolyBus::setPixelColor(_busPtr, _iType, 0, c, _colorOrderMap.getPixelColorOrder(_start, _colorOrder));
      PolyBus::show(_busPtr, _iType);
    }
  }

  void setPixelColor(uint16_t pix, uint32_t c) {
    if (_type == TYPE_SK6812_RGBW || _type == TYPE_TM1814) c = autoWhiteCalc(c);
    if (_cct >= 1900) c = colorBalanceFromKelvin(_cct, c); //color correction from CCT
    if (reversed) pix = _len - pix -1;
    else pix += _skip;
    PolyBus::setPixelColor(_busPtr, _iType, pix, c, _colorOrderMap.getPixelColorOrder(pix+_start, _colorOrder));
  }

  uint32_t getPixelColor(uint16_t pix) {
    if (reversed) pix = _len - pix -1;
    else pix += _skip;
    return PolyBus::getPixelColor(_busPtr, _iType, pix, _colorOrderMap.getPixelColorOrder(pix+_start, _colorOrder));
  }

  inline uint8_t getColorOrder() {
    return _colorOrder;
  }

  uint16_t getLength() {
    return _len - _skip;
  }

  uint8_t getPins(uint8_t* pinArray) {
    uint8_t numPins = IS_2PIN(_type) ? 2 : 1;
    for (uint8_t i = 0; i < numPins; i++) pinArray[i] = _pins[i];
    return numPins;
  }

  void setColorOrder(uint8_t colorOrder) {
    if (colorOrder > 5) return;
    _colorOrder = colorOrder;
  }

  inline uint8_t skippedLeds() {
    return _skip;
  }

  inline void reinit() {
    PolyBus::begin(_busPtr, _iType, _pins);
  }

  void cleanup() {
    DEBUG_PRINTLN(F("Digital Cleanup."));
    PolyBus::cleanup(_busPtr, _iType);
    _iType = I_NONE;
    _valid = false;
    _busPtr = nullptr;
    pinManager.deallocatePin(_pins[1], PinOwner::BusDigital);
    pinManager.deallocatePin(_pins[0], PinOwner::BusDigital);
  }

  ~BusDigital() {
    cleanup();
  }

  private:
  uint8_t _colorOrder = COL_ORDER_GRB;
  uint8_t _pins[2] = {255, 255};
  uint8_t _iType = I_NONE;
  uint8_t _skip = 0;
  void * _busPtr = nullptr;
  const ColorOrderMap &_colorOrderMap;
};


class BusPwm : public Bus {
  public:
  BusPwm(BusConfig &bc) : Bus(bc.type, bc.start) {
    _valid = false;
    if (!IS_PWM(bc.type)) return;
    uint8_t numPins = NUM_PWM_PINS(bc.type);

    #ifdef ESP8266
    analogWriteRange(255);  //same range as one RGB channel
    analogWriteFreq(WLED_PWM_FREQ);
    #else
    _ledcStart = pinManager.allocateLedc(numPins);
    if (_ledcStart == 255) { //no more free LEDC channels
      deallocatePins(); return;
    }
    #endif

    for (uint8_t i = 0; i < numPins; i++) {
      uint8_t currentPin = bc.pins[i];
      if (!pinManager.allocatePin(currentPin, true, PinOwner::BusPwm)) {
        deallocatePins(); return;
      }
      _pins[i] = currentPin; //store only after allocatePin() succeeds
      #ifdef ESP8266
      pinMode(_pins[i], OUTPUT);
      #else
      ledcSetup(_ledcStart + i, WLED_PWM_FREQ, 8);
      ledcAttachPin(_pins[i], _ledcStart + i);
      #endif
    }
    reversed = bc.reversed;
    _valid = true;
  };

  void setPixelColor(uint16_t pix, uint32_t c) {
    if (pix != 0 || !_valid) return; //only react to first pixel
		if (_type != TYPE_ANALOG_3CH) c = autoWhiteCalc(c);
    if (_cct >= 1900 && (_type == TYPE_ANALOG_3CH || _type == TYPE_ANALOG_4CH)) {
      c = colorBalanceFromKelvin(_cct, c); //color correction from CCT
    }
    uint8_t r = R(c);
    uint8_t g = G(c);
    uint8_t b = B(c);
    uint8_t w = W(c);
    uint8_t cct = 0; //0 - full warm white, 255 - full cold white
    if (_cct > -1) {
      if (_cct >= 1900)    cct = (_cct - 1900) >> 5;
      else if (_cct < 256) cct = _cct;
    } else {
      cct = (approximateKelvinFromRGB(c) - 1900) >> 5;
    }

		uint8_t ww, cw;
		#ifdef WLED_USE_IC_CCT
		ww = w;
		cw = cct;
		#else
		//0 - linear (CCT 127 = 50% warm, 50% cold), 127 - additive CCT blending (CCT 127 = 100% warm, 100% cold)
		if (cct       < _cctBlend) ww = 255;
		else ww = ((255-cct) * 255) / (255 - _cctBlend);

		if ((255-cct) < _cctBlend) cw = 255;
		else cw = (cct       * 255) / (255 - _cctBlend);

		ww = (w * ww) / 255; //brightness scaling
		cw = (w * cw) / 255;
		#endif

    switch (_type) {
      case TYPE_ANALOG_1CH: //one channel (white), relies on auto white calculation
        _data[0] = w;
        break;
      case TYPE_ANALOG_2CH: //warm white + cold white
        _data[1] = cw;
        _data[0] = ww;
        break;
      case TYPE_ANALOG_5CH: //RGB + warm white + cold white
        // perhaps a non-linear adjustment would be in order. need to test
        _data[4] = cw;
        w = ww;
      case TYPE_ANALOG_4CH: //RGBW
        _data[3] = w;
      case TYPE_ANALOG_3CH: //standard dumb RGB
        _data[0] = r; _data[1] = g; _data[2] = b;
        break;
    }
  }

  //does no index check
  uint32_t getPixelColor(uint16_t pix) {
    if (!_valid) return 0;
    return RGBW32(_data[0], _data[1], _data[2], _data[3]);
  }

  void show() {
    if (!_valid) return;
    uint8_t numPins = NUM_PWM_PINS(_type);
    for (uint8_t i = 0; i < numPins; i++) {
      uint8_t scaled = (_data[i] * _bri) / 255;
      if (reversed) scaled = 255 - scaled;
      #ifdef ESP8266
      analogWrite(_pins[i], scaled);
      #else
      ledcWrite(_ledcStart + i, scaled);
      #endif
    }
  }

  inline void setBrightness(uint8_t b) {
    _bri = b;
  }

  uint8_t getPins(uint8_t* pinArray) {
    if (!_valid) return 0;
    uint8_t numPins = NUM_PWM_PINS(_type);
    for (uint8_t i = 0; i < numPins; i++) {
      pinArray[i] = _pins[i];
    }
    return numPins;
  }

  inline void cleanup() {
    deallocatePins();
  }

  ~BusPwm() {
    cleanup();
  }

  private:
  uint8_t _pins[5] = {255, 255, 255, 255, 255};
  uint8_t _data[5] = {0};
  #ifdef ARDUINO_ARCH_ESP32
  uint8_t _ledcStart = 255;
  #endif

  void deallocatePins() {
    uint8_t numPins = NUM_PWM_PINS(_type);
    for (uint8_t i = 0; i < numPins; i++) {
      pinManager.deallocatePin(_pins[i], PinOwner::BusPwm);
      if (!pinManager.isPinOk(_pins[i])) continue;
      #ifdef ESP8266
      digitalWrite(_pins[i], LOW); //turn off PWM interrupt
      #else
      if (_ledcStart < 16) ledcDetachPin(_pins[i]);
      #endif
    }
    #ifdef ARDUINO_ARCH_ESP32
    pinManager.deallocateLedc(_ledcStart, numPins);
    #endif
  }
};


class BusNetwork : public Bus {
  public:
    BusNetwork(BusConfig &bc) : Bus(bc.type, bc.start) {
      _valid = false;
//      switch (bc.type) {
//        case TYPE_NET_ARTNET_RGB:
//          _rgbw = false;
//          _UDPtype = 2;
//          break;
//        case TYPE_NET_E131_RGB:
//          _rgbw = false;
//          _UDPtype = 1;
//          break;
//        case TYPE_NET_DDP_RGB:
//          _rgbw = false;
//          _UDPtype = 0;
//          break;
//        default:
          _rgbw = false;
          _UDPtype = bc.type - TYPE_NET_DDP_RGB;
//          break;
//      }
      _UDPchannels = _rgbw ? 4 : 3;
      _data = (byte *)malloc(bc.count * _UDPchannels);
      if (_data == nullptr) return;
      memset(_data, 0, bc.count * _UDPchannels);
      _len = bc.count;
      _client = IPAddress(bc.pins[0],bc.pins[1],bc.pins[2],bc.pins[3]);
      _broadcastLock = false;
      _valid = true;
    };

  void setPixelColor(uint16_t pix, uint32_t c) {
    if (!_valid || pix >= _len) return;
		if (isRgbw()) c = autoWhiteCalc(c);
    if (_cct >= 1900) c = colorBalanceFromKelvin(_cct, c); //color correction from CCT
    uint16_t offset = pix * _UDPchannels;
    _data[offset]   = R(c);
    _data[offset+1] = G(c);
    _data[offset+2] = B(c);
    if (_rgbw) _data[offset+3] = W(c);
  }

  uint32_t getPixelColor(uint16_t pix) {
    if (!_valid || pix >= _len) return 0;
    uint16_t offset = pix * _UDPchannels;
    return RGBW32(_data[offset], _data[offset+1], _data[offset+2], _rgbw ? (_data[offset+3] << 24) : 0);
  }

  void show() {
    if (!_valid || !canShow()) return;
    _broadcastLock = true;
    realtimeBroadcast(_UDPtype, _client, _len, _data, _bri, _rgbw);
    _broadcastLock = false;
  }

  inline bool canShow() {
    // this should be a return value from UDP routine if it is still sending data out
    return !_broadcastLock;
  }

  inline void setBrightness(uint8_t b) {
    _bri = b;
  }

  uint8_t getPins(uint8_t* pinArray) {
    for (uint8_t i = 0; i < 4; i++) {
      pinArray[i] = _client[i];
    }
    return 4;
  }

  inline bool isRgbw() {
    return _rgbw;
  }

  inline uint16_t getLength() {
    return _len;
  }

  void cleanup() {
    _type = I_NONE;
    _valid = false;
    if (_data != nullptr) free(_data);
    _data = nullptr;
  }

  ~BusNetwork() {
    cleanup();
  }

  private:
    IPAddress _client;
    uint8_t   _bri = 255;
    uint8_t   _UDPtype;
    uint8_t   _UDPchannels;
    bool      _rgbw;
    bool      _broadcastLock;
    byte     *_data;
};


class BusManager {
  public:
  BusManager() {

  };

  //utility to get the approx. memory usage of a given BusConfig
  static uint32_t memUsage(BusConfig &bc) {
    uint8_t type = bc.type;
    uint16_t len = bc.count + bc.skipAmount;
    if (type > 15 && type < 32) {
      #ifdef ESP8266
        if (bc.pins[0] == 3) { //8266 DMA uses 5x the mem
          if (type > 29) return len*20; //RGBW
          return len*15;
        }
        if (type > 29) return len*4; //RGBW
        return len*3;
      #else //ESP32 RMT uses double buffer?
        if (type > 29) return len*8; //RGBW
        return len*6;
      #endif
    }
    if (type > 31 && type < 48)   return 5;
    if (type == 44 || type == 45) return len*4; //RGBW
    return len*3; //RGB
  }

  int add(BusConfig &bc) {
    if (numBusses >= WLED_MAX_BUSSES) return -1;
    if (bc.type >= TYPE_NET_DDP_RGB && bc.type < 96) {
      busses[numBusses] = new BusNetwork(bc);
    } else if (IS_DIGITAL(bc.type)) {
      busses[numBusses] = new BusDigital(bc, numBusses, colorOrderMap);
    } else {
      busses[numBusses] = new BusPwm(bc);
    }
    return numBusses++;
  }

  //do not call this method from system context (network callback)
  void removeAll() {
    DEBUG_PRINTLN(F("Removing all."));
    //prevents crashes due to deleting busses while in use.
    while (!canAllShow()) yield();
    for (uint8_t i = 0; i < numBusses; i++) delete busses[i];
    numBusses = 0;
  }

  void show() {
    for (uint8_t i = 0; i < numBusses; i++) {
      busses[i]->show();
    }
  }

	void setStatusPixel(uint32_t c) {
    for (uint8_t i = 0; i < numBusses; i++) {
			busses[i]->setStatusPixel(c);
		}
	}

  void IRAM_ATTR setPixelColor(uint16_t pix, uint32_t c, int16_t cct=-1) {
    for (uint8_t i = 0; i < numBusses; i++) {
      Bus* b = busses[i];
      uint16_t bstart = b->getStart();
      if (pix < bstart || pix >= bstart + b->getLength()) continue;
      busses[i]->setPixelColor(pix - bstart, c);
    }
  }

  void setBrightness(uint8_t b) {
    for (uint8_t i = 0; i < numBusses; i++) {
      busses[i]->setBrightness(b);
    }
  }

  void setSegmentCCT(int16_t cct, bool allowWBCorrection = false) {
    if (cct > 255) cct = 255;
    if (cct >= 0) {
      //if white balance correction allowed, save as kelvin value instead of 0-255
      if (allowWBCorrection) cct = 1900 + (cct << 5);
    } else cct = -1;
    Bus::setCCT(cct);
  }

  uint32_t getPixelColor(uint16_t pix) {
    for (uint8_t i = 0; i < numBusses; i++) {
      Bus* b = busses[i];
      uint16_t bstart = b->getStart();
      if (pix < bstart || pix >= bstart + b->getLength()) continue;
      return b->getPixelColor(pix - bstart);
    }
    return 0;
  }

  bool canAllShow() {
    for (uint8_t i = 0; i < numBusses; i++) {
      if (!busses[i]->canShow()) return false;
    }
    return true;
  }

  Bus* getBus(uint8_t busNr) {
    if (busNr >= numBusses) return nullptr;
    return busses[busNr];
  }

  inline uint8_t getNumBusses() {
    return numBusses;
  }

  //semi-duplicate of strip.getLengthTotal() (though that just returns strip._length, calculated in finalizeInit())
  uint16_t getTotalLength() {
    uint16_t len = 0;
    for (uint8_t i=0; i<numBusses; i++) len += busses[i]->getLength();
    return len;
  }

  void updateColorOrderMap(const ColorOrderMap &com) {
    memcpy(&colorOrderMap, &com, sizeof(ColorOrderMap));
  }

  const ColorOrderMap& getColorOrderMap() const {
    return colorOrderMap;
  }

  private:
  uint8_t numBusses = 0;
  Bus* busses[WLED_MAX_BUSSES];
  ColorOrderMap colorOrderMap;
};
#endif

=== ./bus_wrapper.h ===

#ifndef BusWrapper_h
#define BusWrapper_h

#include "NeoPixelBrightnessBus.h"

//Hardware SPI Pins
#define P_8266_HS_MOSI 13
#define P_8266_HS_CLK  14
#define P_32_HS_MOSI   13
#define P_32_HS_CLK    14
#define P_32_VS_MOSI   23
#define P_32_VS_CLK    18

//The dirty list of possible bus types. Quite a lot...
#define I_NONE 0
//ESP8266 RGB
#define I_8266_U0_NEO_3 1
#define I_8266_U1_NEO_3 2
#define I_8266_DM_NEO_3 3
#define I_8266_BB_NEO_3 4
//RGBW
#define I_8266_U0_NEO_4 5
#define I_8266_U1_NEO_4 6
#define I_8266_DM_NEO_4 7
#define I_8266_BB_NEO_4 8
//400Kbps
#define I_8266_U0_400_3 9
#define I_8266_U1_400_3 10
#define I_8266_DM_400_3 11
#define I_8266_BB_400_3 12
//TM1814 (RGBW)
#define I_8266_U0_TM1_4 13
#define I_8266_U1_TM1_4 14
#define I_8266_DM_TM1_4 15
#define I_8266_BB_TM1_4 16

/*** ESP32 Neopixel methods ***/
//RGB
#define I_32_RN_NEO_3 17
#define I_32_I0_NEO_3 18
#define I_32_I1_NEO_3 19
//RGBW
#define I_32_RN_NEO_4 20
#define I_32_I0_NEO_4 21
#define I_32_I1_NEO_4 22
//400Kbps
#define I_32_RN_400_3 23
#define I_32_I0_400_3 24
#define I_32_I1_400_3 25
//TM1814 (RGBW)
#define I_32_RN_TM1_4 26
#define I_32_I0_TM1_4 27
#define I_32_I1_TM1_4 28
//Bit Bang theoretically possible, but very undesirable and not needed (no pin restrictions on RMT and I2S)

//APA102
#define I_HS_DOT_3 29 //hardware SPI
#define I_SS_DOT_3 30 //soft SPI

//LPD8806
#define I_HS_LPD_3 31
#define I_SS_LPD_3 32

//WS2801
#define I_HS_WS1_3 33
#define I_SS_WS1_3 34

//P9813
#define I_HS_P98_3 35
#define I_SS_P98_3 36

//LPD6803
#define I_HS_LPO_3 37
#define I_SS_LPO_3 38


/*** ESP8266 Neopixel methods ***/
#ifdef ESP8266
//RGB
#define B_8266_U0_NEO_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp8266Uart0Ws2813Method> //3 chan, esp8266, gpio1
#define B_8266_U1_NEO_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp8266Uart1Ws2813Method> //3 chan, esp8266, gpio2
#define B_8266_DM_NEO_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp8266Dma800KbpsMethod>  //3 chan, esp8266, gpio3
#define B_8266_BB_NEO_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp8266BitBang800KbpsMethod> //3 chan, esp8266, bb (any pin but 16)
//RGBW
#define B_8266_U0_NEO_4 NeoPixelBrightnessBus<NeoGrbwFeature, NeoEsp8266Uart0Ws2813Method>   //4 chan, esp8266, gpio1
#define B_8266_U1_NEO_4 NeoPixelBrightnessBus<NeoGrbwFeature, NeoEsp8266Uart1Ws2813Method>   //4 chan, esp8266, gpio2
#define B_8266_DM_NEO_4 NeoPixelBrightnessBus<NeoGrbwFeature, NeoEsp8266Dma800KbpsMethod>    //4 chan, esp8266, gpio3
#define B_8266_BB_NEO_4 NeoPixelBrightnessBus<NeoGrbwFeature, NeoEsp8266BitBang800KbpsMethod> //4 chan, esp8266, bb (any pin)
//400Kbps
#define B_8266_U0_400_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp8266Uart0400KbpsMethod>   //3 chan, esp8266, gpio1
#define B_8266_U1_400_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp8266Uart1400KbpsMethod>   //3 chan, esp8266, gpio2
#define B_8266_DM_400_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp8266Dma400KbpsMethod>     //3 chan, esp8266, gpio3
#define B_8266_BB_400_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp8266BitBang400KbpsMethod> //3 chan, esp8266, bb (any pin)
//TM1814 (RGBW)
#define B_8266_U0_TM1_4 NeoPixelBrightnessBus<NeoWrgbTm1814Feature, NeoEsp8266Uart0Tm1814Method>
#define B_8266_U1_TM1_4 NeoPixelBrightnessBus<NeoWrgbTm1814Feature, NeoEsp8266Uart1Tm1814Method>
#define B_8266_DM_TM1_4 NeoPixelBrightnessBus<NeoWrgbTm1814Feature, NeoEsp8266DmaTm1814Method>
#define B_8266_BB_TM1_4 NeoPixelBrightnessBus<NeoWrgbTm1814Feature, NeoEsp8266BitBangTm1814Method>
#endif

/*** ESP32 Neopixel methods ***/
#ifdef ARDUINO_ARCH_ESP32
//RGB
#define B_32_RN_NEO_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp32RmtNWs2812xMethod>
#ifndef CONFIG_IDF_TARGET_ESP32C3
#define B_32_I0_NEO_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp32I2s0800KbpsMethod>
#endif
#if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
#define B_32_I1_NEO_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp32I2s1800KbpsMethod>
#endif
//RGBW
#define B_32_RN_NEO_4 NeoPixelBrightnessBus<NeoGrbwFeature, NeoEsp32RmtNWs2812xMethod>
#ifndef CONFIG_IDF_TARGET_ESP32C3
#define B_32_I0_NEO_4 NeoPixelBrightnessBus<NeoGrbwFeature, NeoEsp32I2s0800KbpsMethod>
#endif
#if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
#define B_32_I1_NEO_4 NeoPixelBrightnessBus<NeoGrbwFeature, NeoEsp32I2s1800KbpsMethod>
#endif
//400Kbps
#define B_32_RN_400_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp32RmtN400KbpsMethod>
#ifndef CONFIG_IDF_TARGET_ESP32C3
#define B_32_I0_400_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp32I2s0400KbpsMethod>
#endif
#if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
#define B_32_I1_400_3 NeoPixelBrightnessBus<NeoGrbFeature, NeoEsp32I2s1400KbpsMethod>
#endif
//TM1814 (RGBW)
#define B_32_RN_TM1_4 NeoPixelBrightnessBus<NeoWrgbTm1814Feature, NeoEsp32RmtNTm1814Method>
#ifndef CONFIG_IDF_TARGET_ESP32C3
#define B_32_I0_TM1_4 NeoPixelBrightnessBus<NeoWrgbTm1814Feature, NeoEsp32I2s0Tm1814Method>
#endif
#if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
#define B_32_I1_TM1_4 NeoPixelBrightnessBus<NeoWrgbTm1814Feature, NeoEsp32I2s1Tm1814Method>
#endif
//Bit Bang theoretically possible, but very undesirable and not needed (no pin restrictions on RMT and I2S)

#endif

//APA102
#ifdef WLED_USE_ETHERNET
// fix for upstream #2542 (by @BlackBird77)
#define B_HS_DOT_3 NeoPixelBrightnessBus<DotStarBgrFeature, DotStarEsp32DmaHspi5MhzMethod> //hardware HSPI with DMA (ESP32 only)
#else
#define B_HS_DOT_3 NeoPixelBrightnessBus<DotStarBgrFeature, DotStarSpi5MhzMethod> //hardware HSPI
#endif
#define B_SS_DOT_3 NeoPixelBrightnessBus<DotStarBgrFeature, DotStarMethod>    //soft SPI

//LPD8806
#define B_HS_LPD_3 NeoPixelBrightnessBus<Lpd8806GrbFeature, Lpd8806SpiMethod>
#define B_SS_LPD_3 NeoPixelBrightnessBus<Lpd8806GrbFeature, Lpd8806Method>

//LPD6803
#define B_HS_LPO_3 NeoPixelBrightnessBus<Lpd6803GrbFeature, Lpd6803SpiMethod>
#define B_SS_LPO_3 NeoPixelBrightnessBus<Lpd6803GrbFeature, Lpd6803Method>

//WS2801
//#define B_HS_WS1_3 NeoPixelBrightnessBus<NeoRbgFeature, NeoWs2801Spi40MhzMethod>
//#define B_HS_WS1_3 NeoPixelBrightnessBus<NeoRbgFeature, NeoWs2801Spi20MhzMethod>
//#define B_HS_WS1_3 NeoPixelBrightnessBus<NeoRbgFeature, NeoWs2801SpiMethod>     // 10MHz
#define B_HS_WS1_3 NeoPixelBrightnessBus<NeoRbgFeature, NeoWs2801Spi2MhzMethod> //slower, more compatible
#define B_SS_WS1_3 NeoPixelBrightnessBus<NeoRbgFeature, NeoWs2801Method>

//P9813
#define B_HS_P98_3 NeoPixelBrightnessBus<P9813BgrFeature, P9813SpiMethod>
#define B_SS_P98_3 NeoPixelBrightnessBus<P9813BgrFeature, P9813Method>

//handles pointer type conversion for all possible bus types
class PolyBus {
  public:
  // Begin & initialize the PixelSettings for TM1814 strips.
  template <class T>
  static void beginTM1814(void* busPtr) {
    T tm1814_strip = static_cast<T>(busPtr);
    tm1814_strip->Begin();
    // Max current for each LED (22.5 mA).
    tm1814_strip->SetPixelSettings(NeoTm1814Settings(/*R*/225, /*G*/225, /*B*/225, /*W*/225));
  }
  static void begin(void* busPtr, uint8_t busType, uint8_t* pins) {
    switch (busType) {
      case I_NONE: break;
    #ifdef ESP8266
      case I_8266_U0_NEO_3: (static_cast<B_8266_U0_NEO_3*>(busPtr))->Begin(); break;
      case I_8266_U1_NEO_3: (static_cast<B_8266_U1_NEO_3*>(busPtr))->Begin(); break;
      case I_8266_DM_NEO_3: (static_cast<B_8266_DM_NEO_3*>(busPtr))->Begin(); break;
      case I_8266_BB_NEO_3: (static_cast<B_8266_BB_NEO_3*>(busPtr))->Begin(); break;
      case I_8266_U0_NEO_4: (static_cast<B_8266_U0_NEO_4*>(busPtr))->Begin(); break;
      case I_8266_U1_NEO_4: (static_cast<B_8266_U1_NEO_4*>(busPtr))->Begin(); break;
      case I_8266_DM_NEO_4: (static_cast<B_8266_DM_NEO_4*>(busPtr))->Begin(); break;
      case I_8266_BB_NEO_4: (static_cast<B_8266_BB_NEO_4*>(busPtr))->Begin(); break;
      case I_8266_U0_400_3: (static_cast<B_8266_U0_400_3*>(busPtr))->Begin(); break;
      case I_8266_U1_400_3: (static_cast<B_8266_U1_400_3*>(busPtr))->Begin(); break;
      case I_8266_DM_400_3: (static_cast<B_8266_DM_400_3*>(busPtr))->Begin(); break;
      case I_8266_BB_400_3: (static_cast<B_8266_BB_400_3*>(busPtr))->Begin(); break;
      case I_8266_U0_TM1_4: beginTM1814<B_8266_U0_TM1_4*>(busPtr); break;
      case I_8266_U1_TM1_4: beginTM1814<B_8266_U1_TM1_4*>(busPtr); break;
      case I_8266_DM_TM1_4: beginTM1814<B_8266_DM_TM1_4*>(busPtr); break;
      case I_8266_BB_TM1_4: beginTM1814<B_8266_BB_TM1_4*>(busPtr); break;
      case I_HS_DOT_3: (static_cast<B_HS_DOT_3*>(busPtr))->Begin(); break;
      case I_HS_LPD_3: (static_cast<B_HS_LPD_3*>(busPtr))->Begin(); break;
      case I_HS_LPO_3: (static_cast<B_HS_LPO_3*>(busPtr))->Begin(); break;
      case I_HS_WS1_3: (static_cast<B_HS_WS1_3*>(busPtr))->Begin(); break;
      case I_HS_P98_3: (static_cast<B_HS_P98_3*>(busPtr))->Begin(); break;
    #endif
    #ifdef ARDUINO_ARCH_ESP32
      case I_32_RN_NEO_3: (static_cast<B_32_RN_NEO_3*>(busPtr))->Begin(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_3: (static_cast<B_32_I0_NEO_3*>(busPtr))->Begin(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_3: (static_cast<B_32_I1_NEO_3*>(busPtr))->Begin(); break;
      #endif
      case I_32_RN_NEO_4: (static_cast<B_32_RN_NEO_4*>(busPtr))->Begin(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_4: (static_cast<B_32_I0_NEO_4*>(busPtr))->Begin(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_4: (static_cast<B_32_I1_NEO_4*>(busPtr))->Begin(); break;
      #endif
      case I_32_RN_400_3: (static_cast<B_32_RN_400_3*>(busPtr))->Begin(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_400_3: (static_cast<B_32_I0_400_3*>(busPtr))->Begin(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_400_3: (static_cast<B_32_I1_400_3*>(busPtr))->Begin(); break;
      #endif
      case I_32_RN_TM1_4: beginTM1814<B_32_RN_TM1_4*>(busPtr); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_TM1_4: beginTM1814<B_32_I0_TM1_4*>(busPtr); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_TM1_4: beginTM1814<B_32_I1_TM1_4*>(busPtr); break;
      #endif
      // ESP32 can (and should, to avoid inadvertantly driving the chip select signal) specify the pins used for SPI, but only in begin()
      case I_HS_DOT_3: (static_cast<B_HS_DOT_3*>(busPtr))->Begin(pins[1], -1, pins[0], -1); break;
      case I_HS_LPD_3: (static_cast<B_HS_LPD_3*>(busPtr))->Begin(pins[1], -1, pins[0], -1); break;
      case I_HS_LPO_3: (static_cast<B_HS_LPO_3*>(busPtr))->Begin(pins[1], -1, pins[0], -1); break;
      case I_HS_WS1_3: (static_cast<B_HS_WS1_3*>(busPtr))->Begin(pins[1], -1, pins[0], -1); break;
      case I_HS_P98_3: (static_cast<B_HS_P98_3*>(busPtr))->Begin(pins[1], -1, pins[0], -1); break;
    #endif
      case I_SS_DOT_3: (static_cast<B_SS_DOT_3*>(busPtr))->Begin(); break;
      case I_SS_LPD_3: (static_cast<B_SS_LPD_3*>(busPtr))->Begin(); break;
      case I_SS_LPO_3: (static_cast<B_SS_LPO_3*>(busPtr))->Begin(); break;
      case I_SS_WS1_3: (static_cast<B_SS_WS1_3*>(busPtr))->Begin(); break;
      case I_SS_P98_3: (static_cast<B_SS_P98_3*>(busPtr))->Begin(); break;
    }
  };
  static void* create(uint8_t busType, uint8_t* pins, uint16_t len, uint8_t channel) {
    void* busPtr = nullptr;
    switch (busType) {
      case I_NONE: break;
    #ifdef ESP8266
      case I_8266_U0_NEO_3: busPtr = new B_8266_U0_NEO_3(len, pins[0]); break;
      case I_8266_U1_NEO_3: busPtr = new B_8266_U1_NEO_3(len, pins[0]); break;
      case I_8266_DM_NEO_3: busPtr = new B_8266_DM_NEO_3(len, pins[0]); break;
      case I_8266_BB_NEO_3: busPtr = new B_8266_BB_NEO_3(len, pins[0]); break;
      case I_8266_U0_NEO_4: busPtr = new B_8266_U0_NEO_4(len, pins[0]); break;
      case I_8266_U1_NEO_4: busPtr = new B_8266_U1_NEO_4(len, pins[0]); break;
      case I_8266_DM_NEO_4: busPtr = new B_8266_DM_NEO_4(len, pins[0]); break;
      case I_8266_BB_NEO_4: busPtr = new B_8266_BB_NEO_4(len, pins[0]); break;
      case I_8266_U0_400_3: busPtr = new B_8266_U0_400_3(len, pins[0]); break;
      case I_8266_U1_400_3: busPtr = new B_8266_U1_400_3(len, pins[0]); break;
      case I_8266_DM_400_3: busPtr = new B_8266_DM_400_3(len, pins[0]); break;
      case I_8266_BB_400_3: busPtr = new B_8266_BB_400_3(len, pins[0]); break;
      case I_8266_U0_TM1_4: busPtr = new B_8266_U0_TM1_4(len, pins[0]); break;
      case I_8266_U1_TM1_4: busPtr = new B_8266_U1_TM1_4(len, pins[0]); break;
      case I_8266_DM_TM1_4: busPtr = new B_8266_DM_TM1_4(len, pins[0]); break;
      case I_8266_BB_TM1_4: busPtr = new B_8266_BB_TM1_4(len, pins[0]); break;
    #endif
    #ifdef ARDUINO_ARCH_ESP32
      case I_32_RN_NEO_3: busPtr = new B_32_RN_NEO_3(len, pins[0], (NeoBusChannel)channel); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_3: busPtr = new B_32_I0_NEO_3(len, pins[0]); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_3: busPtr = new B_32_I1_NEO_3(len, pins[0]); break;
      #endif
      case I_32_RN_NEO_4: busPtr = new B_32_RN_NEO_4(len, pins[0], (NeoBusChannel)channel); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_4: busPtr = new B_32_I0_NEO_4(len, pins[0]); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_4: busPtr = new B_32_I1_NEO_4(len, pins[0]); break;
      #endif
      case I_32_RN_400_3: busPtr = new B_32_RN_400_3(len, pins[0], (NeoBusChannel)channel); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_400_3: busPtr = new B_32_I0_400_3(len, pins[0]); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_400_3: busPtr = new B_32_I1_400_3(len, pins[0]); break;
      #endif
      case I_32_RN_TM1_4: busPtr = new B_32_RN_TM1_4(len, pins[0], (NeoBusChannel)channel); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_TM1_4: busPtr = new B_32_I0_TM1_4(len, pins[0]); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_TM1_4: busPtr = new B_32_I1_TM1_4(len, pins[0]); break;
      #endif
    #endif
      // for 2-wire: pins[1] is clk, pins[0] is dat.  begin expects (len, clk, dat)
      case I_HS_DOT_3: busPtr = new B_HS_DOT_3(len, pins[1], pins[0]); break;
      case I_SS_DOT_3: busPtr = new B_SS_DOT_3(len, pins[1], pins[0]); break;
      case I_HS_LPD_3: busPtr = new B_HS_LPD_3(len, pins[1], pins[0]); break;
      case I_SS_LPD_3: busPtr = new B_SS_LPD_3(len, pins[1], pins[0]); break;
      case I_HS_LPO_3: busPtr = new B_HS_LPO_3(len, pins[1], pins[0]); break;
      case I_SS_LPO_3: busPtr = new B_SS_LPO_3(len, pins[1], pins[0]); break;
      case I_HS_WS1_3: busPtr = new B_HS_WS1_3(len, pins[1], pins[0]); break;
      case I_SS_WS1_3: busPtr = new B_SS_WS1_3(len, pins[1], pins[0]); break;
      case I_HS_P98_3: busPtr = new B_HS_P98_3(len, pins[1], pins[0]); break;
      case I_SS_P98_3: busPtr = new B_SS_P98_3(len, pins[1], pins[0]); break;
    }
    begin(busPtr, busType, pins);
    return busPtr;
  };
  static void show(void* busPtr, uint8_t busType) {
    switch (busType) {
      case I_NONE: break;
    #ifdef ESP8266
      case I_8266_U0_NEO_3: (static_cast<B_8266_U0_NEO_3*>(busPtr))->Show(); break;
      case I_8266_U1_NEO_3: (static_cast<B_8266_U1_NEO_3*>(busPtr))->Show(); break;
      case I_8266_DM_NEO_3: (static_cast<B_8266_DM_NEO_3*>(busPtr))->Show(); break;
      case I_8266_BB_NEO_3: (static_cast<B_8266_BB_NEO_3*>(busPtr))->Show(); break;
      case I_8266_U0_NEO_4: (static_cast<B_8266_U0_NEO_4*>(busPtr))->Show(); break;
      case I_8266_U1_NEO_4: (static_cast<B_8266_U1_NEO_4*>(busPtr))->Show(); break;
      case I_8266_DM_NEO_4: (static_cast<B_8266_DM_NEO_4*>(busPtr))->Show(); break;
      case I_8266_BB_NEO_4: (static_cast<B_8266_BB_NEO_4*>(busPtr))->Show(); break;
      case I_8266_U0_400_3: (static_cast<B_8266_U0_400_3*>(busPtr))->Show(); break;
      case I_8266_U1_400_3: (static_cast<B_8266_U1_400_3*>(busPtr))->Show(); break;
      case I_8266_DM_400_3: (static_cast<B_8266_DM_400_3*>(busPtr))->Show(); break;
      case I_8266_BB_400_3: (static_cast<B_8266_BB_400_3*>(busPtr))->Show(); break;
      case I_8266_U0_TM1_4: (static_cast<B_8266_U0_TM1_4*>(busPtr))->Show(); break;
      case I_8266_U1_TM1_4: (static_cast<B_8266_U1_TM1_4*>(busPtr))->Show(); break;
      case I_8266_DM_TM1_4: (static_cast<B_8266_DM_TM1_4*>(busPtr))->Show(); break;
      case I_8266_BB_TM1_4: (static_cast<B_8266_BB_TM1_4*>(busPtr))->Show(); break;
    #endif
    #ifdef ARDUINO_ARCH_ESP32
      case I_32_RN_NEO_3: (static_cast<B_32_RN_NEO_3*>(busPtr))->Show(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_3: (static_cast<B_32_I0_NEO_3*>(busPtr))->Show(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_3: (static_cast<B_32_I1_NEO_3*>(busPtr))->Show(); break;
      #endif
      case I_32_RN_NEO_4: (static_cast<B_32_RN_NEO_4*>(busPtr))->Show(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_4: (static_cast<B_32_I0_NEO_4*>(busPtr))->Show(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_4: (static_cast<B_32_I1_NEO_4*>(busPtr))->Show(); break;
      #endif
      case I_32_RN_400_3: (static_cast<B_32_RN_400_3*>(busPtr))->Show(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_400_3: (static_cast<B_32_I0_400_3*>(busPtr))->Show(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_400_3: (static_cast<B_32_I1_400_3*>(busPtr))->Show(); break;
      #endif
      case I_32_RN_TM1_4: (static_cast<B_32_RN_TM1_4*>(busPtr))->Show(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_TM1_4: (static_cast<B_32_I0_TM1_4*>(busPtr))->Show(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_TM1_4: (static_cast<B_32_I1_TM1_4*>(busPtr))->Show(); break;
      #endif
    #endif
      case I_HS_DOT_3: (static_cast<B_HS_DOT_3*>(busPtr))->Show(); break;
      case I_SS_DOT_3: (static_cast<B_SS_DOT_3*>(busPtr))->Show(); break;
      case I_HS_LPD_3: (static_cast<B_HS_LPD_3*>(busPtr))->Show(); break;
      case I_SS_LPD_3: (static_cast<B_SS_LPD_3*>(busPtr))->Show(); break;
      case I_HS_LPO_3: (static_cast<B_HS_LPO_3*>(busPtr))->Show(); break;
      case I_SS_LPO_3: (static_cast<B_SS_LPO_3*>(busPtr))->Show(); break;
      case I_HS_WS1_3: (static_cast<B_HS_WS1_3*>(busPtr))->Show(); break;
      case I_SS_WS1_3: (static_cast<B_SS_WS1_3*>(busPtr))->Show(); break;
      case I_HS_P98_3: (static_cast<B_HS_P98_3*>(busPtr))->Show(); break;
      case I_SS_P98_3: (static_cast<B_SS_P98_3*>(busPtr))->Show(); break;
    }
  };
  static bool canShow(void* busPtr, uint8_t busType) {
    switch (busType) {
      case I_NONE: return true;
    #ifdef ESP8266
      case I_8266_U0_NEO_3: return (static_cast<B_8266_U0_NEO_3*>(busPtr))->CanShow(); break;
      case I_8266_U1_NEO_3: return (static_cast<B_8266_U1_NEO_3*>(busPtr))->CanShow(); break;
      case I_8266_DM_NEO_3: return (static_cast<B_8266_DM_NEO_3*>(busPtr))->CanShow(); break;
      case I_8266_BB_NEO_3: return (static_cast<B_8266_BB_NEO_3*>(busPtr))->CanShow(); break;
      case I_8266_U0_NEO_4: return (static_cast<B_8266_U0_NEO_4*>(busPtr))->CanShow(); break;
      case I_8266_U1_NEO_4: return (static_cast<B_8266_U1_NEO_4*>(busPtr))->CanShow(); break;
      case I_8266_DM_NEO_4: return (static_cast<B_8266_DM_NEO_4*>(busPtr))->CanShow(); break;
      case I_8266_BB_NEO_4: return (static_cast<B_8266_BB_NEO_4*>(busPtr))->CanShow(); break;
      case I_8266_U0_400_3: return (static_cast<B_8266_U0_400_3*>(busPtr))->CanShow(); break;
      case I_8266_U1_400_3: return (static_cast<B_8266_U1_400_3*>(busPtr))->CanShow(); break;
      case I_8266_DM_400_3: return (static_cast<B_8266_DM_400_3*>(busPtr))->CanShow(); break;
      case I_8266_BB_400_3: return (static_cast<B_8266_BB_400_3*>(busPtr))->CanShow(); break;
      case I_8266_U0_TM1_4: return (static_cast<B_8266_U0_TM1_4*>(busPtr))->CanShow(); break;
      case I_8266_U1_TM1_4: return (static_cast<B_8266_U1_TM1_4*>(busPtr))->CanShow(); break;
      case I_8266_DM_TM1_4: return (static_cast<B_8266_DM_TM1_4*>(busPtr))->CanShow(); break;
      case I_8266_BB_TM1_4: return (static_cast<B_8266_BB_TM1_4*>(busPtr))->CanShow(); break;
    #endif
    #ifdef ARDUINO_ARCH_ESP32
      case I_32_RN_NEO_3: return (static_cast<B_32_RN_NEO_3*>(busPtr))->CanShow(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_3: return (static_cast<B_32_I0_NEO_3*>(busPtr))->CanShow(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_3: return (static_cast<B_32_I1_NEO_3*>(busPtr))->CanShow(); break;
      #endif
      case I_32_RN_NEO_4: return (static_cast<B_32_RN_NEO_4*>(busPtr))->CanShow(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_4: return (static_cast<B_32_I0_NEO_4*>(busPtr))->CanShow(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_4: return (static_cast<B_32_I1_NEO_4*>(busPtr))->CanShow(); break;
      #endif
      case I_32_RN_400_3: return (static_cast<B_32_RN_400_3*>(busPtr))->CanShow(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_400_3: return (static_cast<B_32_I0_400_3*>(busPtr))->CanShow(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_400_3: return (static_cast<B_32_I1_400_3*>(busPtr))->CanShow(); break;
      #endif
      case I_32_RN_TM1_4: return (static_cast<B_32_RN_TM1_4*>(busPtr))->CanShow(); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_TM1_4: return (static_cast<B_32_I0_TM1_4*>(busPtr))->CanShow(); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_TM1_4: return (static_cast<B_32_I1_TM1_4*>(busPtr))->CanShow(); break;
      #endif
    #endif
      case I_HS_DOT_3: return (static_cast<B_HS_DOT_3*>(busPtr))->CanShow(); break;
      case I_SS_DOT_3: return (static_cast<B_SS_DOT_3*>(busPtr))->CanShow(); break;
      case I_HS_LPD_3: return (static_cast<B_HS_LPD_3*>(busPtr))->CanShow(); break;
      case I_SS_LPD_3: return (static_cast<B_SS_LPD_3*>(busPtr))->CanShow(); break;
      case I_HS_LPO_3: return (static_cast<B_HS_LPO_3*>(busPtr))->CanShow(); break;
      case I_SS_LPO_3: return (static_cast<B_SS_LPO_3*>(busPtr))->CanShow(); break;
      case I_HS_WS1_3: return (static_cast<B_HS_WS1_3*>(busPtr))->CanShow(); break;
      case I_SS_WS1_3: return (static_cast<B_SS_WS1_3*>(busPtr))->CanShow(); break;
      case I_HS_P98_3: return (static_cast<B_HS_P98_3*>(busPtr))->CanShow(); break;
      case I_SS_P98_3: return (static_cast<B_SS_P98_3*>(busPtr))->CanShow(); break;
    }
    return true;
  };
  static void setPixelColor(void* busPtr, uint8_t busType, uint16_t pix, uint32_t c, uint8_t co) {
    uint8_t r = c >> 16;
    uint8_t g = c >> 8;
    uint8_t b = c >> 0;
    uint8_t w = c >> 24;
    RgbwColor col;

    //TODO make color order override possible on a per-strip basis
    #ifdef COLOR_ORDER_OVERRIDE
    if (pix >= COO_MIN && pix < COO_MAX) co = COO_ORDER;
    #endif

    //reorder channels to selected order
    switch (co)
    {
      case  0: col.G = g; col.R = r; col.B = b; break; //0 = GRB, default
      case  1: col.G = r; col.R = g; col.B = b; break; //1 = RGB, common for WS2811
      case  2: col.G = b; col.R = r; col.B = g; break; //2 = BRG
      case  3: col.G = r; col.R = b; col.B = g; break; //3 = RBG
      case  4: col.G = b; col.R = g; col.B = r; break; //4 = BGR
      default: col.G = g; col.R = b; col.B = r; break; //5 = GBR
    }
    col.W = w;

    switch (busType) {
      case I_NONE: break;
    #ifdef ESP8266
      case I_8266_U0_NEO_3: (static_cast<B_8266_U0_NEO_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_8266_U1_NEO_3: (static_cast<B_8266_U1_NEO_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_8266_DM_NEO_3: (static_cast<B_8266_DM_NEO_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_8266_BB_NEO_3: (static_cast<B_8266_BB_NEO_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_8266_U0_NEO_4: (static_cast<B_8266_U0_NEO_4*>(busPtr))->SetPixelColor(pix, col); break;
      case I_8266_U1_NEO_4: (static_cast<B_8266_U1_NEO_4*>(busPtr))->SetPixelColor(pix, col); break;
      case I_8266_DM_NEO_4: (static_cast<B_8266_DM_NEO_4*>(busPtr))->SetPixelColor(pix, col); break;
      case I_8266_BB_NEO_4: (static_cast<B_8266_BB_NEO_4*>(busPtr))->SetPixelColor(pix, col); break;
      case I_8266_U0_400_3: (static_cast<B_8266_U0_400_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_8266_U1_400_3: (static_cast<B_8266_U1_400_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_8266_DM_400_3: (static_cast<B_8266_DM_400_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_8266_BB_400_3: (static_cast<B_8266_BB_400_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_8266_U0_TM1_4: (static_cast<B_8266_U0_TM1_4*>(busPtr))->SetPixelColor(pix, col); break;
      case I_8266_U1_TM1_4: (static_cast<B_8266_U1_TM1_4*>(busPtr))->SetPixelColor(pix, col); break;
      case I_8266_DM_TM1_4: (static_cast<B_8266_DM_TM1_4*>(busPtr))->SetPixelColor(pix, col); break;
      case I_8266_BB_TM1_4: (static_cast<B_8266_BB_TM1_4*>(busPtr))->SetPixelColor(pix, col); break;
    #endif
    #ifdef ARDUINO_ARCH_ESP32
      case I_32_RN_NEO_3: (static_cast<B_32_RN_NEO_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_3: (static_cast<B_32_I0_NEO_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_3: (static_cast<B_32_I1_NEO_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      #endif
      case I_32_RN_NEO_4: (static_cast<B_32_RN_NEO_4*>(busPtr))->SetPixelColor(pix, col); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_4: (static_cast<B_32_I0_NEO_4*>(busPtr))->SetPixelColor(pix, col); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_4: (static_cast<B_32_I1_NEO_4*>(busPtr))->SetPixelColor(pix, col); break;
      #endif
      case I_32_RN_400_3: (static_cast<B_32_RN_400_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_400_3: (static_cast<B_32_I0_400_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_400_3: (static_cast<B_32_I1_400_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      #endif
      case I_32_RN_TM1_4: (static_cast<B_32_RN_TM1_4*>(busPtr))->SetPixelColor(pix, col); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_TM1_4: (static_cast<B_32_I0_TM1_4*>(busPtr))->SetPixelColor(pix, col); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_TM1_4: (static_cast<B_32_I1_TM1_4*>(busPtr))->SetPixelColor(pix, col); break;
      #endif
    #endif
      case I_HS_DOT_3: (static_cast<B_HS_DOT_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_SS_DOT_3: (static_cast<B_SS_DOT_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_HS_LPD_3: (static_cast<B_HS_LPD_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_SS_LPD_3: (static_cast<B_SS_LPD_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_HS_LPO_3: (static_cast<B_HS_LPO_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_SS_LPO_3: (static_cast<B_SS_LPO_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_HS_WS1_3: (static_cast<B_HS_WS1_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_SS_WS1_3: (static_cast<B_SS_WS1_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_HS_P98_3: (static_cast<B_HS_P98_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
      case I_SS_P98_3: (static_cast<B_SS_P98_3*>(busPtr))->SetPixelColor(pix, RgbColor(col.R,col.G,col.B)); break;
    }
  };
  static void setBrightness(void* busPtr, uint8_t busType, uint8_t b) {
    switch (busType) {
      case I_NONE: break;
    #ifdef ESP8266
      case I_8266_U0_NEO_3: (static_cast<B_8266_U0_NEO_3*>(busPtr))->SetBrightness(b); break;
      case I_8266_U1_NEO_3: (static_cast<B_8266_U1_NEO_3*>(busPtr))->SetBrightness(b); break;
      case I_8266_DM_NEO_3: (static_cast<B_8266_DM_NEO_3*>(busPtr))->SetBrightness(b); break;
      case I_8266_BB_NEO_3: (static_cast<B_8266_BB_NEO_3*>(busPtr))->SetBrightness(b); break;
      case I_8266_U0_NEO_4: (static_cast<B_8266_U0_NEO_4*>(busPtr))->SetBrightness(b); break;
      case I_8266_U1_NEO_4: (static_cast<B_8266_U1_NEO_4*>(busPtr))->SetBrightness(b); break;
      case I_8266_DM_NEO_4: (static_cast<B_8266_DM_NEO_4*>(busPtr))->SetBrightness(b); break;
      case I_8266_BB_NEO_4: (static_cast<B_8266_BB_NEO_4*>(busPtr))->SetBrightness(b); break;
      case I_8266_U0_400_3: (static_cast<B_8266_U0_400_3*>(busPtr))->SetBrightness(b); break;
      case I_8266_U1_400_3: (static_cast<B_8266_U1_400_3*>(busPtr))->SetBrightness(b); break;
      case I_8266_DM_400_3: (static_cast<B_8266_DM_400_3*>(busPtr))->SetBrightness(b); break;
      case I_8266_BB_400_3: (static_cast<B_8266_BB_400_3*>(busPtr))->SetBrightness(b); break;
      case I_8266_U0_TM1_4: (static_cast<B_8266_U0_TM1_4*>(busPtr))->SetBrightness(b); break;
      case I_8266_U1_TM1_4: (static_cast<B_8266_U1_TM1_4*>(busPtr))->SetBrightness(b); break;
      case I_8266_DM_TM1_4: (static_cast<B_8266_DM_TM1_4*>(busPtr))->SetBrightness(b); break;
      case I_8266_BB_TM1_4: (static_cast<B_8266_BB_TM1_4*>(busPtr))->SetBrightness(b); break;
    #endif
    #ifdef ARDUINO_ARCH_ESP32
      case I_32_RN_NEO_3: (static_cast<B_32_RN_NEO_3*>(busPtr))->SetBrightness(b); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_3: (static_cast<B_32_I0_NEO_3*>(busPtr))->SetBrightness(b); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_3: (static_cast<B_32_I1_NEO_3*>(busPtr))->SetBrightness(b); break;
      #endif
      case I_32_RN_NEO_4: (static_cast<B_32_RN_NEO_4*>(busPtr))->SetBrightness(b); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_4: (static_cast<B_32_I0_NEO_4*>(busPtr))->SetBrightness(b); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_4: (static_cast<B_32_I1_NEO_4*>(busPtr))->SetBrightness(b); break;
      #endif
      case I_32_RN_400_3: (static_cast<B_32_RN_400_3*>(busPtr))->SetBrightness(b); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_400_3: (static_cast<B_32_I0_400_3*>(busPtr))->SetBrightness(b); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_400_3: (static_cast<B_32_I1_400_3*>(busPtr))->SetBrightness(b); break;
      #endif
      case I_32_RN_TM1_4: (static_cast<B_32_RN_TM1_4*>(busPtr))->SetBrightness(b); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_TM1_4: (static_cast<B_32_I0_TM1_4*>(busPtr))->SetBrightness(b); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_TM1_4: (static_cast<B_32_I1_TM1_4*>(busPtr))->SetBrightness(b); break;
      #endif
    #endif
      case I_HS_DOT_3: (static_cast<B_HS_DOT_3*>(busPtr))->SetBrightness(b); break;
      case I_SS_DOT_3: (static_cast<B_SS_DOT_3*>(busPtr))->SetBrightness(b); break;
      case I_HS_LPD_3: (static_cast<B_HS_LPD_3*>(busPtr))->SetBrightness(b); break;
      case I_SS_LPD_3: (static_cast<B_SS_LPD_3*>(busPtr))->SetBrightness(b); break;
      case I_HS_LPO_3: (static_cast<B_HS_LPO_3*>(busPtr))->SetBrightness(b); break;
      case I_SS_LPO_3: (static_cast<B_SS_LPO_3*>(busPtr))->SetBrightness(b); break;
      case I_HS_WS1_3: (static_cast<B_HS_WS1_3*>(busPtr))->SetBrightness(b); break;
      case I_SS_WS1_3: (static_cast<B_SS_WS1_3*>(busPtr))->SetBrightness(b); break;
      case I_HS_P98_3: (static_cast<B_HS_P98_3*>(busPtr))->SetBrightness(b); break;
      case I_SS_P98_3: (static_cast<B_SS_P98_3*>(busPtr))->SetBrightness(b); break;
    }
  };
  static uint32_t getPixelColor(void* busPtr, uint8_t busType, uint16_t pix, uint8_t co) {
    RgbwColor col(0,0,0,0);
    switch (busType) {
      case I_NONE: break;
    #ifdef ESP8266
      case I_8266_U0_NEO_3: col = (static_cast<B_8266_U0_NEO_3*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_U1_NEO_3: col = (static_cast<B_8266_U1_NEO_3*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_DM_NEO_3: col = (static_cast<B_8266_DM_NEO_3*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_BB_NEO_3: col = (static_cast<B_8266_BB_NEO_3*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_U0_NEO_4: col = (static_cast<B_8266_U0_NEO_4*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_U1_NEO_4: col = (static_cast<B_8266_U1_NEO_4*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_DM_NEO_4: col = (static_cast<B_8266_DM_NEO_4*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_BB_NEO_4: col = (static_cast<B_8266_BB_NEO_4*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_U0_400_3: col = (static_cast<B_8266_U0_400_3*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_U1_400_3: col = (static_cast<B_8266_U1_400_3*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_DM_400_3: col = (static_cast<B_8266_DM_400_3*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_BB_400_3: col = (static_cast<B_8266_BB_400_3*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_U0_TM1_4: col = (static_cast<B_8266_U0_TM1_4*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_U1_TM1_4: col = (static_cast<B_8266_U1_TM1_4*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_DM_TM1_4: col = (static_cast<B_8266_DM_TM1_4*>(busPtr))->GetPixelColor(pix); break;
      case I_8266_BB_TM1_4: col = (static_cast<B_8266_BB_TM1_4*>(busPtr))->GetPixelColor(pix); break;
    #endif
    #ifdef ARDUINO_ARCH_ESP32
      case I_32_RN_NEO_3: col = (static_cast<B_32_RN_NEO_3*>(busPtr))->GetPixelColor(pix); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_3: col = (static_cast<B_32_I0_NEO_3*>(busPtr))->GetPixelColor(pix); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_3: col = (static_cast<B_32_I1_NEO_3*>(busPtr))->GetPixelColor(pix); break;
      #endif
      case I_32_RN_NEO_4: col = (static_cast<B_32_RN_NEO_4*>(busPtr))->GetPixelColor(pix); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_4: col = (static_cast<B_32_I0_NEO_4*>(busPtr))->GetPixelColor(pix); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_4: col = (static_cast<B_32_I1_NEO_4*>(busPtr))->GetPixelColor(pix); break;
      #endif
      case I_32_RN_400_3: col = (static_cast<B_32_RN_400_3*>(busPtr))->GetPixelColor(pix); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_400_3: col = (static_cast<B_32_I0_400_3*>(busPtr))->GetPixelColor(pix); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_400_3: col = (static_cast<B_32_I1_400_3*>(busPtr))->GetPixelColor(pix); break;
      #endif
      case I_32_RN_TM1_4: col = (static_cast<B_32_RN_TM1_4*>(busPtr))->GetPixelColor(pix); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_TM1_4: col = (static_cast<B_32_I0_TM1_4*>(busPtr))->GetPixelColor(pix); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_TM1_4: col = (static_cast<B_32_I1_TM1_4*>(busPtr))->GetPixelColor(pix); break;
      #endif
    #endif
      case I_HS_DOT_3: col = (static_cast<B_HS_DOT_3*>(busPtr))->GetPixelColor(pix); break;
      case I_SS_DOT_3: col = (static_cast<B_SS_DOT_3*>(busPtr))->GetPixelColor(pix); break;
      case I_HS_LPD_3: col = (static_cast<B_HS_LPD_3*>(busPtr))->GetPixelColor(pix); break;
      case I_SS_LPD_3: col = (static_cast<B_SS_LPD_3*>(busPtr))->GetPixelColor(pix); break;
      case I_HS_LPO_3: col = (static_cast<B_HS_LPO_3*>(busPtr))->GetPixelColor(pix); break;
      case I_SS_LPO_3: col = (static_cast<B_SS_LPO_3*>(busPtr))->GetPixelColor(pix); break;
      case I_HS_WS1_3: col = (static_cast<B_HS_WS1_3*>(busPtr))->GetPixelColor(pix); break;
      case I_SS_WS1_3: col = (static_cast<B_SS_WS1_3*>(busPtr))->GetPixelColor(pix); break;
      case I_HS_P98_3: col = (static_cast<B_HS_P98_3*>(busPtr))->GetPixelColor(pix); break;
      case I_SS_P98_3: col = (static_cast<B_SS_P98_3*>(busPtr))->GetPixelColor(pix); break;
    }

    #ifdef COLOR_ORDER_OVERRIDE
    if (pix >= COO_MIN && pix < COO_MAX) co = COO_ORDER;
    #endif

    switch (co)
    {
      //                    W               G              R               B
      case  0: return ((col.W << 24) | (col.G << 8) | (col.R << 16) | (col.B)); //0 = GRB, default
      case  1: return ((col.W << 24) | (col.R << 8) | (col.G << 16) | (col.B)); //1 = RGB, common for WS2811
      case  2: return ((col.W << 24) | (col.B << 8) | (col.R << 16) | (col.G)); //2 = BRG
      case  3: return ((col.W << 24) | (col.B << 8) | (col.G << 16) | (col.R)); //3 = RBG
      case  4: return ((col.W << 24) | (col.R << 8) | (col.B << 16) | (col.G)); //4 = BGR
      case  5: return ((col.W << 24) | (col.G << 8) | (col.B << 16) | (col.R)); //5 = GBR
    }
    return 0;
  }

  static void cleanup(void* busPtr, uint8_t busType) {
    if (busPtr == nullptr) return;
    switch (busType) {
      case I_NONE: break;
    #ifdef ESP8266
      case I_8266_U0_NEO_3: delete (static_cast<B_8266_U0_NEO_3*>(busPtr)); break;
      case I_8266_U1_NEO_3: delete (static_cast<B_8266_U1_NEO_3*>(busPtr)); break;
      case I_8266_DM_NEO_3: delete (static_cast<B_8266_DM_NEO_3*>(busPtr)); break;
      case I_8266_BB_NEO_3: delete (static_cast<B_8266_BB_NEO_3*>(busPtr)); break;
      case I_8266_U0_NEO_4: delete (static_cast<B_8266_U0_NEO_4*>(busPtr)); break;
      case I_8266_U1_NEO_4: delete (static_cast<B_8266_U1_NEO_4*>(busPtr)); break;
      case I_8266_DM_NEO_4: delete (static_cast<B_8266_DM_NEO_4*>(busPtr)); break;
      case I_8266_BB_NEO_4: delete (static_cast<B_8266_BB_NEO_4*>(busPtr)); break;
      case I_8266_U0_400_3: delete (static_cast<B_8266_U0_400_3*>(busPtr)); break;
      case I_8266_U1_400_3: delete (static_cast<B_8266_U1_400_3*>(busPtr)); break;
      case I_8266_DM_400_3: delete (static_cast<B_8266_DM_400_3*>(busPtr)); break;
      case I_8266_BB_400_3: delete (static_cast<B_8266_BB_400_3*>(busPtr)); break;
      case I_8266_U0_TM1_4: delete (static_cast<B_8266_U0_TM1_4*>(busPtr)); break;
      case I_8266_U1_TM1_4: delete (static_cast<B_8266_U1_TM1_4*>(busPtr)); break;
      case I_8266_DM_TM1_4: delete (static_cast<B_8266_DM_TM1_4*>(busPtr)); break;
      case I_8266_BB_TM1_4: delete (static_cast<B_8266_BB_TM1_4*>(busPtr)); break;
    #endif
    #ifdef ARDUINO_ARCH_ESP32
      case I_32_RN_NEO_3: delete (static_cast<B_32_RN_NEO_3*>(busPtr)); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_3: delete (static_cast<B_32_I0_NEO_3*>(busPtr)); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_3: delete (static_cast<B_32_I1_NEO_3*>(busPtr)); break;
      #endif
      case I_32_RN_NEO_4: delete (static_cast<B_32_RN_NEO_4*>(busPtr)); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_NEO_4: delete (static_cast<B_32_I0_NEO_4*>(busPtr)); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_NEO_4: delete (static_cast<B_32_I1_NEO_4*>(busPtr)); break;
      #endif
      case I_32_RN_400_3: delete (static_cast<B_32_RN_400_3*>(busPtr)); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_400_3: delete (static_cast<B_32_I0_400_3*>(busPtr)); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_400_3: delete (static_cast<B_32_I1_400_3*>(busPtr)); break;
      #endif
      case I_32_RN_TM1_4: delete (static_cast<B_32_RN_TM1_4*>(busPtr)); break;
      #ifndef CONFIG_IDF_TARGET_ESP32C3
      case I_32_I0_TM1_4: delete (static_cast<B_32_I0_TM1_4*>(busPtr)); break;
      #endif
      #if !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      case I_32_I1_TM1_4: delete (static_cast<B_32_I1_TM1_4*>(busPtr)); break;
      #endif
    #endif
      case I_HS_DOT_3: delete (static_cast<B_HS_DOT_3*>(busPtr)); break;
      case I_SS_DOT_3: delete (static_cast<B_SS_DOT_3*>(busPtr)); break;
      case I_HS_LPD_3: delete (static_cast<B_HS_LPD_3*>(busPtr)); break;
      case I_SS_LPD_3: delete (static_cast<B_SS_LPD_3*>(busPtr)); break;
      case I_HS_LPO_3: delete (static_cast<B_HS_LPO_3*>(busPtr)); break;
      case I_SS_LPO_3: delete (static_cast<B_SS_LPO_3*>(busPtr)); break;
      case I_HS_WS1_3: delete (static_cast<B_HS_WS1_3*>(busPtr)); break;
      case I_SS_WS1_3: delete (static_cast<B_SS_WS1_3*>(busPtr)); break;
      case I_HS_P98_3: delete (static_cast<B_HS_P98_3*>(busPtr)); break;
      case I_SS_P98_3: delete (static_cast<B_SS_P98_3*>(busPtr)); break;
    }
  }

  //gives back the internal type index (I_XX_XXX_X above) for the input
  static uint8_t getI(uint8_t busType, uint8_t* pins, uint8_t num = 0) {
    if (!IS_DIGITAL(busType)) return I_NONE;
    if (IS_2PIN(busType)) { //SPI LED chips
      bool isHSPI = false;
      #ifdef ESP8266
      if (pins[0] == P_8266_HS_MOSI && pins[1] == P_8266_HS_CLK) isHSPI = true;
      #else
        if(!num) isHSPI = true; // temporary hack to limit use of hardware SPI to a single SPI peripheral: only allow ESP32 hardware serial on segment 0
      #endif
      uint8_t t = I_NONE;
      switch (busType) {
        case TYPE_APA102:  t = I_SS_DOT_3; break;
        case TYPE_LPD8806: t = I_SS_LPD_3; break;
        case TYPE_LPD6803: t = I_SS_LPO_3; break;
        case TYPE_WS2801:  t = I_SS_WS1_3; break;
        case TYPE_P9813:   t = I_SS_P98_3; break;
        default: t=I_NONE;
      }
      if (t > I_NONE && isHSPI) t--; //hardware SPI has one smaller ID than software
      return t;
    } else {
      #ifdef ESP8266
      uint8_t offset = pins[0] -1; //for driver: 0 = uart0, 1 = uart1, 2 = dma, 3 = bitbang
      if (offset > 3) offset = 3;
      switch (busType) {
        case TYPE_WS2812_RGB:
        case TYPE_WS2812_WWA:
          return I_8266_U0_NEO_3 + offset;
        case TYPE_SK6812_RGBW:
          return I_8266_U0_NEO_4 + offset;
        case TYPE_WS2811_400KHZ:
          return I_8266_U0_400_3 + offset;
        case TYPE_TM1814:
          return I_8266_U0_TM1_4 + offset;
      }
      #else //ESP32
      uint8_t offset = 0; //0 = RMT (num 0-7) 8 = I2S0 9 = I2S1
      #ifndef CONFIG_IDF_TARGET_ESP32S2

      #if 1                          // 0..7 = RMT, 8 = I2S#1
      if (num > 8) return I_NONE;    // WLEDSR 9 instead of 10, as I2S#0 cannot be used for LEDs
      if (num > 7) offset = 2;       // WLEDSR skip I2S0, use I2S1
      #else                          // WLEDSR experimental: use I2S#1 for first bus --> less glitches, 10% faster
      if (num > 8) return I_NONE;    // 0 = I2S#1, 1..8 = RMT
      if (num == 0) offset = 2;
      #endif

      #else //ESP32 S2 only has 4 RMT channels
      if (num > 5) return I_NONE;
      if (num > 4) offset = num -4;
      #endif
      switch (busType) {
        case TYPE_WS2812_RGB:
        case TYPE_WS2812_WWA:
          return I_32_RN_NEO_3 + offset;
        case TYPE_SK6812_RGBW:
          return I_32_RN_NEO_4 + offset;
        case TYPE_WS2811_400KHZ:
          return I_32_RN_400_3 + offset;
        case TYPE_TM1814:
          return I_32_RN_TM1_4 + offset;
      }
      #endif
    }
    return I_NONE;
  }
};

#endif

=== ./button.cpp ===

#include "wled.h"

/*
 * Physical IO
 */

#define WLED_DEBOUNCE_THRESHOLD      50 // only consider button input of at least 50ms as valid (debouncing)
#define WLED_LONG_PRESS             600 // long press if button is released after held for at least 600ms
#define WLED_DOUBLE_PRESS           350 // double press if another press within 350ms after a short press
#define WLED_LONG_REPEATED_ACTION   300 // how often a repeated action (e.g. dimming) is fired on long press on button IDs >0
#define WLED_LONG_AP               5000 // how long button 0 needs to be held to activate WLED-AP
#define WLED_LONG_FACTORY_RESET   10000 // how long button 0 needs to be held to trigger a factory reset

static const char _mqtt_topic_button[] PROGMEM = "%s/button/%d";  // optimize flash usage

void shortPressAction(uint8_t b)
{
  if (!macroButton[b]) {
    switch (b) {
      case 0: toggleOnOff(); stateUpdated(CALL_MODE_BUTTON); break;
      case 1: ++effectCurrent %= strip.getModeCount(); stateChanged = true; colorUpdated(CALL_MODE_BUTTON); break;
    }
  } else {
    applyPreset(macroButton[b], CALL_MODE_BUTTON_PRESET);
  }

  // publish MQTT message
  if (buttonPublishMqtt && WLED_MQTT_CONNECTED) {
    char subuf[64];
    sprintf_P(subuf, _mqtt_topic_button, mqttDeviceTopic, (int)b);
    mqtt->publish(subuf, 0, false, "short");
  }
}

void longPressAction(uint8_t b)
{
  if (!macroLongPress[b]) {
    switch (b) {
      case 0: setRandomColor(col); colorUpdated(CALL_MODE_BUTTON); break;
      case 1: bri += 8; stateUpdated(CALL_MODE_BUTTON); buttonPressedTime[b] = millis(); break; // repeatable action
    }
  } else {
    applyPreset(macroLongPress[b], CALL_MODE_BUTTON_PRESET);
  }

  // publish MQTT message
  if (buttonPublishMqtt && WLED_MQTT_CONNECTED) {
    char subuf[64];
    sprintf_P(subuf, _mqtt_topic_button, mqttDeviceTopic, (int)b);
    mqtt->publish(subuf, 0, false, "long");
  }
}

void doublePressAction(uint8_t b)
{
  if (!macroDoublePress[b]) {
    switch (b) {
      //case 0: toggleOnOff(); colorUpdated(CALL_MODE_BUTTON); break; //instant short press on button 0 if no macro set
      case 1: ++effectPalette %= strip.getPaletteCount(); colorUpdated(CALL_MODE_BUTTON); break;
    }
  } else {
    applyPreset(macroDoublePress[b], CALL_MODE_BUTTON_PRESET);
  }

  // publish MQTT message
  if (buttonPublishMqtt && WLED_MQTT_CONNECTED) {
    char subuf[64];
    sprintf_P(subuf, _mqtt_topic_button, mqttDeviceTopic, (int)b);
    mqtt->publish(subuf, 0, false, "double");
  }
}

bool isButtonPressed(uint8_t i)
{
  if (btnPin[i]<0) return false;
  uint8_t pin = btnPin[i];

  switch (buttonType[i]) {
    case BTN_TYPE_NONE:
    case BTN_TYPE_RESERVED:
      break;
    case BTN_TYPE_PUSH:
    case BTN_TYPE_SWITCH:
      if (digitalRead(pin) == LOW) return true;
      break;
    case BTN_TYPE_PUSH_ACT_HIGH:
    case BTN_TYPE_PIR_SENSOR:
      if (digitalRead(pin) == HIGH) return true;
      break;
    case BTN_TYPE_TOUCH:
      #if defined(ARDUINO_ARCH_ESP32) && !defined(CONFIG_IDF_TARGET_ESP32C3)
      if (touchRead(pin) <= touchThreshold) return true;
      #endif
      break;
  }
  return false;
}

void handleSwitch(uint8_t b)
{
  // isButtonPressed() handles inverted/noninverted logic
  if (buttonPressedBefore[b] != isButtonPressed(b)) {
    buttonPressedTime[b] = millis();
    buttonPressedBefore[b] = !buttonPressedBefore[b];
  }

  if (buttonLongPressed[b] == buttonPressedBefore[b]) return;

  if (millis() - buttonPressedTime[b] > WLED_DEBOUNCE_THRESHOLD) { //fire edge event only after 50ms without change (debounce)
    if (!buttonPressedBefore[b]) { // on -> off
      if (macroButton[b]) applyPreset(macroButton[b], CALL_MODE_BUTTON_PRESET);
      else { //turn on
        if (!bri) {toggleOnOff(); stateUpdated(CALL_MODE_BUTTON);}
      }
    } else {  // off -> on
      if (macroLongPress[b]) applyPreset(macroLongPress[b], CALL_MODE_BUTTON_PRESET);
      else { //turn off
        if (bri) {toggleOnOff(); stateUpdated(CALL_MODE_BUTTON);}
      }
    }

    // publish MQTT message
    if (buttonPublishMqtt && WLED_MQTT_CONNECTED) {
      char subuf[64];
      if (buttonType[b] == BTN_TYPE_PIR_SENSOR) sprintf_P(subuf, PSTR("%s/motion/%d"), mqttDeviceTopic, (int)b);
      else sprintf_P(subuf, _mqtt_topic_button, mqttDeviceTopic, (int)b);
      mqtt->publish(subuf, 0, false, !buttonPressedBefore[b] ? "off" : "on");
    }

    buttonLongPressed[b] = buttonPressedBefore[b]; //save the last "long term" switch state
  }
}

#define ANALOG_BTN_READ_CYCLE 250   // min time between two analog reading cycles
#define STRIP_WAIT_TIME 6           // max wait time in case of strip.isUpdating()
#define POT_SMOOTHING 0.25f         // smoothing factor for raw potentiometer readings
#define POT_SENSITIVITY 4           // changes below this amount are noise (POT scratching, or ADC noise)

void handleAnalog(uint8_t b)
{
  static uint8_t oldRead[WLED_MAX_BUTTONS] = {0};
  static float filteredReading[WLED_MAX_BUTTONS] = {0.0f};
  uint16_t rawReading;    // raw value from analogRead, scaled to 12bit

  #ifdef ESP8266
  rawReading = analogRead(A0) << 2;   // convert 10bit read to 12bit
  #else
  if (digitalPinToAnalogChannel(btnPin[b]) >= 0)  // WLEDSR bugfix: check if GPIO is an ADC pin
    rawReading = analogRead(btnPin[b]); // collect at full 12bit resolution
  else 
    rawReading = 0;
  #endif
  yield();                            // keep WiFi task running - analog read may take several millis on ESP8266

  filteredReading[b] += POT_SMOOTHING * ((float(rawReading) / 16.0f) - filteredReading[b]); // filter raw input, and scale to [0..255]
  uint16_t aRead = max(min(int(filteredReading[b]), 255), 0);                               // squash into 8bit
  if(aRead <= POT_SENSITIVITY) aRead = 0;                                                   // make sure that 0 and 255 are used
  if(aRead >= 255-POT_SENSITIVITY) aRead = 255;

  if (buttonType[b] == BTN_TYPE_ANALOG_INVERTED) aRead = 255 - aRead;

  // remove noise & reduce frequency of UI updates
  if (abs(int(aRead) - int(oldRead[b])) <= POT_SENSITIVITY) return;  // no significant change in reading

  // Unomment the next lines if you still see flickering related to potentiometer
  // This waits until strip finishes updating (why: strip was not updating at the start of handleButton() but may have started during analogRead()?)
  //unsigned long wait_started = millis();
  //while(strip.isUpdating() && (millis() - wait_started < STRIP_WAIT_TIME)) {
  //  delay(1);
  //}
  //if (strip.isUpdating()) return; // give up

  oldRead[b] = aRead;

  // if no macro for "short press" and "long press" is defined use brightness control
  if (!macroButton[b] && !macroLongPress[b]) {
    // if "double press" macro defines which option to change
    if (macroDoublePress[b] >= 250) {
      // global brightness
      if (aRead == 0) {
        briLast = bri;
        bri = 0;
      } else{
        bri = aRead;
      }
    } else if (macroDoublePress[b] == 249) {
      // effect speed
      effectSpeed = aRead;
    } else if (macroDoublePress[b] == 248) {
      // effect intensity
      effectIntensity = aRead;
    } else if (macroDoublePress[b] == 247) {
      // selected palette
      effectPalette = map(aRead, 0, 252, 0, strip.getPaletteCount()-1);
      effectPalette = constrain(effectPalette, 0, strip.getPaletteCount()-1);  // map is allowed to "overshoot", so we need to contrain the result
    } else if (macroDoublePress[b] == 200) {
      // primary color, hue, full saturation
      colorHStoRGB(aRead*256,255,col);
    } else {
      // otherwise use "double press" for segment selection
      WS2812FX::Segment& seg = strip.getSegment(macroDoublePress[b]);
      if (aRead == 0) {
        seg.setOption(SEG_OPTION_ON, false); // off
      } else {
        seg.setOpacity(aRead, macroDoublePress[b]);
        seg.setOption(SEG_OPTION_ON, true);
      }
      // this will notify clients of update (websockets,mqtt,etc)
      updateInterfaces(CALL_MODE_BUTTON);
    }
  } else {
    //TODO:
    // we can either trigger a preset depending on the level (between short and long entries)
    // or use it for RGBW direct control
  }
  colorUpdated(CALL_MODE_BUTTON);
}

void handleButton()
{
  static unsigned long lastRead = 0UL;
  static unsigned long lastRun = 0UL;
  bool analog = false;
  unsigned long now = millis();

  //if (strip.isUpdating()) return; // don't interfere with strip updates. Our button will still be there in 1ms (next cycle)
  if (strip.isUpdating() && (millis() - lastRun < 200)) return;   // be niced, but avoid button starvation
  lastRun = millis();

  for (uint8_t b=0; b<WLED_MAX_BUTTONS; b++) {
    #ifdef ESP8266
    if ((btnPin[b]<0 && !(buttonType[b] == BTN_TYPE_ANALOG || buttonType[b] == BTN_TYPE_ANALOG_INVERTED)) || buttonType[b] == BTN_TYPE_NONE) continue;
    #else
    if (btnPin[b]<0 || buttonType[b] == BTN_TYPE_NONE) continue;
    #endif

    if (usermods.handleButton(b)) continue; // did usermod handle buttons

    if ((buttonType[b] == BTN_TYPE_ANALOG || buttonType[b] == BTN_TYPE_ANALOG_INVERTED) && ((now - lastRead) > ANALOG_BTN_READ_CYCLE)) {   // button is not a button but a potentiometer
      analog = true;
      handleAnalog(b); continue;
    }

    //button is not momentary, but switch. This is only suitable on pins whose on-boot state does not matter (NOT gpio0)
    if (buttonType[b] == BTN_TYPE_SWITCH || buttonType[b] == BTN_TYPE_PIR_SENSOR) {
      handleSwitch(b); continue;
    }

    //momentary button logic
    if (isButtonPressed(b)) { //pressed

      if (!buttonPressedBefore[b]) buttonPressedTime[b] = now;
      buttonPressedBefore[b] = true;

      if (now - buttonPressedTime[b] > WLED_LONG_PRESS) { //long press
        if (!buttonLongPressed[b]) longPressAction(b);
        else if (b) { //repeatable action (~3 times per s) on button > 0
          longPressAction(b);
          buttonPressedTime[b] = now - WLED_LONG_REPEATED_ACTION; //333ms
        }
        buttonLongPressed[b] = true;
      }

    } else if (!isButtonPressed(b) && buttonPressedBefore[b]) { //released

      long dur = now - buttonPressedTime[b];
      if (dur < WLED_DEBOUNCE_THRESHOLD) {buttonPressedBefore[b] = false; continue;} //too short "press", debounce
      bool doublePress = buttonWaitTime[b]; //did we have a short press before?
      buttonWaitTime[b] = 0;

      if (b == 0 && dur > WLED_LONG_AP) { // long press on button 0 (when released)
        if (dur > WLED_LONG_FACTORY_RESET) { // factory reset if pressed > 10 seconds
          WLED_FS.format();
          clearEEPROM();
          doReboot = true;
        } else {
          WLED::instance().initAP(true);
        }
      } else if (!buttonLongPressed[b]) { //short press
        //NOTE: this interferes with double click handling in usermods so usermod needs to implement full button handling
        if ((b != 1) && !macroDoublePress[b]) { //don't wait for double press on buttons without a default action if no double press macro set
          shortPressAction(b);
        } else { //double press if less than 350 ms between current press and previous short press release (buttonWaitTime!=0)
          if (doublePress) {
            doublePressAction(b);
          } else {
            buttonWaitTime[b] = now;
          }
        }
      }
      buttonPressedBefore[b] = false;
      buttonLongPressed[b] = false;
    }

    //if 350ms elapsed since last short press release it is a short press
    if (buttonWaitTime[b] && ((now - buttonWaitTime[b]) > WLED_DOUBLE_PRESS) && !buttonPressedBefore[b]) {
      buttonWaitTime[b] = 0;
      shortPressAction(b);
    }
  }
  if (analog) lastRead = now;
}

void handleIO()
{
  handleButton();

  //set relay when LEDs turn on
  if (strip.getBrightness())
  {
    lastOnTime = millis();
    if (offMode)
    {
      if (rlyPin>=0) {
        pinMode(rlyPin, OUTPUT);
        digitalWrite(rlyPin, rlyMde);
      }
      offMode = false;
    }
  } else if (millis() - lastOnTime > 600)
  {
    if (!offMode) {
      #ifdef ESP8266
      // turn off built-in LED if strip is turned off
      // this will break digital bus so will need to be reinitialised on On
      PinOwner ledPinOwner = pinManager.getPinOwner(LED_BUILTIN);
      if (!strip.isOffRefreshRequired() && (ledPinOwner == PinOwner::None || ledPinOwner == PinOwner::BusDigital)) {
        pinMode(LED_BUILTIN, OUTPUT);
        digitalWrite(LED_BUILTIN, HIGH);
      }
      #endif
      if (rlyPin>=0) {
        pinMode(rlyPin, OUTPUT);
        digitalWrite(rlyPin, !rlyMde);
      }
    }
    offMode = true;
  }
}
=== ./cfg.cpp ===

#include "wled.h"
#include "wled_ethernet.h"

/*
 * Serializes and parses the cfg.json and wsec.json settings files, stored in
 * internal FS. The structure of the JSON is not to be considered an official
 * API and may change without notice.
 */

// simple macro for ArduinoJSON's or syntax
#define CJSON(a, b) a = b | a

void getStringFromJson(char* dest, const char* src, size_t len) {
  if (src != nullptr) strlcpy(dest, src, len);
}

bool deserializeConfig(JsonObject doc, bool fromFS) {
  bool needsSave = false;
  // int rev_major = doc["rev"][0]; // 1
  // int rev_minor = doc["rev"][1]; // 0

  // long vid = doc[F("vid")]; // 2010020

#ifdef WLED_USE_ETHERNET
  JsonObject ethernet = doc[F("eth")];
  CJSON(ethernetType, ethernet["type"]);
  // NOTE: Ethernet configuration takes priority over other use of pins
  WLED::instance().initEthernet();
#endif

  JsonObject id = doc["id"];
  getStringFromJson(cmDNS, id[F("mdns")], 33);
  getStringFromJson(serverDescription, id[F("name")], 33);
  getStringFromJson(alexaInvocationName, id[F("inv")], 33);

  // nw   == network
  // ins  == instance, Future versions MAY have more than 1 network
  // configuration. Not at this time.
  JsonObject nw_ins_0 = doc["nw"]["ins"][0];
  getStringFromJson(clientSSID, nw_ins_0[F("ssid")], 33);
  // int nw_ins_0_pskl = nw_ins_0[F("pskl")];
  // The WiFi PSK is normally not contained in the regular file for security
  // reasons. If it is present however, we will use it
  getStringFromJson(clientPass, nw_ins_0["psk"], 65);

  JsonArray nw_ins_0_ip = nw_ins_0["ip"];  // ip == IP Address
  JsonArray nw_ins_0_gw = nw_ins_0["gw"];  // gw == gateway
  JsonArray nw_ins_0_sn = nw_ins_0["sn"];  // sn == subnet

  for (byte i = 0; i < 4; i++) {
    CJSON(staticIP[i], nw_ins_0_ip[i]);
    CJSON(staticGateway[i], nw_ins_0_gw[i]);
    CJSON(staticSubnet[i], nw_ins_0_sn[i]);
  }

  // ap   == access point
  JsonObject ap = doc["ap"];
  getStringFromJson(apSSID, ap[F("ssid")], 33);
  getStringFromJson(apPass, ap["psk"],
                    65);  // normally not present due to security
  // int ap_pskl = ap[F("pskl")];

  CJSON(apChannel, ap[F("chan")]);
  if (apChannel > 13 || apChannel < 1) apChannel = 1;

  CJSON(apHide, ap[F("hide")]);
  if (apHide > 1) apHide = 1;

  CJSON(apBehavior, ap[F("behav")]);
  /*
  JsonArray ap_ip = ap["ip"];
  for (byte i = 0; i < 4; i++) {
    apIP[i] = ap_ip;
  }
  */

  noWifiSleep = doc[F("wifi")][F("sleep")] | !noWifiSleep;  // inverted
  noWifiSleep = !noWifiSleep;
  // int wifi_phy = doc[F("wifi")][F("phy")]; //force phy mode n?

  // hw   == hardware
  JsonObject hw = doc[F("hw")];

  // initialize LED pins and lengths prior to other HW (except for ethernet)
  JsonObject hw_led = hw["led"];

  CJSON(strip.ablMilliampsMax, hw_led[F("maxpwr")]);
  CJSON(strip.milliampsPerLed, hw_led[F("ledma")]);
  CJSON(strip.autoWhiteMode, hw_led[F("rgbwm")]);
  Bus::setAutoWhiteMode(strip.autoWhiteMode);
  strip.fixInvalidSegments();  // refreshes segment light capabilities (in case
                               // auto white mode changed)
  CJSON(correctWB, hw_led["cct"]);
  CJSON(cctFromRgb, hw_led[F("cr")]);
  CJSON(strip.cctBlending, hw_led[F("cb")]);
  Bus::setCCTBlend(strip.cctBlending);
  strip.setTargetFps(hw_led["fps"]);  // NOP if 0, default 42 FPS

  // 2D Matrix Settings
  CJSON(strip.stripOrMatrixPanel, hw_led[F("somp")]);
  CJSON(strip.matrixWidth, hw_led[F("mxw")]);
  CJSON(strip.matrixHeight, hw_led[F("mxh")]);

  strip.setStripOrPanelWidthAndHeight();

  CJSON(strip.matrixPanels, hw_led[F("mxp")]);
  CJSON(strip.matrixHorizontalPanels, hw_led[F("mph")]);
  CJSON(strip.matrixVerticalPanels, hw_led[F("mpv")]);

  CJSON(strip.panelFirstLedTopBottom, hw_led[F("pfltb")]);
  CJSON(strip.panelFirstLedLeftRight, hw_led[F("pfllr")]);
  CJSON(strip.panelOrientationHorVert, hw_led[F("pohv")]);
  CJSON(strip.panelSerpentine, hw_led[F("pnls")]);
  CJSON(strip.panelTranspose, hw_led[F("pnlt")]);

  JsonArray ins = hw_led["ins"];

  if (fromFS || !ins.isNull()) {
    uint8_t s = 0;  // bus iterator
    if (fromFS)
      busses.removeAll();  // can't safely manipulate busses directly in network
                           // callback
    uint32_t mem = 0;
    bool busesChanged = false;
    for (JsonObject elm : ins) {
      if (s >= WLED_MAX_BUSSES) break;
      uint8_t pins[5] = {255, 255, 255, 255, 255};
      JsonArray pinArr = elm["pin"];
      if (pinArr.size() == 0) continue;
      pins[0] = pinArr[0];
      uint8_t i = 0;
      for (int p : pinArr) {
        pins[i++] = p;
        if (i > 4) break;
      }

      uint16_t length = elm["len"] | 1;
      uint8_t colorOrder = (int)elm[F("order")];
      uint8_t skipFirst = elm[F("skip")];
      uint16_t start = elm["start"] | 0;
      if (length == 0 || start + length > MAX_LEDS)
        continue;  // zero length or we reached max. number of LEDs, just stop
      uint8_t ledType = elm["type"] | TYPE_WS2812_RGB;
      bool reversed = elm["rev"];
      bool refresh = elm["ref"] | false;
      ledType |=
          refresh << 7;  // hack bit 7 to indicate strip requires off refresh
      if (fromFS) {
        BusConfig bc = BusConfig(ledType, pins, start, length, colorOrder,
                                 reversed, skipFirst);
        mem += BusManager::memUsage(bc);
        if (mem <= MAX_LED_MEMORY && busses.getNumBusses() <= WLED_MAX_BUSSES)
          busses.add(bc);  // finalization will be done in WLED::beginStrip()
      } else {
        if (busConfigs[s] != nullptr) delete busConfigs[s];
        busConfigs[s] = new BusConfig(ledType, pins, start, length, colorOrder,
                                      reversed, skipFirst);
        busesChanged = true;
      }
      s++;
    }
    doInitBusses = busesChanged;
    // finalization done in beginStrip()
  }
  if (hw_led["rev"])
    busses.getBus(0)->reversed =
        true;  // set 0.11 global reversed setting for first bus

  // read color order map configuration
  JsonArray hw_com = hw[F("com")];
  if (!hw_com.isNull()) {
    ColorOrderMap com = {};
    uint8_t s = 0;
    for (JsonObject entry : hw_com) {
      if (s > WLED_MAX_COLOR_ORDER_MAPPINGS) break;
      uint16_t start = entry["start"] | 0;
      uint16_t len = entry["len"] | 0;
      uint8_t colorOrder = (int)entry[F("order")];
      com.add(start, len, colorOrder);
      s++;
    }
    busses.updateColorOrderMap(com);
  }

  // read multiple button configuration
  JsonObject btn_obj = hw["btn"];
  JsonArray hw_btn_ins = btn_obj[F("ins")];
  if (!hw_btn_ins.isNull()) {
    uint8_t s = 0;
    for (JsonObject btn : hw_btn_ins) {
      CJSON(buttonType[s], btn["type"]);
      int8_t pin = btn["pin"][0] | -1;
      if (pin > -1 && pinManager.allocatePin(pin, false, PinOwner::Button)) {
        btnPin[s] = pin;
        pinMode(btnPin[s], INPUT_PULLUP);
      } else {
        btnPin[s] = -1;
      }
      JsonArray hw_btn_ins_0_macros = btn["macros"];
      CJSON(macroButton[s], hw_btn_ins_0_macros[0]);
      CJSON(macroLongPress[s], hw_btn_ins_0_macros[1]);
      CJSON(macroDoublePress[s], hw_btn_ins_0_macros[2]);
      if (++s >= WLED_MAX_BUTTONS) break;  // max buttons reached
    }
    // clear remaining buttons
    for (; s < WLED_MAX_BUTTONS; s++) {
      btnPin[s] = -1;
      buttonType[s] = BTN_TYPE_NONE;
      macroButton[s] = 0;
      macroLongPress[s] = 0;
      macroDoublePress[s] = 0;
    }
  } else {
    // new install/missing configuration (button 0 has defaults)
    if (fromFS) {
      // relies upon only being called once with fromFS == true, which is
      // currently true.
      uint8_t s = 0;
      if (pinManager.allocatePin(
              btnPin[0], false,
              PinOwner::Button)) {  // initialized to #define value BTNPIN, or
                                    // zero if not defined(!)
        ++s;  // do not clear default button if allocated successfully
      }
      for (; s < WLED_MAX_BUTTONS; s++) {
        btnPin[s] = -1;
        buttonType[s] = BTN_TYPE_NONE;
        macroButton[s] = 0;
        macroLongPress[s] = 0;
        macroDoublePress[s] = 0;
      }
    }
  }
  CJSON(touchThreshold, btn_obj[F("tt")]);
  CJSON(buttonPublishMqtt, btn_obj["mqtt"]);

  int hw_ir_pin = hw["ir"]["pin"] | -2;  // 4
  if (hw_ir_pin > -2) {
    if (pinManager.allocatePin(hw_ir_pin, false, PinOwner::IR)) {
      irPin = hw_ir_pin;
    } else {
      irPin = -1;
    }
  }
  CJSON(irEnabled, hw["ir"]["type"]);
  CJSON(irApplyToAllSelected, hw["ir"]["sel"]);

  JsonObject relay = hw[F("relay")];
  int hw_relay_pin = relay["pin"] | -2;
  if (hw_relay_pin > -2) {
    if (pinManager.allocatePin(hw_relay_pin, true, PinOwner::Relay)) {
      rlyPin = hw_relay_pin;
      pinMode(rlyPin, OUTPUT);
    } else {
      rlyPin = -1;
    }
  }
  if (relay.containsKey("rev")) {
    rlyMde = !relay["rev"];
  }

  CJSON(serialBaud, hw[F("baud")]);
  if (serialBaud < 96 || serialBaud > 15000) serialBaud = 1152;
  updateBaudRate(serialBaud * 100);

  // Sound Reactive Pin Config
  JsonObject analogmic = hw[F("analogmic")];  // analog mic JsonObject

  // int hw_amic_pin = analogmic[F("pin")];
  CJSON(audioPin, analogmic[F("pin")]);
  // if (pinManager.allocatePin(hw_amic_pin,false, PinOwner::AnalogMic)) {
  //   audioPin = hw_amic_pin;
  // } else {
  //   audioPin = audioPin;
  // }

  JsonObject hw_dmic = hw[F("digitalmic")];  // digital mic JsonObject
  CJSON(dmType, hw_dmic["en"]);

  JsonObject hw_dmic_pins = hw_dmic["pins"];  // digital mic pins JsonObject

  CJSON(i2ssdPin, hw_dmic_pins[F("i2ssd")]);
  // int hw_i2ssd_pin = hw_dmic_pins[F("i2ssd")];
  // if (pinManager.allocatePin(hw_i2ssd_pin,false, PinOwner::DigitalMic)) {
  //   i2ssdPin = hw_i2ssd_pin;
  // } else {
  //   i2ssdPin = i2ssdPin;
  // }
  CJSON(i2swsPin, hw_dmic_pins[F("i2sws")]);
  // int hw_i2sws_pin = hw_dmic_pins[F("i2sws")];
  // if (pinManager.allocatePin(hw_i2sws_pin,false, PinOwner::DigitalMic)) {
  //   i2swsPin = hw_i2sws_pin;
  // } else {
  //   i2swsPin = i2swsPin;
  // }

  CJSON(i2sckPin, hw_dmic_pins[F("i2sck")]);
  // int hw_i2sck_pin = hw_dmic_pins[F("i2sck")];
  // if (pinManager.allocatePin(hw_i2sck_pin,false, PinOwner::DigitalMic)) {
  //   i2sckPin = hw_i2sck_pin;
  // } else {
  //   i2sckPin = i2sckPin;
  // }

  CJSON(mclkPin, hw_dmic_pins[F("i2smclk")]);

  // int hw_status_pin = hw[F("status")]["pin"]; // -1

  JsonObject light = doc[F("light")];
  CJSON(briMultiplier, light[F("scale-bri")]);
  CJSON(strip.paletteBlend, light[F("pal-mode")]);
  CJSON(autoSegments, light[F("aseg")]);

  float light_gc_bri = light["gc"]["bri"];
  float light_gc_col = light["gc"]["col"];  // 2.8
  if (light_gc_bri > 1.5)
    strip.gammaCorrectBri = true;
  else if (light_gc_bri > 0.5)
    strip.gammaCorrectBri = false;
  if (light_gc_col > 1.5)
    strip.gammaCorrectCol = true;
  else if (light_gc_col > 0.5)
    strip.gammaCorrectCol = false;

  JsonObject light_tr = light["tr"];
  CJSON(fadeTransition, light_tr["mode"]);
  int tdd = light_tr["dur"] | -1;
  if (tdd >= 0) transitionDelayDefault = tdd * 100;
  CJSON(strip.paletteFade, light_tr["pal"]);

  JsonObject light_nl = light["nl"];
  CJSON(nightlightMode, light_nl["mode"]);
  byte prev = nightlightDelayMinsDefault;
  CJSON(nightlightDelayMinsDefault, light_nl["dur"]);
  if (nightlightDelayMinsDefault != prev)
    nightlightDelayMins = nightlightDelayMinsDefault;

  CJSON(nightlightTargetBri, light_nl[F("tbri")]);
  CJSON(macroNl, light_nl["macro"]);

  JsonObject def = doc["def"];
  CJSON(bootPreset, def["ps"]);
  CJSON(turnOnAtBoot, def["on"]);  // true
  CJSON(briS, def["bri"]);         // 128

  // if   == interfaces
  JsonObject interfaces = doc["if"];

  JsonObject if_sync = interfaces["sync"];
  CJSON(udpPort, if_sync[F("port0")]);   // 21324
  CJSON(udpPort2, if_sync[F("port1")]);  // 65506

  JsonObject if_sync_recv = if_sync["recv"];
  CJSON(receiveNotificationBrightness, if_sync_recv["bri"]);
  CJSON(receiveNotificationColor, if_sync_recv["col"]);
  CJSON(receiveNotificationEffects, if_sync_recv["fx"]);
  CJSON(receiveGroups, if_sync_recv["grp"]);
  CJSON(receiveSegmentOptions, if_sync_recv["seg"]);
  CJSON(receiveSegmentBounds, if_sync_recv["sb"]);
  //! following line might be a problem if called after boot
  receiveNotifications =
      (receiveNotificationBrightness || receiveNotificationColor ||
       receiveNotificationEffects || receiveSegmentOptions);

  JsonObject if_sync_send = if_sync["send"];
  prev = notifyDirectDefault;
  CJSON(notifyDirectDefault, if_sync_send[F("dir")]);
  if (notifyDirectDefault != prev) notifyDirect = notifyDirectDefault;
  CJSON(notifyButton, if_sync_send["btn"]);
  CJSON(notifyAlexa, if_sync_send["va"]);
  CJSON(notifyHue, if_sync_send["hue"]);
  CJSON(notifyMacro, if_sync_send["macro"]);
  CJSON(notifyTwice, if_sync_send[F("twice")]);
  CJSON(syncGroups, if_sync_send["grp"]);

  JsonObject if_nodes = interfaces["nodes"];
  CJSON(nodeListEnabled, if_nodes[F("list")]);
  CJSON(nodeBroadcastEnabled, if_nodes[F("bcast")]);

  JsonObject if_live = interfaces["live"];
  CJSON(receiveDirect, if_live["en"]);
  CJSON(useMainSegmentOnly, if_live[F("mso")]);
  CJSON(e131Port, if_live["port"]);  // 5568
  if (e131Port == DDP_DEFAULT_PORT)
    e131Port = E131_DEFAULT_PORT;  // prevent double DDP port allocation
  CJSON(e131Multicast, if_live[F("mc")]);

  JsonObject if_live_dmx = if_live[F("dmx")];
  CJSON(e131Universe, if_live_dmx[F("uni")]);
  CJSON(e131SkipOutOfSequence, if_live_dmx[F("seqskip")]);
  CJSON(DMXAddress, if_live_dmx[F("addr")]);
  CJSON(DMXMode, if_live_dmx["mode"]);

  tdd = if_live[F("timeout")] | -1;
  if (tdd >= 0) realtimeTimeoutMs = tdd * 100;
  CJSON(arlsForceMaxBri, if_live[F("maxbri")]);
  CJSON(arlsDisableGammaCorrection, if_live[F("no-gc")]);  // false
  CJSON(arlsOffset, if_live[F("offset")]);                 // 0

  CJSON(alexaEnabled, interfaces["va"][F("alexa")]);  // false

  CJSON(macroAlexaOn, interfaces["va"]["macros"][0]);
  CJSON(macroAlexaOff, interfaces["va"]["macros"][1]);

#ifdef WLED_ENABLE_MQTT
  JsonObject if_mqtt = interfaces["mqtt"];
  CJSON(mqttEnabled, if_mqtt["en"]);
  getStringFromJson(mqttServer, if_mqtt[F("broker")], 33);
  CJSON(mqttPort, if_mqtt["port"]);  // 1883
  getStringFromJson(mqttUser, if_mqtt[F("user")], 41);
  getStringFromJson(mqttPass, if_mqtt["psk"],
                    65);  // normally not present due to security
  getStringFromJson(mqttClientID, if_mqtt[F("cid")], 41);

  getStringFromJson(mqttDeviceTopic, if_mqtt[F("topics")][F("device")],
                    33);  // "wled/test"
  getStringFromJson(mqttGroupTopic, if_mqtt[F("topics")][F("group")],
                    33);  // ""
#endif

#ifndef WLED_DISABLE_HUESYNC
  JsonObject if_hue = interfaces["hue"];
  CJSON(huePollingEnabled, if_hue["en"]);
  CJSON(huePollLightId, if_hue["id"]);
  tdd = if_hue[F("iv")] | -1;
  if (tdd >= 2) huePollIntervalMs = tdd * 100;

  JsonObject if_hue_recv = if_hue["recv"];
  CJSON(hueApplyOnOff, if_hue_recv["on"]);
  CJSON(hueApplyBri, if_hue_recv["bri"]);
  CJSON(hueApplyColor, if_hue_recv["col"]);

  JsonArray if_hue_ip = if_hue["ip"];

  for (byte i = 0; i < 4; i++) CJSON(hueIP[i], if_hue_ip[i]);
#endif

  JsonObject if_ntp = interfaces[F("ntp")];
  CJSON(ntpEnabled, if_ntp["en"]);
  getStringFromJson(ntpServerName, if_ntp[F("host")],
                    33);  // "1.wled.pool.ntp.org"
  CJSON(currentTimezone, if_ntp[F("tz")]);
  CJSON(utcOffsetSecs, if_ntp[F("offset")]);
  CJSON(useAMPM, if_ntp[F("ampm")]);
  CJSON(longitude, if_ntp[F("ln")]);
  CJSON(latitude, if_ntp[F("lt")]);

  // ol   == overlay
  JsonObject ol = doc[F("ol")];
  CJSON(overlayCurrent, ol[F("clock")]);  // 0
  CJSON(countdownMode, ol[F("cntdwn")]);

  CJSON(overlayMin, ol["min"]);
  CJSON(overlayMax, ol[F("max")]);
  CJSON(analogClock12pixel, ol[F("o12pix")]);
  CJSON(analogClock5MinuteMarks, ol[F("o5m")]);
  CJSON(analogClockSecondsTrail, ol[F("osec")]);

  // timed macro rules
  JsonObject tm = doc[F("timers")];
  JsonObject cntdwn = tm[F("cntdwn")];
  JsonArray cntdwn_goal = cntdwn[F("goal")];
  CJSON(countdownYear, cntdwn_goal[0]);
  CJSON(countdownMonth, cntdwn_goal[1]);
  CJSON(countdownDay, cntdwn_goal[2]);
  CJSON(countdownHour, cntdwn_goal[3]);
  CJSON(countdownMin, cntdwn_goal[4]);
  CJSON(countdownSec, cntdwn_goal[5]);
  CJSON(macroCountdown, cntdwn["macro"]);
  setCountdown();

  JsonArray timers = tm["ins"];
  uint8_t it = 0;
  for (JsonObject timer : timers) {
    if (it > 9) break;
    if (it < 8 && timer[F("hour")] == 255)
      it = 8;  // hour==255 -> sunrise/sunset
    CJSON(timerHours[it], timer[F("hour")]);
    CJSON(timerMinutes[it], timer["min"]);
    CJSON(timerMacro[it], timer["macro"]);

    byte dowPrev = timerWeekday[it];
    // note: act is currently only 0 or 1.
    // the reason we are not using bool is that the on-disk type in 0.11.0 was
    // already int
    int actPrev = timerWeekday[it] & 0x01;
    CJSON(timerWeekday[it], timer[F("dow")]);
    if (timerWeekday[it] != dowPrev) {  // present in JSON
      timerWeekday[it] <<= 1;           // add active bit
      int act = timer["en"] | actPrev;
      if (act) timerWeekday[it]++;
    }
    if (it < 8) {
      JsonObject start = timer["start"];
      byte startm = start["mon"];
      if (startm) timerMonth[it] = (startm << 4);
      CJSON(timerDay[it], start["day"]);
      JsonObject end = timer["end"];
      CJSON(timerDayEnd[it], end["day"]);
      byte endm = end["mon"];
      if (startm) timerMonth[it] += endm & 0x0F;
      if (!(timerMonth[it] & 0x0F))
        timerMonth[it] += 12;  // default end month to 12
    }
    it++;
  }

  JsonObject ota = doc["ota"];
  const char* pwd = ota["psk"];  // normally not present due to security

  bool pwdCorrect = !otaLock;  // always allow access if ota not locked
  if (pwd != nullptr && strncmp(otaPass, pwd, 33) == 0) pwdCorrect = true;

  if (pwdCorrect) {  // only accept these values from cfg.json if ota is
                     // unlocked (else from wsec.json)
    CJSON(otaLock, ota[F("lock")]);
    CJSON(wifiLock, ota[F("lock-wifi")]);
    CJSON(aOtaEnabled, ota[F("aota")]);
    getStringFromJson(otaPass, pwd, 33);  // normally not present due to
                                          // security
  }

#ifdef WLED_ENABLE_DMX
  JsonObject dmx = doc["dmx"];
  CJSON(DMXChannels, dmx[F("chan")]);
  CJSON(DMXGap, dmx[F("gap")]);
  CJSON(DMXStart, dmx["start"]);
  CJSON(DMXStartLED, dmx[F("start-led")]);

  JsonArray dmx_fixmap = dmx[F("fixmap")];
  for (int i = 0; i < dmx_fixmap.size(); i++) {
    if (i > 14) break;
    CJSON(DMXFixtureMap[i], dmx_fixmap[i]);
  }

  CJSON(e131ProxyUniverse, dmx[F("e131proxy")]);
#endif

  // Begin Sound Reactive specific settings - 1st attempt
  JsonObject sound = doc["snd"];

  JsonObject snd_cfg = sound[F("cfg")];   // Sound Reactive Configuration
  CJSON(soundSquelch, snd_cfg[F("sq")]);  // sound squelch
  CJSON(sampleGain, snd_cfg[F("gn")]);    // gain
  CJSON(soundAgc, snd_cfg[F("agc")]);     // agc

  JsonObject snd_custom = sound[F("custom")];  // Custom settings
  CJSON(effectCustom1, snd_custom[F("c1")]);
  CJSON(effectCustom2, snd_custom[F("c2")]);
  CJSON(effectCustom3, snd_custom[F("c3")]);

  JsonObject snd_sync = sound[F("sync")];     // Sound Reactive audio sync
  CJSON(audioSyncPort, snd_sync[F("port")]);  // 11988
  CJSON(audioSyncEnabled, snd_sync[F("en")]);

  DEBUG_PRINTLN(F("Starting usermod config."));
  JsonObject usermods_settings = doc["um"];
  if (!usermods_settings.isNull()) {
    needsSave = !usermods.readFromConfig(usermods_settings);
  }

  if (fromFS) return needsSave;
  // if from /json/cfg
  doReboot = doc[F("rb")] | doReboot;
  if (doInitBusses)
    return false;  // no save needed, will do after bus init in wled.cpp loop
  return (doc["sv"] | true);
}

void deserializeConfigFromFS() {
  bool success = deserializeConfigSec();
  if (!success) {  // if file does not exist, try reading from EEPROM
    deEEPSettings();
    return;
  }

#ifdef WLED_USE_DYNAMIC_JSON
  DynamicJsonDocument doc(JSON_BUFFER_SIZE);
#else
  if (!requestJSONBufferLock(1)) return;
#endif

  DEBUG_PRINTLN(F("Reading settings from /cfg.json..."));

  success = readObjectFromFile("/cfg.json", nullptr, &doc);
  if (!success) {  // if file does not exist, try reading from EEPROM
    deEEPSettings();
    releaseJSONBufferLock();
    return;
  }

  // NOTE: This routine deserializes *and* applies the configuration
  //       Therefore, must also initialize ethernet from this function
  bool needsSave = deserializeConfig(doc.as<JsonObject>(), true);
  releaseJSONBufferLock();

  if (needsSave) serializeConfig();  // usermods required new prameters
}

void serializeConfig() {
  serializeConfigSec();

  DEBUG_PRINTLN(F("Writing settings to /cfg.json..."));

#ifdef WLED_USE_DYNAMIC_JSON
  DynamicJsonDocument doc(JSON_BUFFER_SIZE);
#else
  if (!requestJSONBufferLock(2)) return;
#endif

  JsonArray rev = doc.createNestedArray("rev");
  rev.add(1);  // major settings revision
  rev.add(0);  // minor settings revision

  doc[F("vid")] = VERSION;

  JsonObject id = doc.createNestedObject("id");
  id[F("mdns")] = cmDNS;
  id[F("name")] = serverDescription;
  id[F("inv")] = alexaInvocationName;

  JsonObject nw = doc.createNestedObject("nw");

  JsonArray nw_ins = nw.createNestedArray("ins");

  JsonObject nw_ins_0 = nw_ins.createNestedObject();
  nw_ins_0[F("ssid")] = clientSSID;
  nw_ins_0[F("pskl")] = strlen(clientPass);

  JsonArray nw_ins_0_ip = nw_ins_0.createNestedArray("ip");
  JsonArray nw_ins_0_gw = nw_ins_0.createNestedArray("gw");
  JsonArray nw_ins_0_sn = nw_ins_0.createNestedArray("sn");

  for (byte i = 0; i < 4; i++) {
    nw_ins_0_ip.add(staticIP[i]);
    nw_ins_0_gw.add(staticGateway[i]);
    nw_ins_0_sn.add(staticSubnet[i]);
  }

  JsonObject ap = doc.createNestedObject("ap");
  ap[F("ssid")] = apSSID;
  ap[F("pskl")] = strlen(apPass);
  ap[F("chan")] = apChannel;
  ap[F("hide")] = apHide;
  ap[F("behav")] = apBehavior;

  JsonArray ap_ip = ap.createNestedArray("ip");
  ap_ip.add(4);
  ap_ip.add(3);
  ap_ip.add(2);
  ap_ip.add(1);

  JsonObject wifi = doc.createNestedObject("wifi");
  wifi[F("sleep")] = !noWifiSleep;
  // wifi[F("phy")] = 1;

#ifdef WLED_USE_ETHERNET
  JsonObject ethernet = doc.createNestedObject("eth");
  ethernet["type"] = ethernetType;
  if (ethernetType != WLED_ETH_NONE && ethernetType < WLED_NUM_ETH_TYPES) {
    JsonArray pins = ethernet.createNestedArray("pin");
    for (uint8_t p = 0; p < WLED_ETH_RSVD_PINS_COUNT; p++)
      pins.add(esp32_nonconfigurable_ethernet_pins[p].pin);
    if (ethernetBoards[ethernetType].eth_power >= 0)
      pins.add(ethernetBoards[ethernetType].eth_power);
    if (ethernetBoards[ethernetType].eth_mdc >= 0)
      pins.add(ethernetBoards[ethernetType].eth_mdc);
    if (ethernetBoards[ethernetType].eth_mdio >= 0)
      pins.add(ethernetBoards[ethernetType].eth_mdio);
    switch (ethernetBoards[ethernetType].eth_clk_mode) {
      case ETH_CLOCK_GPIO0_IN:
      case ETH_CLOCK_GPIO0_OUT:
        pins.add(0);
        break;
      case ETH_CLOCK_GPIO16_OUT:
        pins.add(16);
        break;
      case ETH_CLOCK_GPIO17_OUT:
        pins.add(17);
        break;
    }
  }
#endif

  JsonObject hw = doc.createNestedObject("hw");

  JsonObject hw_led = hw.createNestedObject("led");
  hw_led[F("total")] =
      strip.getLengthTotal();  // no longer read, but provided for compatibility
                               // on downgrade
  hw_led[F("maxpwr")] = strip.ablMilliampsMax;
  hw_led[F("ledma")] = strip.milliampsPerLed;
  hw_led["cct"] = correctWB;
  hw_led[F("cr")] = cctFromRgb;
  hw_led[F("cb")] = strip.cctBlending;
  hw_led["fps"] = strip.getTargetFps();
  hw_led[F("rgbwm")] = strip.autoWhiteMode;

  // 2D Matrix Settings
  hw_led[F("somp")] = strip.stripOrMatrixPanel;
  hw_led[F("mxw")] = strip.matrixWidth;
  hw_led[F("mxh")] = strip.matrixHeight;

  // 2D Matrix Panels
  hw_led[F("mxp")] = strip.matrixPanels;
  hw_led[F("mph")] = strip.matrixHorizontalPanels;
  hw_led[F("mpv")] = strip.matrixVerticalPanels;

  hw_led[F("pfltb")] = strip.panelFirstLedTopBottom;
  hw_led[F("pfllr")] = strip.panelFirstLedLeftRight;
  hw_led[F("pohv")] = strip.panelOrientationHorVert;
  hw_led[F("pnls")] = strip.panelSerpentine;
  hw_led[F("pnlt")] = strip.panelTranspose;

  JsonArray hw_led_ins = hw_led.createNestedArray("ins");

  for (uint8_t s = 0; s < busses.getNumBusses(); s++) {
    Bus* bus = busses.getBus(s);
    if (!bus || bus->getLength() == 0) break;
    JsonObject ins = hw_led_ins.createNestedObject();
    ins["start"] = bus->getStart();
    ins["len"] = bus->getLength();
    JsonArray ins_pin = ins.createNestedArray("pin");
    uint8_t pins[5];
    uint8_t nPins = bus->getPins(pins);
    for (uint8_t i = 0; i < nPins; i++) ins_pin.add(pins[i]);
    ins[F("order")] = bus->getColorOrder();
    ins["rev"] = bus->reversed;
    ins[F("skip")] = bus->skippedLeds();
    ins["type"] = bus->getType() & 0x7F;
    ins["ref"] = bus->isOffRefreshRequired();
    // ins[F("rgbw")] = bus->isRgbw();
  }

  JsonArray hw_com = hw.createNestedArray(F("com"));
  const ColorOrderMap& com = busses.getColorOrderMap();
  for (uint8_t s = 0; s < com.count(); s++) {
    const ColorOrderMapEntry* entry = com.get(s);
    if (!entry) break;

    JsonObject co = hw_com.createNestedObject();
    co["start"] = entry->start;
    co["len"] = entry->len;
    co[F("order")] = entry->colorOrder;
  }

  // button(s)
  JsonObject hw_btn = hw.createNestedObject("btn");
  hw_btn["max"] = WLED_MAX_BUTTONS;  // just information about max number of
                                     // buttons (not actually used)
  JsonArray hw_btn_ins = hw_btn.createNestedArray("ins");

  // configuration for all buttons
  for (uint8_t i = 0; i < WLED_MAX_BUTTONS; i++) {
    JsonObject hw_btn_ins_0 = hw_btn_ins.createNestedObject();
    hw_btn_ins_0["type"] = buttonType[i];
    JsonArray hw_btn_ins_0_pin = hw_btn_ins_0.createNestedArray("pin");
    hw_btn_ins_0_pin.add(btnPin[i]);
    JsonArray hw_btn_ins_0_macros = hw_btn_ins_0.createNestedArray("macros");
    hw_btn_ins_0_macros.add(macroButton[i]);
    hw_btn_ins_0_macros.add(macroLongPress[i]);
    hw_btn_ins_0_macros.add(macroDoublePress[i]);
  }

  hw_btn[F("tt")] = touchThreshold;
  hw_btn["mqtt"] = buttonPublishMqtt;

  JsonObject hw_ir = hw.createNestedObject("ir");
  hw_ir["pin"] = irPin;
  hw_ir["type"] = irEnabled;  // the byte 'irEnabled' does contain the IR-Remote
                              // Type ( 0=disabled )
  hw_ir["sel"] = irApplyToAllSelected;

  JsonObject hw_relay = hw.createNestedObject(F("relay"));
  hw_relay["pin"] = rlyPin;
  hw_relay["rev"] = !rlyMde;

  hw[F("baud")] = serialBaud;

  // JsonObject hw_status = hw.createNestedObject("status");
  // hw_status["pin"] = -1;

  // Sound Reactive Pin Config
  JsonObject hw_amic = hw.createNestedObject("analogmic");
  hw_amic["pin"] = audioPin;

  JsonObject hw_dmic = hw.createNestedObject("digitalmic");
  hw_dmic["en"] = dmType;

  JsonObject hw_dmic_pins = hw_dmic.createNestedObject("pins");
  hw_dmic_pins[F("i2ssd")] = i2ssdPin;
  hw_dmic_pins[F("i2sws")] = i2swsPin;
  hw_dmic_pins[F("i2sck")] = i2sckPin;
  hw_dmic_pins[F("i2smclk")] = mclkPin;

  JsonObject light = doc.createNestedObject(F("light"));
  light[F("scale-bri")] = briMultiplier;
  light[F("pal-mode")] = strip.paletteBlend;
  light[F("aseg")] = autoSegments;

  JsonObject light_gc = light.createNestedObject("gc");
  light_gc["bri"] = (strip.gammaCorrectBri) ? 2.8 : 1.0;
  light_gc["col"] = (strip.gammaCorrectCol) ? 2.8 : 1.0;

  JsonObject light_tr = light.createNestedObject("tr");
  light_tr["mode"] = fadeTransition;
  light_tr["dur"] = transitionDelayDefault / 100;
  light_tr["pal"] = strip.paletteFade;

  JsonObject light_nl = light.createNestedObject("nl");
  light_nl["mode"] = nightlightMode;
  light_nl["dur"] = nightlightDelayMinsDefault;
  light_nl[F("tbri")] = nightlightTargetBri;
  light_nl["macro"] = macroNl;

  JsonObject def = doc.createNestedObject("def");
  def["ps"] = bootPreset;
  def["on"] = turnOnAtBoot;
  def["bri"] = briS;

  JsonObject interfaces = doc.createNestedObject("if");

  JsonObject if_sync = interfaces.createNestedObject("sync");
  if_sync[F("port0")] = udpPort;
  if_sync[F("port1")] = udpPort2;

  JsonObject if_sync_recv = if_sync.createNestedObject("recv");
  if_sync_recv["bri"] = receiveNotificationBrightness;
  if_sync_recv["col"] = receiveNotificationColor;
  if_sync_recv["fx"] = receiveNotificationEffects;
  if_sync_recv["grp"] = receiveGroups;
  if_sync_recv["seg"] = receiveSegmentOptions;
  if_sync_recv["sb"] = receiveSegmentBounds;

  JsonObject if_sync_send = if_sync.createNestedObject("send");
  if_sync_send[F("dir")] = notifyDirect;
  if_sync_send["btn"] = notifyButton;
  if_sync_send["va"] = notifyAlexa;
  if_sync_send["hue"] = notifyHue;
  if_sync_send["macro"] = notifyMacro;
  if_sync_send[F("twice")] = notifyTwice;
  if_sync_send["grp"] = syncGroups;

  JsonObject if_nodes = interfaces.createNestedObject("nodes");
  if_nodes[F("list")] = nodeListEnabled;
  if_nodes[F("bcast")] = nodeBroadcastEnabled;

  JsonObject if_live = interfaces.createNestedObject("live");
  if_live["en"] = receiveDirect;
  if_live[F("mso")] = useMainSegmentOnly;
  if_live["port"] = e131Port;
  if_live[F("mc")] = e131Multicast;

  JsonObject if_live_dmx = if_live.createNestedObject("dmx");
  if_live_dmx[F("uni")] = e131Universe;
  if_live_dmx[F("seqskip")] = e131SkipOutOfSequence;
  if_live_dmx[F("addr")] = DMXAddress;
  if_live_dmx["mode"] = DMXMode;

  if_live[F("timeout")] = realtimeTimeoutMs / 100;
  if_live[F("maxbri")] = arlsForceMaxBri;
  if_live[F("no-gc")] = arlsDisableGammaCorrection;
  if_live[F("offset")] = arlsOffset;

  JsonObject if_va = interfaces.createNestedObject("va");
  if_va[F("alexa")] = alexaEnabled;

  JsonArray if_va_macros = if_va.createNestedArray("macros");
  if_va_macros.add(macroAlexaOn);
  if_va_macros.add(macroAlexaOff);

#ifdef WLED_ENABLE_MQTT
  JsonObject if_mqtt = interfaces.createNestedObject("mqtt");
  if_mqtt["en"] = mqttEnabled;
  if_mqtt[F("broker")] = mqttServer;
  if_mqtt["port"] = mqttPort;
  if_mqtt[F("user")] = mqttUser;
  if_mqtt[F("pskl")] = strlen(mqttPass);
  if_mqtt[F("cid")] = mqttClientID;

  JsonObject if_mqtt_topics = if_mqtt.createNestedObject(F("topics"));
  if_mqtt_topics[F("device")] = mqttDeviceTopic;
  if_mqtt_topics[F("group")] = mqttGroupTopic;
#endif

#ifndef WLED_DISABLE_HUESYNC
  JsonObject if_hue = interfaces.createNestedObject("hue");
  if_hue["en"] = huePollingEnabled;
  if_hue["id"] = huePollLightId;
  if_hue[F("iv")] = huePollIntervalMs / 100;

  JsonObject if_hue_recv = if_hue.createNestedObject("recv");
  if_hue_recv["on"] = hueApplyOnOff;
  if_hue_recv["bri"] = hueApplyBri;
  if_hue_recv["col"] = hueApplyColor;

  JsonArray if_hue_ip = if_hue.createNestedArray("ip");
  for (byte i = 0; i < 4; i++) {
    if_hue_ip.add(hueIP[i]);
  }
#endif

  JsonObject if_ntp = interfaces.createNestedObject("ntp");
  if_ntp["en"] = ntpEnabled;
  if_ntp[F("host")] = ntpServerName;
  if_ntp[F("tz")] = currentTimezone;
  if_ntp[F("offset")] = utcOffsetSecs;
  if_ntp[F("ampm")] = useAMPM;
  if_ntp[F("ln")] = longitude;
  if_ntp[F("lt")] = latitude;

  JsonObject ol = doc.createNestedObject("ol");
  ol[F("clock")] = overlayCurrent;
  ol[F("cntdwn")] = countdownMode;

  ol["min"] = overlayMin;
  ol[F("max")] = overlayMax;
  ol[F("o12pix")] = analogClock12pixel;
  ol[F("o5m")] = analogClock5MinuteMarks;
  ol[F("osec")] = analogClockSecondsTrail;

  JsonObject timers = doc.createNestedObject(F("timers"));

  JsonObject cntdwn = timers.createNestedObject(F("cntdwn"));
  JsonArray goal = cntdwn.createNestedArray(F("goal"));
  goal.add(countdownYear);
  goal.add(countdownMonth);
  goal.add(countdownDay);
  goal.add(countdownHour);
  goal.add(countdownMin);
  goal.add(countdownSec);
  cntdwn["macro"] = macroCountdown;

  JsonArray timers_ins = timers.createNestedArray("ins");

  for (byte i = 0; i < 10; i++) {
    if (timerMacro[i] == 0 && timerHours[i] == 0 && timerMinutes[i] == 0)
      continue;  // sunrise/sunset get saved always (timerHours=255)
    JsonObject timers_ins0 = timers_ins.createNestedObject();
    timers_ins0["en"] = (timerWeekday[i] & 0x01);
    timers_ins0[F("hour")] = timerHours[i];
    timers_ins0["min"] = timerMinutes[i];
    timers_ins0["macro"] = timerMacro[i];
    timers_ins0[F("dow")] = timerWeekday[i] >> 1;
    if (i < 8) {
      JsonObject start = timers_ins0.createNestedObject("start");
      start["mon"] = (timerMonth[i] >> 4) & 0xF;
      start["day"] = timerDay[i];
      JsonObject end = timers_ins0.createNestedObject("end");
      end["mon"] = timerMonth[i] & 0xF;
      end["day"] = timerDayEnd[i];
    }
  }

  JsonObject ota = doc.createNestedObject("ota");
  ota[F("lock")] = otaLock;
  ota[F("lock-wifi")] = wifiLock;
  ota[F("pskl")] = strlen(otaPass);
  ota[F("aota")] = aOtaEnabled;

#ifdef WLED_ENABLE_DMX
  JsonObject dmx = doc.createNestedObject("dmx");
  dmx[F("chan")] = DMXChannels;
  dmx[F("gap")] = DMXGap;
  dmx["start"] = DMXStart;
  dmx[F("start-led")] = DMXStartLED;

  JsonArray dmx_fixmap = dmx.createNestedArray(F("fixmap"));
  for (byte i = 0; i < 15; i++) {
    dmx_fixmap.add(DMXFixtureMap[i]);
  }

  dmx[F("e131proxy")] = e131ProxyUniverse;
#endif

  // Begin Sound Reactive specific settings - 1st attempt
  JsonObject sound = doc.createNestedObject("snd");

  JsonObject snd_cfg =
      sound.createNestedObject("cfg");  // Sound Reactive Configuration
  snd_cfg[F("sq")] = soundSquelch;
  snd_cfg[F("gn")] = sampleGain;
  snd_cfg[F("agc")] = soundAgc;

  JsonObject snd_custom =
      sound.createNestedObject("custom");  // Custom settings
  snd_custom[F("c1")] = effectCustom1;
  snd_custom[F("c2")] = effectCustom2;
  snd_custom[F("c3")] = effectCustom3;

  JsonObject snd_sync =
      sound.createNestedObject("sync");  // Sound Reactive audio sync
  snd_sync[F("port")] = audioSyncPort;   // 11988
  snd_sync[F("en")] = audioSyncEnabled;

  JsonObject usermods_settings = doc.createNestedObject("um");
  usermods.addToConfig(usermods_settings);

  File f = WLED_FS.open("/cfg.json", "w");
  if (f) serializeJson(doc, f);
  f.close();
  releaseJSONBufferLock();
}

// settings in /wsec.json, not accessible via webserver, for passwords and
// tokens
bool deserializeConfigSec() {
  DEBUG_PRINTLN(F("Reading settings from /wsec.json..."));

#ifdef WLED_USE_DYNAMIC_JSON
  DynamicJsonDocument doc(JSON_BUFFER_SIZE);
#else
  if (!requestJSONBufferLock(3)) return false;
#endif

  bool success = readObjectFromFile("/wsec.json", nullptr, &doc);
  if (!success) {
    releaseJSONBufferLock();
    return false;
  }

  JsonObject nw_ins_0 = doc["nw"]["ins"][0];
  getStringFromJson(clientPass, nw_ins_0["psk"], 65);

  JsonObject ap = doc["ap"];
  getStringFromJson(apPass, ap["psk"], 65);

  JsonObject interfaces = doc["if"];

#ifdef WLED_ENABLE_MQTT
  JsonObject if_mqtt = interfaces["mqtt"];
  getStringFromJson(mqttPass, if_mqtt["psk"], 65);
#endif

#ifndef WLED_DISABLE_HUESYNC
  getStringFromJson(hueApiKey, interfaces["hue"][F("key")], 47);
#endif

  JsonObject ota = doc["ota"];
  getStringFromJson(otaPass, ota[F("pwd")], 33);
  CJSON(otaLock, ota[F("lock")]);
  CJSON(wifiLock, ota[F("lock-wifi")]);
  CJSON(aOtaEnabled, ota[F("aota")]);

  releaseJSONBufferLock();
  return true;
}

void serializeConfigSec() {
  DEBUG_PRINTLN(F("Writing settings to /wsec.json..."));

#ifdef WLED_USE_DYNAMIC_JSON
  DynamicJsonDocument doc(JSON_BUFFER_SIZE);
#else
  if (!requestJSONBufferLock(4)) return;
#endif

  JsonObject nw = doc.createNestedObject("nw");

  JsonArray nw_ins = nw.createNestedArray("ins");

  JsonObject nw_ins_0 = nw_ins.createNestedObject();
  nw_ins_0["psk"] = clientPass;

  JsonObject ap = doc.createNestedObject("ap");
  ap["psk"] = apPass;

  JsonObject interfaces = doc.createNestedObject("if");
#ifdef WLED_ENABLE_MQTT
  JsonObject if_mqtt = interfaces.createNestedObject("mqtt");
  if_mqtt["psk"] = mqttPass;
#endif
#ifndef WLED_DISABLE_HUESYNC
  JsonObject if_hue = interfaces.createNestedObject("hue");
  if_hue[F("key")] = hueApiKey;
#endif

  JsonObject ota = doc.createNestedObject("ota");
  ota[F("pwd")] = otaPass;
  ota[F("lock")] = otaLock;
  ota[F("lock-wifi")] = wifiLock;
  ota[F("aota")] = aOtaEnabled;

  File f = WLED_FS.open("/wsec.json", "w");
  if (f) serializeJson(doc, f);
  f.close();
  releaseJSONBufferLock();
}

=== ./colors.cpp ===

#include "wled.h"

/*
 * Color conversion methods
 */

void setRandomColor(byte* rgb)
{
  lastRandomIndex = strip.get_random_wheel_index(lastRandomIndex);
  colorHStoRGB(lastRandomIndex*256,255,rgb);
}

void colorHStoRGB(uint16_t hue, byte sat, byte* rgb) //hue, sat to rgb
{
  float h = ((float)hue)/65535.0;
  float s = ((float)sat)/255.0;
  byte i = floor(h*6);
  float f = h * 6-i;
  float p = 255 * (1-s);
  float q = 255 * (1-f*s);
  float t = 255 * (1-(1-f)*s);
  switch (i%6) {
    case 0: rgb[0]=255,rgb[1]=t,rgb[2]=p;break;
    case 1: rgb[0]=q,rgb[1]=255,rgb[2]=p;break;
    case 2: rgb[0]=p,rgb[1]=255,rgb[2]=t;break;
    case 3: rgb[0]=p,rgb[1]=q,rgb[2]=255;break;
    case 4: rgb[0]=t,rgb[1]=p,rgb[2]=255;break;
    case 5: rgb[0]=255,rgb[1]=p,rgb[2]=q;
  }
}

//get RGB values from color temperature in K (https://tannerhelland.com/2012/09/18/convert-temperature-rgb-algorithm-code.html)
void colorKtoRGB(uint16_t kelvin, byte* rgb) //white spectrum to rgb, calc
{
  float r = 0, g = 0, b = 0;
  float temp = kelvin / 100;
  if (temp <= 66) {
    r = 255;
    g = round(99.4708025861 * log(temp) - 161.1195681661);
    if (temp <= 19) {
      b = 0;
    } else {
      b = round(138.5177312231 * log((temp - 10)) - 305.0447927307);
    }
  } else {
    r = round(329.698727446 * pow((temp - 60), -0.1332047592));
    g = round(288.1221695283 * pow((temp - 60), -0.0755148492));
    b = 255;
  } 
  //g += 12; //mod by Aircoookie, a bit less accurate but visibly less pinkish
  rgb[0] = (uint8_t) constrain(r, 0, 255);
  rgb[1] = (uint8_t) constrain(g, 0, 255);
  rgb[2] = (uint8_t) constrain(b, 0, 255);
  rgb[3] = 0;
}

void colorCTtoRGB(uint16_t mired, byte* rgb) //white spectrum to rgb, bins
{
  //this is only an approximation using WS2812B with gamma correction enabled
  if (mired > 475) {
    rgb[0]=255;rgb[1]=199;rgb[2]=92;//500
  } else if (mired > 425) {
    rgb[0]=255;rgb[1]=213;rgb[2]=118;//450
  } else if (mired > 375) {
    rgb[0]=255;rgb[1]=216;rgb[2]=118;//400
  } else if (mired > 325) {
    rgb[0]=255;rgb[1]=234;rgb[2]=140;//350
  } else if (mired > 275) {
    rgb[0]=255;rgb[1]=243;rgb[2]=160;//300
  } else if (mired > 225) {
    rgb[0]=250;rgb[1]=255;rgb[2]=188;//250
  } else if (mired > 175) {
    rgb[0]=247;rgb[1]=255;rgb[2]=215;//200
  } else {
    rgb[0]=237;rgb[1]=255;rgb[2]=239;//150
  }
}

#ifndef WLED_DISABLE_HUESYNC
void colorXYtoRGB(float x, float y, byte* rgb) //coordinates to rgb (https://www.developers.meethue.com/documentation/color-conversions-rgb-xy)
{
  float z = 1.0f - x - y;
  float X = (1.0f / y) * x;
  float Z = (1.0f / y) * z;
  float r = (int)255*(X * 1.656492f - 0.354851f - Z * 0.255038f);
  float g = (int)255*(-X * 0.707196f + 1.655397f + Z * 0.036152f);
  float b = (int)255*(X * 0.051713f - 0.121364f + Z * 1.011530f);
  if (r > b && r > g && r > 1.0f) {
    // red is too big
    g = g / r;
    b = b / r;
    r = 1.0f;
  } else if (g > b && g > r && g > 1.0f) {
    // green is too big
    r = r / g;
    b = b / g;
    g = 1.0f;
  } else if (b > r && b > g && b > 1.0f) {
    // blue is too big
    r = r / b;
    g = g / b;
    b = 1.0f;
  }
  // Apply gamma correction
  r = r <= 0.0031308f ? 12.92f * r : (1.0f + 0.055f) * pow(r, (1.0f / 2.4f)) - 0.055f;
  g = g <= 0.0031308f ? 12.92f * g : (1.0f + 0.055f) * pow(g, (1.0f / 2.4f)) - 0.055f;
  b = b <= 0.0031308f ? 12.92f * b : (1.0f + 0.055f) * pow(b, (1.0f / 2.4f)) - 0.055f;

  if (r > b && r > g) {
    // red is biggest
    if (r > 1.0f) {
      g = g / r;
      b = b / r;
      r = 1.0f;
    }
  } else if (g > b && g > r) {
    // green is biggest
    if (g > 1.0f) {
      r = r / g;
      b = b / g;
      g = 1.0f;
    }
  } else if (b > r && b > g) {
    // blue is biggest
    if (b > 1.0f) {
      r = r / b;
      g = g / b;
      b = 1.0f;
    }
  }
  rgb[0] = 255.0*r;
  rgb[1] = 255.0*g;
  rgb[2] = 255.0*b;
}

void colorRGBtoXY(byte* rgb, float* xy) //rgb to coordinates (https://www.developers.meethue.com/documentation/color-conversions-rgb-xy)
{
  float X = rgb[0] * 0.664511f + rgb[1] * 0.154324f + rgb[2] * 0.162028f;
  float Y = rgb[0] * 0.283881f + rgb[1] * 0.668433f + rgb[2] * 0.047685f;
  float Z = rgb[0] * 0.000088f + rgb[1] * 0.072310f + rgb[2] * 0.986039f;
  xy[0] = X / (X + Y + Z);
  xy[1] = Y / (X + Y + Z);
}
#endif // WLED_DISABLE_HUESYNC

//RRGGBB / WWRRGGBB order for hex
void colorFromDecOrHexString(byte* rgb, char* in)
{
  if (in[0] == 0) return;
  char first = in[0];
  uint32_t c = 0;
  
  if (first == '#' || first == 'h' || first == 'H') //is HEX encoded
  {
    c = strtoul(in +1, NULL, 16);
  } else
  {
    c = strtoul(in, NULL, 10);
  }

  rgb[0] = R(c);
  rgb[1] = G(c);
  rgb[2] = B(c);
  rgb[3] = W(c);
}

//contrary to the colorFromDecOrHexString() function, this uses the more standard RRGGBB / RRGGBBWW order
bool colorFromHexString(byte* rgb, const char* in) {
  if (in == nullptr) return false;
  size_t inputSize = strnlen(in, 9);
  if (inputSize != 6 && inputSize != 8) return false;

  uint32_t c = strtoul(in, NULL, 16);

  if (inputSize == 6) {
    rgb[0] = (c >> 16);
    rgb[1] = (c >>  8);
    rgb[2] =  c       ;
  } else {
    rgb[0] = (c >> 24);
    rgb[1] = (c >> 16);
    rgb[2] = (c >>  8);
    rgb[3] =  c       ;
  }
  return true;
}

float minf (float v, float w)
{
  if (w > v) return v;
  return w;
}

float maxf (float v, float w)
{
  if (w > v) return w;
  return v;
}

/*
uint32_t colorRGBtoRGBW(uint32_t c)
{
  byte rgb[4];
  rgb[0] = R(c);
  rgb[1] = G(c);
  rgb[2] = B(c);
  rgb[3] = W(c);
  colorRGBtoRGBW(rgb);
  return RGBW32(rgb[0], rgb[1], rgb[2], rgb[3]);
}

void colorRGBtoRGBW(byte* rgb) //rgb to rgbw (http://codewelt.com/rgbw). (RGBW_MODE_LEGACY)
{
  float low = minf(rgb[0],minf(rgb[1],rgb[2]));
  float high = maxf(rgb[0],maxf(rgb[1],rgb[2]));
  if (high < 0.1f) return;
  float sat = 100.0f * ((high - low) / high);   // maximum saturation is 100  (corrected from 255)
  rgb[3] = (byte)((255.0f - sat) / 255.0f * (rgb[0] + rgb[1] + rgb[2]) / 3);
}
*/

byte correctionRGB[4] = {0,0,0,0};
uint16_t lastKelvin = 0;

// adjust RGB values based on color temperature in K (range [2800-10200]) (https://en.wikipedia.org/wiki/Color_balance)
uint32_t colorBalanceFromKelvin(uint16_t kelvin, uint32_t rgb)
{
  //remember so that slow colorKtoRGB() doesn't have to run for every setPixelColor()
  if (lastKelvin != kelvin) colorKtoRGB(kelvin, correctionRGB);  // convert Kelvin to RGB
  lastKelvin = kelvin;
  byte rgbw[4];
  rgbw[0] = ((uint16_t) correctionRGB[0] * R(rgb)) /255; // correct R
  rgbw[1] = ((uint16_t) correctionRGB[1] * G(rgb)) /255; // correct G
  rgbw[2] = ((uint16_t) correctionRGB[2] * B(rgb)) /255; // correct B
  rgbw[3] =                                W(rgb);
  return RGBW32(rgbw[0],rgbw[1],rgbw[2],rgbw[3]);
}

//approximates a Kelvin color temperature from an RGB color.
//this does no check for the "whiteness" of the color,
//so should be used combined with a saturation check (as done by auto-white)
//values from http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html (10deg)
//equation spreadsheet at https://bit.ly/30RkHaN
//accuracy +-50K from 1900K up to 8000K
//minimum returned: 1900K, maximum returned: 10091K (range of 8192)
uint16_t approximateKelvinFromRGB(uint32_t rgb) {
  //if not either red or blue is 255, color is dimmed. Scale up
  uint8_t r = R(rgb), b = B(rgb);
  if (r == b) return 6550; //red == blue at about 6600K (also can't go further if both R and B are 0)

  if (r > b) {
    //scale blue up as if red was at 255
    uint16_t scale = 0xFFFF / r; //get scale factor (range 257-65535)
    b = ((uint16_t)b * scale) >> 8;
    //For all temps K<6600 R is bigger than B (for full bri colors R=255)
    //-> Use 9 linear approximations for blackbody radiation blue values from 2000-6600K (blue is always 0 below 2000K)
    if (b < 33)  return 1900 + b       *6;
    if (b < 72)  return 2100 + (b-33)  *10;
    if (b < 101) return 2492 + (b-72)  *14;
    if (b < 132) return 2900 + (b-101) *16;
    if (b < 159) return 3398 + (b-132) *19;
    if (b < 186) return 3906 + (b-159) *22;
    if (b < 210) return 4500 + (b-186) *25;
    if (b < 230) return 5100 + (b-210) *30;
                 return 5700 + (b-230) *34;
  } else {
    //scale red up as if blue was at 255
    uint16_t scale = 0xFFFF / b; //get scale factor (range 257-65535)
    r = ((uint16_t)r * scale) >> 8;
    //For all temps K>6600 B is bigger than R (for full bri colors B=255)
    //-> Use 2 linear approximations for blackbody radiation red values from 6600-10091K (blue is always 0 below 2000K)
    if (r > 225) return 6600 + (254-r) *50;
    uint16_t k = 8080 + (225-r) *86;
    return (k > 10091) ? 10091 : k;
  }
}

=== ./const.h ===

#ifndef WLED_CONST_H
#define WLED_CONST_H

/*
 * Readability defines and their associated numerical values + compile-time constants
 */

//Defaults
#define DEFAULT_CLIENT_SSID "Your_Network"
#define DEFAULT_AP_PASS     "wled1234"
#define DEFAULT_OTA_PASS    "wledota"

//increase if you need more
#ifndef WLED_MAX_USERMODS
  #ifdef ESP8266
    #define WLED_MAX_USERMODS 4
  #else
    #define WLED_MAX_USERMODS 6
  #endif
#endif

#ifndef WLED_MAX_BUSSES
  #ifdef ESP8266
    #define WLED_MAX_BUSSES 3
  #else
    #ifdef CONFIG_IDF_TARGET_ESP32S2
      #define WLED_MAX_BUSSES 5
    #else
      #define WLED_MAX_BUSSES 9 // WLEDSR I2S#0 is reserved for audio (needed both for analog _and_ digital)
    #endif
  #endif
#endif

#ifndef WLED_MAX_BUTTONS
  #ifdef ESP8266
    #define WLED_MAX_BUTTONS 2
  #else
    #define WLED_MAX_BUTTONS 4
  #endif
#endif

#ifdef ESP8266
#define WLED_MAX_COLOR_ORDER_MAPPINGS 5
#else
#define WLED_MAX_COLOR_ORDER_MAPPINGS 10
#endif

//Usermod IDs
#define USERMOD_ID_RESERVED               0     //Unused. Might indicate no usermod present
#define USERMOD_ID_UNSPECIFIED            1     //Default value for a general user mod that does not specify a custom ID
#define USERMOD_ID_EXAMPLE                2     //Usermod "usermod_v2_example.h"
#define USERMOD_ID_TEMPERATURE            3     //Usermod "usermod_temperature.h"
#define USERMOD_ID_FIXNETSERVICES         4     //Usermod "usermod_Fix_unreachable_netservices.h"
#define USERMOD_ID_PIRSWITCH              5     //Usermod "usermod_PIR_sensor_switch.h"
#define USERMOD_ID_IMU                    6     //Usermod "usermod_mpu6050_imu.h"
#define USERMOD_ID_FOUR_LINE_DISP         7     //Usermod "usermod_v2_four_line_display.h
#define USERMOD_ID_ROTARY_ENC_UI          8     //Usermod "usermod_v2_rotary_encoder_ui.h"
#define USERMOD_ID_AUTO_SAVE              9     //Usermod "usermod_v2_auto_save.h"
#define USERMOD_ID_DHT                   10     //Usermod "usermod_dht.h"
#define USERMOD_ID_MODE_SORT             11     //Usermod "usermod_v2_mode_sort.h"
#define USERMOD_ID_VL53L0X               12     //Usermod "usermod_vl53l0x_gestures.h"
#define USERMOD_ID_MULTI_RELAY           13     //Usermod "usermod_multi_relay.h"
#define USERMOD_ID_ANIMATED_STAIRCASE    14     //Usermod "Animated_Staircase.h"
#define USERMOD_ID_RTC                   15     //Usermod "usermod_rtc.h"
#define USERMOD_ID_ELEKSTUBE_IPS         16     //Usermod "usermod_elekstube_ips.h"
#define USERMOD_ID_SN_PHOTORESISTOR      17     //Usermod "usermod_sn_photoresistor.h"
#define USERMOD_ID_BATTERY_STATUS_BASIC  18     //Usermod "usermod_v2_battery_status_basic.h"
#define USERMOD_ID_PWM_FAN               19     //Usermod "usermod_PWM_fan.h"
#define USERMOD_ID_BH1750                20     //Usermod "usermod_bh1750.h"
#define USERMOD_ID_SEVEN_SEGMENT_DISPLAY 21     //Usermod "usermod_v2_seven_segment_display.h"
#define USERMOD_RGB_ROTARY_ENCODER       22     //Usermod "rgb-rotary-encoder.h"
#define USERMOD_ID_QUINLED_AN_PENTA      23     //Usermod "quinled-an-penta.h"
#define USERMOD_ID_SSDR                  24     //Usermod "usermod_v2_seven_segment_display_reloaded.h"
#define USERMOD_ID_CRONIXIE              25     //Usermod "usermod_cronixie.h"
#define USERMOD_ID_WIZLIGHTS             26     //Usermod "wizlights.h"
#define USERMOD_ID_WORDCLOCK             27     //Usermod "usermod_v2_word_clock.h"
#define USERMOD_ID_MY9291                28     //Usermod "usermod_MY9291.h"
#define USERMOD_ID_SI7021_MQTT_HA        29     //Usermod "usermod_si7021_mqtt_ha.h"
#define USERMOD_ID_BME280                30     //Usermod "usermod_bme280.h
//WLEDMM
#define USERMOD_ID_ARTIFX                31     //Usermod "usermod_v2_artifx.h"

//Access point behavior
#define AP_BEHAVIOR_BOOT_NO_CONN          0     //Open AP when no connection after boot
#define AP_BEHAVIOR_NO_CONN               1     //Open when no connection (either after boot or if connection is lost)
#define AP_BEHAVIOR_ALWAYS                2     //Always open
#define AP_BEHAVIOR_BUTTON_ONLY           3     //Only when button pressed for 6 sec

//Notifier callMode
#define CALL_MODE_INIT           0     //no updates on init, can be used to disable updates
#define CALL_MODE_DIRECT_CHANGE  1
#define CALL_MODE_BUTTON         2     //default button actions applied to selected segments
#define CALL_MODE_NOTIFICATION   3
#define CALL_MODE_NIGHTLIGHT     4
#define CALL_MODE_NO_NOTIFY      5
#define CALL_MODE_FX_CHANGED     6     //no longer used
#define CALL_MODE_HUE            7
#define CALL_MODE_PRESET_CYCLE   8
#define CALL_MODE_BLYNK          9
#define CALL_MODE_ALEXA         10
#define CALL_MODE_WS_SEND       11     //special call mode, not for notifier, updates websocket only
#define CALL_MODE_BUTTON_PRESET 12     //button/IR JSON preset/macro

//RGB to RGBW conversion mode
#define RGBW_MODE_MANUAL_ONLY     0            //No automatic white channel calculation. Manual white channel slider
#define RGBW_MODE_AUTO_BRIGHTER   1            //New algorithm. Adds as much white as the darkest RGBW channel
#define RGBW_MODE_AUTO_ACCURATE   2            //New algorithm. Adds as much white as the darkest RGBW channel and subtracts this amount from each RGB channel
#define RGBW_MODE_DUAL            3            //Manual slider + auto calculation. Automatically calculates only if manual slider is set to off (0)
#define RGBW_MODE_LEGACY          4            //Old floating algorithm. Too slow for realtime and palette support

//realtime modes
#define REALTIME_MODE_INACTIVE    0
#define REALTIME_MODE_GENERIC     1
#define REALTIME_MODE_UDP         2
#define REALTIME_MODE_HYPERION    3
#define REALTIME_MODE_E131        4
#define REALTIME_MODE_ADALIGHT    5
#define REALTIME_MODE_ARTNET      6
#define REALTIME_MODE_TPM2NET     7
#define REALTIME_MODE_DDP         8

//realtime override modes
#define REALTIME_OVERRIDE_NONE    0
#define REALTIME_OVERRIDE_ONCE    1
#define REALTIME_OVERRIDE_ALWAYS  2

//E1.31 DMX modes
#define DMX_MODE_DISABLED         0            //not used
#define DMX_MODE_SINGLE_RGB       1            //all LEDs same RGB color (3 channels)
#define DMX_MODE_SINGLE_DRGB      2            //all LEDs same RGB color and master dimmer (4 channels)
#define DMX_MODE_EFFECT           3            //trigger standalone effects of WLED (11 channels)
#define DMX_MODE_MULTIPLE_RGB     4            //every LED is addressed with its own RGB (ledCount * 3 channels)
#define DMX_MODE_MULTIPLE_DRGB    5            //every LED is addressed with its own RGB and share a master dimmer (ledCount * 3 + 1 channels)
#define DMX_MODE_MULTIPLE_RGBW    6            //every LED is addressed with its own RGBW (ledCount * 4 channels)

//Light capability byte (unused) 0bRCCCTTTT
//bits 0/1/2/3: specifies a type of LED driver. A single "driver" may have different chip models but must have the same protocol/behavior
//bits 4/5/6: specifies the class of LED driver - 0b000 (dec. 0-15)  unconfigured/reserved
//                                              - 0b001 (dec. 16-31) digital (data pin only)
//                                              - 0b010 (dec. 32-47) analog (PWM)
//                                              - 0b011 (dec. 48-63) digital (data + clock / SPI)
//                                              - 0b100 (dec. 64-79) unused/reserved
//                                              - 0b101 (dec. 80-95) virtual network busses
//                                              - 0b110 (dec. 96-111) unused/reserved
//                                              - 0b111 (dec. 112-127) unused/reserved
//bit 7 is reserved and set to 0

#define TYPE_NONE                 0            //light is not configured
#define TYPE_RESERVED             1            //unused. Might indicate a "virtual" light
//Digital types (data pin only) (16-31)
#define TYPE_WS2812_1CH          20            //white-only chips
#define TYPE_WS2812_WWA          21            //amber + warm + cold white
#define TYPE_WS2812_RGB          22
#define TYPE_GS8608              23            //same driver as WS2812, but will require signal 2x per second (else displays test pattern)
#define TYPE_WS2811_400KHZ       24            //half-speed WS2812 protocol, used by very old WS2811 units
#define TYPE_SK6812_RGBW         30
#define TYPE_TM1814              31
//"Analog" types (PWM) (32-47)
#define TYPE_ONOFF               40            //binary output (relays etc.)
#define TYPE_ANALOG_1CH          41            //single channel PWM. Uses value of brightest RGBW channel
#define TYPE_ANALOG_2CH          42            //analog WW + CW
#define TYPE_ANALOG_3CH          43            //analog RGB
#define TYPE_ANALOG_4CH          44            //analog RGBW
#define TYPE_ANALOG_5CH          45            //analog RGB + WW + CW
//Digital types (data + clock / SPI) (48-63)
#define TYPE_WS2801              50
#define TYPE_APA102              51
#define TYPE_LPD8806             52
#define TYPE_P9813               53
#define TYPE_LPD6803             54
//Network types (master broadcast) (80-95)
#define TYPE_NET_DDP_RGB         80            //network DDP RGB bus (master broadcast bus)
#define TYPE_NET_E131_RGB        81            //network E131 RGB bus (master broadcast bus)
#define TYPE_NET_ARTNET_RGB      82            //network ArtNet RGB bus (master broadcast bus)

#define IS_DIGITAL(t) ((t) & 0x10) //digital are 16-31 and 48-63
#define IS_PWM(t)     ((t) > 40 && (t) < 46)
#define NUM_PWM_PINS(t) ((t) - 40) //for analog PWM 41-45 only
#define IS_2PIN(t)      ((t) > 47)

//Color orders
#define COL_ORDER_GRB             0           //GRB(w),defaut
#define COL_ORDER_RGB             1           //common for WS2811
#define COL_ORDER_BRG             2
#define COL_ORDER_RBG             3
#define COL_ORDER_BGR             4
#define COL_ORDER_GBR             5
#define COL_ORDER_MAX             5


//Button type
#define BTN_TYPE_NONE             0
#define BTN_TYPE_RESERVED         1
#define BTN_TYPE_PUSH             2
#define BTN_TYPE_PUSH_ACT_HIGH    3
#define BTN_TYPE_SWITCH           4
#define BTN_TYPE_PIR_SENSOR       5
#define BTN_TYPE_TOUCH            6
#define BTN_TYPE_ANALOG           7
#define BTN_TYPE_ANALOG_INVERTED  8

//Ethernet board types
#define WLED_NUM_ETH_TYPES       11

#define WLED_ETH_NONE             0
#define WLED_ETH_WT32_ETH01       1
#define WLED_ETH_ESP32_POE        2
#define WLED_ETH_WESP32           3
#define WLED_ETH_QUINLED          4
#define WLED_ETH_TWILIGHTLORD     5
#define WLED_ETH_ESP32DEUX        6
#define WLED_ETH_ESP32ETHKITVE    7
#define WLED_ETH_QUINLED_OCTA     8
#define WLED_ETH_ABCWLEDV43ETH    9
#define WLED_ETH_SERG74          10

//Hue error codes
#define HUE_ERROR_INACTIVE        0
#define HUE_ERROR_UNAUTHORIZED    1
#define HUE_ERROR_LIGHTID         3
#define HUE_ERROR_PUSHLINK      101
#define HUE_ERROR_JSON_PARSING  250
#define HUE_ERROR_TIMEOUT       251
#define HUE_ERROR_ACTIVE        255

//Segment option byte bits
#define SEG_OPTION_SELECTED       0
#define SEG_OPTION_REVERSED       1
#define SEG_OPTION_ON             2
#define SEG_OPTION_MIRROR         3            //Indicates that the effect will be mirrored within the segment
#define SEG_OPTION_ROTATED2D      4            //Indicates that the effect will be rotated 90d within the segment
// #define SEG_OPTION_NONUNITY       4            //Indicates that the effect does not use FRAMETIME or needs getPixelColor
#define SEG_OPTION_FREEZE         5            //Segment contents will not be refreshed
#define SEG_OPTION_REVERSED2D     6            //ewowi20210705
#define SEG_OPTION_TRANSITIONAL   7

//Segment differs return byte
#define SEG_DIFFERS_BRI        0x01
#define SEG_DIFFERS_OPT        0x02
#define SEG_DIFFERS_COL        0x04
#define SEG_DIFFERS_FX         0x08
#define SEG_DIFFERS_BOUNDS     0x10
#define SEG_DIFFERS_GSO        0x20
#define SEG_DIFFERS_SEL        0x80

//Playlist option byte
#define PL_OPTION_SHUFFLE      0x01

// WLED Error modes
#define ERR_NONE         0  // All good :)
#define ERR_EEP_COMMIT   2  // Could not commit to EEPROM (wrong flash layout?)
#define ERR_JSON         9  // JSON parsing failed (input too large?)
#define ERR_FS_BEGIN    10  // Could not init filesystem (no partition?)
#define ERR_FS_QUOTA    11  // The FS is full or the maximum file size is reached
#define ERR_FS_PLOAD    12  // It was attempted to load a preset that does not exist
#define ERR_FS_IRLOAD   13  // It was attempted to load an IR JSON cmd, but the "ir.json" file does not exist
#define ERR_FS_GENERAL  19  // A general unspecified filesystem error occured
#define ERR_OVERTEMP    30  // An attached temperature sensor has measured above threshold temperature (not implemented)
#define ERR_OVERCURRENT 31  // An attached current sensor has measured a current above the threshold (not implemented)
#define ERR_UNDERVOLT   32  // An attached voltmeter has measured a voltage below the threshold (not implemented)

//Timer mode types
#define NL_MODE_SET               0            //After nightlight time elapsed, set to target brightness
#define NL_MODE_FADE              1            //Fade to target brightness gradually
#define NL_MODE_COLORFADE         2            //Fade to target brightness and secondary color gradually
#define NL_MODE_SUN               3            //Sunrise/sunset. Target brightness is set immediately, then Sunrise effect is started. Max 60 min.

//EEPROM size
#ifdef ESP8266
#define EEPSIZE 3300  //Maximum is 4096
#else // ESP8266
#define EEPSIZE 3300  //Maximum is 4096
#endif // ESP32


#define NTP_PACKET_SIZE 48

//maximum number of rendered LEDs - this does not have to match max. physical LEDs, e.g. if there are virtual busses
#ifndef MAX_LEDS
#ifdef ESP8266
#define MAX_LEDS 1664 //can't rely on memory limit to limit this to 1600 LEDs
#else
#define MAX_LEDS 8192
#endif
#endif

#ifndef MAX_LED_MEMORY
#ifdef ESP8266
#define MAX_LED_MEMORY 4000
#else
#define MAX_LED_MEMORY 64000
#endif
#endif

#ifndef MAX_LEDS_PER_BUS
#define MAX_LEDS_PER_BUS 4096
#endif

// string temp buffer (now stored in stack locally)
#ifdef ESP8266
#define SETTINGS_STACK_BUF_SIZE 2048
#else
#define SETTINGS_STACK_BUF_SIZE 3096
#endif

#ifdef WLED_USE_ETHERNET
  #define E131_MAX_UNIVERSE_COUNT 20
#else
  #ifdef ESP8266
    #define E131_MAX_UNIVERSE_COUNT 9
  #else
    #define E131_MAX_UNIVERSE_COUNT 12
  #endif
#endif

#ifndef ABL_MILLIAMPS_DEFAULT
  #define ABL_MILLIAMPS_DEFAULT 1500  // auto lower brightness to stay close to milliampere limit WLEDSR: 1500 minmal for 1024 leds / 2D
#else
  #if ABL_MILLIAMPS_DEFAULT < 250  // make sure value is at least 250
   #define ABL_MILLIAMPS_DEFAULT 250
  #endif
#endif

// PWM settings
#ifndef WLED_PWM_FREQ
#ifdef ESP8266
  #define WLED_PWM_FREQ    880 //PWM frequency proven as good for LEDs
#else
  #define WLED_PWM_FREQ  19531
#endif
#endif

#define TOUCH_THRESHOLD 32 // limit to recognize a touch, higher value means more sensitive

// Size of buffer for API JSON object (increase for more segments)
#ifdef ESP8266
  #define JSON_BUFFER_SIZE 10240
#else
  #define JSON_BUFFER_SIZE 20480
#endif

#ifdef WLED_USE_DYNAMIC_JSON
  #define MIN_HEAP_SIZE JSON_BUFFER_SIZE+512
#else
  #define MIN_HEAP_SIZE 4096
#endif

// Maximum size of node map (list of other WLED instances)
#ifdef ESP8266
  #define WLED_MAX_NODES 24
#else
  #define WLED_MAX_NODES 150
#endif

//this is merely a default now and can be changed at runtime
#ifndef LEDPIN
#ifdef ESP8266
  #define LEDPIN 2    // GPIO2 (D4) on Wemod D1 mini compatible boards
#else
  #define LEDPIN 2   // Changed from 16 to restore compatibility with ESP32-pico
#endif
#endif

#ifdef WLED_ENABLE_DMX
#if (LEDPIN == 2)
  #undef LEDPIN
  #define LEDPIN 1
  #warning "Pin conflict compiling with DMX and LEDs on pin 2. The default LED pin has been changed to pin 1."
#endif
#endif

#ifndef DEFAULT_LED_COUNT
  #define DEFAULT_LED_COUNT 30
#endif

#define INTERFACE_UPDATE_COOLDOWN 2000 //time in ms to wait between websockets, alexa, and MQTT updates


// HW_PIN_SCL & HW_PIN_SDA are used for information in usermods settings page and usermods themselves
// which GPIO pins are actually used in a hardwarea layout (controller board)
#if defined(I2CSCLPIN) && !defined(HW_PIN_SCL)
  #define HW_PIN_SCL I2CSCLPIN
#endif
#if defined(I2CSDAPIN) && !defined(HW_PIN_SDA)
  #define HW_PIN_SDA I2CSDAPIN
#endif
// you cannot change HW I2C pins on 8266
#if defined(ESP8266) && defined(HW_PIN_SCL)
  #undef HW_PIN_SCL
#endif
#if defined(ESP8266) && defined(HW_PIN_SDA)
  #undef HW_PIN_SDA
#endif
// defaults for 1st I2C on ESP32 (Wire global)
#ifndef HW_PIN_SCL
  #define HW_PIN_SCL SCL
#endif
#ifndef HW_PIN_SDA
  #define HW_PIN_SDA SDA
#endif

// HW_PIN_SCLKSPI & HW_PIN_MOSISPI & HW_PIN_MISOSPI are used for information in usermods settings page and usermods themselves
// which GPIO pins are actually used in a hardwarea layout (controller board)
#if defined(SPISCLKPIN) && !defined(HW_PIN_CLOCKSPI)
  #define HW_PIN_CLOCKSPI SPISCLKPIN
#endif
#if defined(SPIMOSIPIN) && !defined(HW_PIN_MOSISPI)
  #define HW_PIN_MOSISPI SPIMOSIPIN
#endif
#if defined(SPIMISOPIN) && !defined(HW_PIN_MISOSPI)
  #define HW_PIN_MISOSPI SPIMISOPIN
#endif
// you cannot change HW SPI pins on 8266
#if defined(ESP8266) && defined(HW_PIN_CLOCKSPI)
  #undef HW_PIN_CLOCKSPI
#endif
#if defined(ESP8266) && defined(HW_PIN_DATASPI)
  #undef HW_PIN_DATASPI
#endif
#if defined(ESP8266) && defined(HW_PIN_MISOSPI)
  #undef HW_PIN_MISOSPI
#endif
// defaults for VSPI on ESP32 (SPI global, SPI.cpp) as HSPI is used by WLED (bus_wrapper.h)
#ifndef HW_PIN_CLOCKSPI
  #define HW_PIN_CLOCKSPI SCK
#endif
#ifndef HW_PIN_DATASPI
  #define HW_PIN_DATASPI MOSI
#endif
#ifndef HW_PIN_MISOSPI
  #define HW_PIN_MISOSPI MISO
#endif
#endif

=== ./dmx.cpp ===

#include "wled.h"

/*
 * Support for DMX Output via MAX485.
 * Change the output pin in src/dependencies/ESPDMX.cpp, if needed (ESP8266)
 * Change the output pin in src/dependencies/SparkFunDMX.cpp, if needed (ESP32)
 * ESP8266 Library from:
 * https://github.com/Rickgg/ESP-Dmx
 * ESP32 Library from:
 * https://github.com/sparkfun/SparkFunDMX
 */

#ifdef WLED_ENABLE_DMX

void handleDMX()
{
  // don't act, when in DMX Proxy mode
  if (e131ProxyUniverse != 0) return;

  uint8_t brightness = strip.getBrightness();

  bool calc_brightness = true;

   // check if no shutter channel is set
   for (byte i = 0; i < DMXChannels; i++)
   {
     if (DMXFixtureMap[i] == 5) calc_brightness = false;
   }

  uint16_t len = strip.getLengthTotal();
  for (int i = DMXStartLED; i < len; i++) {        // uses the amount of LEDs as fixture count

    uint32_t in = strip.getPixelColor(i);     // get the colors for the individual fixtures as suggested by Aircoookie in issue #462
    byte w = W(in);
    byte r = R(in);
    byte g = G(in);
    byte b = B(in);

    int DMXFixtureStart = DMXStart + (DMXGap * (i - DMXStartLED));
    for (int j = 0; j < DMXChannels; j++) {
      int DMXAddr = DMXFixtureStart + j;
      switch (DMXFixtureMap[j]) {
        case 0:        // Set this channel to 0. Good way to tell strobe- and fade-functions to fuck right off.
          dmx.write(DMXAddr, 0);
          break;
        case 1:        // Red
          dmx.write(DMXAddr, calc_brightness ? (r * brightness) / 255 : r);
          break;
        case 2:        // Green
          dmx.write(DMXAddr, calc_brightness ? (g * brightness) / 255 : g);
          break;
        case 3:        // Blue
          dmx.write(DMXAddr, calc_brightness ? (b * brightness) / 255 : b);
          break;
        case 4:        // White
          dmx.write(DMXAddr, calc_brightness ? (w * brightness) / 255 : w);
          break;
        case 5:        // Shutter channel. Controls the brightness.
          dmx.write(DMXAddr, brightness);
          break;
        case 6:        // Sets this channel to 255. Like 0, but more wholesome.
          dmx.write(DMXAddr, 255);
          break;
      }
    }
  }

  dmx.update();        // update the DMX bus
}

void initDMX() {
 #ifdef ESP8266
  dmx.init(512);        // initialize with bus length
 #else
  dmx.initWrite(512);  // initialize with bus length
 #endif  
}

#else
void handleDMX() {}
void initDMX() {}
#endif

=== ./e131.cpp ===

#include "wled.h"

#define MAX_3_CH_LEDS_PER_UNIVERSE 170
#define MAX_4_CH_LEDS_PER_UNIVERSE 128
#define MAX_CHANNELS_PER_UNIVERSE 512

/*
 * E1.31 handler
 */

//DDP protocol support, called by handleE131Packet
//handles RGB data only
void handleDDPPacket(e131_packet_t* p) {
  int lastPushSeq = e131LastSequenceNumber[0];

  //reject late packets belonging to previous frame (assuming 4 packets max. before push)
  if (e131SkipOutOfSequence && lastPushSeq) {
    int sn = p->sequenceNum & 0xF;
    if (sn) {
      if (lastPushSeq > 5) {
        if (sn > (lastPushSeq -5) && sn < lastPushSeq) return;
      } else {
        if (sn > (10 + lastPushSeq) || sn < lastPushSeq) return;
      }
    }
  }

  uint32_t start = htonl(p->channelOffset) /3;
  start += DMXAddress /3;
  uint16_t stop = start + htons(p->dataLen) /3;
  uint8_t* data = p->data;
  uint16_t c = 0;
  if (p->flags & DDP_TIMECODE_FLAG) c = 4; //packet has timecode flag, we do not support it, but data starts 4 bytes later

  realtimeLock(realtimeTimeoutMs, REALTIME_MODE_DDP);

  if (!realtimeOverride) {
    for (uint16_t i = start; i < stop; i++) {
      setRealtimePixel(i, data[c], data[c+1], data[c+2], 0);
      c+=3;
    }
  }

  bool push = p->flags & DDP_PUSH_FLAG;
  if (push) {
    e131NewData = true;
    byte sn = p->sequenceNum & 0xF;
    if (sn) e131LastSequenceNumber[0] = sn;
  }
}

//E1.31 and Art-Net protocol support
void handleE131Packet(e131_packet_t* p, IPAddress clientIP, byte protocol){

  uint16_t uni = 0, dmxChannels = 0;
  uint8_t* e131_data = nullptr;
  uint8_t seq = 0, mde = REALTIME_MODE_E131;

  if (protocol == P_ARTNET)
  {
    uni = p->art_universe;
    dmxChannels = htons(p->art_length);
    e131_data = p->art_data;
    seq = p->art_sequence_number;
    mde = REALTIME_MODE_ARTNET;
  } else if (protocol == P_E131) {
    uni = htons(p->universe);
    dmxChannels = htons(p->property_value_count) -1;
    e131_data = p->property_values;
    seq = p->sequence_number;
  } else { //DDP
    realtimeIP = clientIP;
    handleDDPPacket(p);
    return;
  }

  #ifdef WLED_ENABLE_DMX
  // does not act on out-of-order packets yet
  if (e131ProxyUniverse > 0 && uni == e131ProxyUniverse) {
    for (uint16_t i = 1; i <= dmxChannels; i++)
      dmx.write(i, e131_data[i]);
    dmx.update();
  }
  #endif

  // only listen for universes we're handling & allocated memory
  if (uni >= (e131Universe + E131_MAX_UNIVERSE_COUNT)) return;

  uint8_t previousUniverses = uni - e131Universe;

  if (e131SkipOutOfSequence)
    if (seq < e131LastSequenceNumber[uni-e131Universe] && seq > 20 && e131LastSequenceNumber[uni-e131Universe] < 250){
      DEBUG_PRINT("skipping E1.31 frame (last seq=");
      DEBUG_PRINT(e131LastSequenceNumber[uni-e131Universe]);
      DEBUG_PRINT(", current seq=");
      DEBUG_PRINT(seq);
      DEBUG_PRINT(", universe=");
      DEBUG_PRINT(uni);
      DEBUG_PRINTLN(")");
      return;
    }
  e131LastSequenceNumber[uni-e131Universe] = seq;

  // update status info
  realtimeIP = clientIP;
  byte wChannel = 0;
  uint16_t totalLen = strip.getLengthTotal();
  uint16_t availDMXLen = dmxChannels - DMXAddress + 1;
  uint16_t dataOffset = DMXAddress;

  // DMX data in Art-Net packet starts at index 0, for E1.31 at index 1
  if (protocol == P_ARTNET && dataOffset > 0) {
    dataOffset--;
  }

  switch (DMXMode) {
    case DMX_MODE_DISABLED:
      return;  // nothing to do
      break;

    case DMX_MODE_SINGLE_RGB: // RGB only
      if (uni != e131Universe) return;
      if (availDMXLen < 3) return;
      realtimeLock(realtimeTimeoutMs, mde);
      if (realtimeOverride) return;
      wChannel = (availDMXLen > 3) ? e131_data[dataOffset+3] : 0;
      for (uint16_t i = 0; i < totalLen; i++)
        setRealtimePixel(i, e131_data[dataOffset+0], e131_data[dataOffset+1], e131_data[dataOffset+2], wChannel);
      break;

    case DMX_MODE_SINGLE_DRGB: // Dimmer + RGB
      if (uni != e131Universe) return;
      if (availDMXLen < 4) return;
      realtimeLock(realtimeTimeoutMs, mde);
      if (realtimeOverride) return;
      wChannel = (availDMXLen > 4) ? e131_data[dataOffset+4] : 0;
      if (DMXOldDimmer != e131_data[dataOffset+0]) {
        DMXOldDimmer = e131_data[dataOffset+0];
        bri = e131_data[dataOffset+0];
        strip.setBrightness(bri, true);
      }
      for (uint16_t i = 0; i < totalLen; i++)
        setRealtimePixel(i, e131_data[dataOffset+1], e131_data[dataOffset+2], e131_data[dataOffset+3], wChannel);
      break;

    case DMX_MODE_EFFECT: // Length 1: Apply Preset ID, length 11-13: apply effect config
      if (uni != e131Universe) return;
      if (availDMXLen < 11) {
        if (availDMXLen > 1) return;
        applyPreset(e131_data[dataOffset+0], CALL_MODE_NOTIFICATION);
        return;
      }
      if (DMXOldDimmer != e131_data[dataOffset+0]) {
        DMXOldDimmer = e131_data[dataOffset+0];
        bri = e131_data[dataOffset+0];
      }
      if (e131_data[dataOffset+1] < MODE_COUNT)
        effectCurrent = e131_data[dataOffset+ 1];
      effectSpeed     = e131_data[dataOffset+ 2];  // flickers
      effectIntensity = e131_data[dataOffset+ 3];
      effectPalette   = e131_data[dataOffset+ 4];
      col[0]          = e131_data[dataOffset+ 5];
      col[1]          = e131_data[dataOffset+ 6];
      col[2]          = e131_data[dataOffset+ 7];
      colSec[0]       = e131_data[dataOffset+ 8];
      colSec[1]       = e131_data[dataOffset+ 9];
      colSec[2]       = e131_data[dataOffset+10];
      if (availDMXLen > 11)
      {
        col[3]        = e131_data[dataOffset+11]; //white
        colSec[3]     = e131_data[dataOffset+12];
      }
      transitionDelayTemp = 0;               // act fast
      colorUpdated(CALL_MODE_NOTIFICATION);  // don't send UDP
      return;                                // don't activate realtime live mode
      break;

    case DMX_MODE_MULTIPLE_DRGB:
    case DMX_MODE_MULTIPLE_RGB:
    case DMX_MODE_MULTIPLE_RGBW:
      {
        realtimeLock(realtimeTimeoutMs, mde);
        bool is4Chan = (DMXMode == DMX_MODE_MULTIPLE_RGBW);
        const uint16_t dmxChannelsPerLed = is4Chan ? 4 : 3;
        const uint16_t ledsPerUniverse = is4Chan ? MAX_4_CH_LEDS_PER_UNIVERSE : MAX_3_CH_LEDS_PER_UNIVERSE;
        if (realtimeOverride) return;
        uint16_t previousLeds, dmxOffset, ledsTotal;
        if (previousUniverses == 0) {
          if (availDMXLen < 1) return;
          dmxOffset = dataOffset;
          previousLeds = 0;
          // First DMX address is dimmer in DMX_MODE_MULTIPLE_DRGB mode.
          if (DMXMode == DMX_MODE_MULTIPLE_DRGB) {
            strip.setBrightness(e131_data[dmxOffset++], true);
            ledsTotal = (availDMXLen - 1) / dmxChannelsPerLed;
          } else {
            ledsTotal = availDMXLen / dmxChannelsPerLed;
          }
        } else {
          // All subsequent universes start at the first channel.
          dmxOffset = (protocol == P_ARTNET) ? 0 : 1;
          uint16_t dimmerOffset = (DMXMode == DMX_MODE_MULTIPLE_DRGB) ? 1 : 0;
          uint16_t ledsInFirstUniverse = ((MAX_CHANNELS_PER_UNIVERSE - DMXAddress + 1) - dimmerOffset) / dmxChannelsPerLed;
          previousLeds = ledsInFirstUniverse + (previousUniverses - 1) * ledsPerUniverse;
          ledsTotal = previousLeds + (dmxChannels / dmxChannelsPerLed);
        }
        if (!is4Chan) {
          for (uint16_t i = previousLeds; i < ledsTotal; i++) {
            setRealtimePixel(i, e131_data[dmxOffset], e131_data[dmxOffset+1], e131_data[dmxOffset+2], 0);
            dmxOffset+=3;
          }
        } else {
          for (uint16_t i = previousLeds; i < ledsTotal; i++) {
            setRealtimePixel(i, e131_data[dmxOffset], e131_data[dmxOffset+1], e131_data[dmxOffset+2], e131_data[dmxOffset+3]);
            dmxOffset+=4;
          }
        }
        break;
      }
    default:
      DEBUG_PRINTLN(F("unknown E1.31 DMX mode"));
      return;  // nothing to do
      break;
  }

  e131NewData = true;
}

=== ./fcn_declare.h ===

#ifndef WLED_FCN_DECLARE_H
#define WLED_FCN_DECLARE_H
#include <Arduino.h>
#include "src/dependencies/espalexa/EspalexaDevice.h"
#include "src/dependencies/e131/ESPAsyncE131.h"

/*
 * All globally accessible functions are declared here
 */

//alexa.cpp
void onAlexaChange(EspalexaDevice* dev);
void alexaInit();
void handleAlexa();
void onAlexaChange(EspalexaDevice* dev);

//button.cpp
void shortPressAction(uint8_t b=0);
void longPressAction(uint8_t b=0);
void doublePressAction(uint8_t b=0);
bool isButtonPressed(uint8_t b=0);
void handleButton();
void handleIO();

//cfg.cpp
bool deserializeConfig(JsonObject doc, bool fromFS = false);
void deserializeConfigFromFS();
bool deserializeConfigSec();
void serializeConfig();
void serializeConfigSec();

template<typename DestType>
bool getJsonValue(const JsonVariant& element, DestType& destination) {
  if (element.isNull()) {
    return false;
  }

  destination = element.as<DestType>();
  return true;
}

template<typename DestType, typename DefaultType>
bool getJsonValue(const JsonVariant& element, DestType& destination, const DefaultType defaultValue) {
  if(!getJsonValue(element, destination)) {
    destination = defaultValue;
    return false;
  }

  return true;
}


//colors.cpp
inline uint32_t colorFromRgbw(byte* rgbw) { return uint32_t((byte(rgbw[3]) << 24) | (byte(rgbw[0]) << 16) | (byte(rgbw[1]) << 8) | (byte(rgbw[2]))); }
void colorHStoRGB(uint16_t hue, byte sat, byte* rgb); //hue, sat to rgb
void colorKtoRGB(uint16_t kelvin, byte* rgb);
void colorCTtoRGB(uint16_t mired, byte* rgb); //white spectrum to rgb

void colorXYtoRGB(float x, float y, byte* rgb); // only defined if huesync disabled TODO
void colorRGBtoXY(byte* rgb, float* xy); // only defined if huesync disabled TODO

void colorFromDecOrHexString(byte* rgb, char* in);
bool colorFromHexString(byte* rgb, const char* in);

uint32_t colorBalanceFromKelvin(uint16_t kelvin, uint32_t rgb);
uint16_t approximateKelvinFromRGB(uint32_t rgb);

void setRandomColor(byte* rgb);

//dmx.cpp
void initDMX();
void handleDMX();

//e131.cpp
void handleE131Packet(e131_packet_t* p, IPAddress clientIP, byte protocol);

//file.cpp
bool handleFileRead(AsyncWebServerRequest*, String path);
bool writeObjectToFileUsingId(const char* file, uint16_t id, JsonDocument* content);
bool writeObjectToFile(const char* file, const char* key, JsonDocument* content);
bool readObjectFromFileUsingId(const char* file, uint16_t id, JsonDocument* dest);
bool readObjectFromFile(const char* file, const char* key, JsonDocument* dest);
void updateFSInfo();
void closeFile();

//hue.cpp
void handleHue();
void reconnectHue();
void onHueError(void* arg, AsyncClient* client, int8_t error);
void onHueConnect(void* arg, AsyncClient* client);
void sendHuePoll();
void onHueData(void* arg, AsyncClient* client, void *data, size_t len);

//improv.cpp
void handleImprovPacket();
void sendImprovStateResponse(uint8_t state, bool error = false);
void sendImprovInfoResponse();
void sendImprovRPCResponse(uint8_t commandId);

//ir.cpp
//bool decodeIRCustom(uint32_t code);
void applyRepeatActions();
byte relativeChange(byte property, int8_t amount, byte lowerBoundary = 0, byte higherBoundary = 0xFF);
void decodeIR(uint32_t code);
void decodeIR24(uint32_t code);
void decodeIR24OLD(uint32_t code);
void decodeIR24CT(uint32_t code);
void decodeIR40(uint32_t code);
void decodeIR44(uint32_t code);
void decodeIR21(uint32_t code);
void decodeIR6(uint32_t code);
void decodeIR9(uint32_t code);
void decodeIRJson(uint32_t code);

void initIR();
void handleIR();

//json.cpp
#include "ESPAsyncWebServer.h"
#include "src/dependencies/json/ArduinoJson-v6.h"
#include "src/dependencies/json/AsyncJson-v6.h"
#include "FX.h"

void deserializeSegment(JsonObject elem, byte it, byte presetId = 0);
bool deserializeState(JsonObject root, byte callMode = CALL_MODE_DIRECT_CHANGE, byte presetId = 0);
void serializeSegment(JsonObject& root, WS2812FX::Segment& seg, byte id, bool forPreset = false, bool segmentBounds = true);
void serializeState(JsonObject root, bool forPreset = false, bool includeBri = true, bool segmentBounds = true);
void serializeInfo(JsonObject root);
void serveJson(AsyncWebServerRequest* request);
#ifdef WLED_ENABLE_JSONLIVE
bool serveLiveLeds(AsyncWebServerRequest* request, uint32_t wsClient = 0);
#endif

//led.cpp
void setValuesFromSegment(uint8_t s);
void setValuesFromMainSeg();
void setValuesFromFirstSelectedSeg();
void resetTimebase();
void toggleOnOff();
void applyBri();
void applyFinalBri();
void applyValuesToSelectedSegs();
void colorUpdated(byte callMode);
void stateUpdated(byte callMode);
void updateInterfaces(uint8_t callMode);
void handleTransitions();
void handleNightlight();
byte scaledBri(byte in);

//lx_parser.cpp
bool parseLx(int lxValue, byte* rgbw);
void parseLxJson(int lxValue, byte segId, bool secondary);

//mqtt.cpp
bool initMqtt();
void publishMqtt();

//ntp.cpp
void handleTime();
void handleNetworkTime();
void sendNTPPacket();
bool checkNTPResponse();
void updateLocalTime();
void getTimeString(char* out);
bool checkCountdown();
void setCountdown();
byte weekdayMondayFirst();
void checkTimers();
void calculateSunriseAndSunset();
void setTimeFromAPI(uint32_t timein);

//overlay.cpp
void handleOverlayDraw();
void _overlayAnalogCountdown();
void _overlayAnalogClock();

//playlist.cpp
void shufflePlaylist();
void unloadPlaylist();
int16_t loadPlaylist(JsonObject playlistObject, byte presetId = 0);
void handlePlaylist();

//presets.cpp
bool applyPreset(byte index, byte callMode = CALL_MODE_DIRECT_CHANGE);
inline bool applyTemporaryPreset() {return applyPreset(255);};
void savePreset(byte index, const char* pname = nullptr, JsonObject saveobj = JsonObject());
inline void saveTemporaryPreset() {savePreset(255);};
void deletePreset(byte index);

//set.cpp
bool isAsterisksOnly(const char* str, byte maxLen);
void handleSettingsSet(AsyncWebServerRequest *request, byte subPage);
bool handleSet(AsyncWebServerRequest *request, const String& req, bool apply=true);
int getNumVal(const String* req, uint16_t pos);
void parseNumber(const char* str, byte* val, byte minv=0, byte maxv=255);
bool updateVal(const String* req, const char* key, byte* val, byte minv=0, byte maxv=255);

//udp.cpp
void notify(byte callMode, bool followUp=false);
uint8_t realtimeBroadcast(uint8_t type, IPAddress client, uint16_t length, byte *buffer, uint8_t bri=255, bool isRGBW=false);
void realtimeLock(uint32_t timeoutMs, byte md = REALTIME_MODE_GENERIC);
void exitRealtime();
void handleNotifications();
void setRealtimePixel(uint16_t i, byte r, byte g, byte b, byte w);
void refreshNodeList();
void sendSysInfoUDP();

//util.cpp
//bool oappend(const char* txt); // append new c string to temp buffer efficiently
//bool oappendi(int i);          // append new number to temp buffer efficiently
//void sappend(char stype, const char* key, int val);
//void sappends(char stype, const char* key, char* val);
//void prepareHostname(char* hostname);
//bool isAsterisksOnly(const char* str, byte maxLen);
bool requestJSONBufferLock(uint8_t module=255);
void releaseJSONBufferLock();
uint8_t extractModeName(uint8_t mode, const char *src, char *dest, uint8_t maxLen);

//um_manager.cpp
class Usermod {
  public:
    virtual void loop() {}
    virtual void handleOverlayDraw() {}
    virtual bool handleButton(uint8_t b) { return false; }
    virtual void setup() {}
    virtual void connected() {}
    virtual void addToJsonState(JsonObject& obj) {}
    virtual void addToJsonInfo(JsonObject& obj) {}
    virtual void readFromJsonState(JsonObject& obj) {}
    virtual void addToConfig(JsonObject& obj) {}
    virtual bool readFromConfig(JsonObject& obj) { return true; } // Note as of 2021-06 readFromConfig() now needs to return a bool, see usermod_v2_example.h
    virtual void onMqttConnect(bool sessionPresent) {}
    virtual bool onMqttMessage(char* topic, char* payload) { return false; }
    virtual uint16_t getId() {return USERMOD_ID_UNSPECIFIED;}
};

class UsermodManager {
  private:
    Usermod* ums[WLED_MAX_USERMODS];
    byte numMods = 0;

  public:
    void loop();
    void handleOverlayDraw();
    bool handleButton(uint8_t b);
    void setup();
    void connected();
    void addToJsonState(JsonObject& obj);
    void addToJsonInfo(JsonObject& obj);
    void readFromJsonState(JsonObject& obj);
    void addToConfig(JsonObject& obj);
    bool readFromConfig(JsonObject& obj);
    void onMqttConnect(bool sessionPresent);
    bool onMqttMessage(char* topic, char* payload);
    bool add(Usermod* um);
    Usermod* lookup(uint16_t mod_id);
    byte getModCount();
};

//usermods_list.cpp
void registerUsermods();

//usermod.cpp
void userSetup();
void userConnected();
void userLoop();

//wled_eeprom.cpp
void applyMacro(byte index);
void deEEP();
void deEEPSettings();
void clearEEPROM();

//wled_serial.cpp
void handleSerial();
void updateBaudRate(uint32_t rate);

//wled_server.cpp
bool isIp(String str);
bool captivePortal(AsyncWebServerRequest *request);
void initServer();
void serveIndexOrWelcome(AsyncWebServerRequest *request);
void serveIndex(AsyncWebServerRequest* request);
String msgProcessor(const String& var);
void serveMessage(AsyncWebServerRequest* request, uint16_t code, const String& headl, const String& subl="", byte optionT=255);
String settingsProcessor(const String& var);
String dmxProcessor(const String& var);
void serveSettings(AsyncWebServerRequest* request, bool post = false);

//ws.cpp
void handleWs();
void wsEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len);
void sendDataWs(AsyncWebSocketClient * client = nullptr);

//xml.cpp
void XML_response(AsyncWebServerRequest *request, char* dest = nullptr);
void URL_response(AsyncWebServerRequest *request);
void sappend(char stype, const char* key, int val);
void sappends(char stype, const char* key, char* val);
void getSettingsJS(byte subPage, char* dest);

#endif

CRGB getCRGBForBand(int x, int pal); //WLEDMM netmindz ar palette
=== ./file.cpp ===

#include "wled.h"

/*
 * Utility for SPIFFS filesystem
 */

#ifdef ARDUINO_ARCH_ESP32 //FS info bare IDF function until FS wrapper is available for ESP32
#if WLED_FS != LITTLEFS && ESP_IDF_VERSION_MAJOR < 4
  #include "esp_spiffs.h"
#endif
#endif

#define FS_BUFSIZE 256

/*
 * Structural requirements for files managed by writeObjectToFile() and readObjectFromFile() utilities:
 * 1. File must be a string representation of a valid JSON object
 * 2. File must have '{' as first character
 * 3. There must not be any additional characters between a root-level key and its value object (e.g. space, tab, newline)
 * 4. There must not be any characters between an root object-separating ',' and the next object key string
 * 5. There may be any number of spaces, tabs, and/or newlines before such object-separating ','
 * 6. There must not be more than 5 consecutive spaces at any point except for those permitted in condition 5
 * 7. If it is desired to delete the first usable object (e.g. preset file), a dummy object '"0":{}' is inserted at the beginning.
 *    It shall be disregarded by receiving software.
 *    The reason for it is that deleting the first preset would require special code to handle commas between it and the 2nd preset
 */

// There are no consecutive spaces longer than this in the file, so if more space is required, findSpace() can return false immediately
// Actual space may be lower
constexpr size_t MAX_SPACE = UINT16_MAX * 2U;           // WLEDSR smallest supported config has 128Kb LittleFS
static volatile size_t knownLargestSpace = MAX_SPACE;

static File f;

//wrapper to find out how long closing takes
void closeFile() {
  #ifdef WLED_DEBUG_FS
    DEBUGFS_PRINT(F("Close -> "));
    uint32_t s = millis();
  #endif
  f.close();
  DEBUGFS_PRINTF("took %d ms\n", millis() - s);
  doCloseFile = false;
}

//find() that reads and buffers data from file stream in 256-byte blocks.
//Significantly faster, f.find(key) can take SECONDS for multi-kB files
static bool bufferedFind(const char *target, bool fromStart = true) {
  #ifdef WLED_DEBUG_FS
    DEBUGFS_PRINT("Find ");
    DEBUGFS_PRINTLN(target);
    uint32_t s = millis();
  #endif

  if (!f || !f.size()) return false;
  size_t targetLen = strlen(target);

  size_t index = 0;
  byte buf[FS_BUFSIZE];
  if (fromStart) f.seek(0);

  while (f.position() < f.size() -1) {
    size_t bufsize = f.read(buf, FS_BUFSIZE); // WLEDSR size_t instead if uint16_t
    size_t count = 0;                         // WLEDSR
    while (count < bufsize) {
      if(buf[count] != target[index])
      index = 0; // reset index if any char does not match

      if(buf[count] == target[index]) {
        if(++index >= targetLen) { // return true if all chars in the target match
          f.seek((f.position() - bufsize) + count +1);
          DEBUGFS_PRINTF("Found at pos %d, took %d ms", f.position(), millis() - s);
          return true;
        }
      }
      count++;
    }
  }
  DEBUGFS_PRINTF("No match, took %d ms\n", millis() - s);
  return false;
}

//find empty spots in file stream in 256-byte blocks.
static bool bufferedFindSpace(size_t targetLen, bool fromStart = true) {

  #ifdef WLED_DEBUG_FS
    DEBUGFS_PRINTF("Find %d spaces\n", targetLen);
    uint32_t s = millis();
  #endif

  if (knownLargestSpace < targetLen) {
    DEBUGFS_PRINT(F("No match, KLS "));
    DEBUGFS_PRINTLN(knownLargestSpace);
    return false;
  }

  if (!f || !f.size()) return false;

  size_t index = 0; // WLEDSR size_t instead if uint16_t
  byte buf[FS_BUFSIZE];
  if (fromStart) f.seek(0);

  while (f.position() < f.size() -1) {
    size_t bufsize = f.read(buf, FS_BUFSIZE); // WLEDSR
    size_t count = 0;                         // WLEDSR

    while (count < bufsize) {
      if(buf[count] == ' ') {
        if(++index >= targetLen) { // return true if space long enough
          if (fromStart) {
            f.seek((f.position() - bufsize) + count +1 - targetLen);
            knownLargestSpace = MAX_SPACE; //there may be larger spaces after, so we don't know // WLEDSR smallest supported config has 128Kb flash size
          }
          DEBUGFS_PRINTF("Found at pos %d, took %d ms", f.position(), millis() - s);
          return true;
        }
      } else {
        if (!fromStart) return false;
        if (index) {
          if (knownLargestSpace < index || (knownLargestSpace == MAX_SPACE)) knownLargestSpace = index; // WLEDSR
          index = 0; // reset index if not space
        }
      }

      count++;
    }
  }
  DEBUGFS_PRINTF("No match, took %d ms\n", millis() - s);
  return false;
}

//find the closing bracket corresponding to the opening bracket at the file pos when calling this function
static bool bufferedFindObjectEnd() {
  #ifdef WLED_DEBUG_FS
    DEBUGFS_PRINTLN(F("Find obj end"));
    uint32_t s = millis();
  #endif

  if (!f || !f.size()) return false;

  uint16_t objDepth = 0; //num of '{' minus num of '}'. return once 0
  //size_t start = f.position();
  byte buf[FS_BUFSIZE];

  while (f.position() < f.size() -1) {
    size_t bufsize = f.read(buf, FS_BUFSIZE); // WLEDSR size_t instead of uint16_t
    size_t count = 0;                         // WLEDSR

    while (count < bufsize) {
      if (buf[count] == '{') objDepth++;
      if (buf[count] == '}') objDepth--;
      if (objDepth == 0) {
        f.seek((f.position() - bufsize) + count +1);
        DEBUGFS_PRINTF("} at pos %d, took %d ms", f.position(), millis() - s);
        return true;
      }
      count++;
    }
  }
  DEBUGFS_PRINTF("No match, took %d ms\n", millis() - s);
  return false;
}

//fills n bytes from current file pos with ' ' characters
static void writeSpace(size_t l)
{
  byte buf[FS_BUFSIZE];
  memset(buf, ' ', FS_BUFSIZE);

  while (l > 0) {
    size_t block = (l>FS_BUFSIZE) ? FS_BUFSIZE : l; // WLEDSR size_t instead of uint16_t
    f.write(buf, block);
    l -= block;
  }

  if (knownLargestSpace < l) knownLargestSpace = l;
}

bool appendObjectToFile(const char* key, JsonDocument* content, uint32_t s, uint32_t contentLen = 0)
{
  #ifdef WLED_DEBUG_FS
    DEBUGFS_PRINTLN(F("Append"));
    uint32_t s1 = millis();
  #endif
  uint32_t pos = 0;
  if (!f) return false;

  if (f.size() < 3) {
    char init[10];
    strcpy_P(init, PSTR("{\"0\":{}}"));
    f.print(init);
  }

  if (content->isNull()) {
    doCloseFile = true;
    return true; //nothing  to append
  }

  //if there is enough empty space in file, insert there instead of appending
  if (!contentLen) contentLen = measureJson(*content);
  DEBUGFS_PRINTF("CLen %d\n", contentLen);
  if (bufferedFindSpace(contentLen + strlen(key) + 1)) {
    if (f.position() > 2) f.write(','); //add comma if not first object
    f.print(key);
    serializeJson(*content, f);
    DEBUGFS_PRINTF("Inserted, took %d ms (total %d)", millis() - s1, millis() - s);
    doCloseFile = true;
    return true;
  }

  //not enough space, append at end

  //permitted space for presets exceeded
  updateFSInfo();

  if (f.size() + 9000 > (fsBytesTotal - fsBytesUsed)) { //make sure there is enough space to at least copy the file once
    errorFlag = ERR_FS_QUOTA;
    doCloseFile = true;
    return false;
  }

  //check if last character in file is '}' (typical)
  uint32_t eof = f.size() -1;
  f.seek(eof, SeekSet);
  if (f.read() == '}') pos = eof;

  if (pos == 0) //not found
  {
    DEBUGFS_PRINTLN("not }");
    f.seek(0);
    while (bufferedFind("}",false)) //find last closing bracket in JSON if not last char
    {
      pos = f.position();
    }
    if (pos > 0) pos--;
  }
  DEBUGFS_PRINT("pos "); DEBUGFS_PRINTLN(pos);
  if (pos > 2)
  {
    f.seek(pos, SeekSet);
    f.write(',');
  } else { //file content is not valid JSON object
    f.seek(0, SeekSet);
    f.print('{'); //start JSON
  }

  f.print(key);

  //Append object
  serializeJson(*content, f);
  f.write('}');

  doCloseFile = true;
  DEBUGFS_PRINTF("Appended, took %d ms (total %d)", millis() - s1, millis() - s);
  return true;
}

bool writeObjectToFileUsingId(const char* file, uint16_t id, JsonDocument* content)
{
  char objKey[12]={'\0'};
  snprintf(objKey, sizeof(objKey), "\"%d\":", id); // WLEDSR
  return writeObjectToFile(file, objKey, content);
}

bool writeObjectToFile(const char* file, const char* key, JsonDocument* content)
{
  uint32_t s = 0; //timing
  #ifdef WLED_DEBUG_FS
    DEBUGFS_PRINTF("Write to %s with key %s >>>\n", file, (key==nullptr)?"nullptr":key);
    serializeJson(*content, Serial); DEBUGFS_PRINTLN();
    s = millis();
  #endif

  size_t pos = 0;
  f = WLED_FS.open(file, "r+");
  if (!f && !WLED_FS.exists(file)) f = WLED_FS.open(file, "w+");
  if (!f) {
    DEBUGFS_PRINTLN(F("Failed to open!"));
    return false;
  }

  if (!bufferedFind(key)) //key does not exist in file
  {
    return appendObjectToFile(key, content, s);
  }

  //an object with this key already exists, replace or delete it
  pos = f.position();
  //measure out end of old object
  bufferedFindObjectEnd();
  size_t pos2 = f.position();   // WLEDSR

  uint32_t oldLen = pos2 - pos;
  DEBUGFS_PRINTF("Old obj len %d\n", oldLen);

  //Three cases:
  //1. The new content is null, overwrite old obj with spaces
  //2. The new content is smaller than the old, overwrite and fill diff with spaces
  //3. The new content is larger than the old, but smaller than old + trailing spaces, overwrite with new
  //4. The new content is larger than old + trailing spaces, delete old and append

  size_t contentLen = 0;  // WLEDSR
  if (!content->isNull()) contentLen = measureJson(*content);

  if (contentLen && contentLen <= oldLen) { //replace and fill diff with spaces
    DEBUGFS_PRINTLN(F("replace"));
    f.seek(pos);
    serializeJson(*content, f);
    writeSpace(pos2 - f.position());
  } else if (contentLen && bufferedFindSpace(contentLen - oldLen, false)) { //enough leading spaces to replace
    DEBUGFS_PRINTLN(F("replace (trailing)"));
    f.seek(pos);
    serializeJson(*content, f);
  } else {
    DEBUGFS_PRINTLN(F("delete"));
    pos -= strlen(key);
    if (pos > 3) pos--; //also delete leading comma if not first object
    f.seek(pos);
    writeSpace(pos2 - pos);
    if (contentLen) return appendObjectToFile(key, content, s, contentLen);
  }

  doCloseFile = true;
  DEBUGFS_PRINTF("Replaced/deleted, took %d ms\n", millis() - s);
  return true;
}

bool readObjectFromFileUsingId(const char* file, uint16_t id, JsonDocument* dest)
{
  char objKey[12]={'\0'};
  snprintf(objKey, sizeof(objKey), "\"%d\":", id);
  return readObjectFromFile(file, objKey, dest);
}

//if the key is a nullptr, deserialize entire object
bool readObjectFromFile(const char* file, const char* key, JsonDocument* dest)
{
  if (doCloseFile) closeFile();
  #ifdef WLED_DEBUG_FS
    DEBUGFS_PRINTF("Read from %s with key %s >>>\n", file, (key==nullptr)?"nullptr":key);
    uint32_t s = millis();
  #endif
  f = WLED_FS.open(file, "r");
  if (!f) return false;

  if (key != nullptr && !bufferedFind(key)) //key does not exist in file
  {
    f.close();
    dest->clear();
    DEBUGFS_PRINTLN(F("Obj not found."));
    return false;
  }

  deserializeJson(*dest, f);

  f.close();
  DEBUGFS_PRINTF("Read, took %d ms\n", millis() - s);
  return true;
}

void updateFSInfo() {
  #ifdef ARDUINO_ARCH_ESP32
    #if WLED_FS == LITTLEFS || ESP_IDF_VERSION_MAJOR >= 4
    fsBytesTotal = WLED_FS.totalBytes();
    fsBytesUsed = WLED_FS.usedBytes();
    #else
    esp_spiffs_info(nullptr, &fsBytesTotal, &fsBytesUsed);
    #endif
  #else
    FSInfo fsi;
    WLED_FS.info(fsi);
    fsBytesUsed  = fsi.usedBytes;
    fsBytesTotal = fsi.totalBytes;
  #endif
}


//Un-comment any file types you need
static String getContentType(AsyncWebServerRequest* request, String filename){
  if(request->hasArg("download")) return "application/octet-stream";
  else if(filename.endsWith(".htm")) return "text/html";
  else if(filename.endsWith(".html")) return "text/html";
  else if(filename.endsWith(".css")) return "text/css";
//  else if(filename.endsWith(".js")) return "application/javascript";
  else if(filename.endsWith(".json")) return "application/json";
  else if(filename.endsWith(".png")) return "image/png";
//  else if(filename.endsWith(".gif")) return "image/gif";
  else if(filename.endsWith(".jpg")) return "image/jpeg";
  else if(filename.endsWith(".ico")) return "image/x-icon";
//  else if(filename.endsWith(".xml")) return "text/xml";
//  else if(filename.endsWith(".pdf")) return "application/x-pdf";
//  else if(filename.endsWith(".zip")) return "application/x-zip";
//  else if(filename.endsWith(".gz")) return "application/x-gzip";
  return "text/plain";
}

bool handleFileRead(AsyncWebServerRequest* request, String path){
  DEBUG_PRINTLN("WS FileRead: " + path);
  if(path.endsWith("/")) path += "index.htm";
  if(path.indexOf("sec") > -1) return false;
  String contentType = getContentType(request, path);
  /*String pathWithGz = path + ".gz";
  if(WLED_FS.exists(pathWithGz)){
    request->send(WLED_FS, pathWithGz, contentType);
    return true;
  }*/
  if(WLED_FS.exists(path)) {
    request->send(WLED_FS, path, contentType);
    return true;
  }
  return false;
}

=== ./html_other.h ===

/*
 * More web UI HTML source arrays.
 * This file is auto generated, please don't make any changes manually.
 * Instead, see https://kno.wled.ge/advanced/custom-features/#changing-web-ui
 * to find out how to easily modify the web UI source!
 */

// Autogenerated from wled00/data/usermod.htm, do not edit!!
const char PAGE_usermod[] PROGMEM = R"=====(<!DOCTYPE html><html><body>No usermod custom web page set.</body></html>)=====";


// Autogenerated from wled00/data/msg.htm, do not edit!!
const char PAGE_msg[] PROGMEM = R"=====(<!DOCTYPE html><html><head><meta content="width=device-width" name="viewport">
<title>WLED Message</title><script>
function B(){window.history.back()}function RS(){window.location="/settings"}function RP(){top.location.href="/"}
</script><style>
.bt{background:#333;color:#fff;font-family:Verdana,sans-serif;border:.3ch solid #333;display:inline-block;font-size:20px;margin:8px;margin-top:12px}body{font-family:Verdana,sans-serif;text-align:center;background:#222;color:#fff;line-height:200%%;margin:0}
</style></head><body><h2>%MSG%</body></html>)=====";


#ifdef WLED_ENABLE_DMX

// Autogenerated from wled00/data/dmxmap.htm, do not edit!!
const char PAGE_dmxmap[] PROGMEM = R"=====(<!DOCTYPE html><html><head><meta content="width=device-width" name="viewport">
<title>DMX Map</title><script>
function B(){window.history.back()}function RS(){window.location="/settings"}function RP(){top.location.href="/"}function FM() {%DMXVARS%
var n=["SET 0","RED","GREEN","BLUE","WHITE","SHUTTER","SET 255","DISABLED"],o=[];for(i=0;i<512;i++)o.push(7);for(i=0;i<LC;i++)for(FS=CS+CG*i,j=0;j<CN;j++)DA=FS+j,o[DA-1]=CH[j];for(DMXMap="",i=0;i<512;i++)DMXMap+='<div class="anytype type'+o[i]+'">'+String(i+1)+"<br />"+n[o[i]]+"</div>";document.getElementById("map").innerHTML=DMXMap}
</script><style>
.anytype{border:1px solid #fff;margin:1px;float:left;width:100px;height:100px}.S{margin:0;border:2px solid #fff}.type7{color:#888;border:1px dotted grey}.type6{color:#fff}.type4{color:#fff;font-weight:700}.type3{color:#00f;font-weight:700}.type2{color:#0f0;font-weight:700}.type1{color:red;font-weight:700}.bt{background:#333;color:#fff;font-family:Verdana,sans-serif;border:.3ch solid #333;display:inline-block;font-size:20px;margin:8px;margin-top:12px}body{font-family:Verdana,sans-serif;text-align:center;background:#222;color:#fff;line-height:200%%;margin:0}
</style></head><body onload="FM()"><div id="map">...</div></body></html>)=====";


#else
const char PAGE_dmxmap[] PROGMEM = R"=====()=====";
#endif

// Autogenerated from wled00/data/update.htm, do not edit!!
const char PAGE_update[] PROGMEM = R"=====(<!DOCTYPE html><html><head><meta content="width=device-width" name="viewport">
<title>WLED Update</title><script>
function B(){window.history.back()}function U(){document.getElementById("uf").style.display="none",document.getElementById("msg").style.display="block"}function GetV() {var d=document;
%CSS%%SCSS%</head><body onload="GetV()">
<h2>Sound Reactive WLED Software Update</h2><form method="POST" 
action="/update" id="uf" enctype="multipart/form-data" onsubmit="U()"><span 
class="sip">0.13.4</span><br>Download the latest release: <a 
href="https://github.com/atuline/WLED/releases" target="_blank"><img 
src="https://img.shields.io/github/release/atuline/WLED.svg?style=flat-square">
</a><br><input type="file" name="update" required><br><button type="submit">
Update!</button><br><button type="button" onclick="B()">Back</button></form><div
 id="msg"><b>Updating...</b><br>Please do not close or refresh the page :)</div>
</body></html>)=====";


// Autogenerated from wled00/data/welcome.htm, do not edit!!
const char PAGE_welcome[] PROGMEM = R"=====(<!DOCTYPE html><html><head><meta charset="utf-8"><meta 
content="width=device-width" name="viewport"><meta name="theme-color" 
content="#222222"><title>Welcome!</title><style>
body{font-family:Verdana,Helvetica,sans-serif;text-align:center;background-color:#222;margin:0;color:#fff}button{outline:0;cursor:pointer;padding:8px;margin:10px;width:230px;text-transform:uppercase;font-family:helvetica;font-size:19px;background-color:#333;color:#fff;border:0 solid #fff;border-radius:25px}img{width:950px;max-width:82%;image-rendering:pixelated;image-rendering:crisp-edges;margin:4vh 0 0 0;animation:fi 1s}@keyframes fi{from{opacity:0}to{opacity:1}}.main{animation:fi 1.5s .7s both}
</style></head><body><img alt="" 
src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG0AAAAfCAMAAADazLOuAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABLUExURQAAAAB81gCU/zKq///mo7sWMN8bO+ZIYtZaAP9rAP+HMsCiG+TAIOnMS0KqNU7KPnLUZOrq6v///4CAgGhoaL+/v6CgoExMTAAAAAlm4O8AAAAZdFJOU////////////////////////////////wABNAq3AAAACXBIWXMAAA7DAAAOwwHHb6hkAAACN0lEQVRIS73VjVLCMBAEYIr8CYKkrdj3f1J37zaXFCpTO+piaDgbPq9px9VQ0qyrvKj4q6m0Zr1h+M7xF1zRmnWzqV9/0d2jttGotO1uv9dUObwej5oqp7fzWVPl8n69aprzoOUUbbvdIbV3OLwitXc6vSG1d7m8I3feSEN0j2CeNbOY4MxigjOLCc4sZsTV2l1cCyy4wIILLLjAxtykltq2rbTU+qi01N5rXNO2leaFORoija2l5MM5a02ac9Ya16Sk5tgaPrUpjZub0BL6YqSxKwbH77XUUmSkJXSl8QtaMuyJhq5maL5nTKVpZC13VmtMpTFT2g4vJjTuGfMzzXftiUZnhdtgb1xofvypRon5TjNnxYN9zJo6K5ruSIzQtGuVZn0x91rKvdHBvm39E7SyZ4y06Gz8BDBFKzsXmhcwyfsGZ9VpbhoiCinaxPNmGWmWWrNU2jB0q6HvOhN1JUtCixQtp2g51ZVUXIPS2RMAD++T2nY/DrDjOMDO4wC7jmNYj3d73nrXug8Yt9uNB8xNU1cKNXWlUFNXCjV1pZhGTE83m2vWfYf/NGj4Bg1zu5JD3/MnH5ZWfLOksbmGWGjgXMN5/C2GXYGFFW9Nmtle6Xut0Gm+JsayCj8z0nhjGvYJzVf4aSzmNYsr+u7Q2JIdoX3YOQjOslmsW1jJ3120nE9gfo79hTaNdcsqVR610lvO47pllae9ReZ805zKo2a3iaY5c75pTmVCA6dJ5H7N0sr/asPwBehb7ifEhusRAAAAAElFTkSuQmCC">
<div class="main"><h1>Welcome to SR WLED!</h1><h3>
Thank you for installing my application!</h3><b>Next steps:</b><br><br>
Connect the module to your local WiFi here!<br><button 
onclick='window.location.href="/settings/wifi"'>WiFi settings</button><br><i>
Just trying this out in AP mode?</i><br><button 
onclick='window.location.href="/sliders"'>To the controls!</button><br></div>
</body></html>)=====";


// Autogenerated from wled00/data/liveview.htm, do not edit!!
const char PAGE_liveview[] PROGMEM = R"=====(<!DOCTYPE html><html><head><meta name="viewport" 
content="width=device-width,initial-scale=1,minimum-scale=1"><meta 
charset="utf-8"><meta name="theme-color" content="#222222"><title>
WLED Live Preview</title><style>
body{margin:0}#canv{background:#000;filter:brightness(175%);width:100%;height:100%;position:absolute}
</style></head><body><div id="canv"><script>
update();var tmout=null;function update(){if(document.hidden)return clearTimeout(tmout),void(tmout=setTimeout(update,250));fetch("/json/live").then(t=>(t.ok||(clearTimeout(tmout),tmout=setTimeout(update,2500)),t.json())).then(t=>{var e="linear-gradient(90deg,",u=t.leds.length;for(i=0;i<u;i++){var o=t.leds[i];o.length>6&&(o=o.substring(2)),e+="#"+o,i<u-1&&(e+=",")}e+=")",document.getElementById("canv").style.background=e,clearTimeout(tmout),tmout=setTimeout(update,40)}).catch((function(t){clearTimeout(tmout),tmout=setTimeout(update,2500)}))}
</script></body></html>)=====";


// Autogenerated from wled00/data/liveviewws.htm, do not edit!!
const char PAGE_liveviewws[] PROGMEM = R"=====(<!DOCTYPE html><html><head><meta name="viewport" 
content="width=device-width,initial-scale=1,minimum-scale=1"><meta 
charset="utf-8"><meta name="theme-color" content="#222222"><title>
WLED Live Preview</title><style>
body{margin:0}#canv{background:#000;filter:brightness(175%);width:100%;height:100%;position:absolute}
</style></head><body><div id="canv"><script>
function updatePreview(e){var n="linear-gradient(90deg,",t=e.length;for(i=8;i<t;i+=3)n+=`rgb(${e[i]},${e[i+1]},${e[i+2]})`,i<t-3&&(n+=",");n+=")",document.getElementById("canv").style.background=n}function getLiveJson(e){try{if("[object ArrayBuffer]"===toString.call(e.data)){let e=new Uint8Array(event.data);if(76!=e[0])return;updatePreview(e)}}catch(e){console.error("Peek WS error:",e)}}var ws;try{ws=top.window.ws}catch(e){}ws&&ws.readyState===WebSocket.OPEN?(console.info("Peek uses top WS"),ws.send("{'lv':true}")):(console.info("Peek WS opening"),(ws=new WebSocket(("https:"==window.location.protocol?"wss":"ws")+"://"+document.location.host+"/ws")).onopen=function(){console.info("Peek WS open"),ws.send("{'lv':true}")}),ws.binaryType="arraybuffer",ws.addEventListener("message",getLiveJson)
</script></body></html>)=====";


// Autogenerated from wled00/data/liveviewws2D.htm, do not edit!!
const char PAGE_liveviewws2D[] PROGMEM = R"=====(<!DOCTYPE html><html><head><meta name="viewport" 
content="width=device-width,initial-scale=1,minimum-scale=1"><meta 
charset="utf-8"><meta name="theme-color" content="#222222"><title>
WLED Live Preview</title><style>body{margin:0}</style></head><body><canvas 
id="liveviewCanvas">LiveView</canvas><script 
src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js">
</script><script>
var ws,c=document.getElementById("liveviewCanvas"),ctx=null,pPL=0,lOf=0,mW=0,mH=0,renderer=null,scene=null,camera=null,mD=0;function updatePreview(e){if(mW=e[3],mH=e[4],mD=e[5],1==e[2]){for(ctx||(c.width=.98*window.innerWidth,c.height=.98*window.innerHeight,ctx=c.getContext("2d"),pPL=Math.min(c.width/mW,(c.height-10)/mH),lOf=Math.floor((c.width-pPL*mW)/2)),ctx.clearRect(0,0,c.width,c.height),a=8;a<e.length;a+=3){let t=(a-8)/3;ctx.fillStyle=`rgb(${e[a]},${e[a+1]},${e[a+2]})`,ctx.beginPath(),ctx.arc(t%mW*pPL+.5*pPL+lOf,Math.floor(t/mW)*pPL+.5*pPL,.4*pPL,0,2*Math.PI),ctx.fill()}ctx.fillStyle="rgb(255,255,255)",0!=e[6]&&ctx.fillText("preset "+e[6].toString(),lOf,mH*pPL+10),255!=e[7]&&ctx.fillText("playlist "+e[7].toString(),lOf+70,mH*pPL+10)}else if(2==e[2]){if(!renderer){c.width=0,c.height=0,(renderer=new THREE.WebGLRenderer({alpha:!0})).setClearAlpha(0),renderer.setClearColor(0,0),renderer.setSize(.98*window.innerWidth,.98*window.innerHeight),document.body.appendChild(renderer.domElement),(camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,500)).position.set(0,0,100),camera.lookAt(0,0,0),(scene=new THREE.Scene).background=null;for(var t=-5*(mW-1)/2,r=-5*(mH-1)/2,n=-5*(mD-1)/2,i=0;i<mW;i++)for(var o=0;o<mH;o++)for(var l=0;l<mD;l++){const e=new THREE.SphereGeometry(1,32,16),c=new THREE.MeshBasicMaterial,a=new THREE.Mesh(e,c);a.position.set(t+5*i,r+5*o,n+5*l),scene.add(a)}}let d=6;var a=1;for(i=0;i<mW;i++)for(o=0;o<mH;o++)for(l=0;l<mD;l++)a<scene.children.length&&(scene.children[a].material.color=new THREE.Color(""+e[3*a+d]/255,""+e[3*a+d+1]/255,""+e[3*a+d+2]/255)),a++;scene.rotation.x+=.01,scene.rotation.y+=.01,renderer.render(scene,camera)}}try{ws=top.window.ws}catch(e){}ws&&ws.readyState===WebSocket.OPEN?ws.send("{'lv':true}"):(ws=new WebSocket(("https:"==window.location.protocol?"wss":"ws")+"://"+document.location.host+"/ws")).onopen=()=>{ws.send("{'lv':true}")},ws.binaryType="arraybuffer",ws.addEventListener("message",e=>{try{if("[object ArrayBuffer]"===toString.call(e.data)){let e=new Uint8Array(event.data);if(76!=e[0])return;updatePreview(e)}}catch(e){console.error("Peek WS error:",e)}})
</script></body></html>)=====";


// Autogenerated from wled00/data/404.htm, do not edit!!
const char PAGE_404[] PROGMEM = R"=====(<!DOCTYPE html><html><head><meta charset="utf-8"><meta 
content="width=device-width" name="viewport"><meta name="theme-color" 
content="#222222"><title>Not found</title><style>
body{font-family:Verdana,Helvetica,sans-serif;text-align:center;background-color:#222;margin:0;color:#fff}img{width:400px;max-width:50%;image-rendering:pixelated;image-rendering:crisp-edges;margin:25px 0 -10px 0}button{outline:0;cursor:pointer;padding:8px;margin:10px;width:230px;text-transform:uppercase;font-family:helvetica;font-size:19px;background-color:#333;color:#fff;border:0 solid #fff;border-radius:25px}
</style></head><body><img alt="" 
src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAbUExURQAAAAB81gCU/zKq/////9bW1oCAgGhoaAAAAGPLX8AAAAAJdFJOU///////////AFNPeBIAAAAJcEhZcwAADsAAAA7AAWrWiQkAAACdSURBVDhPxc9bDoUgEANQebP/FUuHMjBGY/B+3EYR7RH0qC/ZBc6HwCljgHO+xZIVSI2sYgHaG7EBWh8jWoxTrCBFdDJ+BD4lbIHxAcz8APAVLTsrZE4eQD5qzt3cAFTYokC4YCN9Gybgu4yAQtBFLQXHuHABA7JMeOEC/E0W5uy9gv4vo5QHK2i7yq2C8UABM4HmL+CSTXCTF1DrCX6+Gp9zB5dsAAAAAElFTkSuQmCC">
<h1>404 Not Found</h1><b>Akemi does not know where you are headed...</b><br><br>
<button onclick='window.location.href="/sliders"'>Back to controls</button>
</body></html>)=====";


// Autogenerated from wled00/data/favicon.ico, do not edit!!
const uint16_t favicon_length = 954;
const uint8_t favicon[] PROGMEM = {
  0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x10, 0x10, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x86, 0x00,
  0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00,
  0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x08, 0x06,
  0x00, 0x00, 0x00, 0x1f, 0xf3, 0xff, 0x61, 0x00, 0x00, 0x00, 0x4d, 0x49, 0x44, 0x41, 0x54, 0x38,
  0x8d, 0x63, 0xfc, 0xff, 0xff, 0x3f, 0x03, 0xb1, 0x80, 0xd1, 0x9e, 0x01, 0x43, 0x31, 0x13, 0xd1,
  0xba, 0x71, 0x00, 0x8a, 0x0d, 0x60, 0x21, 0xa4, 0x00, 0xd9, 0xd9, 0xff, 0x0f, 0x32, 0x30, 0x52,
  0xdd, 0x05, 0xb4, 0xf1, 0x02, 0xb6, 0xd0, 0xa6, 0x99, 0x0b, 0x68, 0x1f, 0x0b, 0xd8, 0x42, 0x9e,
  0xaa, 0x2e, 0xa0, 0xd8, 0x00, 0x46, 0x06, 0x3b, 0xcc, 0xcc, 0x40, 0xc8, 0xd9, 0x54, 0x75, 0x01,
  0xe5, 0x5e, 0x20, 0x25, 0x3b, 0x63, 0x03, 0x00, 0x3e, 0xb7, 0x11, 0x5a, 0x8d, 0x1c, 0x07, 0xb4,
  0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};


=== ./html_settings.h ===

/*
 * More web UI HTML source arrays.
 * This file is auto generated, please don't make any changes manually.
 * Instead, see https://kno.wled.ge/advanced/custom-features/#changing-web-ui
 * to find out how to easily modify the web UI source!
 */

// Autogenerated from wled00/data/style.css, do not edit!!
const char PAGE_settingsCss[] PROGMEM = R"=====(<style>body{font-family:Verdana,sans-serif;text-align:center;background:#222;color:#fff;line-height:200%%;margin:0}hr{border-color:#666}a{color:#28f;text-decoration:none}.btn,button{background:#333;color:#fff;font-family:Verdana,sans-serif;border:.3ch solid #333;border-radius:24px;display:inline-block;font-size:20px;margin:12px 8px 8px;padding:8px 12px;min-width:48px;cursor:pointer;text-decoration:none}button.sml{padding:8px;border-radius:20px;font-size:15px;min-width:40px;margin:0 0 0 10px}.lnk{border:0}button.disabled,button[disabled]{color:#aaa}.helpB{text-align:left;position:absolute;width:60px}input{background:#333;color:#fff;font-family:Verdana,sans-serif;border:.5ch solid #333}input:disabled{color:#888}input[type=number]{width:4em;margin:2px}input[type=number].xxl{width:100px}input[type=number].xl{width:85px}input[type=number].l{width:63px}input[type=number].m{width:56px}input[type=number].s{width:49px}input[type=number].xs{width:42px}input[type=checkbox]{transform:scale(1.5)}select{background:#333;color:#fff;font-family:Verdana,sans-serif;border:.5ch solid #333}td{padding:2px}.d5{width:4.5em!important}.tiny{font-size:14px;color:#bbb}#msg{display:none}#toast{opacity:0;background-color:#444;border-radius:5px;bottom:64px;color:#fff;font-size:17px;padding:16px;pointer-events:none;position:fixed;text-align:center;z-index:5;transform:translateX(-50%%);max-width:90%%;left:50%%}#toast.show{opacity:1;background-color:#264;animation:fadein .5s,fadein .5s 2.5s reverse}#toast.error{opacity:1;background-color:#b21;animation:fadein .5s}</style>)=====";


// Autogenerated from wled00/data/settings.htm, do not edit!!
const char PAGE_settings[] PROGMEM = R"=====(<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>WLED Settings
</title><style>
body{text-align:center;background:#222;height:100px;margin:0}html{--h:8.9vh}button{background:#333;color:#fff;font-family:Verdana,Helvetica,sans-serif;border:1px solid #333;border-radius:.5em;font-size:6.5vmin;height:var(--h);width:calc(100%% - 40px);margin-top:2vh}
</style></head><body><form action="/"><button type="submit" id="b">Back</button>
</form><form action="/settings/wifi"><button type="submit">WiFi Setup</button>
</form><form action="/settings/leds"><button type="submit">LED Preferences
</button></form><form action="/settings/sound"><button type="submit">
Sound Settings</button></form><form action="/settings/ui"><button type="submit">
User Interface</button></form><form action="/settings/sync"><button 
type="submit">Sync Interfaces</button></form><form action="/settings/time">
<button type="submit">Time & Macros</button></form><form action="/settings/um">
<button type="submit">Usermods</button></form>%DMXMENU%<form action="/settings/sec">
<button type="submit">Security & Updates</button></form></body></html>)=====";


// Autogenerated from wled00/data/settings_wifi.htm, do not edit!!
const char PAGE_settings_wifi[] PROGMEM = R"=====(<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta 
name="viewport" content="width=500"><title>WiFi Settings</title><script>
function H(){window.open("https://github.com/atuline/WLED/wiki/Settings#wifi-settings")}function B(){window.open("/settings","_self")}function GetV() {var d=document;
%CSS%%SCSS%</head><body onload="GetV()">
<form id="form_s" name="Sf" method="post"><div class="helpB"><button 
type="button" onclick="H()">?</button></div><button type="button" onclick="B()">
Back</button><button type="submit">Save & Connect</button><hr><h2>WiFi setup
</h2><h3>Connect to existing network</h3>
Network name (SSID, empty to not connect):<br><input name="CS" maxlength="32">
<br>Network password:<br><input type="password" name="CP" maxlength="63"><br>
Static IP (leave at 0.0.0.0 for DHCP):<br><input name="I0" type="number" 
class="s" min="0" max="255" required> . <input name="I1" type="number" 
class="s" min="0" max="255" required> . <input name="I2" type="number" 
class="s" min="0" max="255" required> . <input name="I3" type="number" 
class="s" min="0" max="255" required><br>Static gateway:<br><input name="G0" 
type="number" class="s" min="0" max="255" required> . <input name="G1" 
type="number" class="s" min="0" max="255" required> . <input name="G2" 
type="number" class="s" min="0" max="255" required> . <input name="G3" 
type="number" class="s" min="0" max="255" required><br>Static subnet mask:<br>
<input name="S0" type="number" class="s" min="0" max="255" required> . <input 
name="S1" type="number" class="s" min="0" max="255" required> . <input 
name="S2" type="number" class="s" min="0" max="255" required> . <input 
name="S3" type="number" class="s" min="0" max="255" required><br>
mDNS address (leave empty for no mDNS):<br>http:// <input name="CM" 
maxlength="32"> .local<br>Client IP: <span class="sip">Not connected</span><br>
<h3>Configure Access Point</h3>AP SSID (leave empty for no AP):<br><input 
name="AS" maxlength="32"><br>Hide AP name: <input type="checkbox" name="AH"><br>
AP password (leave empty for open):<br><input type="password" name="AP" 
maxlength="63" pattern="(.{8,63})|()" title="Empty or min. 8 characters"><br>
Access Point WiFi channel: <input name="AC" type="number" class="xs" min="1" 
max="13" required><br>AP opens: <select name="AB"><option value="0">
No connection after boot</option><option value="1">Disconnected</option><option 
value="2">Always</option><option value="3">Never (not recommended)</option>
</select><br>AP IP: <span class="sip">Not active</span><br><h3>Experimental</h3>
Disable WiFi sleep: <input type="checkbox" name="WS"><br><i>
Can help with connectivity issues.<br>
Do not enable if WiFi is working correctly, increases power consumption.</i><div
 id="ethd"><h3>Ethernet Type</h3><select name="ETH"><option value="0">None
</option><option value="9">ABC! WLED V43 &amp; compatible</option><option 
value="2">ESP32-POE</option><option value="6">ESP32Deux</option><option 
value="7">KIT-VE</option><option value="8">QuinLED-Dig-Octa &amp; T-ETH-POE
</option><option value="4">QuinLED-ESP32</option><option value="10">Serg74-ETH32
</option><option value="5">TwilightLord-ESP32</option><option value="3">WESP32
</option><option value="1">WT32-ETH01</option></select><br><br></div><hr><button
 type="button" onclick="B()">Back</button><button type="submit">Save & Connect
</button></form></body></html>)=====";


// Autogenerated from wled00/data/settings_leds.htm, do not edit!!
const char PAGE_settings_leds[] PROGMEM = R"=====(<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta 
name="viewport" content="width=500"><meta 
content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" 
name="viewport"><title>LED Settings</title><script>
var timeout,d=document,laprev=55,maxB=1,maxM=4e3,maxPB=4096,maxL=1333,maxLbquot=0,customStarts=!1,startsDirty=[],maxCOOverrides=5;function H(){window.open("https://kno.wled.ge/features/settings/#led-settings")}function B(){window.open("/settings","_self")}function gId(e){return d.getElementById(e)}function hideNoIR(){gId("irOnOff2").style.display="none"}function off(e){d.getElementsByName(e)[0].value=-1}function showToast(e,n=!1){var t=gId("toast");t.innerHTML=e,t.className=n?"error":"show",clearTimeout(timeout),t.style.animation="none",timeout=setTimeout((function(){t.className=t.className.replace("show","")}),2900)}function bLimits(e,n,t,a){maxB=e,maxM=t,maxPB=n,maxL=a}function pinsOK(){var e=d.getElementsByTagName("input");for(i=0;i<e.length;i++){var n=e[i].name.substring(0,2);if("L0"==n||"L1"==n||"L2"==n||"L3"==n){var t=e[i].name.substring(2);if(parseInt(d.getElementsByName("LT"+t)[0].value,10)>=80)continue}if(("L0"==n||"L1"==n||"L2"==n||"L3"==n||"L4"==n||"RL"==n||"BT"==n||"IR"==n)&&""!=e[i].value&&"-1"!=e[i].value){if(d.um_p&&d.um_p.some(n=>n==parseInt(e[i].value,10)))return alert(`Sorry, pins ${JSON.stringify(d.um_p)} can't be used.`),e[i].value="",e[i].focus(),!1;if(e[i].value>5&&e[i].value<12)return alert("Sorry, pins 6-11 can not be used."),e[i].value="",e[i].focus(),!1;if("IR"!=n&&"BT"!=n&&e[i].value>33)return alert("Sorry, pins >33 are input only."),e[i].value="",e[i].focus(),!1;for(j=i+1;j<e.length;j++){var a=e[j].name.substring(0,2);if("L0"==a||"L1"==a||"L2"==a||"L3"==a||"L4"==a||"RL"==a||"BT"==a||"IR"==a){if("L"===a.substring(0,1)){var l=e[j].name.substring(2);if(parseInt(d.getElementsByName("LT"+l)[0].value,10)>=80)continue}if(""!=e[j].value&&e[i].value==e[j].value)return alert(`Pin conflict between ${e[i].name}/${e[j].name}!`),e[j].value="",e[j].focus(),!1}}}}return!0}function trySubmit(e){if(d.Sf.data.value="",e.preventDefault(),!pinsOK())return e.stopPropagation(),!1;if(bquot>100){var n="Too many LEDs for me to handle!";maxM<1e4&&(n+="\n\rConsider using an ESP32."),alert(n)}d.Sf.checkValidity()&&d.Sf.submit()}function enABL(){var e=gId("able").checked;d.Sf.LA.value=e?laprev:0,gId("abl").style.display=e?"inline":"none",gId("psu2").style.display=e?"inline":"none",d.Sf.LA.value>0&&setABL()}function enLA(){var e=d.Sf.LAsel.value;d.Sf.LA.value=e,gId("LAdis").style.display=50==e?"inline":"none",UI()}function setABL(){switch(gId("able").checked=!0,d.Sf.LAsel.value=50,parseInt(d.Sf.LA.value)){case 0:gId("able").checked=!1,enABL();break;case 30:d.Sf.LAsel.value=30;break;case 35:d.Sf.LAsel.value=35;break;case 55:d.Sf.LAsel.value=55;break;case 255:d.Sf.LAsel.value=255;break;default:gId("LAdis").style.display="inline"}gId("m1").innerHTML=maxM,d.getElementsByName("Sf")[0].addEventListener("submit",trySubmit),UI()}function getMem(e,n){let t=parseInt(d.getElementsByName("LC"+n)[0].value);return t+=parseInt(d.getElementsByName("SL"+n)[0].value),e<32?maxM<1e4&&3==d.getElementsByName("L0"+n)[0].value?e>29?20*t:15*t:maxM>=1e4?e>29?8*t:6*t:e>29?4*t:3*t:e>31&&e<48?5:44==e||45==e?4*t:3*t}function UI(e=!1){var n=!1,t=0;gId("ampwarning").style.display=d.Sf.MA.value>7200?"inline":"none",gId("fpswarning").style.display=d.Sf.FR.value>79?"block":"none",gId("fpshelp1").style.display=d.Sf.FR.value>80&&d.Sf.FR.value<132?"block":"none",gId("fpshelp2").style.display=d.Sf.FR.value>132&&d.Sf.FR.value<196?"block":"none",gId("fpshelp3").style.display=d.Sf.FR.value>196?"block":"none",255==d.Sf.LA.value?laprev=12:d.Sf.LA.value>0&&(laprev=d.Sf.LA.value);var a=d.getElementsByTagName("select");for(i=0;i<a.length;i++)if("LT"==a[i].name.substring(0,2)){var l=a[i].name.substring(2),s=parseInt(a[i].value,10);gId("p0d"+l).innerHTML=s>=80&&s<96?"IP address:":s>49?"Data GPIO:":s>41?"GPIOs:":"GPIO:",gId("p1d"+l).innerHTML=s>49&&s<64?"Clk GPIO:":"";var o=d.getElementsByName("L1"+l)[0];for(t+=getMem(s,l),g=1;g<5;g++){(o=d.getElementsByName("L"+g+l)[0])&&(s>=80&&s<96&&g<4||s>49&&1==g||s>41&&s<50&&g+40<s?(o.style.display="inline",o.required=!0):(o.style.display="none",o.required=!1,o.value=""))}e&&(gId("rf"+l).checked=gId("rf"+l).checked||31==s,s>31&&s<48&&(d.getElementsByName("LC"+l)[0].value=1)),gId("rf"+l).onclick=31==s?function(){return!1}:function(){},n|=30==s||31==s||s>40&&s<46&&43!=s,gId("co"+l).style.display=s>=80&&s<96||s>40&&s<48?"none":"inline",gId("dig"+l+"c").style.display=s>40&&s<48?"none":"inline",gId("dig"+l+"r").style.display=s>=80&&s<96?"none":"inline",gId("dig"+l+"s").style.display=s>=80&&s<96||s>40&&s<48?"none":"inline",gId("dig"+l+"f").style.display=s>=16&&s<32||s>=50&&s<64?"inline":"none",gId("rev"+l).innerHTML=s>40&&s<48?"Inverted output":"Reversed (rotated 180)",gId("psd"+l).innerHTML=s>40&&s<48?"Index:":"Start:"}var r=d.querySelectorAll(".wc"),u=r.length;for(i=0;i<u;i++)r[i].style.display=n?"inline":"none";var p=d.getElementsByTagName("input"),m=0,v=0,c=0;for(i=0;i<p.length;i++){var f=p[i].name.substring(0,2);l=p[i].name.substring(2);if("LC"!=f){if("L0"==f||"L1"==f)d.getElementsByName("LC"+l)[0].max=maxPB;if("L0"==f||"L1"==f||"L2"==f||"L3"==f){if((s=parseInt(d.getElementsByName("LT"+l)[0].value))>=80){p[i].max=255,p[i].min=0,p[i].style.color="#fff";continue}p[i].max=33,p[i].min=-1}if(("L0"==f||"L1"==f||"L2"==f||"L3"==f||"L4"==f||"RL"==f||"BT"==f||"IR"==f)&&""!=p[i].value&&"-1"!=p[i].value){var g=[];if(d.um_p&&Array.isArray(d.um_p))for(k=0;k<d.um_p.length;k++)g.push(d.um_p[k]);for(j=0;j<p.length;j++)if(i!=j){var y=p[j].name.substring(0,2);if("L0"==y||"L1"==y||"L2"==y||"L3"==y||"L4"==y||"RL"==y||"BT"==y||"IR"==y){if("L"===y.substring(0,1)){var I=p[j].name.substring(2);if(parseInt(d.getElementsByName("LT"+I)[0].value,10)>=80)continue}""!=p[j].value&&"-1"!=p[j].value&&g.push(parseInt(p[j].value,10))}}g.some(e=>e==parseInt(p[i].value,10))?p[i].style.color="red":p[i].style.color=parseInt(p[i].value,10)>33?"orange":"#fff"}}else{var L=parseInt(p[i].value,10);customStarts&&startsDirty[l]||(gId("ls"+l).value=m),gId("ls"+l).disabled=!customStarts,L&&((a=parseInt(gId("ls"+l).value))+L>m&&(m=a+L),L>c&&(c=L),(s=parseInt(d.getElementsByName("LT"+l)[0].value))<80&&(v+=L))}}gId("lc").textContent=m,gId("pc").textContent=m==v?"":"("+v+" physical)",gId("m0").innerHTML=t,bquot=t/maxM*100,gId("dbar").style.background=`linear-gradient(90deg, ${bquot>60?bquot>90?"red":"orange":"#ccc"} 0 ${bquot}%%, #444 ${bquot}%% 100%%)`,gId("ledwarning").style.display=c>Math.min(maxPB,800)||bquot>80?"inline":"none",gId("ledwarning").style.color=c>Math.max(maxPB,800)||bquot>100?"red":"orange",gId("wreason").innerHTML=bquot>80?"80% of max. LED memory"+(bquot>100?` (<b>ERROR: Using over ${maxM}B!</b>)`:""):"800 LEDs per output";var b=Math.ceil((100+v*laprev)/500)/2;b=b>5?Math.ceil(b):b;a="";var h=30==d.Sf.LAsel.value,B=255==d.Sf.LAsel.value;b<1.02&&!h&&!B?a="ESP 5V pin with 1A USB supply":(a+=h?"12V ":B?"WS2815 12V ":"5V ",a+=b,a+="A supply connected to LEDs");var S=Math.ceil((100+v*laprev)/1500)/2,x="(for most effects, ~";x+=S=S>5?Math.ceil(S):S,x+="A is enough)<br>",gId("psu").innerHTML=a,gId("psu2").innerHTML=B?"":x,gId("json").style.display=8==d.Sf.IT.value?"":"none";var E=parseInt(d.Sf.SOMP.value,10),$=parseInt(d.Sf.MXW.value,10),T=parseInt(d.Sf.MXH.value,10);if(isNaN($)||isNaN(T)||!($>0||T>0)||$*T==parseInt(m,10)||1!=E){gId("2dwarning").style.display="none";for(let e of d.Sf.querySelectorAll('button[type="submit"]'))e.disabled=!1}else{gId("2dwarning").style.display="inline";for(let e of d.Sf.querySelectorAll('button[type="submit"]'))e.disabled=!0}}function lastEnd(e){if(e<1)return 0;v=parseInt(d.getElementsByName("LS"+(e-1))[0].value)+parseInt(d.getElementsByName("LC"+(e-1))[0].value);var n=parseInt(d.getElementsByName("LT"+(e-1))[0].value);return n>31&&n<48&&(v=1),isNaN(v)?0:v}function addLEDs(e,n=!0){var t=d.getElementsByClassName("iST"),a=t.length;if(!(1==e&&a>=maxB||-1==e&&0==a)){var i=gId("mLC");if(1==e){var l=`<div class="iST">\n<hr style="width:260px">\n${a+1}:\n<select name="LT${a}" onchange="UI(true)">\n<option value="22" selected>WS281x</option>\n<option value="30">SK6812 RGBW</option>\n<option value="31">TM1814</option>\n<option value="24">400kHz</option>\n<option value="50">WS2801</option>\n<option value="51">APA102</option>\n<option value="52">LPD8806</option>\n<option value="54">LPD6803</option>\n<option value="53">P9813</option>\n<option value="41">PWM White</option>\n<option value="42">PWM CCT</option>\n<option value="43">PWM RGB</option>\n<option value="44">PWM RGBW</option>\n<option value="45">PWM RGB+CCT</option>\n\x3c!--option value="46">PWM RGB+DCCT</option--\x3e\n<option value="80">DDP RGB (network)</option>\n\x3c!--option value="81">E1.31 RGB (network)</option--\x3e\n\x3c!--option value="82">ArtNet RGB (network)</option--\x3e\n</select><br>\n<div id="co${a}" style="display:inline">Color Order:\n<select name="CO${a}">\n<option value="0">GRB</option>\n<option value="1">RGB</option>\n<option value="2">BRG</option>\n<option value="3">RBG</option>\n<option value="4">BGR</option>\n<option value="5">GBR</option>\n</select><br></div>\n<span id="psd${a}">Start:</span> <input type="number" name="LS${a}" id="ls${a}" class="l starts" min="0" max="8191" value="${lastEnd(a)}" oninput="startsDirty[${a}]=true;UI();" required />&nbsp;\n<div id="dig${a}c" style="display:inline">Length: <input type="number" name="LC${a}" class="l" min="1" max="${maxPB}" value="1" required oninput="UI()" /></div>\n<br>\n<span id="p0d${a}">GPIO:</span> <input type="number" name="L0${a}" min="0" max="33" required class="xs" onchange="UI()"/>\n<span id="p1d${a}"></span><input type="number" name="L1${a}" min="0" max="33" class="xs" onchange="UI()"/>\n<span id="p2d${a}"></span><input type="number" name="L2${a}" min="0" max="33" class="xs" onchange="UI()"/>\n<span id="p3d${a}"></span><input type="number" name="L3${a}" min="0" max="33" class="xs" onchange="UI()"/>\n<span id="p4d${a}"></span><input type="number" name="L4${a}" min="0" max="33" class="xs" onchange="UI()"/>\n<div id="dig${a}r" style="display:inline"><br><span id="rev${a}">Reversed</span>: <input type="checkbox" name="CV${a}"></div>\n<div id="dig${a}s" style="display:inline"><br>Skip first LEDs: <input type="number" name="SL${a}" min="0" max="255" value="0" oninput="UI()"></div>\n<div id="dig${a}f" style="display:inline"><br>Off Refresh: <input id="rf${a}" type="checkbox" name="RF${a}"></div>\n</div>`;i.insertAdjacentHTML("beforeend",l)}-1==e&&(t[--a].remove(),--a),gId("+").style.display=a<maxB-1?"inline":"none",gId("-").style.display=a>0?"inline":"none",n||UI()}}function addCOM(e=0,n=1,t=0){var a=d.getElementsByClassName("com_entry").length;if(!(a>=10)){var i=`<div class="com_entry">\n<hr style="width:260px">\n${a+1}: Start: <input type="number" name="XS${a}" id="xs${a}" class="l starts" min="0" max="65535" value="${e}" oninput="UI();" required="">&nbsp;\nLength: <input type="number" name="XC${a}" id="xc${a}" class="l" min="1" max="65535" value="${n}" required="" oninput="UI()">\n<div style="display:inline">Color Order:\n<select id="xo${a}" name="XO${a}">\n<option value="0">GRB</option>\n<option value="1">RGB</option>\n<option value="2">BRG</option>\n<option value="3">RBG</option>\n<option value="4">BGR</option>\n<option value="5">GBR</option>\n</select>\n</div><br></div>`;gId("com_entries").insertAdjacentHTML("beforeend",i),gId("xo"+a).value=t,btnCOM(a+1),UI()}}function remCOM(){var e=d.getElementsByClassName("com_entry"),n=e.length;0!==n&&(e[n-1].remove(),btnCOM(n-1),UI())}function resetCOM(e){e&&(maxCOOverrides=e);for(let e of d.getElementsByClassName("com_entry"))e.remove();btnCOM(0)}function btnCOM(e){gId("com_add").style.display=e<maxCOOverrides?"inline":"none",gId("com_rem").style.display=e>0?"inline":"none"}function addBtn(e,n,t){var a=gId("btns").innerHTML,i="BT"+String.fromCharCode((e<10?48:55)+e);a+=`Button ${e} GPIO: <input type="number" min="-1" max="40" name="${i}" onchange="UI()" class="xs" value="${n}">`,a+=`&nbsp;<select name="${"BE"+String.fromCharCode((e<10?48:55)+e)}">`,a+=`<option value="0" ${0==t?"selected":""}>Disabled</option>`,a+=`<option value="2" ${2==t?"selected":""}>Pushbutton</option>`,a+=`<option value="3" ${3==t?"selected":""}>Push inverted</option>`,a+=`<option value="4" ${4==t?"selected":""}>Switch</option>`,a+=`<option value="5" ${5==t?"selected":""}>PIR sensor</option>`,a+=`<option value="6" ${6==t?"selected":""}>Touch</option>`,a+=`<option value="7" ${7==t?"selected":""}>Analog</option>`,a+=`<option value="8" ${8==t?"selected":""}>Analog inverted</option>`,a+="</select>",a+=`<span style="cursor: pointer;" onclick="off('${i}')">&nbsp;&#215;</span><br>`,gId("btns").innerHTML=a}function Ps(){d.getElementById("mphv").style.display=d.getElementById("mxp").checked?"block":"none"}function MPDiv(){d.getElementById("mpdiv").style.display=1==d.getElementById("somp").value?"block":"none"}function tglSi(e){(customStarts=e)||(startsDirty=[]),UI()}function checkSi(){for(var e=!1,n=1;n<d.getElementsByClassName("iST").length;n++){parseInt(gId("ls"+(n-1)).value)+parseInt(d.getElementsByName("LC"+(n-1))[0].value)!=parseInt(gId("ls"+n).value)&&(e=!0,startsDirty[n]=!0)}0!=parseInt(gId("ls0").value)&&(e=!0,startsDirty[0]=!0),gId("si").checked=e,tglSi(e)}function uploadFile(e){var n=new XMLHttpRequest;n.addEventListener("load",(function(){showToast(this.responseText,this.status>=400)})),n.addEventListener("error",(function(e){showToast(e.stack,!0)})),n.open("POST","/upload");var t=new FormData;return t.append("data",d.Sf.data.files[0],e),n.send(t),d.Sf.data.value="",!1}function loadCfg(e){var n,t;"function"==typeof window.FileReader?(e.files?e.files[0]?(n=e.files[0],(t=new FileReader).onload=function(e){let n=e.target.result;var t=JSON.parse(n);if(t.hw){if(t.hw.led){for(var a=0;a<10;a++)addLEDs(-1);t.hw.led.ins.forEach((e,n,t)=>{addLEDs(1);for(var a=0;a<e.pin.length;a++)d.getElementsByName(`L${a}${n}`)[0].value=e.pin[a];d.getElementsByName("LT"+n)[0].value=e.type,d.getElementsByName("LS"+n)[0].value=e.start,d.getElementsByName("LC"+n)[0].value=e.len,d.getElementsByName("CO"+n)[0].value=e.order,d.getElementsByName("SL"+n)[0].value=e.skip,d.getElementsByName("RF"+n)[0].checked=e.ref,d.getElementsByName("CV"+n)[0].checked=e.rev})}if(t.hw.com&&(resetCOM(),t.hw.com.forEach(e=>{addCOM(e.start,e.len,e.order)})),t.hw.btn){var i=t.hw.btn;Array.isArray(i.ins)&&(gId("btns").innerHTML=""),i.ins.forEach((e,n,t)=>{addBtn(n,e.pin[0],e.type)}),d.getElementsByName("TT")[0].value=i.tt}t.hw.ir&&(d.getElementsByName("IR")[0].value=t.hw.ir.pin,d.getElementsByName("IT")[0].value=t.hw.ir.type),t.hw.relay&&(d.getElementsByName("RL")[0].value=t.hw.relay.pin,d.getElementsByName("RM")[0].checked=t.hw.relay.inv),UI()}},t.readAsText(n)):alert("Please select a JSON file first!"):alert("This browser doesn't support the `files` property of file inputs."),e.value=""):alert("The file API isn't supported on this browser yet.")}function S(){GetV(),checkSi(),setABL(),Ps(),MPDiv()}function GetV() {var d=document;
%CSS%%SCSS%</head><body onload="S()"><form
 id="form_s" name="Sf" method="post"><div class="helpB"><button type="button" 
onclick="H()">?</button></div><button type="button" onclick="B()">Back</button>
<button type="submit">Save</button><hr><h2>LED &amp; Hardware setup</h2>
Total LEDs: <span id="lc">?</span> <span id="pc"></span><br><i>
Recommended power supply for brightest white:</i><br><b><span id="psu">?</span>
</b><br><span id="psu2"><br></span><br>Strip or panel: <select id="somp" 
name="SOMP" onchange="MPDiv()"><option value="0" selected="selected">1D Strip
</option><option value="1">2D Matrix panel</option><option value="2">
3D Cube (Experimental)</option></select><br><div id="mpdiv"><h3>2D Matrix</h3>
Width <input id="mxw" name="MXW" type="number" min="1" max="16384" 
oninput="UI()"> x Height <input id="mxh" name="MXH" type="number" min="1" 
max="16384" oninput="UI()"><br><div id="2dwarning" 
style="color:orange;display:inline">
&#9888; width x height should match LED count!<br></div><h3>2D Panels</h3><i>
A matrix is made of 1 or more identical physical led panels</i><br>
Multiple panels: <input type="checkbox" id="mxp" name="MXP" onclick="Ps()"><br>
<div id="mphv">Horizontal panels: <input name="MPH" type="number" min="1" 
max="8" oninput="UI()"> Vertical panels: <input name="MPV" type="number" 
min="1" max="8" oninput="UI()"><br></div><h3>2D Panel layout</h3>
First led position: <select name="PFLTB"><option value="0" selected="selected">
Top</option><option value="1">Bottom</option></select> <select name="PFLLR">
<option value="0" selected="selected">Left</option><option value="1">Right
</option></select><br>Orientation: <select name="POHV"><option value="0" 
selected="selected">Horizontal</option><option value="1">Vertical</option>
</select><br>Serpentine: <input type="checkbox" name="PNLS" checked="checked">
<br>Transpose: <input type="checkbox" name="PNLT" checked="checked"><br><br>
</div><br>Enable automatic brightness limiter: <input type="checkbox" 
name="ABen" onchange="enABL()" id="able"><br><div id="abl">Maximum Current: 
<input name="MA" type="number" class="l" min="250" max="65000" oninput="UI()" 
required> mA<br><div id="ampwarning" style="color:orange;display:none">
&#9888; Your power supply provides high current.<br>
To improve the safety of your setup,<br>please use thick cables,<br>
multiple power injection points and a fuse!<br></div><i>
Automatically limits brightness to stay close to the limit.<br>
Keep at &lt;1A if powering LEDs directly from the ESP 5V pin!<br>
If you are using an external power supply, enter its rating.<br>
(Current estimated usage: <span class="pow">unknown</span>)</i><br><br>
LED voltage (Max. current for a single LED):<br><select name="LAsel" 
onchange="enLA()"><option value="55" selected="selected">5V default (55mA)
</option><option value="35">5V efficient (35mA)</option><option value="30">
12V (30mA)</option><option value="255">WS2815 (12mA)</option><option value="50">
Custom</option></select><br><span id="LAdis" style="display:none">
Custom max. current per LED: <input name="LA" type="number" min="0" max="255" 
id="la" oninput="UI()" required> mA<br></span><i>
Keep at default if you are unsure about your type of LEDs.</i><br></div><h3>
Hardware setup</h3><div id="mLC">LED outputs:</div><hr style="width:260px">
<button type="button" id="+" onclick="addLEDs(1,!1)" 
style="display:none;border-radius:20px;height:36px">+</button> <button 
type="button" id="-" onclick="addLEDs(-1,!1)" 
style="display:none;border-radius:20px;width:36px;height:36px">-</button><br>
LED Memory Usage: <span id="m0">0</span> / <span id="m1">?</span> B<br><div 
id="dbar" 
style="display:inline-block;width:100px;height:10px;border-radius:20px"></div>
<br><div id="ledwarning" style="color:orange;display:none">
&#9888; You might run into stability or lag issues.<br>Use less than <span 
id="wreason">800 LEDs per output</span> for the best experience!<br></div><hr 
style="width:260px">Make a segment for each output: <input type="checkbox" 
name="MS"><br>Custom bus start indices: <input type="checkbox" 
onchange="tglSi(this.checked)" id="si"><br><hr style="width:260px"><div 
id="color_order_mapping">Color Order Override:<div id="com_entries"></div><hr 
style="width:260px"><button type="button" id="com_add" onclick="addCOM(),UI()" 
style="display:none;border-radius:20px;height:36px">+</button> <button 
type="button" id="com_rem" onclick="remCOM(),UI()" 
style="display:none;border-radius:20px;width:36px;height:36px">-</button><br>
</div><hr style="width:260px"><div id="btns"></div>Touch threshold: <input 
type="number" class="s" min="0" max="100" name="TT" required><br><div 
id="irOnOff2"><em style="color:#ff8c00">
This firmware build does not include IR Remote support.<br></em></div>IR GPIO: 
<input type="number" min="-1" max="40" name="IR" onchange="UI()" class="xs">
<select name="IT" onchange="UI()"><option value="0">Remote disabled</option>
<option value="1">24-key RGB</option><option value="2">24-key with CT</option>
<option value="3">40-key blue</option><option value="4">44-key RGB</option>
<option value="5">21-key RGB</option><option value="6">6-key black</option>
<option value="7">9-key red</option><option value="8">JSON remote</option>
</select><span style="cursor:pointer" onclick='off("IR")'>&nbsp;&#215;</span>
<br>Apply IR change to main segment only: <input type="checkbox" name="MSO"><br>
<div id="json" style="display:none">JSON file: <input type="file" name="data" 
accept=".json"> <input type="button" value="Upload" 
onclick='uploadFile("/ir.json")'><br></div><a 
href="https://kno.wled.ge/interfaces/infrared/" target="_blank">IR info</a><br>
Relay GPIO: <input type="number" min="-1" max="33" name="RL" onchange="UI()" 
class="xs"> Invert <input type="checkbox" name="RM"><span 
style="cursor:pointer" onclick='off("RL")'>&nbsp;&#215;</span><br><hr 
style="width:260px"><h3>Defaults</h3>Turn LEDs on after power up/reset: <input 
type="checkbox" name="BO"><br>Default brightness: <input name="CA" 
type="number" class="s" min="0" max="255" required> (0-255)<br><br>Apply preset 
<input name="BP" type="number" class="s" min="0" max="250" required>
 at boot (0 uses defaults)<br><br>Use Gamma correction for color: <input 
type="checkbox" name="GC"> (strongly recommended)<br>
Use Gamma correction for brightness: <input type="checkbox" name="GB">
 (not recommended)<br><br>Brightness factor: <input name="BF" type="number" 
class="s" min="1" max="255" required> %%<h3>Transitions</h3>Crossfade: <input 
type="checkbox" name="TF"><br>Transition Time: <input name="TD" type="number" 
class="l" min="0" max="65500"> ms<br>Enable Palette transitions: <input 
type="checkbox" name="PF"><h3>Timed light</h3>Default Duration: <input 
name="TL" type="number" class="s" min="1" max="255" required> min<br>
Default Target brightness: <input name="TB" type="number" class="s" min="0" 
max="255" required><br>Mode: <select name="TW"><option value="0">Wait and set
</option><option value="1">Fade</option><option value="2">Fade Color</option>
<option value="3">Sunrise</option></select><h3>White management</h3>
White Balance correction: <input type="checkbox" name="CCT"><br><span 
class="wc">Auto-calculate white channel from RGB:<br><select name="AW"><option 
value="0">None</option><option value="1">Brighter</option><option value="2">
Accurate</option><option value="3">Dual</option></select><br>
Calculate CCT from RGB: <input type="checkbox" name="CR"><br>
CCT additive blending: <input type="number" class="s" min="0" max="100" 
name="CB" required> %%</span><h3>Advanced</h3>Palette blending: <select 
name="PB"><option value="0">Linear (wrap if moving)</option><option value="1">
Linear (always wrap)</option><option value="2">Linear (never wrap)</option>
<option value="3">None (not recommended)</option></select><br>
Target refresh rate: <input type="number" class="s" min="1" max="250" name="FR" 
oninput="UI()" required> FPS<div id="fpswarning" 
style="color:orange;display:none">&#9888; WLED may become unstable above 80 fps.
<br>
To protect your setup, please make sure to backup WLED configuration and presets before raising target FPS above 80!
<br></div><div id="fpshelp1" style="color:orange;display:none">
For a very smooth experience, use less than 300 LEDs per output!<br></div><div 
id="fpshelp2" style="color:orange;display:none">
For an extremely smooth experience, use less than 180 LEDs per output!<br></div>
<div id="fpshelp3" style="color:orange;display:none">
For a mega ultra smooth experience, use less than 132 LEDs per output!<br></div>
<hr style="width:260px"><div id="cfg">Config template: <input type="file" 
name="data2" accept=".json"> <input type="button" value="Apply" 
onclick="loadCfg(d.Sf.data2)"><br></div><hr><button type="button" onclick="B()">
Back</button><button type="submit">Save</button></form><div id="toast"></div>
</body></html>)=====";


// Autogenerated from wled00/data/settings_sound.htm, do not edit!!
const char PAGE_settings_sound[] PROGMEM = R"=====(<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta 
name="viewport" content="width=500"><title>Sound Settings</title><script>
var d=document;function H(){window.open("https://github.com/atuline/WLED/wiki/Sound-Settings")}function B(){window.open("/settings","_self")}function S(){GetV(),enDM()}function enDM(){var e=parseInt(d.getElementById("dme").value);d.getElementById("dm").style.display=e>=1?"inline":"none",d.getElementById("dm_mclk").style.display=2==e||4==e?"inline":"none",d.getElementById("dm_sck").style.display=5!=e&&e>=1?"inline":"none",d.getElementById("dm_pdmdat").style.display=5==e?"inline":"none",d.getElementById("dm_pdmclk").style.display=5==e?"inline":"none",d.getElementById("dm_xdat").style.display=5!=e&&e>=1?"inline":"none",d.getElementById("dm_xws").style.display=5!=e&&e>=1?"inline":"none",d.getElementById("am").style.display=0==e?"inline":"none"}function GetV() {var d=document;
%CSS%%SCSS%</head><body onload="S()"><form
 id="form_s" name="Sf" method="post"><div class="helpB"><button type="button" 
onclick="H()">?</button></div><button type="button" onclick="B()">Back</button>
<button type="submit">Save</button><hr><h2>Sound Input Settings</h2><p>Squelch: 
<input name="SQ" type="number" min="0" max="255" required><br>Gain: <input 
name="GN" type="number" min="0" max="255" required></p><p class="tiny"><a 
href="https://github.com/atuline/WLED/wiki/Sound-Settings#how-to" 
target="_blank">How to tune Squelch and Gain</a><br><i>
Gain=40 means an amplification of 1; 1 is about 1/12, 255 is about 6.5</i>. <i>
To tune, set input level slider to middle/128, start with Squelch=5..10 and Gain=40 and modify according to your setup.
</i><br></p><p>Automatic Gain Control (AGC): <select name="AGC"><option 
value="0">Off</option><option value="1">Normal</option><option value="2">Vivid
</option><option value="3">Lazy</option></select><br></p><div class="tiny"><i>
If AGC is enabled, the input slider () will automatically be adjusted</i>
</div><p></p><h2>Sound Input Pin Manager</h2>Microphone type: <select id="dme" 
name="DMM" onchange="enDM()"><option value="0" selected="selected">
Generic Analog</option><option value="1">Generic I2S</option><option value="2">
ES7243</option><option value="3">SPH0654</option><option value="4">
Generic I2S with Mclk</option><option value="5">Generic I2S PDM</option>
</select><br><div id="dm">I2S SD pin: <input type="number" min="-1" max="40" 
name="DI"> &nbsp; <span id="dm_xdat" class="tiny">SD / DATA / DOUT</span><span 
id="dm_pdmdat" class="tiny">DATA</span><br>I2S WS pin: <input type="number" 
min="-1" max="40" name="LR"> &nbsp; <span id="dm_xws" class="tiny">
WS / CLK / LRCK &nbsp;</span><span id="dm_pdmclk" class="tiny">CLK &nbsp;</span>
<br><div id="dm_sck">I2S SCK pin: <input type="number" min="-1" max="40" 
name="CK"> &nbsp; <span class="tiny">
SCK / BCLK &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br></div><div 
id="dm_mclk">I2S MCLK pin: <input type="number" min="-1" max="3" name="MCLK">
 &nbsp; <span class="tiny">MCK / MCLK &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br>
</div></div><i class="tiny">
Changing the microphone type or pins requires a hard reset/power cycle</i><br>
<div id="am">Analog Input pin: <input type="number" min="-1" max="40" name="SI">
<br></div><p><a 
href="https://github.com/atuline/WLED/wiki/Digital-Microphone-Hookup" 
target="_blank">about I2S Digital Input</a> &nbsp; <a 
href="https://github.com/atuline/WLED/wiki/Analog-Audio-Input-Options" 
target="_blank">about Analog Input</a><br></p><button type="button" 
onclick="B()">Back</button><button type="submit">Save</button></form></body>
</html>)=====";


#ifdef WLED_ENABLE_DMX

// Autogenerated from wled00/data/settings_dmx.htm, do not edit!!
const char PAGE_settings_dmx[] PROGMEM = R"=====(<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=500">
<meta charset="utf-8"><title>DMX Settings</title><script>
function GCH(n){for(d=document,d.getElementById("dmxchannels").innerHTML+="",i=0;i<n;i++)d.getElementById("dmxchannels").innerHTML+="<span id=CH"+(i+1)+"s >Channel "+(i+1)+": <select name=CH"+(i+1)+' id="CH'+(i+1)+'"><option value=0>Set to 0</option><option value=1>Red</option><option value=2>Green</option><option value=3>Blue</option><option value=4>White</option><option value=5>Shutter (Brightness)</option><option value=6>Set to 255</option></select></span><br />\n'}function mMap(){for(d=document,numCh=document.Sf.CN.value,numGap=document.Sf.CG.value,parseInt(numCh)>parseInt(numGap)?d.getElementById("gapwarning").style.display="block":d.getElementById("gapwarning").style.display="none",i=0;i<15;i++)i>=numCh?(d.getElementById("CH"+(i+1)+"s").style.opacity="0.5",d.getElementById("CH"+(i+1)).disabled=!0):(d.getElementById("CH"+(i+1)+"s").style.opacity="1",d.getElementById("CH"+(i+1)).disabled=!1)}function S(){GCH(15),GetV(),mMap()}function H(){window.open("https://github.com/atuline/WLED/wiki/DMX")}function B(){window.history.back()}function GetV() {var d=document;
%CSS%%SCSS%</head><body onload="S()"><form
 id="form_s" name="Sf" method="post"><div class="helpB"><button type="button" 
onclick="H()">?</button></div><button type="button" onclick="B()">Back</button>
<button type="submit">Save</button><hr><h2>
Imma firin ma lazer (if it has DMX support)</h2>Proxy Universe <input name="PU" 
type="number" min="0" max="63999" required> from E1.31 to DMX (0=disabled)<br>
<i>This will disable the LED data output to DMX configurable below</i><br><br>
<i>Number of fixtures is taken from LED config page</i><br>
Channels per fixture (15 max): <input type="number" min="1" max="15" name="CN" 
maxlength="2" onchange="mMap()"><br>Start channel: <input type="number" min="1" 
max="512" name="CS" maxlength="2"><br>Spacing between start channels: <input 
type="number" min="1" max="512" name="CG" maxlength="2" onchange="mMap()"> [ <a 
href="javascript:alert('if set to 10, first fixture will start at 10,\nsecond will start at 20 etc.\nRegardless of the channel count.\nMakes memorizing channel numbers easier.');">
info</a> ]<br><div id="gapwarning" style="color:orange;display:none">
WARNING: Channel gap is lower than channels per fixture.<br>
This will cause overlap.</div><button type="button" 
onclick='location.href="/dmxmap"'>DMX Map</button><br>DMX fixtures start LED: 
<input type="number" min="0" max="1500" name="SL"><h3>Channel functions</h3><div
 id="dmxchannels"></div><hr><button type="button" onclick="B()">Back</button>
<button type="submit">Save</button></form></body></html>)=====";


#else
const char PAGE_settings_dmx[] PROGMEM = R"=====()=====";
#endif

// Autogenerated from wled00/data/settings_ui.htm, do not edit!!
const char PAGE_settings_ui[] PROGMEM = R"=====(<!DOCTYPE html><html><head lang="en"><meta charset="utf-8"><meta 
name="viewport" content="width=500"><title>UI Settings</title><script>
var initial_ds,initial_st,timeout,d=document,sett=null,l={comp:{labels:"Show button labels",colors:{LABEL:"Color selection methods",picker:"Color Wheel",rgb:"RGB sliders",quick:"Quick color selectors",hex:"HEX color input"},pcmbot:"Show bottom tab bar in PC mode",pid:"Show preset IDs",seglen:"Set segment length instead of stop LED",css:"Enable custom CSS",hdays:"Enable custom Holidays list"},theme:{alpha:{bg:"Background opacity",tab:"Button opacity"},bg:{url:"BG image URL",random:"Random BG image"},color:{bg:"BG HEX color"}}};function gId(e){return d.getElementById(e)}function isObject(e){return e&&"object"==typeof e&&!Array.isArray(e)}function set(e,t,i){for(var n=t,s=e.split("_"),o=s.length,a=0;a<o-1;a++){var l=s[a];n[l]||(n[l]={}),n=n[l]}n[s[o-1]]=i}function showToast(e,t=!1){var i=gId("toast");i.innerHTML=e,i.className=t?"error":"show",clearTimeout(timeout),i.style.animation="none",timeout=setTimeout((function(){i.className=i.className.replace("show","")}),2900)}function addRec(e,t="",n=null){var s="";for(i in e){var o=t+(t?"_":"")+i;if(isObject(e[i]))n&&n[i]&&n[i].LABEL&&(s+=`<h3>${n[i].LABEL}</h3>`),s+=addRec(e[i],o,n?n[i]:null);else{var a=o;if(n&&n[i]?a=n[i]:e[i+"LABEL"]&&(a=e[i+"LABEL"]),i.indexOf("LABEL")>0)continue;var l=typeof e[i];gId(o)?("boolean"===l?gId(o).checked=e[i]:gId(o).value=e[i],gId(o).previousElementSibling.matches(".l")&&(gId(o).previousElementSibling.innerHTML=a)):"boolean"===l?s+=`${a}: <input class="agi cb" type="checkbox" id=${o} ${e[i]?"checked":""}><br>`:"number"===l?s+=`${a}: <input class="agi" type="number" id=${o} value=${e[i]}><br>`:"string"===l&&(s+=`${a}:<br><input class="agi" id=${o} value=${e[i]}><br>`)}}return s}function genForm(e){var t;t=addRec(e,"",l),gId("gen").innerHTML=t}function GetLS(){(sett=localStorage.getItem("wledUiCfg"))||(gId("lserr").style.display="inline");try{sett=JSON.parse(sett)}catch(e){sett={},gId("lserr").style.display="inline",gId("lserr").innerHTML="&#9888; Settings JSON parsing failed. ("+e+")"}genForm(sett),gId("dm").checked="light"===gId("theme_base").value}function SetLS(){for(var e=d.querySelectorAll(".agi"),t=0;t<e.length;t++){var i=e[t],n=i.classList.contains("cb")?i.checked:i.value;set(i.id,sett,n),console.log(`${i.id} set to ${n}`)}try{localStorage.setItem("wledUiCfg",JSON.stringify(sett)),gId("lssuc").style.display="inline"}catch(i){gId("lssuc").style.display="none",gId("lserr").style.display="inline",gId("lserr").innerHTML="&#9888; Settings JSON saving failed. ("+i+")"}}function Save(){SetLS(),d.Sf.DS.value==initial_ds&&d.Sf.ST.checked==initial_st||d.Sf.submit()}function S(){GetV(),initial_ds=d.Sf.DS.value,initial_st=d.Sf.ST.checked,GetLS()}function H(){window.open("https://github.com/atuline/WLED/wiki/Settings#user-interface-settings")}function B(){window.open("/settings","_self")}function UI(){gId("idonthateyou").style.display=gId("dm").checked?"inline":"none";var e=gId("theme_base");e&&(e.value=gId("dm").checked?"light":"dark")}function setRandomBg(){gId("theme_bg_random").checked?gId("theme_bg_url").value="https://picsum.photos/1920/1080":gId("theme_bg_url").value=""}function checkRandomBg(){"https://picsum.photos/1920/1080"===gId("theme_bg_url").value?gId("theme_bg_random").checked=!0:gId("theme_bg_random").checked=!1}function uploadFile(e,t){var i=new XMLHttpRequest;i.addEventListener("load",(function(){showToast(this.responseText,this.status>=400)})),i.addEventListener("error",(function(e){showToast(e.stack,!0)})),i.open("POST","/upload");var n=new FormData;return n.append("data",e.files[0],t),i.send(n),e.value="",!1}function GetV() {var d=document;
%CSS%%SCSS%</head><body onload="S()"><form
 id="form_s" name="Sf" method="post"><div 
style="position:sticky;top:0;background-color:#222;z-index:1"><div 
class="helpB"><button type="button" onclick="H()">?</button></div><button 
type="button" onclick="B()">Back</button><button type="button" onclick="Save()">
Save</button><br><span id="lssuc" style="color:green;display:none">
&#10004; Local UI settings saved!</span> <span id="lserr" 
style="color:red;display:none">
&#9888; Could not access local storage. Make sure it is enabled in your browser.
</span><hr></div><h2>Web Setup</h2>Server description: <input name="DS" 
maxlength="32"><br>Sync button toggles both send and receive: <input 
type="checkbox" name="ST"><br><i>
The following UI customization settings are unique both to the WLED device and this browser.
<br>
You will need to set them again if using a different browser, device or WLED IP address.
<br>Refresh the main UI to apply changes.</i><br><div id="gen">
Loading settings...</div><h3>UI Appearance</h3><span class="l"></span>: <input 
type="checkbox" id="comp_labels" class="agi cb"><br><span class="l"></span>: 
<input type="checkbox" id="comp_pcmbot" class="agi cb"><br><span class="l">
</span>: <input type="checkbox" id="comp_pid" class="agi cb"><br><span 
class="l"></span>: <input type="checkbox" id="comp_seglen" class="agi cb"><br>
I hate dark mode: <input type="checkbox" id="dm" onchange="UI()"><br><span 
id="idonthateyou" style="display:none"><i>Why would you? </i>&#x1F97A;<br>
</span><span class="l"></span>: <input type="number" min="0.0" max="1.0" 
step="0.01" id="theme_alpha_tab" class="agi"><br><span class="l"></span>: <input
 type="number" min="0.0" max="1.0" step="0.01" id="theme_alpha_bg" class="agi">
<br><span class="l"></span>: <input id="theme_color_bg" maxlength="9" 
class="agi"><br><span class="l">BG image URL</span>: <input id="theme_bg_url" 
class="agi" oninput="checkRandomBg()"><br><span class="l">Random BG image</span>
: <input type="checkbox" id="theme_bg_random" class="agi cb" 
onchange="setRandomBg()"><br><input id="theme_base" class="agi" 
style="display:none"> <span class="l"></span>: <input type="checkbox" 
id="comp_css" class="agi cb"><br><div id="skin">Custom CSS: <input type="file" 
name="data" accept=".css"> <input type="button" value="Upload" 
onclick='uploadFile(d.Sf.data,"/skin.css")'><br></div><span class="l"></span>: 
<input type="checkbox" id="comp_hdays" class="agi cb"><br><div id="holidays">
Holidays: <input type="file" name="data2" accept=".json"> <input type="button" 
value="Upload" onclick='uploadFile(d.Sf.data2,"/holidays.json")'><br></div><div 
id="toast"></div><hr><button type="button" onclick="B()">Back</button><button 
type="button" onclick="Save()">Save</button></form></body></html>)=====";


// Autogenerated from wled00/data/settings_sync.htm, do not edit!!
const char PAGE_settings_sync[] PROGMEM = R"=====(<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=500">
<meta charset="utf-8"><title>Sync Settings</title><script>
var d=document;function gId(e){return d.getElementById(e)}function doHide(e){gId(e).style.display="none"}function doShow(e){gId(e).style.display="block"}function hideNoDMX(){gId("dmxOnOff2").style.display="none"}function hideALEXA(){gId("aleOnOff").style.display="none"}function hideNoALEXA(){gId("aleOnOff2").style.display="none"}function hideBLYNK(){gId("blyOnOff").style.display="none"}function hideNoBLYNK(){gId("blyOnOff2").style.display="none"}function hideMQTT(){gId("mqtOnOff").style.display="none"}function hideNoMQTT(){gId("mqtOnOff2").style.display="none"}function hideHUE(){gId("hueOnOff").style.display="none"}function hideNoHUE(){gId("hueOnOff2").style.display="none"}function hideNoADA(){gId("adaOnOff2").style.display="none"}function hideNoLOX(){gId("loxOnOff2").style.display="none"}function H(){window.open("https://kno.wled.ge/interfaces/udp-notifier/")}function B(){window.open("/settings","_self")}function adj(){6454==d.Sf.DI.value?(1==d.Sf.DA.value&&(d.Sf.DA.value=0),1==d.Sf.EU.value&&(d.Sf.EU.value=0)):5568==d.Sf.DI.value&&(0==d.Sf.DA.value&&(d.Sf.DA.value=1),0==d.Sf.EU.value&&(d.Sf.EU.value=1))}function FC(){for(j=0;j<8;j++)gId("G"+(j+1)).checked=gId("GS").value>>j&1,gId("R"+(j+1)).checked=gId("GR").value>>j&1}function GC(){var e=0,n=0,d=1;for(j=0;j<8;j++)e+=gId("G"+(j+1)).checked*d,n+=gId("R"+(j+1)).checked*d,d*=2;gId("GS").value=e,gId("GR").value=n}function SP(){var e=d.Sf.DI.value;gId("xp").style.display=e>0?"none":"block",e>0&&(d.Sf.EP.value=e)}function SetVal(){switch(parseInt(d.Sf.EP.value)){case 5568:d.Sf.DI.value=5568;break;case 6454:d.Sf.DI.value=6454;break;case 4048:d.Sf.DI.value=4048}SP(),FC()}function S(){GetV(),SetVal()}function GetV() {
%CSS%%SCSS%</head><body onload="S()"><form
 id="form_s" name="Sf" method="post" onsubmit="GC()"><div class="helpB"><button 
type="button" onclick="H()">?</button></div><button type="button" onclick="B()">
Back</button><button type="submit">Save</button><hr><h2>Sync setup</h2><h3>
WLED Broadcast</h3>UDP Port: <input name="UP" type="number" min="1" max="65535" 
class="d5" required><br>2nd Port: <input name="U2" type="number" min="1" 
max="65535" class="d5" required><br><br><input name="GS" id="GS" type="number" 
style="display:none"> <input name="GR" id="GR" type="number" 
style="display:none"><table style="margin:0 auto"><tr><td>Sync groups</td><td>1
</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr>
<tr><td>Send:</td><td><input type="checkbox" id="G1" name="G1"></td><td><input 
type="checkbox" id="G2" name="G2"></td><td><input type="checkbox" id="G3" 
name="G3"></td><td><input type="checkbox" id="G4" name="G4"></td><td><input 
type="checkbox" id="G5" name="G5"></td><td><input type="checkbox" id="G6" 
name="G6"></td><td><input type="checkbox" id="G7" name="G7"></td><td><input 
type="checkbox" id="G8" name="G8"></td></tr><tr><td>Receive:</td><td><input 
type="checkbox" id="R1" name="R1"></td><td><input type="checkbox" id="R2" 
name="R2"></td><td><input type="checkbox" id="R3" name="R3"></td><td><input 
type="checkbox" id="R4" name="R4"></td><td><input type="checkbox" id="R5" 
name="R5"></td><td><input type="checkbox" id="R6" name="R6"></td><td><input 
type="checkbox" id="R7" name="R7"></td><td><input type="checkbox" id="R8" 
name="R8"></td></tr></table><br>Receive: <input type="checkbox" name="RB">
 Brightness, <input type="checkbox" name="RC"> Color, and <input 
type="checkbox" name="RX"> Effects<br><input type="checkbox" name="SO">
 Segment options, <input type="checkbox" name="SG"> bounds<br>
Send notifications on direct change: <input type="checkbox" name="SD"><br>
Send notifications on button press or IR: <input type="checkbox" name="SB"><br>
Send Alexa notifications: <input type="checkbox" name="SA"><br>
Send Philips Hue change notifications: <input type="checkbox" name="SH"><br>
Send Macro notifications: <input type="checkbox" name="SM"><br>
Send notifications twice: <input type="checkbox" name="S2"><br><i>
Reboot required to apply changes.</i><h3>Instance List</h3>
Enable instance list: <input type="checkbox" name="NL"><br>
Make this instance discoverable: <input type="checkbox" name="NB"><h3>Realtime
</h3>Receive UDP realtime: <input type="checkbox" name="RD"><br>
Use main segment only: <input type="checkbox" name="MO"><br><br><i>
Network DMX input</i><br>Type: <select name="DI" onchange="SP(),adj()"><option 
value="5568">E1.31 (sACN)</option><option value="6454">Art-Net</option><option 
value="0" selected="selected">Custom port</option></select><br><div id="xp">
Port: <input name="EP" type="number" min="1" max="65535" value="5568" 
class="d5" required><br></div>Multicast: <input type="checkbox" name="EM"><br>
Start universe: <input name="EU" type="number" min="0" max="63999" required><br>
<i>Reboot required.</i> Check out <a href="https://github.com/LedFx/LedFx" 
target="_blank">LedFx</a>!<br>Skip out-of-sequence packets: <input 
type="checkbox" name="ES"><br>DMX start address: <input name="DA" type="number" 
min="0" max="510" required><br>DMX mode: <select name="DM"><option value="0">
Disabled</option><option value="1">Single RGB</option><option value="2">
Single DRGB</option><option value="3">Effect</option><option value="4">Multi RGB
</option><option value="5">Dimmer + Multi RGB</option><option value="6">
Multi RGBW</option></select><br><a 
href="https://kno.wled.ge/interfaces/e1.31-dmx/" target="_blank">E1.31 info</a>
<br>Timeout: <input name="ET" type="number" min="1" max="65000" required> ms<br>
Force max brightness: <input type="checkbox" name="FB"><br>
Disable realtime gamma correction: <input type="checkbox" name="RG"><br>
Realtime LED offset: <input name="WO" type="number" min="-255" max="255" 
required><div id="dmxOnOff2"><br><em style="color:#ff8c00">
This firmware build does not include DMX output support.<br></em></div><h3>
Alexa Voice Assistant</h3><div id="aleOnOff2"><em style="color:#ff8c00">
This firmware build does not include Alexa support.<br></em></div><div 
id="aleOnOff">Emulate Alexa device: <input type="checkbox" name="AL"><br>
Alexa invocation name: <input type="text" name="AI" maxlength="32"></div><br>
<div id="blyOnOff2"><em style="color:#ff8c00">
This firmware build does not include Blynk support.<br></em></div><b>
Network protocols like MQTT and Hue sync all connect to external hosts!<br>
This may impact the responsiveness of the ESP microcontroller.</b><br>
For best results, only use one of these services at a time.<br>
(alternatively, connect a second ESP to them and use the UDP sync)<br><br><div 
id="blyOnOff"><h3>Blynk</h3>Host: <input type="text" name="BH" maxlength="32">
 Port: <input name="BP" type="number" min="1" max="65535" value="80" class="d5">
<br>Device Auth token: <input name="BK" maxlength="33"><br><i>
Clear the token field to disable. </i><a 
href="https://kno.wled.ge/interfaces/blynk/" target="_blank">Setup info</a>
</div><h3>MQTT</h3><div id="mqtOnOff2"><em style="color:#ff8c00">
This firmware build does not include MQTT support.<br></em></div><div 
id="mqtOnOff">Enable MQTT: <input type="checkbox" name="MQ"><br>Broker: <input 
type="text" name="MS" maxlength="32"> Port: <input name="MQPORT" type="number" 
min="1" max="65535" class="d5"><br><b>
The MQTT credentials are sent over an unsecured connection.<br>
Never use the MQTT password for another service!</b><br>Username: <input 
type="text" name="MQUSER" maxlength="40"><br>Password: <input type="password" 
name="MQPASS" maxlength="64"><br>Client ID: <input type="text" name="MQCID" 
maxlength="40"><br>Device Topic: <input type="text" name="MD" maxlength="32">
<br>Group Topic: <input type="text" name="MG" maxlength="32"><br>
Publish on button press: <input type="checkbox" name="BM"><br><i>
Reboot required to apply changes. </i><a 
href="https://kno.wled.ge/interfaces/mqtt/" target="_blank">MQTT info</a></div>
<h3>Philips Hue</h3><div id="hueOnOff2"><em style="color:#ff8c00">
This firmware build does not include Philips Hue support.<br></em></div><div 
id="hueOnOff"><i>
You can find the bridge IP and the light number in the 'About' section of the hue app.
</i><br>Poll Hue light <input name="HL" type="number" min="1" max="99"> every 
<input name="HI" type="number" min="100" max="65000"> ms: <input 
type="checkbox" name="HP"><br>Then, receive <input type="checkbox" name="HO">
 On/Off, <input type="checkbox" name="HB"> Brightness, and <input 
type="checkbox" name="HC"> Color<br>Hue Bridge IP:<br><input name="H0" 
type="number" class="s" min="0" max="255"> . <input name="H1" type="number" 
class="s" min="0" max="255"> . <input name="H2" type="number" class="s" min="0" 
max="255"> . <input name="H3" type="number" class="s" min="0" max="255"><br><b>
Press the pushlink button on the bridge, after that save this page!</b><br>
(when first connecting)<br></div>Hue status: <span class="sip">
Disabled in this build</span><div id="loxOnOff2"><br><em style="color:#ff8c00">
This firmware build does not include Loxone Lighting support.<br></em></div><div
 id="adaOnOff2"><br><em style="color:#ff8c00">
This firmware build does not include AdaLight support.<br></em></div><h3>Serial
</h3>Baud rate: <select name="BD"><option value="1152">115200</option><option 
value="2304">230400</option><option value="4608">460800</option><option 
value="5000">500000</option><option value="5760">576000</option><option 
value="9216">921600</option><option value="10000">1000000</option><option 
value="15000">1500000</option></select><br><i>
Keep at 115200 to use Improv. Some boards may not support high rates.</i><h3>
Audio Sync</h3>Mode: <select name="ASE"><option value="0">Disabled</option>
<option value="1">Transmit</option><option value="2">Receive</option></select>
 Port: <input name="ASP" type="number" min="1" max="65535" class="d5"><br><i>
Reboot required for changes to take effect.</i><hr><button type="button" 
onclick="B()">Back</button><button type="submit">Save</button></form></body>
</html>)=====";


// Autogenerated from wled00/data/settings_time.htm, do not edit!!
const char PAGE_settings_time[] PROGMEM = R"=====(<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=500">
<meta charset="utf-8"><title>Time Settings</title><script>
var d=document,el=!1,ms=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],cals='style="font-size:27px;margin-top:-6px;cursor:pointer"';function H(){window.open("https://kno.wled.ge/features/settings/#time-settings")}function B(){window.open("/settings","_self")}function S(){BTa(),GetV(),updLoc(),Cs(),FC()}function gId(t){return d.getElementById(t)}function gN(t){return d.getElementsByName(t)[0]}function expand(t,e){var n=gId("WD"+e);n.style.display="none"!==n.style.display?"none":"",t.innerHTML="none"===n.style.display?"&#128197;":"&#x2715;"}function Cs(){gId("cac").style.display=gN("OL").checked?"block":"none"}function BTa(){var t="<tr><th>En.</th><th>Hour</th><th>Minute</th><th>Preset</th><th></th></tr>";for(i=0;i<8;i++){for(t+=`<tr><td><input name="W${i}" id="W${i}" type="hidden"><input id="W${i}0" type="checkbox"></td>\n<td><input name="H${i}" class="xs" type="number" min="0" max="24"></td>\n<td><input name="N${i}" class="xs" type="number" min="0" max="59"></td>\n<td><input name="T${i}" class="s" type="number" min="0" max="250"></td>\n<td><div id="CB${i}" onclick="expand(this,${i})" ${cals}>&#128467;</div></td></tr>`,t+=`<tr><td colspan=5><div id="WD${i}" style="display:none;">Run on weekdays`,t+='<table style="width:100%%;"><tr><th>M</th><th>T</th><th>W</th><th>T</th><th>F</th><th>S</th><th>S</th></tr><tr>',j=1;j<8;j++)t+=`<td><input id="W${i}${j}" type="checkbox"></td>`;for(t+=`</tr></table>from\n<select name="M${i}">`,j=0;j<12;j++)t+=`<option value="${j+1}">${ms[j]}</option>`;for(t+=`</select><input name="D${i}" class="xs" type="number" min="1" max="31"></input> to\n<select name="P${i}">`,j=0;j<12;j++)t+=`<option value="${j+1}">${ms[j]}</option>`;t+=`</select><input name="E${i}" class="xs" type="number" min="1" max="31"></input>\n\t\t<hr></div></td></tr>`}for(t+=`<tr><td><input name="W8" id="W8" type="hidden"><input id="W80" type="checkbox"></td>\n<td>Sunrise<input name="H8" value="255" type="hidden"></td>\n<td><input name="N8" class="xs" type="number" min="-59" max="59"></td>\n<td><input name="T8" class="s" type="number" min="0" max="250"></td>\n<td><div id="CB8" onclick="expand(this,8)" ${cals}>&#128467;</div></td></tr><tr><td colspan=5>`,t+='<div id="WD8"style="display:none;"><table style="width:100%%;"><tr><th>M</th><th>T</th><th>W</th><th>T</th><th>F</th><th>S</th><th>S</th></tr><tr>',j=1;j<8;j++)t+=`<td><input id="W8${j}" type="checkbox"></td>`;for(t+="</tr></table><hr></div></td></tr>",t+=`<tr><td><input name="W9" id="W9" type="hidden"><input id="W90" type="checkbox"></td>\n<td>Sunset<input name="H9" value="255" type="hidden"></td>\n<td><input name="N9" class="xs" type="number" min="-59" max="59"></td>\n<td><input name="T9" class="s" type="number" min="0" max="250"></td>\n<td><div id="CB9" onclick="expand(this,9)" ${cals}>&#128467;</div></td></tr><tr><td colspan=5>`,t+='<div id="WD9" style="display:none;"><table style="width:100%%;"><tr><th>M</th><th>T</th><th>W</th><th>T</th><th>F</th><th>S</th><th>S</th></tr><tr>',j=1;j<8;j++)t+=`<td><input id="W9${j}" type="checkbox"></td>`;t+="</tr></table><hr></div></td></tr>",gId("TMT").innerHTML=t}function FC(){for(i=0;i<10;i++){let t=gId("W"+i).value;for(j=0;j<8;j++)gId("W"+i+j).checked=t>>j&1;(254!=(254&t)||i<8&&(1!=gN("M"+i).value||1!=gN("D"+i).value||12!=gN("P"+i).value||31!=gN("E"+i).value))&&expand(gId("CB"+i),i)}}function Wd(){for(a=[0,0,0,0,0,0,0,0,0,0],i=0;i<10;i++){for(m=1,j=0;j<8;j++)a[i]+=gId("W"+i+j).checked*m,m*=2;gId("W"+i).value=a[i]}"S"===d.Sf.LTR.value&&(d.Sf.LT.value=-1*parseFloat(d.Sf.LT.value)),"W"===d.Sf.LNR.value&&(d.Sf.LN.value=-1*parseFloat(d.Sf.LN.value))}function addRow(t,e,n,i){var d=gId("macros"),a=d.rows.length,l=d.insertRow(a),s=String.fromCharCode((t<10?48:55)+t);document.createElement("td");l.insertCell(0).innerHTML=`Button ${t}:`,l.insertCell(1).innerHTML=`<input name="MP${s}" type="number" class="s" min="0" max="250" value="${e}" required>`,l.insertCell(2).innerHTML=`<input name="ML${s}" type="number" class="s" min="0" max="250" value="${n}" required>`,l.insertCell(3).innerHTML=`<input name="MD${s}" type="number" class="s" min="0" max="250" value="${i}" required>`}function getLoc(){el||(window.addEventListener("message",t=>{"https://locate.wled.me"===t.origin&&t.data instanceof Object&&(d.Sf.LT.value=t.data.lat,d.Sf.LN.value=t.data.lon,updLoc())},!1),el=!0),window.open("https://locate.wled.me","_blank")}function updLoc(t){parseFloat(d.Sf.LT.value)<0?(d.Sf.LTR.value="S",d.Sf.LT.value=-1*parseFloat(d.Sf.LT.value)):d.Sf.LTR.value="N",parseFloat(d.Sf.LN.value)<0?(d.Sf.LNR.value="W",d.Sf.LN.value=-1*parseFloat(d.Sf.LN.value)):d.Sf.LNR.value="E"}function GetV() {
%CSS%%SCSS%</head><body onload="S()"><form
 id="form_s" name="Sf" method="post" onsubmit="Wd()"><div class="helpB"><button 
type="button" onclick="H()">?</button></div><button type="button" onclick="B()">
Back</button><button type="submit">Save</button><hr><h2>Time setup</h2>
Get time from NTP server: <input type="checkbox" name="NT"><br><input 
type="text" name="NS" maxlength="32"><br>Use 24h format: <input type="checkbox" 
name="CF"><br>Time zone: <select name="TZ"><option value="0" 
selected="selected">GMT(UTC)</option><option value="1">GMT/BST</option><option 
value="2">CET/CEST</option><option value="3">EET/EEST</option><option value="4">
US-EST/EDT</option><option value="5">US-CST/CDT</option><option value="6">
US-MST/MDT</option><option value="7">US-AZ</option><option value="8">US-PST/PDT
</option><option value="9">CST(AWST)</option><option value="10">JST(KST)
</option><option value="11">AEST/AEDT</option><option value="12">NZST/NZDT
</option><option value="13">North Korea</option><option value="14">IST (India)
</option><option value="15">CA-Saskatchewan</option><option value="16">ACST
</option><option value="17">ACST/ACDT</option><option value="18">HST (Hawaii)
</option><option value="19">NOVT (Novosibirsk)</option><option value="20">
AKST/AKDT (Anchorage)</option><option value="21">MX-CST</option><option 
value="22">PKT (Pakistan)</option></select><br>UTC offset: <input name="UO" 
type="number" min="-65500" max="65500" required> seconds (max. 18 hours)<br>
Current local time is <span class="times">unknown</span>.<br>Latitude: <select 
name="LTR"><option value="N">N</option><option value="S">S</option></select>
<input name="LT" type="number" class="xl" min="0" max="66.6" step="0.01"><br>
Longitude: <select name="LNR"><option value="E">E</option><option value="W">W
</option></select><input name="LN" type="number" class="xl" min="0" max="180" 
step="0.01"><br><button type="button" id="locbtn" onclick="getLoc()">
Get location</button><div><i>(opens new tab, only works in browser)</i></div>
<div id="sun" class="times"></div><h3>Clock</h3>Analog Clock overlay: <input 
type="checkbox" name="OL" onchange="Cs()"><br><div id="cac">First LED: <input 
name="O1" type="number" min="0" max="255" required> Last LED: <input name="O2" 
type="number" min="0" max="255" required><br>12h LED: <input name="OM" 
type="number" min="0" max="255" required><br>Show 5min marks: <input 
type="checkbox" name="O5"><br>Seconds (as trail): <input type="checkbox" 
name="OS"><br></div>Countdown Mode: <input type="checkbox" name="CE"><br>
Countdown Goal:<br>Date:&nbsp;<nowrap>20<input name="CY" class="xs" 
type="number" min="0" max="99" required>-<input name="CI" class="xs" 
type="number" min="1" max="12" required>-<input name="CD" class="xs" 
type="number" min="1" max="31" required></nowrap><br>Time:<nowrap><input 
name="CH" class="xs" type="number" min="0" max="23" required>:<input name="CM" 
class="xs" type="number" min="0" max="59" required>:<input name="CS" class="xs" 
type="number" min="0" max="59" required></nowrap><br><h3>Macro presets</h3><b>
Macros have moved!</b><br><i>
Presets now also can be used as macros to save both JSON and HTTP API commands.
<br>Just enter the preset ID below!</i> <i>
Use 0 for the default action instead of a preset</i><br>Alexa On/Off Preset: 
<input name="A0" class="m" type="number" min="0" max="250" required> <input 
name="A1" class="m" type="number" min="0" max="250" required><br>
Countdown-Over Preset: <input name="MC" class="m" type="number" min="0" 
max="250" required><br>Timed-Light-Over Presets: <input name="MN" class="m" 
type="number" min="0" max="250" required><br><h3>Button actions</h3><table 
style="margin:0 auto" id="macros"><thead><tr><td>push<br>switch</td><td>short
<br>on-&gt;off</td><td>long<br>off-&gt;on</td><td>double<br>N/A</td></tr>
</thead><tbody></tbody></table><a 
href="https://kno.wled.ge/features/macros/#analog-button" target="_blank">
Analog Button setup</a><h3>Time-controlled presets</h3><div 
style="display:inline-block"><table id="TMT" style="min-width:330px"></table>
</div><hr><button type="button" onclick="B()">Back</button><button 
type="submit">Save</button></form></body></html>)=====";


// Autogenerated from wled00/data/settings_sec.htm, do not edit!!
const char PAGE_settings_sec[] PROGMEM = R"=====(<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=500">
<meta charset="utf-8"><title>Misc Settings</title><script>
var timeout,d=document;function H(){window.open("https://github.com/atuline/WLED/wiki/Settings#security-settings")}function B(){window.open("/settings","_self")}function U(){window.open("/update","_self")}function gId(t){return d.getElementById(t)}function isObject(t){return t&&"object"==typeof t&&!Array.isArray(t)}function showToast(t,e=!1){var n=gId("toast");n.innerHTML=t,n.className=e?"error":"show",clearTimeout(timeout),n.style.animation="none",timeout=setTimeout((function(){n.className=n.className.replace("show","")}),2900)}function uploadFile(t,e){var n=new XMLHttpRequest;n.addEventListener("load",(function(){showToast(this.responseText,this.status>=400)})),n.addEventListener("error",(function(t){showToast(t.stack,!0)})),n.open("POST","/upload");var o=new FormData;return o.append("data",t.files[0],e),n.send(o),t.value="",!1}function GetV() {var d=document;
%CSS%%SCSS%</head><body onload="GetV()">
<form id="form_s" name="Sf" method="post"><div class="helpB"><button 
type="button" onclick="H()">?</button></div><button type="button" onclick="B()">
Back</button><button type="submit">Save & Reboot</button><hr><h2>
Security & Update setup</h2>Lock wireless (OTA) software update: <input 
type="checkbox" name="NO"><br>Passphrase: <input type="password" name="OP" 
maxlength="32"><br>
To enable OTA, for security reasons you need to also enter the correct password!
<br>The password should be changed when OTA is enabled.<br><b>
Disable OTA when not in use, otherwise an attacker can reflash device software!
</b><br><i>Settings on this page are only changable if OTA lock is disabled!</i>
<br>Deny access to WiFi settings if locked: <input type="checkbox" name="OW">
<br><br>Factory reset: <input type="checkbox" name="RS"><br>
All settings and presets will be erased.<br><br>
HTTP traffic is unencrypted. An attacker in the same network can intercept form data!
<h3>Software Update</h3><button type="button" onclick="U()">Manual OTA Update
</button><br>Enable ArduinoOTA: <input type="checkbox" name="AO"><br><h3>
Backup & Restore</h3><a class="btn lnk" href="/presets.json?download" 
target="download-frame">Backup presets</a><br><div>Restore presets<br><input 
type="file" name="data" accept=".json"> <input type="button" value="Upload" 
onclick='uploadFile(d.Sf.data,"/presets.json")'><br></div><br><a 
class="btn lnk" href="/cfg.json?download" target="download-frame">
Backup configuration</a><br><div>Restore configuration<br><input type="file" 
name="data2" accept=".json"> <input type="button" value="Upload" 
onclick='uploadFile(d.Sf.data2,"/cfg.json")'><br></div><div style="color:#fa0">
&#9888; Restoring presets/configuration will OVERWRITE your current presets/configuration.
<br>
Incorrect configuration may require a factory reset or re-flashing of your ESP.
</div>For security reasons, passwords are not backed up.<h3>About</h3><a 
href="https://github.com/atuline/WLED/" target="_blank">WLED</a>
 SR version 0.13.4<br><br><a 
href="https://github.com/atuline/WLED/wiki/Contributors-and-credits" 
target="_blank">Contributors, dependencies and special thanks</a><br>
A huge thank you to everyone who helped me create WLED!<br><br>
(c) 2016-2022 Christian Schwinne<br><i>Licensed under the <a 
href="https://github.com/atuline/WLED/blob/master/LICENSE" target="_blank">
MIT license</a></i><br><br>Server message: <span class="sip">Response error!
</span><hr><div id="toast"></div><button type="button" onclick="B()">Back
</button><button type="submit">Save & Reboot</button></form><iframe 
name="download-frame" style="display:none"></iframe></body></html>)=====";


// Autogenerated from wled00/data/settings_um.htm, do not edit!!
const char PAGE_settings_um[] PROGMEM = R"=====(<!DOCTYPE html><html><head lang="en"><meta charset="utf-8"><meta 
name="viewport" content="width=500"><title>Usermod Settings</title><script>
var owner,locip,urows,d=document,umCfg={},pins=[6,7,8,9,10,11],pinO=["rsvd","rsvd","rsvd","rsvd","rsvd","rsvd"],loc=!1,numM=0;function gId(e){return d.getElementById(e)}function isO(e){return e&&"object"==typeof e&&!Array.isArray(e)}function H(){window.open("https://github.com/atuline/WLED/wiki/Settings#usermod-settings")}function B(){window.open("/settings","_self")}function S(){"file:"==window.location.protocol&&(loc=!0,(locip=localStorage.getItem("locIp"))||(locip=prompt("File Mode. Please enter WLED IP!"),localStorage.setItem("locIp",locip))),GetV(),numM>0||locip?ldS():gId("um").innerHTML="No Usermods installed."}function isF(e){return e===+e&&e!==(0|e)}function isI(e){return e===+e&&e===(0|e)}function check(e,n){var i=e.name.replace("[]","").substr(-3);if("number"==e.type&&"pin"==i.substr(0,3))for(var t=0;t<pins.length;t++)if(n!=pinO[t]){if(e.value==pins[t]||e.value<-1||e.value>39){e.style.color="red";break}e.style.color=e.value>33?"orange":"#fff"}}function getPins(e){if(isO(e))for(const[i,t]of Object.entries(e))if(isO(t))owner=i,getPins(t);else if("pin"==i.replace("[]","").substr(-3))if(Array.isArray(t))for(var n=0;n<t.length;n++)t[n]>=0&&(pins.push(t[n]),pinO.push(owner));else t>=0&&(pins.push(t),pinO.push(owner));else if(Array.isArray(t))for(n=0;n<t.length;n++)getPins(t[n])}function addField(e,n,i,t=!1){if(isO(i))for(const[t,s]of Object.entries(i))"unknown"===n||e.includes(":")?addField(e,t,s):addField(e+":"+n,t,s);else if(Array.isArray(i))for(var s=0;s<i.length;s++)addField(e,n,i[s],!0);else{var o,r=typeof i;switch(r){case"boolean":r="checkbox",o='value="true"'+(i?" checked":"");break;case"number":o=`value="${i}"`,"pin"===n.substr(-3)?(o+=' max="39" min="-1" style="width:40px;"',r="int"):o+=' step="any" style="width:100px;"';break;default:r="text",o=`value="${i}" style="width:250px;"`}e.includes(":")&&(urows+=e.substr(e.indexOf(":")+1)),urows+=` ${n}: `,"checkbox"==r?urows+=`<input type="hidden" name="${e}:${n}${t?"[]":""}" value="false">`:t||(urows+=`<input type="hidden" name="${e}:${n}${t?"[]":""}" value="${r}">`),urows+=`<input type="${"int"===r?"number":r}" name="${e}:${n}${t?"[]":""}" ${o} oninput="check(this,'${e.substr(e.indexOf(":")+1)}')"><br>`}}function ldS(){fetch((loc?"http://"+locip:"")+"/cfg.json",{method:"get"}).then(e=>(e.ok||(gId("lserr").style.display="inline"),e.json())).then(e=>{if(umCfg=e.um,getPins(e),urows="",isO(umCfg))for(const[e,n]of Object.entries(umCfg))urows+=`<hr><h3>${e}</h3>`,addField(e,"unknown",n);""===urows&&(urows="Usermods configuration not found.<br>Press <i>Save</i> to initialize defaults."),gId("um").innerHTML=urows}).catch((function(e){gId("lserr").style.display="inline",console.log(e)}))}function svS(e){e.preventDefault(),console.log(d.Sf),d.Sf.checkValidity()&&d.Sf.submit()}function GetV() {var d=document;
%CSS%%SCSS%</head><body onload="S()"><form
 id="form_s" name="Sf" method="post" onsubmit="svS(event)"><div class="toprow">
<div class="helpB"><button type="button" onclick="H()">?</button></div><button 
type="button" onclick="B()">Back</button><button type="submit">Save</button><br>
<span id="lssuc" style="color:green;display:none">&#10004; Configuration saved!
</span> <span id="lserr" style="color:red;display:none">
&#9888; Could not load configuration.</span><hr></div><h2>Usermod Setup</h2><div
 id="um">Loading settings...</div><hr><button type="button" onclick="B()">Back
</button><button type="submit">Save</button></form></body></html>)=====";


=== ./html_ui.h ===

/*
 * Binary array for the Web UI.
 * gzip is used for smaller size and improved speeds.
 *
 * Please see https://kno.wled.ge/advanced/custom-features/#changing-web-ui
 * to find out how to easily modify the web UI source!
 */

// Autogenerated from wled00/data/index.htm, do not edit!!
const uint16_t PAGE_index_L = 39343;
const uint8_t PAGE_index[] PROGMEM = {
  0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0a, 0xd4, 0xbd, 0xe9, 0x7a, 0xea, 0xba,
  0xd2, 0x30, 0xf8, 0x3f, 0x57, 0xc1, 0x62, 0xed, 0xbd, 0x36, 0x5e, 0x18, 0x63, 0xe6, 0x21, 0xcb,
  0x2b, 0x2f, 0x99, 0xe7, 0x89, 0xcc, 0x39, 0x39, 0xe7, 0x31, 0x46, 0x80, 0x13, 0x63, 0x13, 0xdb,
  0x4c, 0x21, 0x7c, 0x97, 0xd0, 0x17, 0xd0, 0x7f, 0xfa, 0x16, 0xfb, 0x12, 0xba, 0x4a, 0x92, 0x27,
  0x30, 0x49, 0xf6, 0x79, 0x87, 0xfe, 0xbe, 0x3d, 0x04, 0x5b, 0x43, 0x49, 0xaa, 0x2a, 0x95, 0xaa,
  0x4a, 0x25, 0xf9, 0xd7, 0xb7, 0xed, 0xb3, 0xad, 0xab, 0xfb, 0xf3, 0x9d, 0x44, 0xcf, 0xed, 0x1b,
  0xbf, 0x13, 0xbf, 0xf0, 0x27, 0x61, 0xa8, 0x66, 0x57, 0x49, 0x12, 0x33, 0x89, 0x09, 0x44, 0x6d,
  0xc3, 0x4f, 0x9f, 0xb8, 0x6a, 0xc2, 0x54, 0xfb, 0x44, 0x49, 0x8e, 0x74, 0x32, 0x1e, 0x58, 0xb6,
  0x9b, 0x4c, 0xac, 0x69, 0x96, 0xe9, 0x12, 0xd3, 0x55, 0x92, 0x63, 0xbd, 0xed, 0xf6, 0x94, 0x36,
  0x19, 0xe9, 0x1a, 0xc9, 0xd0, 0x17, 0x51, 0x37, 0x75, 0x57, 0x57, 0x8d, 0x8c, 0xa3, 0xa9, 0x06,
  0x51, 0x72, 0x62, 0x1f, 0x12, 0xfa, 0xc3, 0xbe, 0xf7, 0x9e, 0xf4, 0x80, 0xae, 0x69, 0x3d, 0xd5,
  0x76, 0x08, 0x00, 0x19, 0xba, 0x9d, 0x4c, 0x35, 0x19, 0x6d, 0xcc, 0xed, 0x91, 0x3e, 0xc9, 0x68,
  0x96, 0x61, 0xd9, 0xc9, 0x84, 0xdf, 0xdc, 0xf7, 0x3c, 0xfd, 0x27, 0x04, 0xc3, 0xcb, 0x99, 0x12,
  0x27, 0xc9, 0xab, 0xaa, 0x83, 0x81, 0x41, 0x32, 0x7d, 0xab, 0xa5, 0xc3, 0xcf, 0x98, 0xb4, 0x32,
  0x90, 0x90, 0xd1, 0xd4, 0x81, 0xda, 0x32, 0x08, 0xd6, 0x34, 0x74, 0xf3, 0x25, 0x61, 0x13, 0x43,
  0x49, 0x3a, 0x3d, 0x18, 0x8e, 0x36, 0x74, 0x13, 0x3a, 0xc0, 0x81, 0x61, 0xf5, 0x6c, 0xd2, 0x51,
  0x92, 0x6d, 0xd5, 0x55, 0xeb, 0x7a, 0x5f, 0xed, 0x92, 0xec, 0x24, 0x83, 0x39, 0xeb, 0x2d, 0xd5,
  0x21, 0xe5, 0xa2, 0xd8, 0x68, 0x34, 0x36, 0x1b, 0x8d, 0x9d, 0xc6, 0x0e, 0xfc, 0xc5, 0xdf, 0xbd,
  0xc6, 0xd6, 0x1e, 0x3e, 0xed, 0x76, 0xe1, 0xcf, 0x81, 0x71, 0x71, 0xf5, 0xa2, 0x9d, 0x6e, 0xf5,
  0xac, 0x23, 0x4c, 0xdb, 0xbe, 0x36, 0x0e, 0x2e, 0x77, 0x0f, 0xf0, 0xf1, 0x82, 0x95, 0xee, 0xd2,
  0xb2, 0xfb, 0xd9, 0xf3, 0xec, 0x3d, 0xa6, 0xec, 0xe4, 0x0e, 0x2f, 0x77, 0x76, 0xaf, 0xcf, 0x0e,
  0x72, 0xcf, 0x90, 0x94, 0x3d, 0x1f, 0x9f, 0x4d, 0xba, 0xa7, 0x7b, 0xa4, 0x71, 0x7d, 0x32, 0xd9,
  0xa9, 0xed, 0x95, 0xb5, 0x8b, 0xad, 0xa3, 0xed, 0xdb, 0x46, 0x6f, 0xd0, 0xd8, 0x7e, 0xc8, 0x77,
  0xaa, 0xe7, 0x27, 0xcf, 0x9b, 0xcd, 0xc2, 0xc5, 0xad, 0x5c, 0xbd, 0x38, 0xca, 0xcb, 0x47, 0xea,
  0xc3, 0x56, 0xbe, 0xdb, 0xd9, 0xaa, 0xf5, 0xb6, 0xcc, 0x57, 0x6b, 0x68, 0x9d, 0x76, 0x1b, 0x97,
  0xdd, 0xfb, 0xca, 0xdb, 0xc9, 0xa4, 0x31, 0x3d, 0x35, 0xae, 0xdb, 0x17, 0xfb, 0xc6, 0x9d, 0xde,
  0x30, 0xce, 0xf2, 0x27, 0xdb, 0x8d, 0xed, 0x72, 0x61, 0xe7, 0xe6, 0xf5, 0x74, 0xbf, 0x41, 0xe4,
  0x06, 0xed, 0x88, 0xb1, 0x7b, 0xf5, 0xd2, 0x1c, 0x5e, 0xf4, 0xb7, 0xb6, 0x92, 0xbf, 0xd7, 0x12,
  0xbf, 0x5c, 0xdd, 0x35, 0xc8, 0xef, 0xdb, 0xe3, 0x9d, 0xed, 0x5f, 0x59, 0xf6, 0x9c, 0xf8, 0xe5,
  0x68, 0xb6, 0x3e, 0x70, 0x7f, 0x77, 0x86, 0xa6, 0xe6, 0xea, 0x96, 0x99, 0xe8, 0x10, 0xd2, 0x6e,
  0xa9, 0xda, 0x4b, 0x4a, 0x98, 0xcd, 0x7f, 0x65, 0x79, 0x2e, 0x14, 0x73, 0xa7, 0x50, 0x7c, 0xed,
  0x3f, 0x3a, 0x40, 0x84, 0x4c, 0x47, 0xd5, 0xc8, 0x8c, 0x3f, 0xf5, 0x75, 0x63, 0x5a, 0xbf, 0x3d,
  0x00, 0xd4, 0x39, 0xeb, 0x8e, 0xad, 0xd5, 0x87, 0xb6, 0x91, 0xa2, 0x58, 0xc5, 0xfc, 0xec, 0xd8,
  0xea, 0x74, 0xf2, 0xeb, 0x1e, 0xf5, 0x29, 0xf1, 0x3d, 0x0c, 0xb7, 0xe5, 0xda, 0xde, 0x49, 0xb7,
  0x41, 0xf1, 0xdb, 0x68, 0x98, 0xd7, 0x8d, 0x86, 0xc3, 0x3a, 0x9d, 0xc3, 0xbf, 0xfd, 0xdd, 0x46,
  0x63, 0xef, 0xa1, 0xdf, 0x6d, 0xac, 0xfc, 0x67, 0xb3, 0xdf, 0x68, 0x74, 0xef, 0xc6, 0x97, 0x5b,
  0x8d, 0x57, 0xed, 0xfe, 0xf0, 0xe1, 0xa0, 0x71, 0x75, 0xbf, 0x75, 0xd8, 0x38, 0x1d, 0x6f, 0xbd,
  0x59, 0x8d, 0xcd, 0x2d, 0x20, 0xd4, 0xf8, 0x7e, 0xff, 0x60, 0xd3, 0xa9, 0x6c, 0x57, 0xf5, 0xb3,
  0xf1, 0x5b, 0xb7, 0x5f, 0x38, 0xb9, 0x3b, 0x31, 0xdf, 0x1e, 0xb6, 0x5e, 0x5c, 0xf3, 0x59, 0x6b,
  0x9d, 0xa6, 0x2f, 0x8c, 0xc3, 0x63, 0xf5, 0xb0, 0x30, 0x34, 0xae, 0x8f, 0x07, 0xc6, 0xe0, 0xb6,
  0x7c, 0xfd, 0x7a, 0xab, 0x5b, 0xa4, 0x59, 0xcb, 0x1d, 0x4e, 0x89, 0xfc, 0x7c, 0x6d, 0x1c, 0x8e,
  0x1f, 0xec, 0x92, 0x79, 0xd5, 0xde, 0x29, 0x1c, 0x9b, 0x6e, 0xfb, 0x7c, 0xd4, 0xe8, 0xa6, 0x3b,
  0x6e, 0xb6, 0xd3, 0x72, 0x8e, 0x9d, 0x3d, 0xe3, 0xf4, 0x78, 0xd8, 0x33, 0xfa, 0x17, 0xcf, 0x47,
  0x7a, 0xe5, 0xf4, 0x7c, 0x7b, 0xe7, 0xa0, 0x3b, 0xbe, 0xea, 0x03, 0x65, 0xd5, 0x72, 0xbf, 0x6d,
  0xa4, 0x9b, 0xfb, 0xd7, 0x9b, 0xbd, 0x9d, 0x83, 0xf6, 0xfe, 0xee, 0x44, 0x7d, 0xa9, 0x38, 0xc5,
  0x9d, 0xec, 0xf4, 0xad, 0x77, 0xd8, 0x7c, 0xde, 0xaa, 0x6c, 0x5e, 0x5c, 0x1c, 0x77, 0xb6, 0xc7,
  0xd6, 0x60, 0x37, 0xab, 0x97, 0xd5, 0xd7, 0xe6, 0x8e, 0xb1, 0xb3, 0xbb, 0x7d, 0x37, 0xa9, 0x3e,
  0xdc, 0xdc, 0x3e, 0x4f, 0x0b, 0xf6, 0xb4, 0x5f, 0x3c, 0x2d, 0xef, 0x1a, 0x0f, 0x17, 0xc5, 0xde,
  0x30, 0x6d, 0xde, 0x39, 0x7b, 0x07, 0xdb, 0x27, 0x17, 0xbb, 0x85, 0x6e, 0x63, 0xa2, 0xe6, 0x8a,
  0x8d, 0x6e, 0xc3, 0x76, 0x6f, 0x4e, 0x7a, 0x9d, 0x97, 0xee, 0x73, 0x67, 0xa7, 0xd1, 0xd2, 0xb7,
  0x7a, 0xe3, 0x61, 0xf3, 0x60, 0xbc, 0x73, 0xbd, 0xd5, 0x1f, 0xb6, 0xcf, 0x7b, 0xfa, 0x45, 0xfb,
  0xaa, 0x6c, 0x8f, 0x0e, 0x9e, 0x8f, 0x9b, 0x97, 0x0f, 0x3b, 0xe3, 0xed, 0xde, 0x6e, 0x6d, 0xf3,
  0xc0, 0xb1, 0xac, 0x83, 0x52, 0xe1, 0xea, 0xe0, 0xf2, 0xc0, 0x3a, 0xb8, 0xde, 0xae, 0xbe, 0x4c,
  0x4f, 0x1f, 0x0e, 0x2a, 0xd7, 0xcf, 0x8d, 0xe9, 0x89, 0x7d, 0x99, 0x55, 0x4f, 0xb2, 0xdb, 0x63,
  0xf5, 0x6c, 0x60, 0xbd, 0xa9, 0xbd, 0xda, 0xf1, 0xde, 0x96, 0x73, 0x9f, 0x7f, 0x3b, 0xcd, 0xdf,
  0x9f, 0xbd, 0x39, 0xf9, 0xe3, 0xc2, 0xe4, 0x95, 0x9c, 0x0e, 0x8a, 0x6f, 0x77, 0xcf, 0xaf, 0xd5,
  0xd6, 0xdd, 0x55, 0xb6, 0x77, 0xb2, 0x79, 0xfc, 0x9c, 0x2d, 0x15, 0xee, 0xb7, 0x1b, 0x07, 0xcd,
  0x74, 0x65, 0x58, 0x2e, 0x57, 0xcd, 0xc2, 0x7e, 0x7a, 0xff, 0xf2, 0xbc, 0xfd, 0xd0, 0xce, 0x0d,
  0x0b, 0x57, 0x6f, 0xed, 0xcb, 0x87, 0xf6, 0xcd, 0xc9, 0x55, 0xe7, 0xc0, 0x28, 0xed, 0x77, 0x8e,
  0xba, 0xed, 0x5c, 0xab, 0xd2, 0x1c, 0xbd, 0xb6, 0x6b, 0xb7, 0xb5, 0xe1, 0xc0, 0x6e, 0x9f, 0x57,
  0x2f, 0xae, 0xce, 0xfa, 0x44, 0x7d, 0x2b, 0x5d, 0x9d, 0x9f, 0x5d, 0x1e, 0x1a, 0xdb, 0xdb, 0xcf,
  0xfb, 0x37, 0xcf, 0x7b, 0x72, 0xe3, 0xf4, 0xe4, 0xe2, 0xde, 0xe9, 0x5f, 0xda, 0x47, 0x46, 0x7f,
  0x30, 0x7d, 0xbd, 0xa9, 0xbc, 0x0c, 0x5b, 0x07, 0x17, 0x5b, 0xf9, 0xbd, 0xe6, 0xc1, 0xcb, 0x6e,
  0x33, 0x7d, 0x62, 0x92, 0xad, 0xc3, 0x62, 0xf5, 0xf0, 0x70, 0xf7, 0x66, 0xab, 0x77, 0xd1, 0x19,
  0x8e, 0x8f, 0x4e, 0x06, 0xf9, 0xe9, 0x75, 0x6d, 0xd0, 0x7f, 0xcd, 0xdd, 0x1c, 0x5d, 0x5f, 0x96,
  0x6d, 0xe2, 0xca, 0x7b, 0x03, 0xb9, 0xf9, 0x7c, 0x73, 0x7f, 0x79, 0xb9, 0x9b, 0xbe, 0x7b, 0xae,
  0xa4, 0xcf, 0xf4, 0xeb, 0xe6, 0x4b, 0x76, 0xef, 0xe0, 0x6d, 0x98, 0xeb, 0xeb, 0xfb, 0x0f, 0xb7,
  0x93, 0x74, 0xb7, 0x7a, 0x9f, 0xbb, 0xbc, 0x7e, 0x71, 0xcf, 0xfb, 0xaf, 0x07, 0xba, 0x7b, 0x79,
  0x75, 0x77, 0x73, 0xfa, 0xf6, 0xb6, 0xe5, 0x0e, 0x77, 0xcf, 0x8f, 0xb4, 0x7d, 0xf9, 0xed, 0x72,
  0x73, 0x2f, 0x7d, 0x5f, 0xcb, 0x6e, 0x99, 0xbd, 0x4d, 0x35, 0x2f, 0x8f, 0x4a, 0xd6, 0x7e, 0xc7,
  0xd9, 0xb9, 0x3e, 0xe9, 0xde, 0x9d, 0x9c, 0xef, 0x74, 0xce, 0x4a, 0x0f, 0xda, 0xe1, 0x44, 0xde,
  0x3d, 0x38, 0xd7, 0x6f, 0xa6, 0xe3, 0xee, 0x73, 0xab, 0x7c, 0x72, 0x30, 0xbc, 0x49, 0x5b, 0x0f,
  0xc5, 0x51, 0xfe, 0xe5, 0xa5, 0x9c, 0x7d, 0x33, 0x0f, 0x26, 0xdb, 0x47, 0x76, 0x77, 0x78, 0x92,
  0xcf, 0x4f, 0xd3, 0xad, 0xdb, 0xea, 0xf8, 0x7a, 0xef, 0x55, 0xaf, 0xa8, 0xc7, 0xd5, 0xce, 0xc5,
  0xe1, 0xdb, 0xd8, 0xdc, 0x7a, 0xae, 0xba, 0x07, 0x83, 0x41, 0xfb, 0xa0, 0xd6, 0xba, 0xdf, 0x6e,
  0xde, 0x1c, 0xde, 0x6c, 0x5d, 0x1c, 0x98, 0xfa, 0xe0, 0x56, 0xde, 0x6f, 0xb9, 0x9a, 0xa1, 0x5d,
  0x55, 0x46, 0x5b, 0xd3, 0xe3, 0xfe, 0x9d, 0xda, 0xbc, 0xb1, 0x2f, 0x9a, 0xa7, 0x27, 0xd3, 0x96,
  0x7a, 0x78, 0xb8, 0xd9, 0xcb, 0x9f, 0xeb, 0x77, 0xf6, 0x5d, 0xab, 0xdb, 0x2e, 0x37, 0x5a, 0xaf,
  0x44, 0x6b, 0x6f, 0x5f, 0x9d, 0xd5, 0x76, 0x2e, 0x76, 0x0e, 0xc8, 0xad, 0x7c, 0x73, 0x7e, 0x7b,
  0xa1, 0xb5, 0x2f, 0xaa, 0x86, 0x7b, 0x7e, 0xb6, 0x33, 0x4c, 0x57, 0xca, 0xaf, 0xf9, 0x83, 0xc9,
  0xf5, 0x95, 0x75, 0x48, 0x6e, 0x07, 0x9d, 0xe7, 0x0b, 0x7d, 0x7f, 0x7f, 0xbf, 0x04, 0x53, 0x69,
  0xfb, 0xf8, 0x39, 0xd7, 0xda, 0xef, 0x5e, 0x4c, 0xee, 0x9c, 0x6b, 0x18, 0xd0, 0xd1, 0x7d, 0xab,
  0x9b, 0xde, 0x9a, 0xc0, 0xbf, 0xe5, 0x1a, 0xd9, 0xd7, 0xce, 0x46, 0xb7, 0x3d, 0x72, 0x98, 0x33,
  0xca, 0x2d, 0xd9, 0xdc, 0xae, 0x3c, 0xef, 0xa5, 0x5b, 0xcd, 0x46, 0xae, 0xbd, 0xf5, 0x70, 0x33,
  0xe9, 0x8f, 0xab, 0x0f, 0x87, 0xd9, 0x83, 0x7b, 0x77, 0x72, 0xee, 0xb6, 0x0e, 0x27, 0xc6, 0xe0,
  0x22, 0x7b, 0xbc, 0xf7, 0xdc, 0x7c, 0x95, 0xe5, 0xab, 0x7e, 0xfb, 0xf4, 0xe0, 0x61, 0x62, 0xef,
  0x11, 0x23, 0x3d, 0x4d, 0xdb, 0x0f, 0x87, 0xb6, 0x95, 0x36, 0xaf, 0x7b, 0x85, 0x73, 0xfb, 0xf4,
  0x60, 0x6f, 0x7c, 0x54, 0xbe, 0xb5, 0xef, 0x4e, 0x4f, 0x6e, 0xf2, 0x93, 0x2b, 0x72, 0x79, 0xbb,
  0xdf, 0x7c, 0x6e, 0x6a, 0x2f, 0xee, 0xf1, 0x61, 0x87, 0xe4, 0x6c, 0xad, 0xe2, 0x0c, 0xa6, 0xa3,
  0x97, 0x42, 0xab, 0x7c, 0x53, 0x7c, 0x29, 0x56, 0x9b, 0x76, 0xa1, 0xd1, 0xcf, 0x9d, 0x8f, 0xb2,
  0x17, 0x7a, 0xa7, 0xe7, 0x1c, 0xe4, 0x87, 0x27, 0x23, 0xad, 0x5a, 0x2e, 0x9c, 0xe9, 0x17, 0x17,
  0x97, 0xa7, 0x16, 0x69, 0x0f, 0xce, 0x3b, 0xfb, 0x66, 0x73, 0xac, 0x11, 0x97, 0xa4, 0xd5, 0xed,
  0x9d, 0x9d, 0x72, 0x45, 0x3b, 0x7a, 0xbb, 0xea, 0x6e, 0x1a, 0x17, 0xdd, 0xe7, 0xc1, 0x73, 0xf7,
  0x6a, 0xdb, 0x3c, 0x74, 0xf7, 0xcc, 0xbb, 0xfc, 0x6b, 0xab, 0x7f, 0x77, 0x58, 0xde, 0x3d, 0xdb,
  0x3c, 0x7e, 0xa8, 0x8c, 0x1d, 0x3b, 0x7d, 0xf8, 0xf0, 0x76, 0x6f, 0xb6, 0x9e, 0xdb, 0xad, 0x97,
  0xad, 0xe1, 0x4e, 0xe7, 0x5a, 0xde, 0x1f, 0x19, 0xe3, 0xd7, 0x96, 0x7b, 0xdd, 0x3d, 0xac, 0xbc,
  0x5d, 0xde, 0xed, 0x9e, 0x1e, 0x3a, 0xa3, 0xe6, 0xc4, 0x18, 0xbf, 0xe5, 0x6f, 0xef, 0x5d, 0xb5,
  0x38, 0x79, 0xb6, 0xf5, 0x6c, 0xc7, 0x19, 0x1a, 0xa6, 0xb9, 0x7b, 0x73, 0x3e, 0xb5, 0xcc, 0xc1,
  0xb9, 0x7c, 0x79, 0x5c, 0xb2, 0x6e, 0x4e, 0x8f, 0x5e, 0x5e, 0x3a, 0x3b, 0xc6, 0x5e, 0x51, 0x73,
  0xae, 0xb6, 0x4f, 0x1b, 0x4e, 0xf7, 0x6d, 0xab, 0x50, 0xdd, 0xab, 0x74, 0x9b, 0x47, 0x37, 0xdd,
  0xe6, 0x43, 0xa5, 0x9f, 0xd5, 0x76, 0x46, 0x47, 0x8d, 0xe3, 0xfe, 0xe4, 0xe8, 0x2d, 0x9b, 0x1d,
  0x56, 0x7a, 0x65, 0xd2, 0xdd, 0xdf, 0xad, 0x9c, 0xd8, 0xfb, 0xc5, 0xe7, 0xc3, 0x41, 0xf6, 0x61,
  0x52, 0x7c, 0x2d, 0xe4, 0xd5, 0xea, 0x55, 0x25, 0x37, 0x31, 0xf7, 0x6f, 0x2e, 0xb7, 0xf6, 0x8c,
  0xce, 0xee, 0xc3, 0xa9, 0xeb, 0xb6, 0xf3, 0xbb, 0xda, 0xb5, 0xaa, 0x4e, 0xcb, 0xa4, 0x76, 0xfe,
  0xd2, 0x1b, 0x6a, 0xd3, 0x4b, 0xd9, 0x3a, 0x1f, 0xe6, 0xde, 0x72, 0x6f, 0xd9, 0xed, 0xcd, 0x74,
  0x75, 0xac, 0x4f, 0x1a, 0xbb, 0xed, 0x93, 0xeb, 0x5c, 0xd7, 0xec, 0x6f, 0x16, 0x27, 0x8d, 0x71,
  0xb9, 0x3a, 0x18, 0xef, 0x6b, 0xb7, 0xcf, 0xc6, 0xae, 0xbd, 0x69, 0xde, 0x4d, 0x8e, 0x9f, 0x9f,
  0xcb, 0x85, 0xeb, 0xbd, 0xee, 0xe8, 0x74, 0xef, 0x66, 0xaf, 0x71, 0xb8, 0xfb, 0x36, 0xd9, 0x1d,
  0xa7, 0x6f, 0xad, 0xbe, 0x59, 0x39, 0x69, 0xe8, 0xad, 0x9b, 0xd6, 0xb0, 0x6c, 0x90, 0xfd, 0xcb,
  0xcd, 0x92, 0xa3, 0xe5, 0xe4, 0xce, 0xb1, 0xdb, 0xb2, 0xdb, 0x76, 0xf6, 0xf0, 0xf5, 0xa6, 0x7c,
  0x6f, 0xa7, 0xad, 0xd1, 0x78, 0xd7, 0xbd, 0xdc, 0xdf, 0xa9, 0x9c, 0x14, 0xdf, 0xf6, 0x6a, 0xf2,
  0xeb, 0xe9, 0x66, 0xf9, 0xfe, 0x72, 0xc7, 0xb2, 0x4a, 0xb9, 0x97, 0xdd, 0x43, 0xb5, 0xf5, 0x5a,
  0x38, 0x25, 0xfb, 0x37, 0x47, 0x6d, 0xd2, 0xc9, 0xf6, 0x9c, 0x93, 0xdd, 0xdd, 0xe6, 0xc0, 0x2d,
  0xf5, 0xab, 0x77, 0xfd, 0xc3, 0xd7, 0xed, 0xed, 0x86, 0x79, 0x29, 0x6b, 0xc5, 0x5c, 0xb5, 0x3f,
  0xe9, 0x4f, 0xec, 0x8b, 0xb7, 0x8b, 0xe1, 0xf4, 0xdc, 0x74, 0x06, 0x97, 0xe3, 0x4e, 0xe3, 0xfe,
  0x65, 0xe0, 0xf6, 0xde, 0x6c, 0x40, 0xcb, 0x55, 0x6e, 0x72, 0xda, 0xec, 0x14, 0x6f, 0xdd, 0xcd,
  0x93, 0x93, 0xda, 0xf6, 0xc5, 0x55, 0xae, 0x36, 0x3c, 0x4e, 0x77, 0x5b, 0xc5, 0x4a, 0x77, 0xf7,
  0xf8, 0xbc, 0xa0, 0x5d, 0xc9, 0xd5, 0xdd, 0xea, 0x41, 0xb1, 0xfd, 0x30, 0x39, 0x34, 0x8a, 0xb9,
  0x3d, 0x67, 0x52, 0xbb, 0xdd, 0x7f, 0x3b, 0xde, 0x3c, 0xdb, 0x7f, 0xbb, 0x7d, 0xbe, 0x6c, 0xd6,
  0x4e, 0x8f, 0xb7, 0xce, 0xae, 0x37, 0xb7, 0x76, 0x2f, 0xd2, 0xc3, 0xbd, 0xde, 0x66, 0xf6, 0xa6,
  0xf2, 0xf0, 0x76, 0x3d, 0x3e, 0xda, 0x69, 0x5e, 0xf5, 0xb7, 0x6d, 0xfd, 0x30, 0x7d, 0x8d, 0xbc,
  0x9f, 0x6d, 0xed, 0xde, 0xed, 0x9e, 0x1c, 0x1f, 0x3b, 0xcf, 0x5d, 0xbd, 0xe1, 0x16, 0x07, 0x83,
  0xca, 0xd0, 0x18, 0x4c, 0x5a, 0x79, 0xf7, 0x6d, 0xa7, 0x7a, 0x50, 0x9d, 0xf4, 0xa6, 0xfb, 0x67,
  0xdb, 0x9b, 0x47, 0x85, 0xe6, 0x5e, 0xb7, 0x7c, 0x71, 0x9e, 0xcb, 0x6f, 0xea, 0xe7, 0x85, 0xfb,
  0x93, 0x71, 0xde, 0xde, 0xde, 0x75, 0x6f, 0xaf, 0xb7, 0xef, 0x8e, 0xd3, 0xc4, 0x31, 0x47, 0x85,
  0xfd, 0xda, 0xc5, 0xe4, 0xb5, 0xd3, 0x6f, 0x6d, 0x9b, 0xad, 0x93, 0xe3, 0xe7, 0xbd, 0xeb, 0xdd,
  0xc1, 0xeb, 0xeb, 0x43, 0xcb, 0xbc, 0x6d, 0x76, 0x65, 0xa3, 0x77, 0x3b, 0xaa, 0x8d, 0xaf, 0x0b,
  0xa5, 0xd7, 0xab, 0xfd, 0xd7, 0xf3, 0xda, 0xdb, 0xeb, 0xb5, 0x7d, 0x5c, 0x79, 0x79, 0x3d, 0x7a,
  0xae, 0xde, 0x3f, 0x3f, 0xbc, 0x75, 0xe5, 0xdc, 0xa0, 0x55, 0x4b, 0x4f, 0x2f, 0xaa, 0xce, 0xdd,
  0xc3, 0xe0, 0x7e, 0x72, 0xb4, 0xa7, 0xef, 0x1e, 0x5e, 0x9d, 0x3a, 0x07, 0xe3, 0xf1, 0x60, 0x7a,
  0x59, 0x2c, 0x76, 0x77, 0xce, 0xcc, 0x9b, 0x6c, 0x9a, 0x00, 0x23, 0xb5, 0xf7, 0xb7, 0xb3, 0x79,
  0xe3, 0xa2, 0x30, 0x6c, 0x96, 0xa6, 0xb9, 0xd7, 0xb7, 0x83, 0x37, 0xf7, 0xee, 0xfa, 0xf4, 0x7c,
  0xa7, 0x6c, 0xb5, 0xef, 0x0f, 0xe5, 0xf3, 0xd7, 0x6b, 0xfd, 0xf6, 0xd0, 0xed, 0x1e, 0xed, 0x1d,
  0x9d, 0x1c, 0x1c, 0xdf, 0x97, 0xe5, 0xf6, 0x84, 0xdc, 0x4f, 0xcd, 0x56, 0x2b, 0xed, 0xec, 0x1e,
  0x1d, 0xbd, 0x9e, 0x9a, 0xf2, 0xed, 0x5b, 0xde, 0x3e, 0x76, 0x4f, 0x5a, 0x9b, 0x17, 0xb7, 0xe7,
  0xe6, 0xbd, 0xdb, 0x3f, 0x54, 0x8b, 0xb7, 0xaf, 0xbb, 0x97, 0x56, 0x2b, 0x5b, 0xeb, 0xf7, 0x87,
  0x53, 0xed, 0xe2, 0x66, 0x54, 0xd1, 0x3b, 0x5b, 0xa7, 0xa3, 0x3b, 0xdb, 0xe8, 0xbd, 0x75, 0xb7,
  0x8f, 0xb7, 0x47, 0xa0, 0x98, 0xa4, 0xab, 0xfb, 0xa5, 0xc9, 0xf3, 0x51, 0xad, 0x58, 0xd5, 0xb6,
  0x89, 0x9b, 0xde, 0x55, 0xef, 0x3a, 0xcd, 0xf4, 0xf1, 0x8b, 0x95, 0xbd, 0x75, 0xd3, 0xa3, 0xa6,
  0xf6, 0xaa, 0xda, 0xaf, 0xe5, 0x97, 0x87, 0xab, 0xd6, 0x4b, 0xf1, 0x54, 0x3d, 0x7a, 0x1d, 0x9c,
  0xb5, 0x5e, 0x76, 0x76, 0x06, 0x8e, 0xaa, 0xd5, 0x8e, 0x73, 0xf6, 0xe5, 0xe9, 0xdd, 0x61, 0xf7,
  0xbc, 0x65, 0xdf, 0x4e, 0xb7, 0xdb, 0xf7, 0xcf, 0xa4, 0xec, 0x6e, 0x5e, 0x34, 0xde, 0xdc, 0x97,
  0xd6, 0xfd, 0x96, 0x3c, 0xde, 0x26, 0xc5, 0x6b, 0xf3, 0x54, 0x1f, 0xf4, 0xcd, 0x07, 0xf7, 0xc0,
  0x1c, 0x66, 0x87, 0xcf, 0x9d, 0xf2, 0x51, 0xa7, 0x32, 0x22, 0xb9, 0x5c, 0x7e, 0x7f, 0xd8, 0xa9,
  0xe5, 0x77, 0x46, 0xd9, 0x0a, 0x31, 0x37, 0xb3, 0x69, 0xf3, 0xbc, 0x32, 0x68, 0xd9, 0xe7, 0xfa,
  0xc5, 0xe1, 0x43, 0x4b, 0x97, 0x9f, 0xb7, 0x9a, 0x03, 0xeb, 0xb4, 0x06, 0x03, 0xbf, 0x7a, 0x79,
  0xae, 0x1c, 0x9e, 0x8c, 0x07, 0xad, 0xdb, 0xae, 0x35, 0x68, 0xb4, 0x7a, 0x6e, 0xeb, 0xec, 0xf6,
  0x65, 0xea, 0x36, 0x76, 0x0b, 0x47, 0xe9, 0xec, 0xab, 0x25, 0x37, 0x1b, 0xcd, 0xd3, 0xdb, 0xfc,
  0x5e, 0xbe, 0x75, 0xdc, 0x31, 0x9d, 0xde, 0x60, 0xb3, 0xa8, 0xd6, 0xda, 0xfd, 0xb7, 0x4a, 0x76,
  0x7f, 0x92, 0xcd, 0xb6, 0xb5, 0xc2, 0xd9, 0xdd, 0xe9, 0x43, 0x11, 0x78, 0x75, 0x7a, 0x77, 0x7d,
  0x93, 0x6f, 0xdf, 0x5f, 0x3a, 0xdb, 0xb5, 0xca, 0xeb, 0xd1, 0x71, 0xa5, 0xf6, 0xaa, 0xbe, 0x0d,
  0x61, 0x68, 0x07, 0xb9, 0xd1, 0xf9, 0xdd, 0x55, 0xa5, 0x50, 0x29, 0xb5, 0x6e, 0x9b, 0x7b, 0x96,
  0xb6, 0x69, 0x75, 0xb6, 0xf3, 0xe4, 0xe0, 0xf2, 0xed, 0x50, 0xd6, 0x4e, 0xb6, 0x64, 0x50, 0x16,
  0xc7, 0x17, 0x72, 0xb7, 0x33, 0x1a, 0x36, 0xdb, 0xa3, 0x76, 0xae, 0xd8, 0xc9, 0x0d, 0x81, 0xeb,
  0x8f, 0xcf, 0x77, 0x0a, 0x87, 0x87, 0xfb, 0xc7, 0xe5, 0xe1, 0x56, 0x3b, 0x6b, 0x96, 0xcc, 0x6a,
  0xbb, 0x50, 0xba, 0x3e, 0x3b, 0x3a, 0x37, 0xcb, 0x66, 0xcf, 0x86, 0x05, 0xd2, 0xbe, 0x29, 0xa8,
  0xed, 0x82, 0xf9, 0x96, 0xd7, 0xaf, 0xf4, 0xd3, 0xe3, 0x62, 0xae, 0xb8, 0x63, 0x92, 0xce, 0x71,
  0xf6, 0x70, 0xef, 0xd8, 0xb8, 0x7d, 0x70, 0x1f, 0x6e, 0xd5, 0x57, 0x6b, 0xa7, 0x57, 0x9c, 0x34,
  0x9f, 0x47, 0xce, 0x5e, 0x2b, 0x5b, 0xee, 0xd7, 0x6c, 0x75, 0xd7, 0x70, 0x8e, 0xfb, 0xc5, 0xe1,
  0xfe, 0xcb, 0xc5, 0xad, 0x31, 0xaa, 0x5c, 0x65, 0xc7, 0xe4, 0xe1, 0xed, 0x79, 0x7f, 0x9f, 0x54,
  0x26, 0x0f, 0xfa, 0xf5, 0xdb, 0xe0, 0xb0, 0x74, 0xdb, 0xb8, 0xdd, 0x3c, 0xde, 0x3e, 0x1d, 0x5f,
  0x1e, 0x4d, 0xc6, 0x97, 0xf7, 0xe6, 0xae, 0x75, 0xb7, 0x37, 0xd1, 0xd4, 0xa3, 0xc9, 0x69, 0x79,
  0xfb, 0xb2, 0xba, 0x79, 0x6a, 0xe6, 0xad, 0xda, 0xe9, 0x2b, 0x50, 0xd8, 0x1d, 0xd9, 0x6a, 0xe9,
  0xca, 0x3c, 0x78, 0xbe, 0x3b, 0xd9, 0x34, 0xfa, 0x07, 0xbb, 0x0f, 0x85, 0xe9, 0xf9, 0xfd, 0x5d,
  0xe1, 0xc4, 0xad, 0x8d, 0x4a, 0xfd, 0xfe, 0xfe, 0x70, 0x7c, 0x3f, 0x1a, 0x4d, 0xce, 0x47, 0xc4,
  0x3e, 0xae, 0x91, 0xe6, 0xc8, 0x79, 0xbb, 0x3b, 0x7d, 0xbe, 0xbe, 0xb3, 0x5f, 0x5a, 0xaf, 0xda,
  0xde, 0xd9, 0xcd, 0x6d, 0xbe, 0xb5, 0xd3, 0xda, 0xde, 0x3b, 0xd2, 0x0b, 0x27, 0xc7, 0x37, 0x57,
  0xb7, 0x6f, 0x6f, 0xb7, 0xfb, 0xbb, 0xa5, 0xe2, 0xe6, 0x30, 0x9b, 0xb7, 0x1b, 0xb9, 0xd7, 0x17,
  0xab, 0x6c, 0xd4, 0x3a, 0xbb, 0xdd, 0x9b, 0xd6, 0xe6, 0xd0, 0xee, 0xdc, 0x6c, 0xde, 0xee, 0xee,
  0x1a, 0x37, 0xb7, 0xb9, 0x61, 0x77, 0x72, 0x36, 0xd6, 0x9c, 0x74, 0xf5, 0x36, 0x9b, 0x05, 0xf9,
  0xf4, 0x70, 0xa8, 0x93, 0x63, 0xa3, 0x76, 0x7b, 0xd7, 0xa8, 0x92, 0xbd, 0xe3, 0x92, 0x66, 0x6f,
  0x56, 0x3a, 0xbd, 0xb3, 0x93, 0xe9, 0xc4, 0xa8, 0xb6, 0x9e, 0x2f, 0x6e, 0xf7, 0x9e, 0x37, 0x73,
  0xad, 0xdb, 0xac, 0xf5, 0x52, 0xbe, 0xd6, 0x5e, 0x89, 0xe9, 0xd8, 0x95, 0xdd, 0xea, 0x7e, 0x65,
  0xe8, 0x3a, 0xfd, 0xf6, 0xab, 0xb5, 0xdf, 0x7f, 0xab, 0xd5, 0xec, 0xd1, 0x94, 0xec, 0x64, 0xcf,
  0xdf, 0x40, 0x41, 0x28, 0xf6, 0x47, 0x37, 0x77, 0xc7, 0xcf, 0xd3, 0xfb, 0xea, 0xa8, 0xfa, 0x5c,
  0xba, 0xeb, 0x3d, 0x90, 0xfd, 0x82, 0x7a, 0x7e, 0x57, 0x29, 0xb5, 0x07, 0xfa, 0x59, 0x89, 0x9c,
  0x66, 0xcf, 0xde, 0xc6, 0xda, 0x5e, 0xe5, 0xed, 0xa5, 0x63, 0xb8, 0x59, 0xa7, 0x5d, 0x22, 0x95,
  0x7b, 0xed, 0xb5, 0x75, 0x66, 0x8d, 0x3b, 0x97, 0xdd, 0x7c, 0xfe, 0xb2, 0x54, 0xaa, 0x96, 0x54,
  0x37, 0x3f, 0xba, 0xbb, 0xab, 0x56, 0x6e, 0x73, 0xf7, 0x72, 0xf7, 0x42, 0xae, 0xd4, 0x8a, 0xb5,
  0x0a, 0xb9, 0xbf, 0xca, 0xed, 0xbc, 0x4c, 0xad, 0x9d, 0xd7, 0x93, 0x7b, 0xd0, 0x01, 0xf7, 0xdb,
  0xd5, 0x8b, 0xd1, 0xd1, 0x9e, 0x7d, 0xb9, 0x57, 0x6e, 0x1d, 0xde, 0x5f, 0x6d, 0x6f, 0x6d, 0x3d,
  0xdc, 0xef, 0xed, 0xdc, 0x6a, 0xfd, 0xd2, 0x5e, 0x0e, 0xd0, 0x98, 0xd7, 0x4b, 0xc5, 0xfb, 0xda,
  0xad, 0xab, 0x6f, 0x0e, 0x5f, 0x8c, 0xf3, 0x52, 0xe5, 0xde, 0xdd, 0x7c, 0x38, 0x69, 0xdc, 0x1a,
  0xc3, 0x7c, 0xe7, 0xfe, 0x6d, 0xfb, 0xa4, 0x72, 0x91, 0x2e, 0xed, 0x82, 0x24, 0x6f, 0x16, 0xce,
  0xde, 0x4a, 0xcf, 0xb0, 0x86, 0x1d, 0xa8, 0x9a, 0xdb, 0xba, 0x3d, 0xb7, 0xc6, 0xc3, 0x8b, 0xee,
  0xe9, 0x74, 0xdf, 0x18, 0x1e, 0x19, 0xea, 0xb8, 0x36, 0x36, 0x5b, 0x67, 0x7d, 0x77, 0xa8, 0x3e,
  0x5b, 0xd9, 0x9b, 0xe6, 0xb8, 0x06, 0x12, 0xb9, 0x79, 0x39, 0x3e, 0xd1, 0x86, 0xc0, 0x96, 0x0f,
  0xe3, 0xdd, 0x5e, 0xaf, 0xec, 0x54, 0x7a, 0xce, 0xab, 0xad, 0xdf, 0x6e, 0x39, 0xdd, 0x46, 0xde,
  0x29, 0x98, 0xbb, 0xa0, 0x36, 0x17, 0x0f, 0x2a, 0x67, 0x69, 0xd5, 0x99, 0x8c, 0x27, 0x0f, 0x2d,
  0xf7, 0xf8, 0x58, 0x2e, 0xec, 0xd4, 0x5a, 0x3d, 0xed, 0xb2, 0x7c, 0xff, 0x56, 0xeb, 0x1f, 0xb4,
  0x76, 0xe5, 0xeb, 0x5a, 0xf9, 0x48, 0x9e, 0xec, 0x35, 0x2a, 0xad, 0x49, 0x6d, 0x9a, 0x36, 0xf2,
  0xd9, 0x6c, 0xa5, 0xf0, 0x9c, 0xde, 0xcf, 0xeb, 0xf2, 0xce, 0x5e, 0x3b, 0x5f, 0x19, 0x36, 0x6e,
  0x4e, 0x0f, 0xb2, 0xb7, 0xbd, 0xad, 0xfb, 0xe1, 0xed, 0xeb, 0xc1, 0xb6, 0x7a, 0x3f, 0x51, 0xdb,
  0x8e, 0x6c, 0x68, 0x37, 0xbb, 0x37, 0xe9, 0xf6, 0x99, 0xb1, 0xdf, 0xdf, 0x9c, 0x64, 0x5f, 0xcf,
  0x2a, 0x5a, 0x39, 0x3b, 0x7c, 0xb8, 0x93, 0xdd, 0x4b, 0x72, 0xed, 0x1e, 0x5e, 0x8c, 0xca, 0xc5,
  0x29, 0xb0, 0x6f, 0x63, 0x74, 0x57, 0x9e, 0x6c, 0x93, 0xb7, 0xc6, 0x5d, 0xb6, 0x7a, 0xdb, 0xaf,
  0x6e, 0x75, 0x7b, 0xd9, 0x5a, 0xe9, 0xac, 0x76, 0x36, 0x71, 0x4e, 0xb7, 0xee, 0x4d, 0xe7, 0xee,
  0xf6, 0x22, 0x5d, 0x19, 0x6c, 0xbd, 0x55, 0xb3, 0xa7, 0x27, 0x0f, 0xa5, 0xca, 0x43, 0xe3, 0x60,
  0x6f, 0xa7, 0x7d, 0x35, 0x4e, 0xab, 0x83, 0xea, 0x4d, 0xfa, 0xa0, 0x70, 0x7a, 0x7d, 0x43, 0x60,
  0x4e, 0x8d, 0xf5, 0x51, 0xda, 0xd0, 0xb4, 0xd7, 0xe7, 0x5c, 0x25, 0x7f, 0x57, 0xb9, 0x1f, 0x97,
  0xba, 0x87, 0x8d, 0xeb, 0x8b, 0xbd, 0xfb, 0xf3, 0x8b, 0xf2, 0xc5, 0x74, 0x72, 0xd9, 0xe9, 0x92,
  0xad, 0xf4, 0x85, 0x56, 0xba, 0x35, 0x1b, 0x27, 0x5b, 0x8d, 0xfd, 0xdd, 0x51, 0xf9, 0xea, 0xd0,
  0x25, 0x6e, 0x61, 0x60, 0x66, 0xab, 0x85, 0x56, 0xf1, 0x7e, 0xab, 0x71, 0xb0, 0x39, 0x2a, 0x94,
  0xac, 0xce, 0xe0, 0xea, 0x72, 0xea, 0x96, 0xce, 0x9f, 0x41, 0x27, 0xbd, 0xaa, 0x1e, 0xdd, 0x37,
  0x76, 0x2e, 0x8e, 0xaa, 0xe6, 0x6e, 0x77, 0x53, 0x03, 0xb5, 0xf8, 0x7a, 0x0c, 0xbc, 0xff, 0xba,
  0xdf, 0xdc, 0x3c, 0xb2, 0x76, 0xf6, 0x2a, 0x47, 0x0f, 0x17, 0xc7, 0x27, 0x83, 0x67, 0xab, 0x34,
  0xec, 0xa9, 0xd9, 0xf3, 0x83, 0xfc, 0x74, 0xb8, 0x79, 0x0b, 0x96, 0x6b, 0x73, 0xfb, 0x41, 0x7d,
  0x1e, 0xbc, 0x5e, 0x94, 0xab, 0xe9, 0x07, 0x35, 0x57, 0x7d, 0xee, 0xee, 0x75, 0xef, 0x4f, 0xae,
  0xaa, 0xe6, 0x66, 0xef, 0xf9, 0x48, 0xdb, 0xb5, 0x8f, 0xb6, 0xee, 0x77, 0xcb, 0xd3, 0xa3, 0xe6,
  0xc3, 0xe5, 0xf1, 0x6e, 0xc9, 0xbd, 0x2c, 0xdd, 0x1f, 0xf5, 0xae, 0xdf, 0xde, 0x4e, 0x6f, 0x4f,
  0x4a, 0xf9, 0xfe, 0xe6, 0x68, 0x78, 0x7e, 0xa2, 0x1f, 0x57, 0x26, 0xe7, 0x93, 0xe2, 0xb5, 0x7a,
  0xd9, 0xdd, 0xd5, 0x0f, 0x1f, 0x1a, 0x37, 0xbb, 0x8e, 0xf6, 0x90, 0xdf, 0xbf, 0x3e, 0xe8, 0x5d,
  0x9f, 0x6b, 0x3b, 0xea, 0x7e, 0xe9, 0xf6, 0x76, 0x7b, 0x34, 0xea, 0x8f, 0xda, 0xe7, 0x1d, 0xa3,
  0x74, 0xa4, 0x6e, 0x8d, 0xce, 0xaa, 0x56, 0x2e, 0xdd, 0xd9, 0xdd, 0xda, 0x6c, 0x95, 0x7b, 0xa3,
  0xe1, 0xf1, 0x5b, 0xd5, 0x38, 0xb9, 0x3c, 0x1b, 0x77, 0x9e, 0xcf, 0x4f, 0xab, 0xba, 0x6a, 0xd7,
  0xe4, 0xcb, 0xad, 0x2d, 0xfd, 0x72, 0xeb, 0xd0, 0x2e, 0x0c, 0xbb, 0xaf, 0xfb, 0x9d, 0xf2, 0xf1,
  0x6b, 0xf7, 0xfa, 0xfe, 0xde, 0x29, 0xf5, 0xde, 0x46, 0xc3, 0x9a, 0x7b, 0x72, 0x70, 0x76, 0x6d,
  0x67, 0x27, 0x83, 0xd1, 0xa5, 0x73, 0x7a, 0x33, 0x6a, 0x3f, 0x64, 0x07, 0xe9, 0xfe, 0x66, 0xd5,
  0xac, 0xdc, 0xe4, 0x41, 0x2a, 0xca, 0x57, 0x69, 0xf5, 0xb2, 0x77, 0x3e, 0x38, 0xed, 0x39, 0xa7,
  0xbb, 0x67, 0xaf, 0x13, 0x6b, 0x27, 0x3f, 0x94, 0x9d, 0xe1, 0xeb, 0x95, 0x3e, 0xe8, 0x4e, 0x4a,
  0xd5, 0x83, 0xc3, 0x06, 0x35, 0xdc, 0x14, 0x21, 0xd1, 0xb1, 0xec, 0xbe, 0xea, 0xa6, 0xfe, 0x42,
  0x03, 0xea, 0x2f, 0x61, 0x5e, 0xb7, 0x2d, 0xcb, 0x9d, 0x65, 0x32, 0x5a, 0x26, 0x57, 0xff, 0x9e,
  0xcb, 0xe5, 0xd6, 0xf1, 0xb1, 0x53, 0xff, 0xde, 0xe9, 0x74, 0xe8, 0x63, 0xbe, 0x8e, 0xe6, 0x32,
  0x7d, 0x2c, 0xd4, 0xbf, 0x17, 0x0a, 0x05, 0xfa, 0x58, 0xac, 0x7f, 0x2f, 0x16, 0x8b, 0xf4, 0xb1,
  0x54, 0xff, 0x5e, 0x2a, 0x95, 0xe8, 0x63, 0xb9, 0xfe, 0xbd, 0x5c, 0x2e, 0xd3, 0xc7, 0x6a, 0xfd,
  0x7b, 0xb5, 0x5a, 0xa5, 0x8f, 0xad, 0xfa, 0xf7, 0x56, 0xab, 0x45, 0x1f, 0xb5, 0xfa, 0x77, 0x4d,
  0xd3, 0xe8, 0x23, 0xa9, 0x7f, 0x27, 0x84, 0xd0, 0xc7, 0x76, 0xfd, 0x7b, 0xbb, 0xdd, 0xa6, 0x8f,
  0x36, 0x54, 0x2b, 0x60, 0x1f, 0x5c, 0xa8, 0x26, 0x4b, 0x0c, 0xac, 0x55, 0xb7, 0xbb, 0x2d, 0x35,
  0x55, 0x28, 0x8a, 0x09, 0xef, 0x7f, 0x59, 0xaa, 0x09, 0x34, 0xcf, 0x6d, 0x2d, 0x67, 0x8e, 0x54,
  0x3b, 0x45, 0x21, 0x08, 0x5e, 0x19, 0x95, 0x15, 0xca, 0xc9, 0x79, 0x31, 0x11, 0xfc, 0x59, 0x2e,
  0xd7, 0x63, 0xe5, 0x4a, 0x39, 0x31, 0xe1, 0xfd, 0x1f, 0x2d, 0xe4, 0xf6, 0xea, 0x15, 0x79, 0x30,
  0xc1, 0xa7, 0x81, 0xf7, 0x04, 0xb5, 0xca, 0x05, 0x96, 0xd6, 0x1a, 0xd4, 0x73, 0xc5, 0xc1, 0x24,
  0xc1, 0xfe, 0xc8, 0xfc, 0x09, 0xcb, 0x40, 0x4e, 0x0d, 0x5e, 0xe5, 0x44, 0x05, 0xff, 0xd2, 0x5a,
  0xed, 0xba, 0x69, 0x99, 0x88, 0x81, 0x56, 0xdf, 0xad, 0x43, 0xd9, 0x39, 0x7a, 0x4f, 0x66, 0xae,
  0x35, 0xd4, 0x7a, 0x19, 0x95, 0x9a, 0xcc, 0xf5, 0xbe, 0x0a, 0x0a, 0xfd, 0xd0, 0x50, 0xf1, 0x65,
  0xde, 0xb2, 0xda, 0xd3, 0x59, 0x5f, 0xb5, 0xbb, 0xba, 0x59, 0x97, 0xd7, 0xd1, 0x92, 0xee, 0xda,
  0xd6, 0xd0, 0x6c, 0x33, 0xff, 0x46, 0x9d, 0x75, 0x14, 0xc8, 0x28, 0xac, 0x87, 0x0d, 0xe8, 0x7d,
  0x62, 0x8c, 0x88, 0xab, 0x6b, 0xaa, 0x78, 0x43, 0xec, 0xb6, 0x6a, 0xaa, 0xa2, 0xa3, 0x9a, 0x4e,
  0xc6, 0x21, 0xb6, 0xde, 0x61, 0x05, 0x1d, 0xfd, 0x8d, 0xd4, 0x73, 0xd0, 0xaf, 0xf5, 0x28, 0xa0,
  0x8e, 0xb0, 0xee, 0x92, 0x89, 0x9b, 0x51, 0x0d, 0xbd, 0x6b, 0xd6, 0x35, 0x62, 0xba, 0xc4, 0x5e,
  0x47, 0x57, 0xc8, 0x8b, 0xee, 0x66, 0x58, 0x37, 0x35, 0xd5, 0x30, 0xac, 0xa1, 0xcb, 0x07, 0xc2,
  0xb3, 0x86, 0x00, 0x1b, 0xe0, 0x1b, 0x44, 0xe3, 0x19, 0x4b, 0x09, 0x3e, 0x10, 0x75, 0x90, 0xe9,
  0xe9, 0xdd, 0x1e, 0x34, 0xd0, 0x73, 0xf9, 0x30, 0x5c, 0x1b, 0xba, 0x37, 0x50, 0x6d, 0x68, 0x6e,
  0xdd, 0xd1, 0x6c, 0xcb, 0x30, 0x5a, 0xaa, 0xcd, 0x9c, 0x42, 0xf5, 0x32, 0xf4, 0x31, 0x48, 0x8b,
  0xf6, 0xd6, 0x69, 0x09, 0x89, 0x50, 0x5d, 0x8a, 0x2d, 0x91, 0x62, 0xb4, 0x47, 0x10, 0x7c, 0x3d,
  0x27, 0xcb, 0x7f, 0xae, 0x33, 0x38, 0xf4, 0x71, 0x60, 0x39, 0x3a, 0x45, 0x72, 0x47, 0x9f, 0x90,
  0xf6, 0xba, 0x05, 0x8b, 0x1f, 0x83, 0x9d, 0x69, 0x91, 0x9e, 0x3a, 0xd2, 0x01, 0x36, 0x76, 0x76,
  0xfe, 0xbd, 0xd5, 0x0d, 0x81, 0x18, 0xf5, 0x02, 0x18, 0xa3, 0xf1, 0x22, 0x90, 0xb7, 0x8c, 0x6e,
  0xb6, 0xc9, 0xa4, 0x9e, 0xc9, 0x45, 0x08, 0xe4, 0x97, 0xe2, 0x48, 0x0c, 0x65, 0xd9, 0x64, 0x40,
  0x54, 0x44, 0x0b, 0x7f, 0x0a, 0xe7, 0x51, 0xc2, 0x68, 0xd8, 0xb1, 0x75, 0x6b, 0xa0, 0x6a, 0xba,
  0x3b, 0x05, 0xba, 0xd3, 0x31, 0x32, 0x68, 0x3c, 0x31, 0x91, 0x77, 0xe6, 0x03, 0x8f, 0x31, 0x28,
  0xd3, 0xc9, 0x89, 0x3c, 0xe5, 0xb2, 0x28, 0x86, 0xda, 0xc2, 0xbc, 0x35, 0x74, 0x5d, 0xcb, 0x9c,
  0x01, 0xc9, 0x0c, 0xdd, 0x24, 0x00, 0x4d, 0x1b, 0xda, 0x0e, 0x14, 0x19, 0x58, 0x3a, 0x76, 0x6c,
  0x2e, 0x19, 0x6a, 0x8b, 0x18, 0x4e, 0xc0, 0x65, 0x03, 0xb5, 0xdd, 0xd6, 0xcd, 0x6e, 0xbd, 0x1a,
  0x40, 0x9d, 0x7f, 0x47, 0x07, 0x19, 0x2d, 0x38, 0x5b, 0x18, 0x7e, 0xcb, 0x02, 0xf0, 0xfd, 0x3a,
  0x70, 0x85, 0x96, 0x62, 0xad, 0xb6, 0x7a, 0x42, 0x22, 0x9d, 0x00, 0xba, 0x09, 0xeb, 0x36, 0x45,
  0x61, 0x71, 0x89, 0xcd, 0xca, 0xc2, 0x42, 0x2f, 0xd6, 0xc7, 0x36, 0x00, 0x35, 0xbb, 0x99, 0xbe,
  0xd5, 0x26, 0x75, 0x18, 0x3d, 0x72, 0xaf, 0x91, 0xb1, 0x8d, 0xb9, 0xd4, 0xb2, 0xf5, 0x99, 0xd7,
  0x25, 0x80, 0x34, 0x97, 0xc6, 0xb6, 0x3a, 0x18, 0x10, 0x7b, 0xb1, 0x23, 0xae, 0x35, 0x80, 0xce,
  0x1b, 0xa4, 0x03, 0x13, 0x8b, 0x37, 0x1c, 0x26, 0x88, 0xdf, 0xb6, 0xdb, 0x12, 0x7c, 0x9a, 0xe5,
  0xe6, 0x12, 0xba, 0xe9, 0x9c, 0x38, 0xf7, 0x13, 0x9b, 0x27, 0xe8, 0xa8, 0x02, 0x4a, 0x81, 0xf8,
  0x34, 0x42, 0x33, 0x27, 0x8f, 0x43, 0x42, 0x74, 0x66, 0x3c, 0x2e, 0x59, 0x6f, 0xeb, 0xce, 0xc0,
  0x50, 0xa7, 0x75, 0xdd, 0xa4, 0xe9, 0x2d, 0xc3, 0xd2, 0x5e, 0xd6, 0x39, 0x4e, 0x33, 0x14, 0x89,
  0x89, 0x22, 0x45, 0xa5, 0xd4, 0x1b, 0x76, 0xb9, 0xbf, 0x8b, 0xc2, 0x2a, 0xe6, 0x71, 0x50, 0x30,
  0xf8, 0x69, 0x28, 0x31, 0x17, 0xe0, 0xec, 0xbb, 0xaa, 0xaa, 0xd0, 0x4d, 0xb3, 0x03, 0x22, 0xdb,
  0x45, 0x4f, 0x64, 0x06, 0x9a, 0xc1, 0x09, 0xc8, 0x86, 0x1d, 0x70, 0xf7, 0x5c, 0x72, 0x48, 0xd7,
  0x6d, 0xcf, 0x96, 0x27, 0x30, 0x4d, 0xa1, 0x4c, 0x84, 0x0b, 0x41, 0x7d, 0x88, 0xe8, 0xd3, 0x54,
  0x87, 0xac, 0x47, 0x1b, 0x9c, 0x4b, 0x2f, 0x64, 0x1a, 0x05, 0x80, 0xe8, 0xf4, 0x18, 0x22, 0xc3,
  0x49, 0x5d, 0xc5, 0x92, 0x23, 0xd5, 0x88, 0x96, 0xa4, 0x18, 0x8f, 0x2d, 0xea, 0x18, 0x7a, 0x1b,
  0x84, 0x01, 0x22, 0x7a, 0x16, 0x74, 0x82, 0x3e, 0x81, 0x94, 0x23, 0x29, 0xe0, 0x14, 0xb1, 0x80,
  0xdc, 0xb2, 0xc4, 0xba, 0x12, 0x59, 0x59, 0xeb, 0x3e, 0xb5, 0xa2, 0x0a, 0xc8, 0x9c, 0x95, 0x95,
  0xee, 0x56, 0x55, 0x22, 0x6d, 0x90, 0x4c, 0xb4, 0x96, 0xcf, 0x54, 0x6a, 0xcb, 0xb1, 0x8c, 0xa1,
  0x4b, 0x38, 0x2b, 0x65, 0xf2, 0x28, 0x88, 0x90, 0xc7, 0x70, 0xb6, 0xf9, 0xd4, 0xa6, 0xd2, 0x02,
  0xda, 0x54, 0x6d, 0x90, 0x8c, 0x2b, 0x00, 0x50, 0x96, 0xac, 0x86, 0x6b, 0x73, 0xa6, 0xcf, 0x90,
  0x11, 0xd0, 0xc7, 0x89, 0x02, 0xd1, 0x54, 0x53, 0xf3, 0x86, 0xb0, 0xaa, 0x33, 0x1e, 0xb0, 0x1a,
  0x32, 0x49, 0x74, 0x1e, 0x45, 0x3b, 0xd6, 0x31, 0xec, 0x59, 0xc7, 0xb0, 0x40, 0xd8, 0x30, 0xf2,
  0x2c, 0x14, 0xf6, 0xa7, 0xfc, 0xf2, 0x22, 0xe0, 0x23, 0xcf, 0xb6, 0x5c, 0x24, 0x92, 0x2c, 0x84,
  0xa5, 0x90, 0x9f, 0x9d, 0x90, 0x0a, 0x0e, 0xa0, 0x6f, 0x32, 0x98, 0x2d, 0xd5, 0xc8, 0x55, 0xe5,
  0x36, 0xe9, 0x02, 0x72, 0x75, 0x63, 0x16, 0x3b, 0x39, 0xfc, 0x59, 0xce, 0x18, 0xa8, 0xaf, 0xb7,
  0xdb, 0x06, 0x88, 0x5e, 0x43, 0x1f, 0x11, 0xdc, 0x30, 0xf0, 0x04, 0x70, 0x71, 0x01, 0xdd, 0x61,
  0x79, 0xde, 0xb2, 0x6c, 0x60, 0xad, 0xba, 0x1c, 0xd4, 0xca, 0x6f, 0x7b, 0xf5, 0x6a, 0x90, 0x1f,
  0x53, 0xaf, 0x16, 0xaa, 0xe6, 0x23, 0x20, 0xa1, 0x0e, 0x5d, 0x6b, 0x7d, 0x19, 0xdd, 0x88, 0xe4,
  0x12, 0x54, 0xa0, 0x24, 0xc4, 0x87, 0x38, 0xfe, 0xcd, 0x40, 0x86, 0x88, 0x7f, 0x60, 0xac, 0x30,
  0x41, 0x67, 0x4b, 0xab, 0x74, 0x78, 0x79, 0x5b, 0xe6, 0x3d, 0x98, 0x2a, 0x2b, 0x64, 0xaa, 0x2f,
  0xcd, 0xc2, 0x23, 0x5e, 0xa5, 0x02, 0x80, 0x58, 0xa3, 0xcd, 0x27, 0xb8, 0xbc, 0xff, 0xb0, 0x17,
  0x8c, 0x27, 0xe8, 0xe4, 0xe6, 0xb8, 0xa0, 0x18, 0x0a, 0x51, 0x98, 0xd6, 0x41, 0xea, 0x8a, 0x8b,
  0x80, 0x30, 0xf1, 0x63, 0x25, 0x42, 0xc3, 0x9e, 0x58, 0x03, 0xaf, 0x27, 0x9e, 0xf0, 0xe6, 0x5a,
  0x55, 0x6b, 0xc0, 0x06, 0x1d, 0x9f, 0x0d, 0x4a, 0x93, 0xc0, 0xc7, 0x9b, 0x2f, 0xfd, 0x19, 0x1e,
  0x51, 0xbd, 0x87, 0xab, 0xe2, 0xec, 0x03, 0x04, 0xf4, 0x16, 0xa7, 0x36, 0x89, 0xa0, 0x44, 0x42,
  0x05, 0x6b, 0x44, 0x3e, 0x82, 0xa0, 0x0a, 0xdf, 0xf4, 0x3e, 0xee, 0x54, 0xa9, 0x4b, 0xa4, 0xea,
  0x00, 0xac, 0xcf, 0x00, 0x94, 0x3f, 0xae, 0x8e, 0x5b, 0x4e, 0x2a, 0xf0, 0xbf, 0x0d, 0xaa, 0x37,
  0xac, 0xda, 0x61, 0xb2, 0xb2, 0xc7, 0xd0, 0x22, 0x6a, 0x0a, 0x3f, 0x31, 0x43, 0x58, 0xe7, 0xdc,
  0x4c, 0xb3, 0x30, 0x25, 0x91, 0xf1, 0xd4, 0xd3, 0x81, 0xe0, 0x3f, 0xc3, 0xd0, 0x05, 0xce, 0xcc,
  0x19, 0xe4, 0x59, 0xbf, 0x44, 0x2c, 0xc3, 0x86, 0x9a, 0xd1, 0x45, 0x59, 0xc8, 0x26, 0xfc, 0x26,
  0x33, 0xb4, 0x4d, 0x61, 0xb5, 0x62, 0x84, 0xe8, 0xe4, 0x3b, 0x67, 0xb3, 0x10, 0x13, 0xf9, 0xfc,
  0x6b, 0x13, 0x54, 0x5c, 0x47, 0x64, 0xc5, 0xd8, 0xf0, 0x3d, 0xeb, 0xb5, 0x26, 0xf8, 0x9a, 0x46,
  0x2e, 0x47, 0x55, 0x97, 0x96, 0x35, 0x41, 0x9e, 0xc2, 0x14, 0xc6, 0x95, 0xb0, 0x8c, 0x4c, 0x82,
  0xc9, 0x8a, 0x9d, 0x82, 0x36, 0xc7, 0x75, 0x3a, 0x59, 0xc3, 0x1a, 0xde, 0x6a, 0x3d, 0x6e, 0xa7,
  0xd3, 0x01, 0x0d, 0xd4, 0xf1, 0x98, 0x2c, 0xc3, 0x94, 0x84, 0x10, 0xa6, 0xb0, 0xe9, 0x38, 0x1c,
  0x63, 0xba, 0xe0, 0x2b, 0xad, 0x5e, 0xd3, 0x19, 0xd6, 0x0a, 0xf6, 0x90, 0x2a, 0xc3, 0x20, 0xb5,
  0xfb, 0x60, 0x4a, 0xf5, 0x66, 0xb1, 0xb2, 0x31, 0x84, 0xe7, 0x8e, 0x98, 0x13, 0x7e, 0x4a, 0x25,
  0x47, 0x48, 0x10, 0x58, 0x77, 0x33, 0xb0, 0x7c, 0x53, 0x54, 0x66, 0x98, 0x4a, 0xe5, 0x8b, 0x21,
  0x39, 0x91, 0x29, 0x51, 0x54, 0x2c, 0xac, 0xa3, 0x61, 0x19, 0xe8, 0x51, 0x1c, 0x65, 0x07, 0xf6,
  0x0b, 0xd2, 0x16, 0xe5, 0xc7, 0x0a, 0xed, 0x37, 0xa2, 0x21, 0xad, 0x64, 0xe2, 0x82, 0xb0, 0xa8,
  0xe8, 0x78, 0x2d, 0x77, 0x0c, 0x32, 0x59, 0xa7, 0xc2, 0x3a, 0xa3, 0xbb, 0xa4, 0xef, 0x78, 0xea,
  0xc5, 0xf3, 0xd0, 0x71, 0xf5, 0xce, 0x34, 0xc3, 0x19, 0xc3, 0x4b, 0xf6, 0x95, 0xac, 0x9c, 0xaf,
  0xca, 0x4a, 0xb5, 0x52, 0x58, 0xc8, 0x48, 0x15, 0x67, 0xc5, 0x5a, 0xe8, 0xaa, 0x53, 0xe8, 0xad,
  0xbf, 0x6e, 0xb0, 0x05, 0xc3, 0x1f, 0xa5, 0x47, 0x16, 0x68, 0x56, 0x7b, 0x99, 0x06, 0xe9, 0xfc,
  0x3d, 0x46, 0xe9, 0x03, 0x03, 0x89, 0x8d, 0xde, 0xef, 0x54, 0x84, 0x09, 0x60, 0x90, 0x5c, 0xe6,
  0x54, 0x40, 0x1b, 0xf3, 0x96, 0x05, 0xca, 0x67, 0x9c, 0x13, 0x6d, 0xb5, 0xad, 0x0f, 0x1d, 0x90,
  0x49, 0xa0, 0xd1, 0x7c, 0xef, 0x4c, 0x5a, 0x32, 0x27, 0x9a, 0x47, 0x21, 0xac, 0xd6, 0xd1, 0x0d,
  0x18, 0x49, 0xbd, 0x6d, 0x5b, 0x83, 0x8c, 0xd3, 0x53, 0xdb, 0xd6, 0x38, 0x85, 0x24, 0x45, 0xe6,
  0xfe, 0x2e, 0xcb, 0x32, 0xd0, 0xab, 0xa3, 0xdb, 0x8e, 0x3b, 0x0b, 0xb7, 0x8c, 0x36, 0xe0, 0x77,
  0xd7, 0x52, 0x21, 0x39, 0xd0, 0xf7, 0x57, 0xd2, 0xa6, 0x84, 0xb3, 0x7c, 0x92, 0x09, 0x56, 0xb2,
  0x2f, 0x58, 0x6f, 0xd1, 0x01, 0x94, 0x50, 0xfd, 0xf0, 0xa6, 0x5d, 0x99, 0xea, 0x22, 0xb1, 0xd6,
  0x4c, 0xe9, 0xc3, 0x35, 0xef, 0x8e, 0x2e, 0x7a, 0xc2, 0x4a, 0xe5, 0x3f, 0x9f, 0xc7, 0xd9, 0xb3,
  0xb0, 0x48, 0xc4, 0x51, 0x9a, 0x0d, 0x5d, 0x72, 0x7a, 0xd6, 0xd8, 0x1f, 0x7f, 0x6e, 0x1d, 0x2c,
  0xe0, 0xbe, 0xca, 0x3a, 0xa5, 0xb6, 0x89, 0x6e, 0x26, 0x60, 0xe6, 0x88, 0xc1, 0x63, 0x22, 0x8f,
  0x7f, 0x6c, 0x82, 0xb3, 0xde, 0x07, 0x41, 0x6c, 0xdb, 0xb2, 0x43, 0x30, 0x96, 0x70, 0xf8, 0xbd,
  0x95, 0x8f, 0x87, 0x3c, 0x97, 0xc0, 0xe8, 0x50, 0x97, 0x0c, 0x1b, 0x6f, 0x9e, 0x78, 0x6b, 0xb1,
  0x67, 0x52, 0x20, 0xd9, 0x42, 0x03, 0x76, 0x7b, 0x28, 0x86, 0xa9, 0xb4, 0x58, 0x49, 0x36, 0x2b,
  0x56, 0x0e, 0xdf, 0xa7, 0x98, 0x84, 0x8f, 0xd7, 0xab, 0x8a, 0x4e, 0xd8, 0x10, 0x5b, 0xc4, 0x65,
  0x44, 0x16, 0xf2, 0x01, 0x7c, 0x71, 0x9d, 0x2c, 0x0a, 0xf3, 0xef, 0x68, 0x4d, 0xcc, 0x3c, 0x52,
  0x17, 0xc0, 0xba, 0x03, 0xab, 0xcb, 0x11, 0xbf, 0xdb, 0xb4, 0xa6, 0x97, 0x9e, 0x87, 0xf4, 0xb6,
  0xe1, 0xfa, 0x56, 0x26, 0xb3, 0x04, 0x99, 0xe6, 0x9f, 0xd0, 0x17, 0x8c, 0x95, 0x39, 0xab, 0x0c,
  0x13, 0x37, 0xd6, 0x30, 0x5b, 0x40, 0x58, 0x3a, 0x51, 0x42, 0x84, 0x51, 0x14, 0xe7, 0x16, 0xf5,
  0xbb, 0x05, 0xfb, 0xf4, 0x3b, 0x88, 0x15, 0x13, 0x7a, 0xf4, 0x55, 0xc3, 0x33, 0x80, 0x5c, 0x0c,
  0xf1, 0x3a, 0xf2, 0xfd, 0xf2, 0x4c, 0x58, 0x66, 0x12, 0xb5, 0x16, 0xc8, 0x88, 0x0c, 0x60, 0x40,
  0xef, 0x77, 0xc7, 0xb3, 0x8f, 0x6c, 0x3b, 0x34, 0x71, 0xbe, 0xbf, 0x98, 0xe2, 0xf7, 0x97, 0xd1,
  0x2c, 0x98, 0x9b, 0xc5, 0x5a, 0xd8, 0x4a, 0x08, 0xd7, 0xc3, 0xc2, 0x09, 0x30, 0x9d, 0x16, 0x24,
  0x3c, 0x62, 0x17, 0xb4, 0xd8, 0x30, 0x8c, 0xb2, 0xbc, 0x1a, 0x46, 0x0f, 0x8c, 0x05, 0x77, 0xb6,
  0xac, 0xaf, 0xd5, 0x22, 0xaa, 0x59, 0xd9, 0x57, 0xcd, 0x6c, 0xd2, 0x9e, 0xc3, 0x50, 0x42, 0xd0,
  0xe9, 0x8a, 0x80, 0xaf, 0xa1, 0xc5, 0x02, 0x6c, 0x6b, 0x7d, 0x46, 0xe3, 0x57, 0x32, 0xa0, 0x26,
  0x02, 0xae, 0x10, 0x73, 0x03, 0xc0, 0x36, 0xb2, 0x6b, 0x7b, 0x7d, 0x31, 0x47, 0xb3, 0xa1, 0x6f,
  0x19, 0xd2, 0xee, 0x12, 0xc7, 0x13, 0x9f, 0x54, 0x9e, 0xfd, 0x07, 0x98, 0x91, 0x1d, 0x5b, 0xed,
  0x13, 0x27, 0xc1, 0x66, 0xd9, 0xac, 0x63, 0x5b, 0xfd, 0x99, 0x3f, 0x93, 0x7c, 0x41, 0x37, 0x77,
  0xad, 0xd9, 0xc7, 0x22, 0xc4, 0x9f, 0xcf, 0x73, 0xcf, 0x8e, 0xe4, 0xf8, 0x98, 0x79, 0x8b, 0xcd,
  0x5f, 0x7f, 0xad, 0xd0, 0xdb, 0x73, 0x20, 0x25, 0x28, 0xd1, 0x39, 0x7e, 0xe9, 0x1b, 0xe3, 0x38,
  0xf4, 0xdc, 0xb1, 0xe9, 0x4c, 0x1f, 0x63, 0xd6, 0x8b, 0xa2, 0xb0, 0xc0, 0x2d, 0xab, 0x24, 0x58,
  0xc8, 0xfd, 0x83, 0x5e, 0xbd, 0x6e, 0x58, 0xe1, 0xfb, 0x6e, 0xa3, 0xab, 0x22, 0xb1, 0xd0, 0x71,
  0x5a, 0xea, 0x7b, 0x47, 0x06, 0xa3, 0xa5, 0xbb, 0x3a, 0x5f, 0xee, 0x40, 0x7e, 0xeb, 0x83, 0x7c,
  0xb9, 0x03, 0x9c, 0x14, 0x93, 0x2f, 0x7e, 0x1f, 0xb7, 0x40, 0x16, 0x2c, 0x54, 0x0a, 0x0d, 0x11,
  0xd9, 0x48, 0xb5, 0x33, 0x5d, 0x1c, 0x18, 0x0c, 0x23, 0x55, 0x43, 0x33, 0x4d, 0xfc, 0xde, 0xe9,
  0x54, 0x3b, 0xb9, 0x4e, 0x42, 0xc6, 0xa7, 0x4e, 0x02, 0x4d, 0x9a, 0xef, 0x5a, 0xab, 0xdd, 0xea,
  0xa0, 0xe2, 0xca, 0x60, 0xb5, 0x86, 0xad, 0x96, 0x41, 0x66, 0x8c, 0xd2, 0x85, 0xf2, 0x82, 0x07,
  0x84, 0x6a, 0x0a, 0x31, 0x98, 0x04, 0x75, 0x22, 0x86, 0x3e, 0x1f, 0x2d, 0x29, 0x11, 0xb4, 0x07,
  0xcb, 0x71, 0x86, 0xd1, 0x2e, 0x94, 0x80, 0x54, 0x2e, 0x84, 0xe6, 0xb8, 0xbc, 0x30, 0x59, 0xe6,
  0x52, 0x0f, 0x6c, 0x4a, 0x62, 0xce, 0x22, 0x46, 0xb1, 0x6e, 0x0e, 0x86, 0xee, 0xa3, 0x3b, 0x1d,
  0x10, 0x05, 0xda, 0xee, 0x92, 0xa7, 0x99, 0xa7, 0x4e, 0xa0, 0x5b, 0x49, 0xb5, 0xd1, 0xfe, 0x0e,
  0x1b, 0x8c, 0xf9, 0xbc, 0x1c, 0x69, 0xc3, 0x57, 0xd6, 0xb8, 0xdb, 0x8d, 0x5a, 0xf4, 0x1f, 0xdb,
  0x7c, 0x51, 0x81, 0xb6, 0xd4, 0x81, 0x7a, 0xc7, 0xd2, 0x86, 0x4e, 0xe0, 0xa1, 0x8b, 0x29, 0x11,
  0xa8, 0x3c, 0xcc, 0x99, 0x62, 0x0f, 0x4d, 0x93, 0xfa, 0x82, 0xa0, 0x1d, 0xed, 0x65, 0x16, 0x9a,
  0xd2, 0x9c, 0x1c, 0x05, 0x79, 0xd9, 0x37, 0x10, 0xa2, 0x0e, 0xe8, 0x25, 0x5f, 0x68, 0xc5, 0xed,
  0x0d, 0xfb, 0x2d, 0xdf, 0x11, 0x5a, 0xf6, 0xb5, 0x24, 0xfa, 0x18, 0x33, 0x3f, 0x62, 0xc8, 0xdf,
  0x59, 0xf2, 0xf4, 0xad, 0xc2, 0x76, 0x88, 0xa8, 0x00, 0x2b, 0xb6, 0x77, 0x7d, 0xeb, 0x2d, 0x43,
  0x5f, 0x3e, 0x1e, 0xf6, 0x12, 0x31, 0xa8, 0x83, 0x5f, 0x16, 0xe9, 0xbf, 0xc2, 0x67, 0x90, 0xe9,
  0x98, 0x3d, 0xa3, 0x23, 0x01, 0x0c, 0xab, 0xb7, 0xc3, 0x4e, 0xe6, 0xf5, 0xff, 0x2c, 0x3a, 0x62,
  0x35, 0x01, 0x28, 0x1e, 0xd7, 0x31, 0x66, 0x70, 0xa6, 0xa3, 0x13, 0x30, 0xca, 0xe4, 0x1f, 0xcc,
  0xa5, 0xf9, 0xf7, 0x81, 0x6a, 0xa0, 0x88, 0x10, 0xbf, 0x0f, 0xd8, 0x0f, 0x20, 0x82, 0x3d, 0xa0,
  0x8c, 0x80, 0xbf, 0xf8, 0x32, 0x5b, 0xf0, 0x65, 0xd1, 0xa6, 0x68, 0x86, 0x87, 0xd3, 0x90, 0x7a,
  0x5c, 0x94, 0xc3, 0x2a, 0xa3, 0x67, 0xed, 0x41, 0xad, 0x56, 0xe0, 0x40, 0x4e, 0x64, 0x70, 0xc6,
  0xe0, 0x3a, 0x9c, 0xc8, 0x94, 0xa9, 0x03, 0x70, 0xec, 0x65, 0xb2, 0x39, 0x9c, 0x41, 0xfa, 0x4a,
  0xbd, 0xf6, 0x2c, 0xc6, 0xa4, 0xf9, 0xde, 0xb2, 0x75, 0xda, 0x78, 0xd8, 0x6d, 0xb5, 0x64, 0xd9,
  0xb6, 0xfa, 0x2e, 0x8e, 0x0e, 0xb4, 0x7d, 0xd0, 0x57, 0xc2, 0x5e, 0x70, 0xaa, 0xb2, 0xf3, 0xbe,
  0x96, 0x71, 0x2d, 0x92, 0x5a, 0x6e, 0xe0, 0x62, 0xa8, 0x06, 0xba, 0x3d, 0x9d, 0xb5, 0xbc, 0x20,
  0x65, 0x9a, 0xd0, 0xb2, 0x59, 0x8b, 0xe3, 0xa1, 0x90, 0x3c, 0x5b, 0x52, 0xba, 0x17, 0xe7, 0x59,
  0x94, 0x79, 0xe8, 0xb6, 0xda, 0xb2, 0x19, 0x11, 0xd2, 0xfb, 0x32, 0xed, 0xa1, 0xcd, 0xb4, 0x52,
  0xaa, 0x8e, 0x4e, 0x26, 0x0e, 0x67, 0x6d, 0x8a, 0x6e, 0xcf, 0x0f, 0x26, 0x07, 0xbd, 0x2f, 0xf3,
  0x91, 0x65, 0xbc, 0x82, 0xf9, 0x4a, 0xf9, 0xa3, 0x4e, 0xe7, 0x05, 0x56, 0x5c, 0x9f, 0x2d, 0x1b,
  0x96, 0x3c, 0x07, 0xfd, 0x8d, 0x3e, 0x05, 0xd1, 0xf5, 0x4f, 0xbd, 0xd5, 0x2b, 0x9c, 0x74, 0xb4,
  0xca, 0xc0, 0x6b, 0x3b, 0xe7, 0x77, 0x67, 0x60, 0x64, 0xda, 0x51, 0x7b, 0x56, 0x4e, 0x14, 0x42,
  0x99, 0xd0, 0xb8, 0x97, 0x59, 0xa0, 0xc2, 0x93, 0x36, 0x35, 0xff, 0xfe, 0xaa, 0x39, 0x99, 0xf1,
  0xa2, 0x5d, 0xb4, 0xe0, 0xcb, 0x84, 0x32, 0x3e, 0x21, 0xa9, 0x7b, 0x9c, 0x03, 0xca, 0x2f, 0x4f,
  0xbe, 0xe2, 0x2a, 0xbd, 0x09, 0x81, 0xb4, 0x02, 0x28, 0x05, 0xbf, 0x2a, 0x6a, 0xa1, 0x9c, 0x5c,
  0xe1, 0x05, 0xbc, 0x47, 0x26, 0x91, 0x6e, 0x95, 0x16, 0x7b, 0xf5, 0xdd, 0x75, 0x97, 0xfd, 0xed,
  0x73, 0x49, 0x33, 0xbc, 0x65, 0xb2, 0x4a, 0xd5, 0x0e, 0x6f, 0x26, 0xb1, 0x37, 0xde, 0xf1, 0x4a,
  0xac, 0x02, 0x0a, 0x86, 0x22, 0x73, 0x84, 0x50, 0x03, 0x92, 0xe3, 0x30, 0x87, 0xf5, 0x28, 0x23,
  0x51, 0x07, 0x37, 0xd1, 0x40, 0x1d, 0xc3, 0x46, 0x96, 0x0a, 0x46, 0x8a, 0x01, 0xc6, 0x3d, 0x11,
  0x59, 0xcb, 0x47, 0x1b, 0xf3, 0xa7, 0x70, 0xae, 0x8c, 0xb4, 0xa6, 0x12, 0x2c, 0x50, 0x68, 0x13,
  0x9c, 0x38, 0x1e, 0x14, 0x12, 0xa6, 0x74, 0x3c, 0x18, 0x6c, 0x80, 0x82, 0x99, 0xb3, 0xfe, 0xad,
  0x5c, 0x54, 0x17, 0xdf, 0x43, 0x42, 0x12, 0x83, 0x7d, 0xc3, 0x31, 0xd4, 0xce, 0xa8, 0x9b, 0x9e,
  0xf4, 0x8d, 0xf5, 0xa1, 0xdb, 0xa9, 0x8a, 0xbf, 0xe0, 0x2d, 0x01, 0x6f, 0xa6, 0xa3, 0xfc, 0xd5,
  0x73, 0xdd, 0x41, 0x3d, 0x9b, 0x1d, 0x8f, 0xc7, 0xd2, 0xb8, 0x20, 0x59, 0x76, 0x37, 0x9b, 0x07,
  0xb4, 0x61, 0xf9, 0xbf, 0x12, 0x2c, 0xae, 0xfc, 0x2f, 0x58, 0x14, 0xfe, 0x4a, 0x30, 0xb4, 0xf3,
  0x17, 0xb0, 0xce, 0x0d, 0xe5, 0xaf, 0x71, 0x4f, 0x77, 0xc9, 0x5f, 0xbf, 0x7f, 0x0d, 0x2c, 0x63,
  0xda, 0xb5, 0xcc, 0x04, 0x9d, 0xb3, 0x00, 0x12, 0x56, 0x06, 0x58, 0xc9, 0xf1, 0x6f, 0x49, 0x16,
  0x4b, 0xf2, 0x5f, 0xd9, 0xdf, 0xbf, 0x10, 0xde, 0xef, 0xa4, 0x90, 0x58, 0xbd, 0x4f, 0x97, 0x5b,
  0x85, 0xd5, 0xbc, 0x5c, 0xf6, 0xb0, 0xea, 0x4d, 0x38, 0x5f, 0x7b, 0x09, 0xb9, 0x08, 0x3f, 0xda,
  0x13, 0x0c, 0xb4, 0x01, 0xbe, 0x8b, 0x4a, 0xd7, 0x28, 0xaa, 0x29, 0xa0, 0xf2, 0x3d, 0x8b, 0x93,
  0x1e, 0xb2, 0xb3, 0xbe, 0xac, 0x7d, 0x50, 0xf6, 0x8c, 0x30, 0x09, 0x65, 0x10, 0x6b, 0x80, 0x55,
  0x66, 0x7f, 0x47, 0xce, 0x85, 0x17, 0x28, 0x13, 0x56, 0x49, 0x62, 0x3f, 0x89, 0xa1, 0x24, 0x6c,
  0xe8, 0x69, 0x16, 0xaf, 0x02, 0x2e, 0x89, 0xcc, 0x2f, 0xca, 0xc8, 0x18, 0xc9, 0x8d, 0x98, 0xf5,
  0xfe, 0x97, 0x17, 0xc5, 0x76, 0xc8, 0x22, 0x5a, 0xf6, 0x5b, 0xe7, 0x9d, 0x00, 0xab, 0x5c, 0xf6,
  0x97, 0xe8, 0x76, 0xfe, 0x32, 0xab, 0xe2, 0x58, 0x3a, 0x3a, 0x31, 0xda, 0xeb, 0x71, 0x89, 0x73,
  0x7c, 0x02, 0xec, 0xaa, 0x71, 0xa3, 0xcd, 0xc7, 0x8c, 0xd6, 0x5b, 0x68, 0xca, 0x81, 0x2c, 0xa0,
  0x06, 0x62, 0x8c, 0x45, 0xca, 0xf0, 0x92, 0xf7, 0xc5, 0x11, 0x0d, 0xb4, 0x08, 0xba, 0x6d, 0x13,
  0x3a, 0x58, 0x3a, 0x75, 0xa2, 0x63, 0x9f, 0xd7, 0xeb, 0x8c, 0x53, 0xa2, 0x64, 0xf5, 0xbb, 0xd1,
  0x8a, 0xd0, 0x8f, 0x11, 0xcb, 0x57, 0xa0, 0x10, 0x75, 0x4b, 0x62, 0x6c, 0xb1, 0xb8, 0x34, 0x70,
  0x27, 0xae, 0x27, 0x0a, 0xe4, 0xd0, 0x72, 0x94, 0xa7, 0xb4, 0xa0, 0x14, 0xa1, 0x76, 0xec, 0x52,
  0x45, 0x07, 0x2b, 0x46, 0x8c, 0xfc, 0x90, 0x50, 0x2d, 0xc7, 0xd5, 0x78, 0x35, 0x82, 0xb6, 0x90,
  0x48, 0x31, 0xbc, 0xc7, 0xd4, 0xe6, 0x25, 0x0e, 0xe4, 0xda, 0x74, 0x0c, 0x06, 0xca, 0x71, 0x1c,
  0x1c, 0x28, 0xbd, 0xba, 0x69, 0x62, 0xcc, 0xc2, 0x00, 0x9d, 0x7a, 0xd4, 0x93, 0x22, 0x7e, 0x54,
  0x1a, 0x48, 0x12, 0x2d, 0xbd, 0x4a, 0xe2, 0xcd, 0xa5, 0x81, 0x61, 0xf2, 0x91, 0x94, 0x2b, 0x91,
  0xf9, 0xef, 0xaf, 0x93, 0x48, 0x6e, 0xba, 0xdd, 0x1e, 0xca, 0x8c, 0x59, 0x56, 0x00, 0x90, 0x27,
  0xd1, 0xab, 0x21, 0x89, 0xcd, 0x37, 0xe9, 0x13, 0xf2, 0x8a, 0x45, 0x6f, 0x60, 0xe8, 0xfe, 0x72,
  0x14, 0xae, 0x85, 0xff, 0xe6, 0x6b, 0x2b, 0xd7, 0x4a, 0x87, 0x74, 0xcd, 0xd9, 0x12, 0x87, 0x2e,
  0x77, 0xbf, 0xe0, 0x13, 0x3f, 0xd4, 0x7d, 0xda, 0x59, 0xb5, 0x4f, 0x44, 0x69, 0xc0, 0x7e, 0x10,
  0x1a, 0x3c, 0xac, 0xda, 0x1f, 0xfd, 0xc4, 0xd1, 0x48, 0xc5, 0x36, 0x60, 0x5b, 0xa5, 0x48, 0x45,
  0x05, 0x71, 0x29, 0x8c, 0x01, 0x1b, 0x40, 0x9e, 0x09, 0xb9, 0x38, 0x50, 0x03, 0x0c, 0x5c, 0x65,
  0xcc, 0x18, 0x64, 0x78, 0xf5, 0x13, 0x35, 0x43, 0x1f, 0xcc, 0xfd, 0xce, 0x31, 0x1f, 0xb1, 0x27,
  0x74, 0x6a, 0xcc, 0xe1, 0x15, 0x19, 0x88, 0xcf, 0xfe, 0xd5, 0xa8, 0x74, 0x02, 0xe4, 0x2f, 0xbb,
  0x5e, 0xbf, 0xd2, 0xf4, 0xc0, 0x6f, 0x38, 0x87, 0x8a, 0x12, 0x6b, 0x8c, 0x75, 0x04, 0xde, 0xf4,
  0xf6, 0x2c, 0xde, 0xbb, 0xe1, 0xfb, 0xf1, 0xa3, 0x7b, 0x28, 0xa8, 0x2b, 0xe4, 0xa2, 0xda, 0x6c,
  0x60, 0xa7, 0xe4, 0x63, 0xa7, 0xf9, 0x82, 0xb4, 0xc2, 0x6d, 0x44, 0x93, 0x8c, 0x01, 0x23, 0x33,
  0x8e, 0xe1, 0x36, 0xe9, 0xa8, 0x43, 0xc3, 0xc5, 0x50, 0x09, 0x5f, 0x75, 0x2a, 0xf3, 0xc6, 0xb0,
  0x8f, 0x8e, 0xeb, 0xcc, 0xfe, 0x33, 0xea, 0xb2, 0x07, 0x33, 0xef, 0xc1, 0x0c, 0x6b, 0xbc, 0xa0,
  0x4b, 0x99, 0x9d, 0xd9, 0xa7, 0x1a, 0x77, 0xec, 0xa2, 0xb3, 0xda, 0xf3, 0x4d, 0xf5, 0xb0, 0x44,
  0x3e, 0xc7, 0xcc, 0x94, 0x25, 0xb7, 0x01, 0x58, 0x4b, 0xb3, 0xa5, 0x80, 0x95, 0xb8, 0x9d, 0xb4,
  0xbc, 0x1f, 0xba, 0xb0, 0xc0, 0x8c, 0x60, 0xb8, 0xcd, 0x96, 0x37, 0x00, 0xdb, 0xe1, 0xf0, 0x19,
  0x9f, 0x9c, 0x41, 0xac, 0x44, 0xb0, 0xbd, 0x3f, 0x97, 0x3a, 0xf6, 0xdb, 0x8c, 0x92, 0xb8, 0x10,
  0xf1, 0xd2, 0x2f, 0x30, 0xc1, 0x0a, 0x54, 0x52, 0x08, 0x64, 0x32, 0x50, 0xcd, 0x36, 0x69, 0x27,
  0x28, 0xac, 0xa8, 0x32, 0xad, 0xf5, 0x88, 0xf6, 0x22, 0x4a, 0x88, 0x1a, 0x2b, 0xde, 0xbd, 0xb9,
  0xbc, 0xa5, 0xb7, 0x60, 0x3a, 0x14, 0x42, 0x9e, 0x18, 0xcf, 0xc9, 0x56, 0x5c, 0x76, 0x3a, 0xc4,
  0x88, 0x31, 0x47, 0xeb, 0xbd, 0x18, 0xb3, 0x30, 0xd9, 0xe9, 0xa6, 0x57, 0xa2, 0x50, 0x5a, 0x92,
  0x4e, 0x38, 0x0e, 0x9b, 0x8c, 0x96, 0x2a, 0xc8, 0xd1, 0xe2, 0x19, 0xdf, 0xb7, 0x18, 0x5a, 0x57,
  0x18, 0x1a, 0x27, 0xac, 0xee, 0x47, 0x93, 0x88, 0x16, 0xa4, 0x18, 0x49, 0x50, 0x89, 0xcf, 0xf1,
  0xc2, 0x5e, 0x62, 0xaa, 0x06, 0x1b, 0x35, 0x0b, 0x63, 0xe5, 0x7c, 0xeb, 0x29, 0x17, 0x32, 0x87,
  0x0a, 0x7d, 0xf2, 0x70, 0x8d, 0x8f, 0xab, 0x44, 0xa0, 0xcf, 0xf7, 0xd4, 0x95, 0xe6, 0x19, 0xdc,
  0x1f, 0x99, 0x75, 0xcb, 0x5e, 0x4a, 0xd9, 0x1f, 0x0a, 0x6d, 0xc9, 0x5b, 0x5e, 0x43, 0x8d, 0x2f,
  0x4c, 0x8a, 0xb8, 0x90, 0x82, 0x88, 0xf6, 0xc8, 0xdd, 0x31, 0x94, 0x68, 0xbe, 0x58, 0x72, 0x46,
  0x8c, 0x37, 0xf9, 0x89, 0x4d, 0x8f, 0x85, 0xbd, 0x57, 0x86, 0x5b, 0xbe, 0x61, 0x42, 0x8b, 0x47,
  0xa9, 0x87, 0x94, 0xe3, 0xee, 0xb3, 0xf5, 0x45, 0xa3, 0x6f, 0x81, 0xa0, 0x7c, 0x34, 0x6c, 0x53,
  0x83, 0x51, 0xe4, 0x7f, 0x85, 0x06, 0xf8, 0xc1, 0x4e, 0x59, 0x84, 0xa4, 0x75, 0xfa, 0x4c, 0xda,
  0x5f, 0xaa, 0x5b, 0x16, 0x42, 0x38, 0xac, 0xab, 0x1d, 0x20, 0x6d, 0x88, 0x7c, 0x2c, 0xc1, 0xf7,
  0x3f, 0x27, 0x93, 0x31, 0x93, 0x33, 0x66, 0xb2, 0xad, 0xec, 0x47, 0xa4, 0x81, 0xc5, 0x52, 0x8b,
  0xad, 0x46, 0x36, 0x44, 0x3d, 0xc8, 0x8b, 0xb0, 0x66, 0x91, 0x88, 0xa3, 0x80, 0x99, 0x42, 0x96,
  0x68, 0x2e, 0xd0, 0x3e, 0xeb, 0x8b, 0x66, 0xaf, 0xc7, 0x53, 0x9c, 0x89, 0xa9, 0x31, 0x58, 0x60,
  0x11, 0xac, 0x5e, 0x0c, 0xe7, 0x62, 0xac, 0x4f, 0xb1, 0x84, 0xa1, 0x3e, 0xeb, 0x99, 0xbe, 0xb3,
  0x32, 0x6f, 0x45, 0x3a, 0x67, 0xcd, 0xc4, 0xd2, 0x48, 0xf9, 0x12, 0x9e, 0x0f, 0xf5, 0x39, 0xcf,
  0x47, 0x14, 0x89, 0xc8, 0xf1, 0x42, 0xec, 0x96, 0x7d, 0x70, 0x51, 0xde, 0x8e, 0x08, 0xe2, 0x5e,
  0x78, 0xf7, 0xaa, 0xf0, 0xc5, 0x55, 0xb1, 0x35, 0x58, 0xd8, 0xf3, 0x2d, 0xd1, 0x05, 0x1b, 0x34,
  0x72, 0xaa, 0xdd, 0xcc, 0x96, 0x25, 0x66, 0xbc, 0x60, 0xfd, 0xd8, 0x19, 0x55, 0xfe, 0x3b, 0xce,
  0xa8, 0xfc, 0xbf, 0x67, 0x59, 0x2d, 0xe8, 0x01, 0x34, 0x84, 0xe3, 0x43, 0xcb, 0xa9, 0xe4, 0x78,
  0x9b, 0xdb, 0x2d, 0x3a, 0xab, 0x4d, 0xe2, 0x38, 0xa9, 0x9c, 0x10, 0x38, 0x23, 0x3e, 0xdc, 0x6e,
  0x0c, 0x5c, 0x16, 0x88, 0xa6, 0x0f, 0x9d, 0x54, 0x5e, 0xc9, 0x44, 0x58, 0x72, 0x06, 0x89, 0x94,
  0x49, 0x3e, 0x99, 0xbd, 0xd8, 0xa0, 0xa1, 0x3b, 0x6e, 0x0c, 0x3d, 0x3e, 0x1b, 0x63, 0x68, 0xdf,
  0x9f, 0x7a, 0x12, 0x99, 0x6f, 0x7f, 0x71, 0xa7, 0x6e, 0xc1, 0x73, 0x08, 0xad, 0x39, 0xee, 0xc1,
  0x6c, 0x31, 0x08, 0x61, 0x41, 0xf7, 0xc3, 0x95, 0x08, 0x5d, 0x91, 0x9e, 0xc5, 0xe4, 0x3b, 0x2b,
  0x23, 0x3a, 0x24, 0x83, 0xb5, 0xb4, 0x83, 0x1b, 0x1d, 0x1b, 0x96, 0x30, 0x54, 0xc7, 0xcd, 0x68,
  0x3d, 0xdd, 0x68, 0xcf, 0x42, 0x01, 0x5c, 0x2c, 0xd3, 0xc7, 0x97, 0xc8, 0x5f, 0x69, 0x87, 0x66,
  0x41, 0xcc, 0x2b, 0xba, 0x85, 0x11, 0x43, 0x89, 0x68, 0x71, 0x2a, 0xdd, 0x0b, 0xe5, 0x60, 0xcf,
  0x2c, 0x83, 0xaa, 0xe4, 0x52, 0x69, 0x06, 0x0d, 0xcb, 0xb2, 0xfc, 0xa5, 0xe4, 0x5c, 0xc9, 0xc7,
  0x0a, 0xd5, 0x65, 0xc3, 0x66, 0xc2, 0xe7, 0x8a, 0xfc, 0xa2, 0x55, 0x4b, 0xe1, 0xc0, 0x24, 0x1b,
  0xcd, 0xc2, 0xdb, 0x31, 0x5c, 0x24, 0x94, 0x16, 0x82, 0x35, 0x56, 0x2a, 0x57, 0x7c, 0xa5, 0x2f,
  0xc5, 0x1a, 0xa7, 0x34, 0xf0, 0x72, 0x21, 0xd6, 0x24, 0xec, 0x1a, 0x8e, 0x8f, 0x4b, 0x0a, 0x13,
  0x0e, 0xff, 0x47, 0x6b, 0xa1, 0xb0, 0xe0, 0xa7, 0xa0, 0x4c, 0xc4, 0xa3, 0x0b, 0x17, 0x27, 0xdc,
  0x07, 0x2a, 0xf3, 0xaa, 0x3e, 0x2e, 0x99, 0xb6, 0xcb, 0xac, 0xbf, 0xaa, 0xa6, 0x69, 0xb9, 0xa9,
  0x3a, 0x8c, 0x4f, 0x23, 0x3d, 0xcb, 0xc0, 0x21, 0x60, 0xc8, 0x85, 0x29, 0x7c, 0xbc, 0x80, 0xa2,
  0x6c, 0x5b, 0x90, 0x79, 0xcc, 0xa1, 0x4f, 0x20, 0x65, 0xb6, 0x88, 0x80, 0x22, 0xfb, 0x5d, 0x58,
  0xfc, 0x3c, 0x2d, 0x74, 0x69, 0xe9, 0x8a, 0xf3, 0x9b, 0x0e, 0xac, 0xfc, 0x4a, 0x37, 0x01, 0xd5,
  0xd2, 0x06, 0x63, 0xd5, 0x36, 0x67, 0xc1, 0x9e, 0xb6, 0xd4, 0x03, 0xd5, 0x96, 0xd1, 0x2a, 0x1c,
  0x15, 0x96, 0xff, 0x48, 0x68, 0x52, 0x0b, 0xc7, 0xca, 0x30, 0xd0, 0xbe, 0xaf, 0x7a, 0x1e, 0xda,
  0xfd, 0xf2, 0x8e, 0x1b, 0xcc, 0xfc, 0x23, 0x08, 0x71, 0xb9, 0x7c, 0x13, 0x6a, 0x61, 0x57, 0x2d,
  0xb6, 0x20, 0xdb, 0x53, 0x5a, 0x9e, 0xcf, 0x4e, 0x2b, 0xd8, 0xe2, 0x96, 0xf2, 0xcb, 0x06, 0xcb,
  0x6a, 0x68, 0xab, 0x65, 0x84, 0xd3, 0xea, 0x09, 0xf3, 0xff, 0xe8, 0x93, 0xb6, 0xae, 0x26, 0x60,
  0xe6, 0x26, 0x00, 0xfb, 0x89, 0x54, 0x60, 0x14, 0x17, 0x50, 0xf9, 0x12, 0x66, 0xf1, 0x5b, 0x4a,
  0x94, 0x64, 0x1f, 0x54, 0x2e, 0xe1, 0xd4, 0x16, 0x78, 0x2a, 0xd0, 0x85, 0x83, 0xac, 0x14, 0x29,
  0x48, 0x8c, 0x2a, 0x41, 0x19, 0xc7, 0x97, 0xee, 0x12, 0x0e, 0xe0, 0x03, 0x60, 0xe5, 0x2a, 0xeb,
  0x49, 0x28, 0x54, 0xd4, 0xb3, 0xdb, 0xa5, 0xf2, 0x9f, 0x0b, 0xc7, 0x10, 0xbc, 0xd8, 0xf9, 0x76,
  0xa4, 0xaf, 0x21, 0x7f, 0x83, 0xbf, 0x71, 0x14, 0x62, 0x99, 0xb0, 0x3b, 0x85, 0xed, 0x27, 0x7d,
  0x36, 0xc0, 0x5c, 0xbe, 0x58, 0xc3, 0x4e, 0x7d, 0x67, 0x1d, 0x3a, 0xd7, 0xfa, 0x0b, 0xb8, 0x59,
  0xfb, 0x95, 0x65, 0x97, 0x57, 0xf8, 0x97, 0x58, 0x48, 0x1a, 0xb9, 0xf2, 0xdc, 0x81, 0x41, 0x60,
  0x96, 0xbf, 0x1f, 0x89, 0x02, 0x24, 0xec, 0xb4, 0x0b, 0x0b, 0x40, 0x98, 0x5f, 0xf3, 0xef, 0x2f,
  0x1a, 0xd9, 0x69, 0xeb, 0xae, 0x65, 0x7f, 0x2d, 0x7c, 0x24, 0xd4, 0x81, 0x2c, 0xbf, 0x69, 0x05,
  0x8f, 0xbd, 0x24, 0x2c, 0x13, 0x06, 0xd8, 0x56, 0x92, 0x96, 0x79, 0x0c, 0xbf, 0x29, 0x01, 0xef,
  0x2b, 0x69, 0xeb, 0xa3, 0x84, 0x0e, 0x69, 0xda, 0x28, 0x99, 0xd0, 0x60, 0xc9, 0x70, 0x20, 0x9b,
  0x45, 0x0c, 0x26, 0x7f, 0xaf, 0x61, 0x31, 0xc0, 0x6f, 0x02, 0x2f, 0xf0, 0x48, 0x5c, 0x1f, 0x48,
  0x92, 0xf4, 0x2b, 0x0b, 0x15, 0xa0, 0x9a, 0x69, 0xf1, 0x8b, 0x3a, 0x28, 0x80, 0x85, 0x8a, 0x09,
  0xda, 0x3a, 0xbc, 0x7b, 0x91, 0x19, 0x00, 0xaa, 0x69, 0xd9, 0xf6, 0x54, 0xf4, 0x20, 0x25, 0x4c,
  0x42, 0xda, 0x4e, 0xe2, 0x50, 0x1d, 0xa9, 0x4d, 0x0a, 0xe7, 0x1b, 0x03, 0xfc, 0x2b, 0xeb, 0x03,
  0x0e, 0xba, 0xd6, 0xea, 0x26, 0x7f, 0x7b, 0xed, 0x62, 0xda, 0x1a, 0x6f, 0x8e, 0x1f, 0xf2, 0x48,
  0xd2, 0x42, 0x40, 0x4b, 0x6f, 0x38, 0x3c, 0x1b, 0xa3, 0x7a, 0x97, 0x53, 0x81, 0xf9, 0xb0, 0x1e,
  0xa6, 0x32, 0xfa, 0x25, 0xd6, 0x68, 0x1b, 0x8c, 0x96, 0xd6, 0x18, 0xe1, 0x59, 0xa6, 0x66, 0xc0,
  0x52, 0x85, 0x40, 0xbb, 0x5d, 0x83, 0xd0, 0x54, 0xc0, 0x96, 0x0f, 0xb8, 0x6b, 0x40, 0x87, 0x74,
  0xef, 0x95, 0x9e, 0x0e, 0x49, 0xfe, 0xfe, 0xf1, 0x7d, 0x42, 0xe4, 0x6a, 0x67, 0x1d, 0x90, 0xaf,
  0xff, 0xfe, 0x35, 0x08, 0xf5, 0x82, 0x45, 0x70, 0x26, 0x7f, 0x53, 0x38, 0xbf, 0xb2, 0x03, 0x18,
  0x0c, 0x6b, 0x2e, 0xe8, 0x43, 0xd0, 0x85, 0x53, 0x23, 0x99, 0x58, 0x5b, 0xe8, 0xc0, 0xa9, 0x81,
  0xb4, 0x8a, 0x6d, 0x31, 0xaf, 0xe6, 0xd7, 0x57, 0x36, 0x78, 0xa5, 0xf7, 0x59, 0x83, 0x6b, 0x1f,
  0xb5, 0xd8, 0x9c, 0x9a, 0xda, 0xd2, 0x98, 0x31, 0x31, 0xb6, 0xd1, 0x35, 0x6c, 0x35, 0x97, 0x2b,
  0xaf, 0x6e, 0x15, 0xab, 0x7e, 0x36, 0xca, 0xa6, 0xbd, 0x3c, 0xca, 0x63, 0x1e, 0x9e, 0xbf, 0x72,
  0xac, 0xc5, 0x9c, 0xbc, 0xba, 0xd5, 0xb5, 0x73, 0x42, 0x5e, 0x3e, 0x6b, 0xf6, 0x60, 0x69, 0x9c,
  0x07, 0x20, 0x8f, 0x56, 0x8f, 0x53, 0x2e, 0x7f, 0x30, 0x4e, 0xac, 0xfa, 0x29, 0x35, 0x31, 0x68,
  0x2e, 0x86, 0xa0, 0x98, 0xbc, 0x9a, 0xa6, 0xf9, 0xf6, 0xea, 0x56, 0x69, 0xd5, 0xb5, 0x48, 0xbb,
  0xde, 0xdc, 0xe0, 0xad, 0x7b, 0x6d, 0xfd, 0x35, 0x06, 0x65, 0xce, 0x1a, 0x4b, 0x20, 0x12, 0xe8,
  0xd6, 0x8f, 0xc4, 0x2e, 0x20, 0xca, 0x3a, 0xc4, 0xc5, 0x63, 0x54, 0x4e, 0xf2, 0x2f, 0x6c, 0x7e,
  0x2d, 0x86, 0x8b, 0x3f, 0xe2, 0xa9, 0x2d, 0xcb, 0xec, 0xe8, 0xdd, 0xf8, 0x71, 0x87, 0x67, 0x92,
  0xd6, 0x5f, 0x9e, 0x47, 0xda, 0x09, 0x74, 0x3e, 0xf5, 0x4d, 0x5e, 0x39, 0xf0, 0x82, 0x3f, 0xf0,
  0xb5, 0x98, 0xe9, 0xb3, 0x95, 0xc0, 0xfa, 0x0b, 0x4d, 0x87, 0xe4, 0x02, 0x6d, 0x9d, 0x49, 0xf8,
  0xe4, 0x82, 0xa8, 0xd0, 0x0d, 0x4c, 0xf1, 0xc7, 0xd3, 0x6b, 0x27, 0x7f, 0x6f, 0xfa, 0x56, 0x0a,
  0x42, 0x4c, 0x2c, 0x74, 0x28, 0x11, 0x3a, 0x91, 0x14, 0xa1, 0x5f, 0xd7, 0xb8, 0xc2, 0xcb, 0xa3,
  0x90, 0x78, 0x6c, 0xfe, 0x31, 0x0e, 0x89, 0xc8, 0x98, 0x20, 0x3e, 0x22, 0xc1, 0x1a, 0xa6, 0x1a,
  0x17, 0x43, 0x0f, 0xcb, 0x83, 0xc6, 0x29, 0x7a, 0x7a, 0x18, 0xc3, 0x01, 0x89, 0xc4, 0x85, 0x14,
  0x14, 0x31, 0x96, 0x49, 0xcb, 0x2a, 0xc9, 0xe1, 0xa0, 0x0d, 0x16, 0xf0, 0x95, 0xad, 0xea, 0x46,
  0xca, 0xed, 0xe9, 0x0e, 0xe4, 0x81, 0xec, 0x57, 0x92, 0xf9, 0x52, 0x09, 0xfa, 0x03, 0x0b, 0xab,
  0x92, 0xcc, 0x25, 0x13, 0x54, 0x89, 0x4b, 0xd2, 0x48, 0x90, 0x24, 0x98, 0xe7, 0xc6, 0x10, 0xde,
  0x72, 0xf9, 0x6a, 0x32, 0xae, 0x3f, 0x7c, 0xa9, 0x08, 0x64, 0x29, 0xfb, 0x59, 0x0b, 0xa3, 0x30,
  0x40, 0x17, 0xc5, 0x26, 0x24, 0x1d, 0x60, 0x77, 0x8e, 0xc9, 0x88, 0x2c, 0x63, 0x90, 0x66, 0x25,
  0x68, 0x9e, 0x87, 0xc2, 0xb5, 0xd5, 0x38, 0x8c, 0x45, 0xe1, 0xff, 0xfb, 0xff, 0xfc, 0x5f, 0xff,
  0x77, 0x80, 0xbe, 0xb5, 0x8f, 0xf1, 0x17, 0xa0, 0x2f, 0xd4, 0xa9, 0x28, 0x16, 0x83, 0x0c, 0x44,
  0xe6, 0xda, 0xd7, 0xb0, 0x49, 0x91, 0x29, 0x7f, 0x8a, 0xcc, 0xb5, 0xaf, 0x60, 0x73, 0xe1, 0x47,
  0xa7, 0x31, 0x8e, 0xb4, 0xe7, 0xde, 0xe9, 0x23, 0xe8, 0x96, 0x63, 0x6b, 0x4a, 0x52, 0x6d, 0xe1,
  0x01, 0xbd, 0x96, 0xa1, 0x9a, 0x2f, 0x08, 0x84, 0x95, 0x8c, 0x32, 0x34, 0x6f, 0xd0, 0x3f, 0x13,
  0x12, 0x5e, 0xaf, 0xb7, 0x50, 0x5f, 0x45, 0xd1, 0x12, 0x4c, 0x14, 0xee, 0x6e, 0x0a, 0x97, 0x1a,
  0x84, 0x27, 0x03, 0x4d, 0xa0, 0xf1, 0x30, 0xfe, 0x52, 0x06, 0xab, 0x2d, 0x8e, 0xc6, 0x1f, 0xc5,
  0x9a, 0x5f, 0x70, 0x14, 0xae, 0x19, 0x4b, 0x97, 0x68, 0xb1, 0x45, 0x12, 0xdd, 0x04, 0x5d, 0xf3,
  0x1a, 0x09, 0x98, 0x1b, 0x63, 0x3d, 0x6f, 0x18, 0xbb, 0x87, 0x88, 0x47, 0x87, 0x94, 0x92, 0x3d,
  0xda, 0xe4, 0x64, 0x39, 0xa0, 0xcd, 0xda, 0x2a, 0xe2, 0x80, 0xae, 0x41, 0x06, 0x80, 0x4d, 0x73,
  0xfa, 0x37, 0x98, 0x7e, 0xed, 0x57, 0xcb, 0x5e, 0xa2, 0x95, 0x37, 0xf2, 0x97, 0x4f, 0x47, 0x1e,
  0x37, 0xa3, 0x8f, 0x96, 0x70, 0x1a, 0x1d, 0xee, 0xd1, 0x07, 0xc3, 0x5d, 0xf3, 0xc6, 0x5b, 0xcb,
  0xf1, 0x11, 0xe7, 0x6a, 0xf2, 0x0a, 0x86, 0x2c, 0x83, 0x7e, 0xfd, 0xf1, 0x48, 0xd7, 0xe2, 0x59,
  0xd1, 0x1b, 0x1e, 0x8f, 0xef, 0x8a, 0xcc, 0x66, 0x76, 0xbc, 0x37, 0xf9, 0xfb, 0x72, 0x6f, 0x33,
  0x41, 0x0d, 0x21, 0x36, 0x9f, 0x57, 0xcf, 0x49, 0x06, 0x69, 0x15, 0xed, 0x2f, 0x97, 0x71, 0xb1,
  0xb6, 0x62, 0xe8, 0x11, 0x1c, 0x5d, 0x76, 0x5b, 0xa9, 0xcf, 0x67, 0xe6, 0xda, 0xbf, 0x25, 0xe7,
  0x18, 0xc5, 0x3f, 0x19, 0x51, 0x77, 0xd5, 0x88, 0xf6, 0xfe, 0x4f, 0x1d, 0x51, 0x6b, 0xd5, 0x88,
  0x36, 0xff, 0xb7, 0x1d, 0x51, 0x58, 0xd3, 0xc7, 0xfe, 0x8e, 0x57, 0xb2, 0xeb, 0x2d, 0xda, 0x49,
  0x09, 0xec, 0xb3, 0xe9, 0x2d, 0x41, 0x1f, 0xcc, 0xd9, 0xb5, 0x25, 0x1c, 0xdc, 0xc6, 0xcd, 0xd9,
  0xf8, 0x19, 0xfa, 0xff, 0xdf, 0x4a, 0xe2, 0xcd, 0x5b, 0x0c, 0xc7, 0x8c, 0xc5, 0xc2, 0x1a, 0x43,
  0x03, 0x64, 0x63, 0x3c, 0xc1, 0xa7, 0x68, 0x58, 0xc2, 0x42, 0x23, 0x56, 0x52, 0x87, 0x55, 0x13,
  0x06, 0x99, 0x0e, 0x57, 0xa2, 0xa3, 0x89, 0x1d, 0xf4, 0xda, 0x7f, 0x81, 0x32, 0xb2, 0x44, 0x7c,
  0x1a, 0xf5, 0xb7, 0x00, 0x01, 0xd2, 0x02, 0x75, 0xe2, 0xaf, 0xc1, 0x56, 0x2a, 0xf9, 0xbd, 0xd3,
  0x91, 0xe1, 0x9f, 0xa4, 0xf0, 0x57, 0x82, 0xde, 0x32, 0xa9, 0x24, 0x2f, 0x49, 0x1b, 0x17, 0x5a,
  0x66, 0x87, 0x2e, 0x07, 0xfb, 0x42, 0xee, 0xef, 0x98, 0x95, 0x36, 0x16, 0xb2, 0xca, 0x21, 0xaf,
  0x71, 0xd0, 0x67, 0x7c, 0x84, 0xab, 0x80, 0x7b, 0x55, 0x56, 0x36, 0xb0, 0xb6, 0xd8, 0x82, 0x56,
  0x8d, 0xf4, 0xfd, 0x9e, 0x18, 0x86, 0x35, 0xfe, 0xb0, 0x01, 0x5a, 0x23, 0xba, 0x68, 0x7f, 0x34,
  0x04, 0x50, 0xe9, 0xc3, 0x0d, 0xdc, 0xaa, 0x76, 0x3f, 0x41, 0xb9, 0xe6, 0x03, 0x1c, 0x79, 0xd5,
  0xbe, 0x3e, 0x0c, 0xfc, 0x27, 0xdc, 0x0a, 0x6b, 0xe0, 0x03, 0xf8, 0x9d, 0x78, 0xbb, 0x1e, 0xa0,
  0x27, 0x30, 0x08, 0x73, 0x71, 0x1c, 0xb2, 0xbc, 0x40, 0xe4, 0x4d, 0x03, 0x80, 0x7e, 0x34, 0x84,
  0x10, 0x19, 0x02, 0x69, 0xf9, 0xe1, 0x18, 0x64, 0x39, 0x32, 0x86, 0x73, 0x1d, 0xb4, 0xb3, 0x0f,
  0x86, 0x20, 0xaf, 0x1e, 0x42, 0x5c, 0xef, 0x23, 0xb0, 0x37, 0x61, 0x82, 0x7c, 0x00, 0x5b, 0x46,
  0xd8, 0x6b, 0x5f, 0x63, 0x52, 0x84, 0xac, 0x55, 0x43, 0xb0, 0xb7, 0xa6, 0xaa, 0xf9, 0x31, 0x62,
  0x68, 0x85, 0xaf, 0xd2, 0x56, 0xae, 0x22, 0x66, 0x42, 0xf0, 0xf7, 0x6c, 0x42, 0xcc, 0x8f, 0x3a,
  0xcf, 0x2a, 0x7c, 0x91, 0x43, 0x6d, 0xb3, 0x1d, 0x9e, 0xba, 0x2a, 0x98, 0xad, 0xfd, 0x0f, 0x7a,
  0x1f, 0x3e, 0x36, 0x12, 0x5c, 0xfa, 0x41, 0xfd, 0xca, 0xb1, 0x81, 0xf3, 0x19, 0xdc, 0x8e, 0x01,
  0x63, 0x63, 0xed, 0x72, 0x85, 0x68, 0xd5, 0x1c, 0x23, 0x19, 0xb5, 0xde, 0x69, 0x43, 0x9b, 0xf4,
  0x5d, 0xf6, 0x17, 0x89, 0xc9, 0xc4, 0x81, 0xc7, 0x44, 0xcb, 0x8d, 0x58, 0x84, 0x6c, 0x6b, 0xa4,
  0x69, 0x58, 0x2e, 0xae, 0x14, 0xbf, 0x73, 0xf1, 0xee, 0x80, 0x10, 0xc0, 0xdc, 0xd7, 0x01, 0xe6,
  0x00, 0x60, 0xfe, 0x53, 0x80, 0xf9, 0xaf, 0x03, 0xcc, 0x03, 0xc0, 0xc2, 0xb2, 0xf5, 0x3c, 0x08,
  0x40, 0x9e, 0x99, 0x67, 0x9d, 0xce, 0x31, 0xb5, 0xb8, 0x7d, 0x5b, 0x0f, 0xe9, 0x38, 0xc0, 0xeb,
  0x7c, 0x3d, 0x84, 0x61, 0xcc, 0x73, 0x74, 0x29, 0x81, 0x14, 0xcd, 0x5b, 0xf7, 0xd0, 0x69, 0x1f,
  0xab, 0x5d, 0xbc, 0x90, 0x69, 0xdb, 0x1a, 0x9b, 0xb4, 0xf4, 0x0e, 0x7a, 0xf3, 0x51, 0x93, 0x40,
  0x9f, 0xbc, 0x66, 0xf5, 0x07, 0x06, 0x71, 0xd1, 0x65, 0x08, 0x53, 0x04, 0xd7, 0x16, 0x83, 0x98,
  0x5d, 0xb7, 0xa7, 0x24, 0xab, 0x0b, 0x84, 0xc1, 0x76, 0xcc, 0x4e, 0xb0, 0x62, 0xe1, 0x88, 0xe9,
  0x70, 0xfd, 0xd1, 0xa2, 0x92, 0xb2, 0x4f, 0x26, 0x31, 0xde, 0x95, 0x84, 0xef, 0xd1, 0x67, 0xb6,
  0x7b, 0xa1, 0xc6, 0xfc, 0x49, 0x6b, 0xab, 0xdd, 0x09, 0xfc, 0x70, 0x44, 0xd2, 0xc7, 0x11, 0x24,
  0x10, 0xd7, 0x25, 0x51, 0x04, 0x79, 0x2b, 0x71, 0x8c, 0x05, 0xcc, 0xaf, 0xe9, 0x88, 0x9a, 0xbf,
  0xbc, 0x7b, 0xd4, 0x7f, 0xd0, 0x2a, 0x30, 0xff, 0x01, 0xd5, 0x35, 0x12, 0x1c, 0x7c, 0x62, 0x59,
  0xff, 0x66, 0x6b, 0x77, 0xa8, 0x5f, 0xb8, 0xdf, 0x16, 0xf4, 0x00, 0x5f, 0xa2, 0xf3, 0x18, 0xf7,
  0xc4, 0x92, 0x09, 0x0c, 0x95, 0xce, 0x60, 0x0d, 0x99, 0x6a, 0x40, 0xb4, 0xa7, 0xbe, 0x5d, 0x49,
  0x23, 0x03, 0x68, 0xa4, 0x0d, 0x64, 0xfe, 0x30, 0x5b, 0xce, 0x60, 0xdd, 0xa3, 0xa9, 0xb7, 0x96,
  0xb7, 0x75, 0x2b, 0xd0, 0xe6, 0xfe, 0x98, 0xf1, 0xfe, 0x39, 0x8f, 0xfa, 0x93, 0xa4, 0xb7, 0xe7,
  0xde, 0xa5, 0xd8, 0x3c, 0x79, 0x41, 0x6f, 0x38, 0x67, 0xa9, 0xcc, 0xcf, 0xec, 0x0c, 0x54, 0xd3,
  0x1f, 0x8c, 0xbf, 0x91, 0x4f, 0x5b, 0x47, 0xf6, 0xc2, 0x6c, 0x44, 0x3f, 0xed, 0xe0, 0xf2, 0x40,
  0x42, 0xa6, 0x6d, 0x04, 0x90, 0xb7, 0x81, 0x08, 0x19, 0xdb, 0x2c, 0x04, 0x2d, 0x11, 0xc0, 0xfa,
  0xc0, 0x2e, 0x5f, 0x92, 0x03, 0x6b, 0x14, 0xad, 0xfc, 0x2a, 0x80, 0x64, 0x22, 0xd6, 0xa8, 0x1e,
  0x84, 0x94, 0x26, 0xca, 0x00, 0x81, 0x68, 0xe0, 0x87, 0xd1, 0x41, 0xc6, 0x30, 0x10, 0x09, 0x67,
  0x40, 0x48, 0x7b, 0x59, 0x17, 0xe3, 0xc5, 0x42, 0x80, 0xe4, 0xe4, 0x67, 0x8e, 0x13, 0x2e, 0x06,
  0xa3, 0x5b, 0xa0, 0x49, 0x4f, 0x5a, 0xee, 0x82, 0x24, 0x7e, 0x23, 0x0b, 0x2e, 0x2a, 0x96, 0xe8,
  0xf1, 0x58, 0x21, 0x5f, 0xfa, 0x77, 0x7c, 0x54, 0x4d, 0x1c, 0xc2, 0x27, 0x1a, 0x32, 0x2d, 0xf3,
  0x5f, 0xeb, 0x6a, 0xb1, 0x86, 0x2e, 0xed, 0x48, 0xa4, 0x9f, 0x6c, 0x0f, 0x2a, 0xc1, 0xf6, 0xc9,
  0x91, 0x5f, 0x58, 0xa9, 0x7f, 0xc7, 0xcd, 0xb5, 0x44, 0xc5, 0xdc, 0x32, 0x15, 0x39, 0x11, 0x11,
  0xd3, 0x18, 0x0c, 0x30, 0x8d, 0x31, 0x87, 0x97, 0x29, 0x99, 0x4b, 0xfe, 0x1d, 0x2f, 0x22, 0x6d,
  0xda, 0xf1, 0x48, 0x54, 0x94, 0x6b, 0xff, 0x0e, 0x89, 0x0e, 0xbc, 0x0e, 0x7e, 0x42, 0x26, 0xbf,
  0xdc, 0xff, 0xe1, 0xa4, 0xca, 0x2f, 0x93, 0x6a, 0x6b, 0xe8, 0xb8, 0x56, 0x3f, 0x91, 0x5b, 0x3d,
  0xd7, 0x42, 0xf8, 0xca, 0x7f, 0x42, 0xa2, 0xc8, 0x36, 0xc3, 0xdf, 0xf4, 0x49, 0xb2, 0x8e, 0xe4,
  0x3e, 0x35, 0xab, 0x59, 0xb1, 0xaf, 0xfb, 0x7a, 0x3f, 0x34, 0xaf, 0xca, 0x21, 0x32, 0xfc, 0x0d,
  0x2a, 0xfc, 0x2d, 0x03, 0x74, 0x89, 0x0a, 0x85, 0x18, 0xb1, 0xc7, 0xc9, 0x90, 0xff, 0x8a, 0xc8,
  0x2b, 0x7c, 0x46, 0x85, 0xb5, 0x65, 0x32, 0xfc, 0x3d, 0x2a, 0xe4, 0x3f, 0x33, 0x69, 0x79, 0xb1,
  0xbf, 0xeb, 0x71, 0xff, 0xd2, 0x74, 0xf8, 0x1a, 0x1d, 0xd6, 0xfe, 0xb6, 0x4d, 0xbc, 0x44, 0x87,
  0x62, 0x72, 0x49, 0x1c, 0x79, 0xd3, 0xa1, 0xf0, 0x15, 0x3a, 0x14, 0x3f, 0x5b, 0x7a, 0x7e, 0xff,
  0x5d, 0x3a, 0xac, 0x2d, 0x12, 0xa2, 0xf0, 0x99, 0x87, 0x85, 0x95, 0xfa, 0x2f, 0x12, 0x4b, 0xf9,
  0x52, 0xfe, 0x7f, 0x4e, 0x2c, 0xe1, 0x2d, 0x84, 0x46, 0x44, 0x0d, 0x5c, 0x5c, 0x3e, 0xfa, 0x7c,
  0xb7, 0x2a, 0x50, 0xdb, 0x3a, 0x13, 0xa6, 0xb5, 0xad, 0x45, 0xd5, 0x36, 0xbe, 0xcd, 0x2e, 0x49,
  0xd2, 0x2a, 0xe7, 0x4f, 0x93, 0x74, 0xfb, 0x78, 0x9f, 0x40, 0xbc, 0x66, 0x12, 0x78, 0xed, 0x1d,
  0xd2, 0xc5, 0xe4, 0x78, 0x98, 0xa1, 0x42, 0x43, 0x97, 0x91, 0x6d, 0xd1, 0xdd, 0xc2, 0xb3, 0xf2,
  0x21, 0xad, 0x3b, 0xd8, 0x37, 0x4f, 0xd0, 0xd3, 0xa4, 0xdc, 0xf7, 0xeb, 0x44, 0xb5, 0x6e, 0x1b,
  0x7a, 0x48, 0x57, 0xb3, 0xb5, 0x4b, 0x02, 0x74, 0x05, 0xc5, 0x97, 0x75, 0x38, 0xc6, 0xd6, 0xf8,
  0x7d, 0x15, 0x84, 0xd8, 0x85, 0x27, 0xb0, 0x1b, 0x67, 0x34, 0x30, 0x32, 0xb3, 0x93, 0x35, 0x01,
  0xf1, 0x29, 0x3b, 0x94, 0x4b, 0x52, 0xc9, 0x73, 0xff, 0xcb, 0x52, 0xce, 0xe7, 0x02, 0x59, 0xaa,
  0x24, 0x7f, 0xf3, 0x4d, 0xbd, 0xc5, 0xf1, 0x9d, 0xdb, 0xd8, 0xbb, 0x55, 0x0a, 0x9e, 0xaf, 0x5d,
  0xc7, 0xa0, 0x87, 0xa6, 0xbf, 0x86, 0x52, 0x03, 0xa4, 0x0f, 0x56, 0xa3, 0x7c, 0x99, 0x9a, 0xa1,
  0xe0, 0x84, 0x96, 0xe5, 0x72, 0x27, 0xad, 0xc5, 0xa8, 0x18, 0xc5, 0x38, 0x5e, 0xe4, 0xa8, 0x9b,
  0x2f, 0x21, 0x63, 0x39, 0x69, 0x0d, 0x88, 0x79, 0xa5, 0xb6, 0x52, 0xab, 0x77, 0x50, 0xb9, 0x39,
  0x11, 0xbf, 0x83, 0xca, 0xf6, 0x8c, 0xe2, 0xf7, 0x6e, 0x97, 0x1a, 0x5d, 0x5b, 0x6a, 0x35, 0xf7,
  0x85, 0x7d, 0xdb, 0xe5, 0x46, 0xb9, 0x4e, 0xbd, 0xf6, 0xc5, 0x66, 0x97, 0x5a, 0xcd, 0xaf, 0xdc,
  0x9d, 0x2f, 0x14, 0x5b, 0x1f, 0x44, 0x21, 0xf8, 0x0c, 0xf8, 0x6f, 0x8e, 0xb6, 0xb0, 0x6a, 0xb4,
  0x72, 0x51, 0x5b, 0xdd, 0x2c, 0x67, 0xb0, 0xb5, 0x8f, 0x77, 0xa9, 0xf9, 0x75, 0x35, 0x51, 0xff,
  0x0b, 0x8b, 0x62, 0x51, 0x51, 0x22, 0x2c, 0xf1, 0xad, 0x7f, 0xb5, 0xea, 0xd2, 0xa6, 0x7a, 0x10,
  0x4a, 0xb0, 0x00, 0x0a, 0x23, 0xad, 0x7c, 0x3e, 0xa7, 0x97, 0xff, 0x24, 0xc3, 0xa6, 0x0e, 0x5e,
  0x5a, 0x43, 0x05, 0x77, 0xbf, 0xeb, 0x15, 0x1a, 0xeb, 0x60, 0x8d, 0x83, 0x05, 0xc5, 0xf6, 0x27,
  0x43, 0x87, 0x6c, 0x07, 0x66, 0xd7, 0xfb, 0x86, 0x8e, 0x7e, 0xb3, 0x79, 0x76, 0x39, 0x96, 0x8f,
  0xf6, 0xba, 0x16, 0xde, 0x1b, 0x7d, 0xda, 0xbc, 0xee, 0xed, 0x5c, 0xe3, 0x37, 0x73, 0x36, 0xe9,
  0x3d, 0xd2, 0xbb, 0x5b, 0x8d, 0x7b, 0xf8, 0xd9, 0x2a, 0xed, 0x0e, 0x3b, 0x25, 0xfa, 0xd1, 0x9c,
  0xbb, 0xd3, 0xe6, 0xa5, 0x7c, 0xd0, 0xb0, 0x9d, 0xa2, 0x56, 0xa6, 0xdf, 0x2a, 0xba, 0x34, 0x2f,
  0xae, 0x73, 0x9b, 0x50, 0x66, 0xf2, 0x3c, 0x1e, 0x55, 0xef, 0x2f, 0xae, 0x31, 0xf1, 0x50, 0xdb,
  0xe9, 0x3d, 0x68, 0xe3, 0x46, 0x63, 0xdb, 0x39, 0x81, 0xd7, 0xca, 0x76, 0x43, 0x6b, 0x8f, 0x5e,
  0xf7, 0xb0, 0xc2, 0x66, 0xab, 0x79, 0x7d, 0xb9, 0x79, 0xb3, 0xd5, 0xbb, 0x32, 0xee, 0x6b, 0xad,
  0x6d, 0xab, 0x31, 0xde, 0x3e, 0x39, 0xbd, 0xad, 0x98, 0x35, 0x73, 0xbc, 0xa5, 0x0f, 0xa6, 0xee,
  0xc5, 0x69, 0xf1, 0xa1, 0xea, 0xb6, 0xec, 0xab, 0xfd, 0xfe, 0x76, 0x7f, 0xb7, 0x68, 0x9d, 0xbf,
  0x4d, 0x8d, 0xf6, 0xf8, 0xf2, 0x75, 0x90, 0x6b, 0x36, 0xdb, 0xe6, 0x4d, 0xf6, 0x74, 0xf8, 0x30,
  0x7c, 0x7b, 0x25, 0x76, 0x63, 0x73, 0x3a, 0xb9, 0x7b, 0x33, 0x37, 0xc7, 0x05, 0xbd, 0xfb, 0x42,
  0x76, 0x77, 0x3a, 0x77, 0xd3, 0xeb, 0x61, 0xef, 0x28, 0x3b, 0xdd, 0x3d, 0x91, 0xb7, 0x26, 0x87,
  0x9d, 0xe9, 0xeb, 0xdd, 0xc3, 0xce, 0x99, 0x56, 0xce, 0x36, 0xed, 0x5a, 0xb6, 0xd5, 0xa9, 0x0c,
  0x0f, 0xb6, 0x4a, 0xa7, 0xe3, 0x76, 0xc5, 0xb2, 0x4f, 0x46, 0x8d, 0xf3, 0xd8, 0xaf, 0x1b, 0x2d,
  0x38, 0x16, 0xe9, 0xe6, 0xe1, 0x28, 0xf9, 0x3b, 0x90, 0x03, 0xe1, 0x12, 0xcb, 0xe2, 0x94, 0xc7,
  0xc2, 0x85, 0x99, 0xcf, 0x26, 0xaf, 0x43, 0xe2, 0xb8, 0x87, 0x8e, 0x65, 0xa6, 0xcc, 0xa1, 0x61,
  0x00, 0x5d, 0x2f, 0x49, 0x07, 0x78, 0xaa, 0xb7, 0x92, 0x87, 0x57, 0x40, 0x8a, 0x86, 0xb7, 0x6c,
  0x19, 0x96, 0x43, 0x12, 0x2c, 0x62, 0xc5, 0x8b, 0x1a, 0xf9, 0x7a, 0xaf, 0x16, 0x38, 0xed, 0xc0,
  0x84, 0x95, 0xce, 0xd4, 0x48, 0xe2, 0x18, 0x96, 0xaf, 0x2f, 0xf6, 0x8b, 0xae, 0x19, 0x38, 0x35,
  0xa2, 0xcb, 0x86, 0x66, 0x76, 0xe8, 0x7a, 0x91, 0xa2, 0x03, 0x6d, 0x59, 0x96, 0x9b, 0x60, 0x1f,
  0x8b, 0x8a, 0x74, 0x92, 0x9a, 0xfc, 0x81, 0x33, 0x6a, 0xed, 0x44, 0x6d, 0x93, 0xc4, 0x58, 0x77,
  0x7b, 0x3c, 0x8b, 0x39, 0x86, 0x54, 0xdb, 0xc5, 0x09, 0x9a, 0x93, 0xe5, 0x6a, 0x71, 0x1d, 0x26,
  0xea, 0xee, 0x8e, 0xbc, 0xb3, 0xce, 0xbd, 0x01, 0x6b, 0x89, 0xd6, 0x34, 0xd1, 0xd0, 0x6d, 0xcd,
  0xb2, 0xac, 0x17, 0x9d, 0xd0, 0x90, 0x3e, 0xb7, 0x47, 0x58, 0x38, 0x9a, 0x66, 0xf5, 0xfb, 0x43,
  0x93, 0x9a, 0x79, 0x51, 0xd7, 0x81, 0x47, 0x54, 0x93, 0x47, 0xf1, 0xc4, 0x4c, 0x26, 0x96, 0xdf,
  0x36, 0xa0, 0x69, 0x0a, 0x4b, 0xe7, 0xb8, 0x71, 0x96, 0x76, 0x95, 0xcd, 0x65, 0xc6, 0x58, 0xfb,
  0x94, 0x06, 0x3e, 0xa2, 0x30, 0x70, 0xcf, 0x27, 0xc0, 0x4a, 0x96, 0x58, 0xfb, 0x10, 0xc6, 0x02,
  0x19, 0x19, 0x4f, 0x18, 0x61, 0x1a, 0xc6, 0x6f, 0xc0, 0x79, 0xc1, 0x87, 0xb1, 0xd2, 0x84, 0x0d,
  0xce, 0x2f, 0xb2, 0x82, 0xf9, 0x17, 0x97, 0xcc, 0x7e, 0x70, 0x17, 0xeb, 0x07, 0x50, 0xc3, 0x85,
  0x3c, 0x6f, 0xf0, 0xf2, 0x7d, 0x2e, 0xf8, 0xfc, 0x71, 0xbb, 0xc1, 0xde, 0x37, 0x46, 0x28, 0xc6,
  0x10, 0x72, 0xc1, 0x18, 0xc1, 0xdb, 0x97, 0x17, 0x42, 0xce, 0x22, 0x93, 0xdc, 0x80, 0x49, 0xbe,
  0x11, 0x34, 0xc3, 0xc8, 0x78, 0x65, 0x25, 0x86, 0x80, 0xcf, 0xd6, 0x50, 0x37, 0xf0, 0x9c, 0x70,
  0x82, 0xb0, 0x75, 0x4f, 0xa4, 0xa9, 0xc0, 0xa4, 0xd8, 0xb4, 0x0d, 0x4a, 0x0d, 0x8f, 0x63, 0x4d,
  0x80, 0x30, 0xb7, 0xc6, 0x12, 0xad, 0x9f, 0xb8, 0xb7, 0x86, 0x09, 0x0d, 0xca, 0xd8, 0xc4, 0x1d,
  0xda, 0x66, 0xc2, 0xb5, 0xe0, 0x09, 0x24, 0xb1, 0xde, 0x27, 0x54, 0x89, 0x44, 0xe6, 0xc5, 0x38,
  0x6b, 0x07, 0x63, 0x31, 0x91, 0x6d, 0xf1, 0x0a, 0x35, 0x20, 0x30, 0x7d, 0xc6, 0xd0, 0x58, 0x0c,
  0x16, 0x07, 0x36, 0xb6, 0x4d, 0x62, 0x4b, 0xab, 0x98, 0x2a, 0xc4, 0x08, 0x30, 0xe1, 0x8e, 0x2d,
  0x9b, 0xae, 0xe7, 0x67, 0x5e, 0xaf, 0x2c, 0xba, 0x77, 0xf8, 0x01, 0x43, 0x2d, 0xd7, 0xcf, 0x87,
  0xeb, 0x0f, 0x4d, 0xd0, 0x99, 0xa0, 0xdb, 0x38, 0x87, 0xe3, 0xa6, 0xef, 0x5a, 0x68, 0xfe, 0xee,
  0x5a, 0x36, 0x0c, 0xdf, 0x71, 0x13, 0x03, 0x62, 0xd3, 0xcf, 0x0e, 0x40, 0xdb, 0x62, 0x42, 0x07,
  0x35, 0x10, 0xaf, 0xec, 0xc3, 0xe9, 0x48, 0xe8, 0xa1, 0x44, 0xc0, 0x03, 0xc5, 0x87, 0xd5, 0xe9,
  0xf0, 0x61, 0x03, 0x5a, 0xfa, 0x88, 0x04, 0xc7, 0x1a, 0xda, 0x20, 0x80, 0xc6, 0x3d, 0x62, 0x26,
  0x4c, 0x0b, 0x3d, 0x35, 0x88, 0x66, 0x69, 0x6d, 0x71, 0x06, 0xeb, 0x01, 0xd9, 0x11, 0x67, 0xc9,
  0x18, 0x3a, 0x2f, 0x0d, 0x4b, 0x16, 0x02, 0xda, 0xaf, 0x05, 0xc4, 0xe7, 0x61, 0xa9, 0x6b, 0xdf,
  0xbc, 0x0f, 0xd7, 0xa5, 0x5c, 0x91, 0x08, 0xb3, 0xa4, 0xd5, 0x7a, 0x06, 0x3a, 0x27, 0x15, 0x05,
  0x55, 0x55, 0xab, 0x93, 0x20, 0x13, 0x0c, 0x27, 0x76, 0x7e, 0xfc, 0x48, 0x0e, 0x61, 0x10, 0x1d,
  0xdd, 0x24, 0xed, 0xe4, 0x37, 0x2f, 0x13, 0xa8, 0x39, 0x34, 0xc8, 0x06, 0xfb, 0x91, 0x78, 0x51,
  0x85, 0xa4, 0x84, 0x7a, 0xd2, 0x03, 0x1b, 0x40, 0x62, 0xb5, 0x7f, 0xfc, 0x60, 0xbf, 0x92, 0xda,
  0x6f, 0x6f, 0xb0, 0xc7, 0x14, 0x11, 0xea, 0x29, 0x57, 0x71, 0xdf, 0xdf, 0x1d, 0x62, 0x74, 0x04,
  0x49, 0xb7, 0x2d, 0x84, 0x31, 0xa7, 0xd6, 0x92, 0x98, 0xf2, 0x3b, 0x08, 0xbd, 0x43, 0xe6, 0x03,
  0xb4, 0xe9, 0xd0, 0xc3, 0x75, 0xff, 0x8b, 0x7b, 0x2e, 0xeb, 0x3a, 0xa0, 0x1e, 0xaf, 0x53, 0x4b,
  0xa0, 0xac, 0x48, 0x10, 0xc1, 0x7d, 0x34, 0x9f, 0x14, 0x02, 0x7f, 0xd6, 0x3d, 0x36, 0x9c, 0xfb,
  0x35, 0x48, 0xca, 0x15, 0x66, 0x58, 0x96, 0x28, 0xae, 0xc4, 0x8e, 0xfd, 0xa1, 0x1c, 0x59, 0x87,
  0xde, 0x11, 0xc9, 0x26, 0x7d, 0x40, 0xf0, 0x16, 0x9e, 0x34, 0x81, 0x62, 0x41, 0x25, 0x33, 0x45,
  0x44, 0x53, 0xd4, 0x59, 0x45, 0x4b, 0x74, 0x44, 0x43, 0x54, 0xc5, 0xa1, 0xa2, 0xda, 0xdd, 0x21,
  0x55, 0xcd, 0xd6, 0xf5, 0x4e, 0xca, 0x54, 0xdc, 0xd4, 0x6c, 0x2e, 0x9a, 0x82, 0x58, 0xf8, 0xe5,
  0x67, 0x48, 0xcc, 0xfb, 0x2f, 0x60, 0x07, 0x75, 0xe5, 0x51, 0x7f, 0x12, 0x2d, 0xa5, 0xb0, 0x6e,
  0x2d, 0x15, 0x58, 0xb7, 0xd2, 0x69, 0x41, 0x97, 0x06, 0x43, 0xa7, 0x97, 0x1a, 0x3e, 0x5a, 0x4f,
  0x02, 0x85, 0x08, 0xcb, 0xe6, 0x37, 0x45, 0xff, 0xf1, 0x23, 0x65, 0x4a, 0xf4, 0xf4, 0x0b, 0x74,
  0x56, 0xd1, 0x05, 0x91, 0xa5, 0x43, 0x87, 0xf9, 0x83, 0xc4, 0xcf, 0x2c, 0x9f, 0xdb, 0xd6, 0xc0,
  0xa1, 0x4d, 0x39, 0x14, 0x0f, 0xd1, 0xf4, 0x91, 0xa5, 0xb7, 0x13, 0xb2, 0xa2, 0x28, 0xe6, 0xa3,
  0xf3, 0x84, 0x30, 0xe1, 0x67, 0xa1, 0x2e, 0xa4, 0x08, 0x1e, 0xca, 0x54, 0xc5, 0xc4, 0x0b, 0xd2,
  0x79, 0x63, 0x29, 0x03, 0x5e, 0x6d, 0xd2, 0x11, 0x90, 0x86, 0xb8, 0xbf, 0x91, 0xa0, 0xaf, 0x3c,
  0x57, 0x0d, 0xa5, 0x62, 0x1d, 0x9b, 0xa2, 0x4b, 0x15, 0x8d, 0x10, 0x0a, 0x6d, 0xa4, 0x14, 0xa4,
  0xda, 0x0c, 0x89, 0xba, 0x32, 0x43, 0xde, 0xa8, 0xbb, 0xe2, 0x00, 0x5b, 0xae, 0x13, 0x11, 0x2a,
  0xd6, 0x21, 0x9b, 0x74, 0xea, 0xb6, 0x68, 0xd6, 0x11, 0xb0, 0xa8, 0xb3, 0x1f, 0x52, 0x97, 0x45,
  0x8b, 0x3d, 0x1a, 0xec, 0x47, 0xe3, 0x3f, 0xc0, 0xfa, 0xae, 0x3d, 0xd4, 0x5c, 0xdc, 0x4a, 0xa3,
  0xc3, 0x9b, 0x7b, 0xdd, 0x7f, 0x93, 0x46, 0xb8, 0xd6, 0xfd, 0xf8, 0xc1, 0x1f, 0x52, 0x80, 0x37,
  0x3d, 0xe8, 0x8d, 0x8e, 0x5c, 0xe0, 0x31, 0x87, 0x8f, 0xdc, 0x20, 0xdf, 0x62, 0x7c, 0x45, 0xe3,
  0x04, 0x68, 0x07, 0x15, 0x57, 0xa4, 0x2f, 0xd4, 0xc6, 0x9a, 0xb8, 0x0a, 0x09, 0xca, 0x3a, 0xac,
  0x2c, 0x27, 0x98, 0xa2, 0x10, 0xc1, 0x07, 0xac, 0x6f, 0x40, 0xa6, 0xa4, 0x8b, 0xf0, 0xbf, 0x64,
  0x4a, 0xf4, 0x44, 0xd2, 0x59, 0x07, 0x9a, 0x4e, 0xe7, 0x04, 0x3a, 0x82, 0x75, 0x9f, 0x71, 0xd7,
  0xc9, 0x2f, 0x17, 0x8a, 0x70, 0x6e, 0x20, 0xc8, 0x0d, 0x1e, 0x03, 0x20, 0x67, 0x49, 0xe6, 0x23,
  0x79, 0x12, 0x3c, 0x8a, 0x9b, 0x92, 0xe5, 0xb5, 0x01, 0x8f, 0x7c, 0xc8, 0x31, 0xd3, 0xce, 0x95,
  0xf0, 0x01, 0xfb, 0xc0, 0x9a, 0x0b, 0xfa, 0x6c, 0xf8, 0xb3, 0x40, 0x34, 0x03, 0x56, 0xc3, 0x99,
  0x28, 0xe9, 0x7e, 0x33, 0x80, 0x18, 0x36, 0xb5, 0x5c, 0xc9, 0xc2, 0x17, 0x09, 0x35, 0x67, 0x85,
  0x91, 0x44, 0x91, 0xff, 0x76, 0x8f, 0x67, 0x51, 0x30, 0xd0, 0xf1, 0x16, 0x08, 0xc1, 0x97, 0x39,
  0x1f, 0x09, 0x76, 0x69, 0x1e, 0xf4, 0x50, 0xc5, 0x1e, 0xa6, 0xbe, 0xb9, 0x52, 0x07, 0x78, 0x15,
  0xfe, 0x2a, 0xdf, 0x64, 0x80, 0x96, 0x03, 0xfe, 0xbd, 0x66, 0xd3, 0xc4, 0x15, 0xde, 0xdf, 0x77,
  0xbf, 0x29, 0xca, 0x1b, 0xb0, 0x70, 0xcb, 0x82, 0x6a, 0xe4, 0xd2, 0xbb, 0xab, 0x11, 0x0a, 0xa6,
  0x76, 0xe3, 0x32, 0xc4, 0x54, 0x4c, 0xe2, 0xfb, 0xfb, 0xa6, 0x90, 0x1a, 0x0a, 0x21, 0x5e, 0x1d,
  0xa6, 0x7c, 0xe4, 0x88, 0xb6, 0xa8, 0x8b, 0x16, 0xce, 0x76, 0x51, 0xa3, 0xd4, 0xba, 0x96, 0x1c,
  0x90, 0x74, 0xa9, 0x54, 0x54, 0x76, 0xf2, 0x31, 0xc0, 0x74, 0x92, 0x48, 0xc6, 0xc5, 0xbf, 0x73,
  0x41, 0x58, 0x27, 0xd8, 0x57, 0x6b, 0x90, 0x12, 0xd6, 0x05, 0x42, 0xc7, 0xa1, 0x2b, 0xb6, 0xc2,
  0x18, 0x55, 0x54, 0x95, 0x94, 0x85, 0x88, 0x22, 0x82, 0xd4, 0x16, 0x24, 0x0b, 0xa4, 0x89, 0x29,
  0x0d, 0x44, 0x0d, 0xfe, 0x0e, 0x45, 0xf8, 0x5f, 0xf9, 0x96, 0x13, 0x87, 0x50, 0xc3, 0x56, 0x1e,
  0x9f, 0x44, 0x5d, 0x19, 0xa5, 0x86, 0xd0, 0x0b, 0x2a, 0x60, 0x2c, 0x10, 0x00, 0xd2, 0x58, 0x64,
  0x60, 0x60, 0xfc, 0x43, 0xc9, 0x1a, 0xc3, 0x6a, 0xd9, 0xbc, 0xd9, 0xdb, 0x31, 0x08, 0xca, 0x14,
  0x3a, 0x29, 0xa1, 0xdf, 0x9a, 0xc8, 0xf8, 0x51, 0x05, 0x06, 0xb0, 0x84, 0xba, 0x2a, 0x88, 0xdd,
  0x94, 0x8d, 0xd5, 0x75, 0x3a, 0x63, 0x0d, 0x48, 0x0c, 0x0f, 0x5a, 0x83, 0x91, 0x78, 0xc3, 0x35,
  0xd8, 0x80, 0x19, 0x16, 0xda, 0x62, 0x47, 0x1c, 0x88, 0x5d, 0xb1, 0x2f, 0x4e, 0xc4, 0xb1, 0xf8,
  0xa2, 0xd8, 0x3f, 0x7e, 0xd8, 0x92, 0xf9, 0xfe, 0x7e, 0x23, 0x36, 0x95, 0x17, 0x8f, 0xfe, 0x40,
  0xfb, 0xa1, 0xa2, 0xbc, 0x42, 0x8f, 0x87, 0x0a, 0x23, 0xb9, 0xb1, 0x61, 0x3c, 0xca, 0x4f, 0xf5,
  0x26, 0xb4, 0x6e, 0x8b, 0x32, 0x63, 0x40, 0x41, 0x6c, 0x2b, 0x32, 0x74, 0xdf, 0x54, 0x7a, 0x20,
  0xd3, 0xcc, 0x90, 0x80, 0x0f, 0x26, 0x10, 0x08, 0x34, 0xfa, 0x4c, 0x24, 0x5d, 0x31, 0x45, 0x58,
  0x5a, 0x00, 0x25, 0x24, 0x9d, 0xe3, 0x83, 0x51, 0x52, 0x03, 0xe5, 0xe5, 0xb1, 0xfd, 0x04, 0xc4,
  0x1f, 0xa0, 0xc4, 0x06, 0xa9, 0xa1, 0x28, 0x03, 0xfc, 0xc1, 0x37, 0xea, 0x63, 0xc1, 0x77, 0x7c,
  0x10, 0xb0, 0x1c, 0x47, 0xf7, 0x3a, 0x31, 0x60, 0xf9, 0x40, 0xfa, 0x75, 0x80, 0x73, 0x3b, 0xbf,
  0x9a, 0xeb, 0x1d, 0x60, 0x58, 0x6c, 0x86, 0xc2, 0xeb, 0x20, 0xa7, 0x7e, 0x0c, 0x6c, 0x86, 0xa5,
  0x3c, 0x68, 0x8c, 0x71, 0x07, 0x74, 0xa4, 0x73, 0x00, 0xd2, 0x05, 0x02, 0xa1, 0x78, 0x1b, 0x28,
  0x83, 0xf7, 0xf7, 0x57, 0x1f, 0x85, 0x94, 0x10, 0x88, 0x47, 0x18, 0xa8, 0x42, 0xb8, 0xfc, 0x1c,
  0xe0, 0xef, 0x37, 0x05, 0xd9, 0x61, 0xac, 0x8c, 0xdf, 0xdf, 0x1f, 0x9f, 0x04, 0xc6, 0xd0, 0x1d,
  0x18, 0xac, 0xf6, 0xfe, 0xde, 0x05, 0x7e, 0xe2, 0x72, 0xb5, 0x1b, 0x92, 0x2a, 0x13, 0x28, 0x3f,
  0x81, 0x14, 0x4f, 0xfa, 0x4b, 0x86, 0xd0, 0xc5, 0xbf, 0x50, 0xc9, 0xa0, 0xfd, 0x60, 0x43, 0x84,
  0xf2, 0x50, 0x18, 0x7a, 0xd1, 0xfd, 0xa6, 0x0c, 0xdf, 0xdf, 0x59, 0xdd, 0x6e, 0x68, 0xa1, 0x83,
  0x69, 0x58, 0xf7, 0x81, 0x42, 0x89, 0x61, 0x28, 0x0f, 0xb8, 0xc9, 0x15, 0x5c, 0x09, 0xcf, 0xa2,
  0x98, 0x6d, 0xb6, 0x0a, 0x76, 0x05, 0x0a, 0x97, 0x8a, 0x81, 0xbe, 0x32, 0x14, 0x11, 0x7d, 0xf0,
  0xd0, 0x97, 0x4c, 0x90, 0x82, 0x4d, 0x1d, 0x9d, 0x0e, 0x38, 0xdd, 0x18, 0x46, 0x95, 0x3c, 0xca,
  0x80, 0x3e, 0x34, 0x28, 0x50, 0x0c, 0x25, 0xdc, 0x75, 0x90, 0x27, 0xa6, 0x43, 0x6c, 0x77, 0x93,
  0x00, 0x04, 0x92, 0xea, 0x8a, 0x43, 0x61, 0x9e, 0x64, 0xb7, 0x31, 0x81, 0x9c, 0x32, 0x29, 0x6e,
  0xe9, 0x04, 0xe7, 0x2e, 0xaf, 0xa4, 0x30, 0x1f, 0x42, 0x7f, 0x43, 0xd0, 0xc5, 0x18, 0xc1, 0xe6,
  0xd7, 0x03, 0xf9, 0x03, 0x8d, 0xcd, 0x3d, 0x19, 0xd2, 0x4e, 0xa7, 0x45, 0x9c, 0x79, 0xc0, 0x62,
  0x96, 0x32, 0xe1, 0xa8, 0x32, 0x40, 0x81, 0xf1, 0x41, 0x7c, 0x8b, 0x82, 0xa0, 0xab, 0x65, 0x5b,
  0x31, 0x3c, 0x36, 0x6e, 0x67, 0x32, 0xeb, 0x02, 0xaf, 0x06, 0xdc, 0x03, 0x6c, 0x90, 0xc2, 0x5f,
  0x61, 0x9d, 0x95, 0x6b, 0x86, 0x0b, 0xbc, 0xd0, 0x02, 0xad, 0x14, 0xfe, 0x8a, 0x94, 0x27, 0x71,
  0x16, 0x8c, 0x39, 0x48, 0x79, 0xbd, 0xfd, 0x6b, 0xec, 0x83, 0x05, 0x66, 0x9b, 0xa6, 0xc6, 0x58,
  0x70, 0xfc, 0x98, 0x4e, 0xfb, 0x3f, 0xa1, 0xe9, 0xd7, 0x63, 0xeb, 0x63, 0x88, 0xe2, 0x26, 0x8e,
  0x0f, 0xa6, 0xbf, 0xc0, 0x59, 0x1f, 0x94, 0xa4, 0x24, 0xe8, 0xa4, 0x06, 0x51, 0xc3, 0x22, 0x5e,
  0x40, 0x3d, 0x80, 0x31, 0x10, 0x61, 0x86, 0xb6, 0xe0, 0x73, 0x42, 0xc3, 0xb6, 0xd5, 0xa9, 0xa4,
  0x3b, 0xf4, 0x17, 0x04, 0xa6, 0xe0, 0x2d, 0x37, 0x3a, 0x74, 0x4f, 0x07, 0xf1, 0xed, 0x4d, 0x5e,
  0xe8, 0x1e, 0xb4, 0x8f, 0xea, 0x09, 0x76, 0x81, 0xd5, 0xf7, 0x80, 0x6e, 0x90, 0x90, 0xac, 0x0b,
  0x75, 0x6f, 0x45, 0x77, 0xbc, 0x75, 0x09, 0x39, 0x12, 0xca, 0x26, 0x51, 0x65, 0x33, 0xbb, 0xa1,
  0x12, 0x50, 0x8d, 0x3b, 0x41, 0x97, 0x6b, 0xd9, 0x14, 0xb6, 0xc8, 0x45, 0x18, 0x1d, 0xcd, 0x7a,
  0xd0, 0xa0, 0x64, 0xb1, 0xe5, 0x44, 0xa1, 0x2b, 0x93, 0xb7, 0xc8, 0xae, 0x33, 0x65, 0x0e, 0x57,
  0x29, 0x04, 0x07, 0x6b, 0x2d, 0x5d, 0xb0, 0xe1, 0xd7, 0x53, 0x5f, 0x7c, 0x9d, 0x86, 0xd0, 0x05,
  0xc8, 0x02, 0x16, 0x41, 0x64, 0xd4, 0x5d, 0x3f, 0x23, 0xb4, 0xf2, 0xb7, 0x3d, 0x3a, 0x24, 0x33,
  0xd0, 0x41, 0xd0, 0x22, 0xe5, 0xa7, 0x0d, 0x57, 0xc2, 0x18, 0x00, 0x80, 0x0a, 0x8c, 0x3c, 0x45,
  0xdd, 0x06, 0xea, 0xc2, 0xea, 0xa6, 0x2c, 0x0d, 0x04, 0x48, 0xf6, 0x0d, 0x97, 0xa8, 0x3d, 0xc9,
  0x05, 0xa3, 0x00, 0x84, 0xda, 0x86, 0x99, 0x4e, 0x0e, 0x26, 0xc9, 0x3a, 0xa7, 0xe8, 0x46, 0x12,
  0x1e, 0x83, 0xb6, 0x3a, 0x9e, 0x4e, 0xb4, 0xa4, 0x5a, 0x52, 0xd4, 0x41, 0xff, 0xb1, 0x0b, 0x29,
  0xa2, 0xe8, 0x1b, 0x49, 0xaa, 0xee, 0x9f, 0x62, 0x80, 0x00, 0xf6, 0x8a, 0xbf, 0x27, 0xeb, 0xa4,
  0xce, 0x9f, 0x42, 0xa9, 0xb4, 0x54, 0x9d, 0x80, 0x88, 0x4c, 0x7a, 0x9a, 0x0d, 0xcd, 0x0e, 0x18,
  0x23, 0x49, 0x4d, 0x50, 0x96, 0x08, 0xaf, 0x88, 0x15, 0x9a, 0x22, 0x2e, 0x91, 0xcb, 0x14, 0x2c,
  0x49, 0x73, 0x1c, 0x3c, 0xf3, 0xa7, 0x98, 0x4c, 0x14, 0xc4, 0x51, 0x15, 0xd6, 0x84, 0x54, 0x50,
  0x30, 0x99, 0x14, 0x6d, 0x85, 0xc9, 0x7b, 0x3b, 0xd0, 0x47, 0x6d, 0x01, 0xd0, 0x43, 0x9f, 0x60,
  0xf1, 0x68, 0xa7, 0x70, 0xac, 0x30, 0xdd, 0x29, 0x7d, 0x69, 0x21, 0x83, 0x66, 0x09, 0x00, 0xca,
  0x7c, 0x34, 0x9e, 0xa0, 0x6f, 0x36, 0xfc, 0xb0, 0x92, 0xc0, 0x0b, 0xf0, 0x2c, 0xcc, 0xb1, 0xfd,
  0xa4, 0xe5, 0xd1, 0x05, 0xe6, 0x35, 0x1b, 0xd8, 0x63, 0xee, 0x69, 0x23, 0xa5, 0x2a, 0x28, 0xbf,
  0x00, 0x59, 0x28, 0x68, 0xe9, 0xd9, 0xdf, 0x54, 0x76, 0x4b, 0x1d, 0x00, 0x7d, 0xc9, 0x1f, 0x59,
  0x6c, 0x49, 0x00, 0xad, 0x25, 0x05, 0xcb, 0x13, 0x48, 0x76, 0xeb, 0x18, 0x0f, 0xb0, 0x6d, 0x81,
  0x1e, 0x92, 0x12, 0x04, 0xb4, 0x3e, 0x37, 0x86, 0x80, 0x2f, 0x3c, 0x25, 0x0a, 0xb5, 0xf2, 0x30,
  0xe1, 0x36, 0x52, 0xf6, 0xfb, 0x3b, 0x48, 0xc2, 0x76, 0x7b, 0x07, 0x6f, 0x3f, 0x46, 0xf7, 0x10,
  0x81, 0x45, 0x16, 0x68, 0x3f, 0x10, 0x61, 0x21, 0x45, 0x5e, 0x7b, 0x7f, 0xc7, 0xbf, 0xca, 0x0c,
  0xc4, 0x0d, 0xf2, 0x02, 0xf2, 0x04, 0xb7, 0x1f, 0xe2, 0xaa, 0x80, 0x59, 0x44, 0xb7, 0x48, 0xa0,
  0x8b, 0x30, 0x61, 0x93, 0xae, 0xda, 0xa5, 0x54, 0xe2, 0xaf, 0x68, 0x3a, 0xf2, 0xe7, 0x6f, 0xa0,
  0xef, 0x13, 0x6a, 0x11, 0x6f, 0x50, 0x1e, 0x0b, 0x73, 0x4e, 0x3d, 0x4e, 0x8e, 0x41, 0xf5, 0x36,
  0xee, 0x1d, 0xd9, 0xd6, 0xd0, 0x31, 0xa6, 0x4d, 0xdc, 0x22, 0x87, 0x66, 0xf7, 0xaf, 0x4e, 0x8e,
  0x39, 0xc4, 0xd4, 0x32, 0x5e, 0xfe, 0x39, 0x41, 0x67, 0x71, 0x7d, 0x83, 0xe1, 0x65, 0x83, 0xb7,
  0xf1, 0xfe, 0x4e, 0x99, 0xd7, 0xdc, 0xf0, 0x06, 0xd2, 0x70, 0x81, 0xcc, 0x60, 0x00, 0x93, 0xd3,
  0x66, 0x2a, 0xb9, 0x7c, 0x0d, 0x61, 0xae, 0x56, 0xab, 0x65, 0x29, 0xa4, 0xa4, 0xb8, 0x88, 0xd4,
  0x3a, 0x9d, 0x33, 0xff, 0x3e, 0x00, 0x9c, 0x63, 0x9f, 0x76, 0x0b, 0xad, 0xc7, 0x68, 0x3b, 0x74,
  0x72, 0x86, 0xa4, 0xea, 0x20, 0xac, 0xe7, 0xa3, 0xfe, 0xee, 0x3e, 0x32, 0x31, 0xf1, 0x04, 0x9a,
  0x20, 0xbd, 0xd8, 0x7a, 0x83, 0xff, 0xa2, 0x8e, 0x1c, 0x36, 0xf9, 0x46, 0x29, 0x36, 0x33, 0xf9,
  0x84, 0x14, 0xdb, 0x40, 0xc6, 0x11, 0x9b, 0xa5, 0x5d, 0x71, 0x2a, 0xb6, 0x98, 0x32, 0x24, 0x36,
  0xc5, 0x1d, 0xf1, 0x59, 0xdc, 0x12, 0xaf, 0xf8, 0x5a, 0x86, 0xec, 0xec, 0xab, 0x66, 0xa6, 0x14,
  0xb2, 0x50, 0x22, 0x92, 0x11, 0x34, 0x06, 0x68, 0x17, 0x16, 0xce, 0x2e, 0x30, 0xff, 0xba, 0x6b,
  0x4f, 0xd9, 0xaa, 0x1c, 0xb3, 0xd4, 0x5d, 0x51, 0x91, 0xbb, 0x83, 0xda, 0x21, 0x15, 0x6b, 0xcf,
  0x0a, 0xd4, 0xbd, 0xf2, 0xec, 0x90, 0x2b, 0x5c, 0xc3, 0x60, 0x56, 0x3d, 0x76, 0x25, 0xed, 0x49,
  0xdc, 0x52, 0xba, 0x1b, 0xcf, 0x1b, 0xcf, 0xac, 0x24, 0x5b, 0x51, 0xeb, 0x5d, 0x49, 0xaf, 0x3b,
  0xa2, 0x2d, 0x69, 0x1b, 0x4d, 0x25, 0x35, 0xc5, 0x2e, 0x29, 0xf0, 0x02, 0x96, 0xb6, 0x32, 0x95,
  0x5e, 0xea, 0xa9, 0x24, 0x94, 0x75, 0x2d, 0x6c, 0x2b, 0x09, 0x3c, 0x77, 0xf5, 0xe3, 0xc7, 0x95,
  0xe4, 0xa7, 0x48, 0xec, 0xf2, 0xf3, 0x0d, 0xac, 0x03, 0x35, 0xc9, 0x38, 0x71, 0x95, 0xda, 0x11,
  0xb7, 0xc0, 0x62, 0x0f, 0x52, 0x2c, 0x9a, 0x22, 0x4e, 0xc3, 0x23, 0x55, 0xae, 0xe0, 0x9d, 0xd5,
  0x55, 0xfa, 0x82, 0xf8, 0xfc, 0xe3, 0xc7, 0xb3, 0xe4, 0x0c, 0x5b, 0xa9, 0x29, 0x96, 0x63, 0xd6,
  0xd4, 0x0e, 0x3c, 0x39, 0x78, 0x31, 0x0a, 0xcc, 0x22, 0xfe, 0x84, 0x33, 0x89, 0xc1, 0xa1, 0x06,
  0xd6, 0x16, 0x3c, 0x8f, 0x15, 0x47, 0x6c, 0x41, 0x3f, 0x51, 0xf9, 0x87, 0xd7, 0x7e, 0x68, 0x31,
  0x9c, 0x4a, 0x00, 0x16, 0xaa, 0x3e, 0x2b, 0xbc, 0xba, 0xa7, 0x18, 0x5d, 0x49, 0x5d, 0xe2, 0x6e,
  0x83, 0x62, 0x3f, 0x22, 0xed, 0x26, 0x66, 0xec, 0xda, 0x56, 0x9f, 0x5a, 0xb7, 0x3f, 0x7e, 0xb8,
  0xb4, 0x82, 0x57, 0x63, 0x03, 0x5f, 0xa8, 0x4a, 0x0d, 0x0f, 0x42, 0x1d, 0xfe, 0x88, 0xab, 0x2b,
  0xa7, 0x76, 0x68, 0x29, 0x41, 0x6c, 0x09, 0xac, 0x03, 0x1f, 0xb5, 0xc3, 0x7a, 0x82, 0x63, 0xe9,
  0x0f, 0x2c, 0x13, 0x98, 0xeb, 0x56, 0x37, 0x8c, 0x13, 0xb0, 0x3a, 0xdc, 0x1f, 0x3f, 0xe2, 0x52,
  0x53, 0x5e, 0xe7, 0x43, 0x99, 0xdb, 0x7a, 0x9b, 0xd7, 0x18, 0xb2, 0x85, 0x78, 0x2a, 0xf8, 0xe2,
  0xf7, 0x6b, 0x3d, 0x50, 0x94, 0xf6, 0x8a, 0xae, 0x5c, 0x12, 0x8d, 0x40, 0x2d, 0x5e, 0xf6, 0x83,
  0x4c, 0x46, 0xdc, 0x6f, 0x21, 0x38, 0x4e, 0xcf, 0x1a, 0x1a, 0xed, 0x2d, 0xaf, 0xc2, 0x35, 0xdd,
  0xe0, 0xe6, 0xab, 0xde, 0x8a, 0x5c, 0x86, 0x3a, 0x00, 0xc4, 0x8c, 0xc9, 0x25, 0x16, 0x40, 0x5a,
  0x8a, 0x94, 0xc8, 0x39, 0x11, 0x72, 0xdb, 0x20, 0x4a, 0x61, 0x9d, 0x66, 0x0d, 0x0e, 0x36, 0x06,
  0x30, 0x8f, 0x6c, 0xc9, 0xda, 0x18, 0xd4, 0xe1, 0x2f, 0x33, 0xfb, 0xd1, 0x7e, 0x00, 0x0b, 0x44,
  0xec, 0x82, 0x16, 0xd3, 0xfd, 0x65, 0x06, 0x46, 0x68, 0x17, 0xf4, 0x18, 0x78, 0x7d, 0xec, 0x52,
  0xff, 0x06, 0x7d, 0x40, 0x23, 0x42, 0x58, 0xe7, 0xda, 0xe8, 0x3c, 0x16, 0x1b, 0xde, 0x18, 0x62,
  0x93, 0xfd, 0xce, 0xcf, 0xb1, 0xef, 0x13, 0x85, 0xf7, 0x5e, 0x1c, 0x7b, 0x5c, 0xb4, 0xc0, 0xb2,
  0x71, 0x63, 0xa3, 0x93, 0xfd, 0x84, 0x4f, 0x76, 0x6f, 0xa4, 0x74, 0xa0, 0x58, 0x41, 0x21, 0x30,
  0x10, 0x6f, 0xbe, 0x78, 0xd8, 0x11, 0x97, 0xa0, 0x0b, 0x9e, 0xd9, 0xc4, 0x2c, 0x03, 0x00, 0xc6,
  0x0d, 0x14, 0xdd, 0xa3, 0x76, 0x17, 0x15, 0x9e, 0x8d, 0x2e, 0x9f, 0xfd, 0xde, 0xca, 0x5f, 0xef,
  0x06, 0xcc, 0x05, 0xfc, 0x42, 0xb5, 0xfa, 0x2d, 0x06, 0x12, 0x90, 0xe4, 0xc0, 0x04, 0xa0, 0x53,
  0xc0, 0xc1, 0x8e, 0x2d, 0xe4, 0x83, 0x18, 0x07, 0x7e, 0xf7, 0x8c, 0x08, 0x9a, 0xdd, 0x34, 0xd5,
  0x01, 0x10, 0x99, 0xab, 0xf3, 0x0c, 0x45, 0x30, 0x85, 0x5f, 0x56, 0xe7, 0xa6, 0x40, 0x4e, 0x02,
  0x18, 0x6d, 0x41, 0x9c, 0xa2, 0x30, 0x85, 0x16, 0x7d, 0x57, 0x00, 0xa2, 0xa0, 0xef, 0x19, 0xcb,
  0xde, 0xe4, 0xf6, 0x51, 0x08, 0xa6, 0xab, 0x84, 0x5f, 0xe2, 0xc4, 0x49, 0xe0, 0x77, 0x68, 0x12,
  0xf4, 0x2c, 0x3c, 0x6b, 0xbc, 0x4e, 0xc5, 0xa5, 0xa6, 0xa8, 0xd0, 0x16, 0xc4, 0x26, 0x05, 0x8f,
  0xbd, 0xd6, 0x99, 0x9e, 0x32, 0xe7, 0x2a, 0xaf, 0xa5, 0x84, 0xed, 0x7a, 0xdf, 0x1e, 0x86, 0x5e,
  0x33, 0xd1, 0x8f, 0x5d, 0xef, 0xe1, 0x5a, 0xe0, 0xcb, 0xe3, 0x11, 0xac, 0xab, 0xf4, 0x09, 0x25,
  0xbf, 0xae, 0x24, 0x9d, 0x51, 0x97, 0xea, 0x24, 0x94, 0x3a, 0xef, 0xef, 0xba, 0xa7, 0xbc, 0x7b,
  0x53, 0xc8, 0xa2, 0xba, 0x8e, 0x0a, 0xac, 0xab, 0xfe, 0xb2, 0x3c, 0xc6, 0x55, 0x23, 0xde, 0x93,
  0xa1, 0x62, 0x3d, 0xaa, 0x68, 0x91, 0xf2, 0x89, 0xce, 0x81, 0x6d, 0x14, 0x14, 0xb4, 0xf6, 0xd1,
  0x9b, 0x85, 0x62, 0xbf, 0x3e, 0xa4, 0xe7, 0xa1, 0x0d, 0xd4, 0x23, 0xfc, 0x32, 0x30, 0xc7, 0x5c,
  0xb0, 0xd2, 0xb0, 0x3e, 0x33, 0x0a, 0x99, 0xa5, 0x1a, 0xe8, 0xd0, 0x21, 0x05, 0xde, 0xab, 0xe2,
  0xd9, 0x4e, 0x96, 0x46, 0x5d, 0x92, 0x92, 0x06, 0x55, 0x5c, 0x7a, 0xcb, 0x03, 0xda, 0x84, 0xa9,
  0x11, 0xac, 0x4f, 0xa0, 0x80, 0x2e, 0x64, 0x73, 0x5f, 0x43, 0xfc, 0xba, 0xee, 0xdd, 0x4f, 0x4c,
  0x57, 0x75, 0x6c, 0xa2, 0x1e, 0x5f, 0x3b, 0xc5, 0xb3, 0x45, 0x36, 0xdd, 0xe7, 0xa1, 0x15, 0x32,
  0x18, 0x35, 0x0a, 0x80, 0x11, 0xc7, 0x05, 0xa0, 0x0f, 0x15, 0xcd, 0x47, 0x2b, 0xe4, 0x4b, 0x7b,
  0xe2, 0x9a, 0xa6, 0x2b, 0xe1, 0x3e, 0xaf, 0x32, 0x12, 0xea, 0xa8, 0xef, 0x98, 0xd1, 0x1a, 0xca,
  0x0d, 0x53, 0xee, 0x18, 0x17, 0x71, 0x8f, 0x1f, 0xdd, 0x3f, 0x02, 0xde, 0xec, 0xa1, 0x53, 0x81,
  0xd3, 0x13, 0xcc, 0x77, 0x41, 0x5a, 0xa1, 0x4f, 0x89, 0x6d, 0x65, 0xb4, 0x32, 0xcf, 0x80, 0x69,
  0xd0, 0x7e, 0x7f, 0xef, 0x21, 0xd9, 0x40, 0x5e, 0xf6, 0x7e, 0xfc, 0x68, 0x4b, 0x67, 0x8a, 0xd2,
  0x93, 0xce, 0xa8, 0xa2, 0xa8, 0x7b, 0x05, 0x51, 0x28, 0xb7, 0x31, 0x91, 0x6a, 0xa4, 0xcb, 0xdc,
  0xc6, 0x0d, 0x01, 0x6a, 0x70, 0x5a, 0x4c, 0x23, 0xa6, 0x3f, 0xc0, 0x4b, 0x68, 0x2e, 0x58, 0xdc,
  0x34, 0x7a, 0xb4, 0x9e, 0x40, 0xb7, 0x0e, 0x4a, 0x81, 0x1e, 0x1f, 0x6b, 0xe6, 0x12, 0x28, 0x08,
  0x6d, 0x51, 0x5d, 0x00, 0xf9, 0xd2, 0xa2, 0x46, 0x01, 0xbd, 0x6f, 0x8d, 0xbf, 0x22, 0x28, 0xaa,
  0x44, 0x63, 0x41, 0xd6, 0x04, 0x3e, 0x7b, 0x4d, 0x80, 0xa9, 0x24, 0x8e, 0x60, 0xba, 0xea, 0x30,
  0x05, 0x80, 0x9c, 0xa6, 0xc7, 0xee, 0xbe, 0x80, 0x11, 0x61, 0xd4, 0x9a, 0xdf, 0x7f, 0x54, 0x65,
  0x89, 0xde, 0x35, 0xcf, 0xd8, 0x5e, 0xc2, 0x37, 0x8f, 0x8c, 0x3f, 0x7e, 0xb0, 0x79, 0xf4, 0x8a,
  0x60, 0x10, 0x57, 0xbc, 0x4b, 0xd0, 0x75, 0x20, 0xae, 0xaf, 0x31, 0x8d, 0x98, 0xd6, 0x02, 0x29,
  0xec, 0x01, 0x3d, 0x12, 0x5e, 0x92, 0xef, 0x24, 0x60, 0xfc, 0xc1, 0x4b, 0xa0, 0x62, 0xcc, 0x1f,
  0x05, 0xd1, 0x1f, 0xda, 0x12, 0x58, 0x9e, 0x81, 0x80, 0xf9, 0x23, 0x05, 0xed, 0x27, 0xa7, 0xfc,
  0xe7, 0xa0, 0x30, 0x8a, 0x3f, 0x77, 0x9e, 0x82, 0x75, 0x27, 0x22, 0xba, 0x60, 0x42, 0x50, 0x89,
  0xde, 0xd6, 0x3b, 0x1d, 0x28, 0xc4, 0xc4, 0xfa, 0x5c, 0x53, 0x5d, 0xad, 0x87, 0x6e, 0xac, 0x37,
  0xc9, 0x62, 0xb2, 0x4e, 0x98, 0x07, 0x3e, 0xda, 0x40, 0xaf, 0xec, 0x2e, 0xec, 0x58, 0xac, 0xa3,
  0xaf, 0x94, 0xcb, 0x3d, 0xd4, 0x03, 0xcd, 0x65, 0x15, 0x20, 0xe5, 0x41, 0x77, 0x19, 0x74, 0x30,
  0x8f, 0xa5, 0xb6, 0x30, 0x7f, 0x93, 0x34, 0x74, 0x6f, 0x83, 0x64, 0x0d, 0xa9, 0xad, 0x53, 0xcf,
  0x7c, 0x45, 0x58, 0x71, 0x2e, 0xe1, 0x0d, 0x97, 0x69, 0xcd, 0xda, 0xd0, 0x46, 0xb7, 0x8f, 0x42,
  0x96, 0x60, 0x87, 0xbd, 0xb0, 0x2d, 0xe6, 0x14, 0xe4, 0x3e, 0x7b, 0xa4, 0x20, 0x8a, 0xb9, 0x37,
  0x69, 0x68, 0xf6, 0x99, 0x72, 0xe2, 0x3f, 0x02, 0x00, 0x11, 0xe4, 0x9f, 0xcb, 0xbd, 0x5c, 0xd3,
  0x94, 0xce, 0x39, 0x15, 0x6c, 0x40, 0xe0, 0xb9, 0x55, 0xce, 0x69, 0xe0, 0x04, 0x9b, 0xaf, 0xf5,
  0xd4, 0x0c, 0xb5, 0x10, 0xe7, 0xd4, 0x4c, 0x67, 0x5e, 0x2d, 0x6f, 0xff, 0x41, 0xa7, 0x36, 0x3f,
  0x95, 0x5e, 0xfa, 0xc2, 0x3a, 0xcd, 0xda, 0xa7, 0xc8, 0x8b, 0xcf, 0x8a, 0xc1, 0x9f, 0x30, 0xd7,
  0xd9, 0xda, 0xa3, 0x4b, 0x81, 0x17, 0x0f, 0xdb, 0x60, 0xa6, 0xa8, 0x03, 0xe2, 0xd9, 0xf9, 0xa5,
  0x7b, 0xe2, 0xd9, 0x41, 0xf1, 0x4c, 0x77, 0x4d, 0x5a, 0x29, 0xfc, 0xa5, 0x28, 0x59, 0xf7, 0xc5,
  0x0b, 0x49, 0x59, 0x21, 0x0a, 0xf4, 0x3d, 0x0a, 0x84, 0xcd, 0x8e, 0x90, 0x76, 0xcc, 0x9a, 0xf7,
  0x8b, 0x4f, 0x52, 0x5e, 0x49, 0xd0, 0x2e, 0xd8, 0xac, 0x91, 0xc0, 0x86, 0x87, 0x29, 0x04, 0xb3,
  0x31, 0xe4, 0x77, 0xf1, 0x18, 0x86, 0x04, 0xbb, 0x4e, 0xa2, 0xa9, 0xe4, 0xd6, 0xcd, 0xe5, 0xbd,
  0x24, 0x13, 0x5d, 0x9b, 0x58, 0xd6, 0x66, 0x9b, 0x60, 0xbe, 0xd7, 0x87, 0x59, 0xe1, 0xbc, 0x91,
  0x40, 0xcd, 0xef, 0xa9, 0xce, 0xd9, 0xd8, 0xf4, 0xfc, 0x1b, 0x4c, 0x44, 0xa2, 0x24, 0xc2, 0x59,
  0xf1, 0xa8, 0x3f, 0x81, 0x1d, 0xae, 0x3f, 0xf9, 0xcc, 0xec, 0xce, 0x05, 0x74, 0x10, 0x1a, 0x53,
  0xb6, 0x45, 0xe7, 0x37, 0x1e, 0x1a, 0xd2, 0x78, 0x01, 0x03, 0x27, 0xaa, 0xdb, 0x93, 0xfa, 0xba,
  0x99, 0x62, 0x0f, 0xea, 0x84, 0x4e, 0x81, 0x08, 0x16, 0x5e, 0xd8, 0xac, 0xa0, 0x33, 0x42, 0xc9,
  0xe4, 0x7e, 0xb9, 0xbe, 0x80, 0x4f, 0xfe, 0x99, 0x04, 0x0e, 0x52, 0x06, 0xaa, 0xed, 0x90, 0x5d,
  0xbc, 0xd5, 0x28, 0x15, 0x72, 0xdb, 0x6c, 0x90, 0x6c, 0x4e, 0x96, 0x7f, 0xda, 0x75, 0x3b, 0x00,
  0xd5, 0x0c, 0x99, 0x7c, 0xb4, 0xd6, 0x01, 0x32, 0xa7, 0x98, 0x2b, 0x87, 0x9a, 0xdb, 0x89, 0x6c,
  0xff, 0xb8, 0x56, 0x93, 0xba, 0x33, 0x52, 0x50, 0x46, 0x1a, 0xa8, 0xa8, 0x4c, 0xdb, 0x6e, 0x2a,
  0x2f, 0x26, 0xe5, 0x64, 0xa8, 0xce, 0x73, 0x68, 0xcb, 0x04, 0x18, 0x85, 0xee, 0xde, 0x43, 0xc7,
  0x5c, 0x7e, 0xb7, 0x54, 0x53, 0x7f, 0x23, 0x22, 0x72, 0x10, 0xbb, 0xd6, 0xea, 0x96, 0x66, 0x23,
  0x1f, 0xf7, 0x54, 0xb3, 0x6d, 0x90, 0x4b, 0x7a, 0xcb, 0x95, 0xe8, 0xd0, 0x4d, 0x47, 0x7a, 0xd2,
  0x4b, 0x34, 0x82, 0xba, 0x3d, 0x75, 0x40, 0x44, 0x55, 0x49, 0xf6, 0x2c, 0x5b, 0x7f, 0xc3, 0x3b,
  0x12, 0x0c, 0x14, 0xce, 0x30, 0x07, 0xe8, 0xb7, 0x8f, 0xb7, 0x75, 0x9b, 0x5d, 0x74, 0xee, 0x8d,
  0xdb, 0x9f, 0x31, 0x44, 0xb1, 0x85, 0x0d, 0x52, 0xcf, 0xff, 0x74, 0xd2, 0xf9, 0x9f, 0x16, 0x88,
  0x3f, 0xdd, 0xd6, 0x98, 0x5f, 0xc7, 0xd8, 0x98, 0xb1, 0x86, 0xe9, 0x60, 0xea, 0x7e, 0xab, 0xe9,
  0x85, 0x0e, 0x79, 0x2f, 0xb0, 0xa8, 0xd5, 0xcd, 0x0c, 0x00, 0xca, 0x20, 0x20, 0x16, 0x9a, 0x60,
  0x8a, 0x3c, 0x2e, 0xc1, 0x14, 0xb5, 0x49, 0xdd, 0xcc, 0xe6, 0x45, 0x6d, 0x4a, 0x7f, 0xf8, 0x95,
  0x5d, 0xf0, 0x98, 0xd1, 0xb3, 0xf9, 0x79, 0x3d, 0xd2, 0x94, 0x0d, 0x05, 0xa2, 0x50, 0x6d, 0xaf,
  0x02, 0x66, 0x4d, 0xea, 0x60, 0xca, 0xc1, 0xff, 0xfc, 0x1a, 0xb3, 0x0d, 0x3b, 0x68, 0x46, 0xdd,
  0x30, 0x81, 0x90, 0x01, 0xc6, 0xb7, 0x22, 0x54, 0xa2, 0x15, 0xa0, 0x45, 0x7f, 0x28, 0x99, 0xe8,
  0x50, 0x32, 0x11, 0xd4, 0x07, 0x50, 0xae, 0xc2, 0x1b, 0xbe, 0x1c, 0x08, 0x47, 0x24, 0xbf, 0xc1,
  0xca, 0x27, 0x26, 0xeb, 0x25, 0x89, 0x42, 0xc2, 0xb1, 0x13, 0x1c, 0x39, 0x09, 0x75, 0xed, 0xd2,
  0x63, 0x71, 0x36, 0xcd, 0x00, 0x42, 0x8f, 0x10, 0xa3, 0x61, 0x76, 0x0d, 0xc6, 0x04, 0xf4, 0x75,
  0x89, 0x6e, 0xe8, 0xab, 0xd1, 0xf0, 0x5e, 0xab, 0xb1, 0xee, 0x50, 0x2a, 0xe9, 0x1b, 0x40, 0xc1,
  0x34, 0xf5, 0xe1, 0x2d, 0xa4, 0x16, 0xca, 0x72, 0x06, 0x73, 0xb0, 0x8a, 0x6a, 0xba, 0x7a, 0x4c,
  0xb5, 0x5c, 0x55, 0xce, 0x40, 0xd5, 0xe5, 0x5c, 0x74, 0xf9, 0x28, 0x76, 0x06, 0xa6, 0xd8, 0x00,
  0x84, 0xbd, 0x08, 0xa0, 0x42, 0x6c, 0xdc, 0x88, 0xf6, 0x1c, 0xb1, 0x03, 0x3d, 0xb6, 0x25, 0x6d,
  0x02, 0xdc, 0x0a, 0x3f, 0x53, 0xe0, 0x51, 0x44, 0xfc, 0x3a, 0xc8, 0xc6, 0x0c, 0xb2, 0xba, 0x95,
  0x31, 0xa9, 0x8b, 0xd5, 0x50, 0x70, 0xd0, 0x74, 0x0a, 0x83, 0x9e, 0x65, 0xe6, 0x53, 0x19, 0x53,
  0x84, 0x36, 0x7e, 0xa6, 0x00, 0x7e, 0xb6, 0xe3, 0x82, 0xdc, 0x56, 0x15, 0x7f, 0xa6, 0x8f, 0x5c,
  0xea, 0x89, 0x01, 0xb3, 0xc2, 0x43, 0x75, 0xaf, 0x4e, 0x33, 0xe9, 0xe9, 0xc7, 0x14, 0xe8, 0x00,
  0x4e, 0xf8, 0x3d, 0x87, 0xfa, 0xe2, 0x4f, 0x35, 0xbc, 0xf2, 0x9c, 0x2c, 0x91, 0x8d, 0x4e, 0xbb,
  0x96, 0x35, 0xd9, 0xa7, 0xdc, 0x12, 0x25, 0x21, 0xf1, 0x59, 0x95, 0x6d, 0x37, 0x02, 0x27, 0x11,
  0x8f, 0x9e, 0xab, 0x78, 0x3f, 0xd4, 0xd8, 0x59, 0x14, 0x29, 0x27, 0x1e, 0x52, 0xc6, 0x7c, 0x16,
  0xdb, 0x12, 0x03, 0x0f, 0xb8, 0xb1, 0x25, 0x06, 0x16, 0xa6, 0x6f, 0x8a, 0x64, 0x1c, 0x21, 0x9b,
  0xd2, 0x71, 0xda, 0xd0, 0x0f, 0xd8, 0xe2, 0xa6, 0x9e, 0x49, 0xd3, 0x2c, 0x3f, 0xcd, 0xeb, 0x27,
  0x1f, 0x2f, 0x4a, 0x3f, 0x59, 0xf4, 0xf1, 0x64, 0x88, 0x50, 0x04, 0x50, 0x37, 0x8a, 0xcd, 0x85,
  0xbc, 0x8c, 0xca, 0x4a, 0x84, 0x3a, 0x7b, 0x10, 0xec, 0xa4, 0x47, 0xfd, 0xf9, 0x76, 0xd8, 0x9f,
  0xcf, 0xd4, 0x48, 0x2a, 0xbb, 0xa5, 0x09, 0x10, 0xd2, 0x61, 0x8f, 0xd3, 0x0c, 0xdd, 0xef, 0xa5,
  0x4d, 0x38, 0xaf, 0x20, 0xe6, 0xac, 0x9f, 0x56, 0xda, 0x81, 0xbe, 0xfe, 0x8a, 0x22, 0xc7, 0xb3,
  0x0a, 0xf4, 0xb0, 0x52, 0x1e, 0xf4, 0xe1, 0x3c, 0x98, 0x9a, 0xf8, 0x59, 0x96, 0x26, 0xbb, 0x2f,
  0x32, 0x19, 0x5c, 0x18, 0x99, 0x14, 0xf9, 0x4d, 0x9d, 0x91, 0xb9, 0x84, 0xce, 0x70, 0x7e, 0x53,
  0x6b, 0x32, 0xed, 0xe5, 0xd0, 0x58, 0xde, 0xd0, 0xf8, 0xb6, 0x17, 0x17, 0xd0, 0x74, 0x32, 0xf8,
  0x7e, 0x5b, 0x32, 0x4d, 0xd2, 0x49, 0x11, 0x6a, 0x9b, 0x80, 0xac, 0x41, 0x2a, 0xb2, 0x35, 0xc1,
  0xb9, 0xe5, 0x51, 0x0e, 0xe2, 0x3e, 0x1e, 0x73, 0x4f, 0xe9, 0x64, 0x82, 0x56, 0xfa, 0x33, 0x39,
  0x17, 0x04, 0xe9, 0xd9, 0x02, 0xbc, 0x26, 0xc5, 0xa4, 0x90, 0x4e, 0x0a, 0xc9, 0xa0, 0xcd, 0xfd,
  0x60, 0x3c, 0xcb, 0x3b, 0x16, 0x1b, 0x20, 0x3f, 0xa9, 0x1b, 0x3f, 0x28, 0x7f, 0x1a, 0xe6, 0x4e,
  0x9b, 0x2e, 0x03, 0x43, 0xdb, 0x00, 0x9e, 0x21, 0xc0, 0x2d, 0xc4, 0x9f, 0xef, 0x29, 0x6a, 0x0e,
  0x8a, 0x33, 0xdf, 0x2d, 0x5f, 0x4f, 0x1e, 0xd8, 0xd6, 0x3e, 0xc5, 0x73, 0xc2, 0x7f, 0xca, 0x64,
  0x10, 0x19, 0x74, 0xc1, 0xa3, 0x9d, 0x45, 0x73, 0xc1, 0x69, 0xd0, 0x8f, 0x61, 0x6d, 0x24, 0x43,
  0xa5, 0xbc, 0xc4, 0x64, 0x1d, 0x6c, 0x07, 0x91, 0x3a, 0xec, 0xeb, 0xb3, 0xa4, 0x7f, 0x4d, 0xb1,
  0x3a, 0xc8, 0xf4, 0x80, 0x49, 0x0d, 0x64, 0x54, 0x76, 0xbe, 0x18, 0x0a, 0xf2, 0x8f, 0x81, 0x25,
  0xf8, 0x7f, 0xc2, 0x7a, 0x52, 0x0c, 0x4e, 0x16, 0x27, 0x83, 0xbb, 0xdd, 0x93, 0x69, 0x40, 0x81,
  0x34, 0x11, 0x18, 0x72, 0xf1, 0x79, 0x4a, 0x51, 0x04, 0x72, 0xda, 0x30, 0xb6, 0xe8, 0x31, 0x07,
  0x5e, 0x9c, 0xfa, 0xaa, 0x45, 0xbc, 0x70, 0x70, 0x3f, 0x85, 0x32, 0x86, 0x5e, 0x35, 0xca, 0x1e,
  0xd9, 0x5c, 0xdc, 0x4f, 0xe5, 0x7f, 0xc2, 0x0b, 0x9f, 0x90, 0xfc, 0xcd, 0xbf, 0xab, 0x34, 0xe9,
  0x5d, 0x56, 0x9a, 0x14, 0xfd, 0x4b, 0x63, 0x93, 0x23, 0xdd, 0xd1, 0x5b, 0xb0, 0x70, 0xcd, 0xe7,
  0x22, 0xba, 0xff, 0x53, 0x18, 0xec, 0x93, 0x14, 0x23, 0xda, 0x50, 0x6a, 0x46, 0x1d, 0xc5, 0xfb,
  0x18, 0x20, 0x12, 0x26, 0xfa, 0x91, 0x72, 0xf4, 0xfe, 0xee, 0x9b, 0x97, 0x5d, 0xe2, 0x72, 0xdb,
  0xd2, 0xd9, 0x9c, 0x5e, 0x31, 0x27, 0x7b, 0x2a, 0x89, 0x9a, 0x5e, 0x52, 0xe0, 0x1b, 0x45, 0xfc,
  0x2e, 0x31, 0x53, 0x1d, 0xe9, 0x5d, 0x15, 0xf4, 0x31, 0x09, 0xda, 0xb2, 0x1b, 0x5d, 0xba, 0x71,
  0xae, 0x64, 0xff, 0x99, 0x4a, 0x6d, 0x7c, 0xd3, 0x7a, 0xb6, 0xd5, 0x27, 0xef, 0x80, 0x76, 0x1b,
  0x2c, 0x08, 0x41, 0x12, 0x7e, 0x3a, 0x6a, 0x47, 0xb5, 0xf5, 0xac, 0xee, 0xed, 0xeb, 0x00, 0xc5,
  0xb3, 0xfa, 0x79, 0x0f, 0x34, 0xcd, 0x77, 0xfd, 0xdc, 0x6a, 0xc3, 0x1f, 0xb5, 0x1d, 0xca, 0xd5,
  0x95, 0x85, 0x1b, 0xcb, 0x38, 0x47, 0xa4, 0x40, 0xa9, 0xb3, 0x41, 0xaf, 0x92, 0x7f, 0x1d, 0xf1,
  0xb9, 0xba, 0xa1, 0x33, 0x45, 0x0c, 0xe8, 0x95, 0x4e, 0x66, 0xb3, 0xc9, 0xb4, 0x2e, 0xf5, 0x2c,
  0xc7, 0x85, 0x9f, 0x01, 0x4c, 0x51, 0x0c, 0x96, 0x86, 0x47, 0x76, 0xab, 0x69, 0x1a, 0xd8, 0x10,
  0xac, 0x11, 0x61, 0xee, 0x6d, 0x71, 0x81, 0xdc, 0xf8, 0xc6, 0xd0, 0xc5, 0xd7, 0x7d, 0x60, 0xb4,
  0x49, 0x5d, 0xc7, 0xb5, 0xca, 0x12, 0x6d, 0x10, 0x80, 0xf8, 0x11, 0xa0, 0x7a, 0x12, 0x2f, 0x62,
  0x4c, 0xd2, 0x9d, 0x1d, 0xeb, 0x85, 0xb0, 0x2b, 0x17, 0x93, 0xf5, 0xbc, 0xc8, 0xde, 0xeb, 0xf4,
  0x38, 0x3f, 0x4c, 0x8d, 0x8f, 0x41, 0x65, 0xf2, 0x0c, 0x98, 0x2b, 0xe1, 0xcf, 0x07, 0xc0, 0xf0,
  0x2a, 0x84, 0x79, 0xd8, 0x03, 0x7f, 0x1b, 0x9e, 0x29, 0xec, 0x0b, 0x6f, 0x07, 0xc8, 0xe9, 0xa2,
  0x17, 0x09, 0xc1, 0x36, 0x29, 0x30, 0x98, 0x84, 0xf2, 0xac, 0xa7, 0xc5, 0x6e, 0x78, 0xef, 0x8f,
  0xe4, 0xa9, 0xce, 0x9f, 0x01, 0xaf, 0xa8, 0x85, 0xc1, 0x14, 0xd3, 0xb9, 0x68, 0x76, 0xe0, 0x89,
  0x8b, 0x66, 0x03, 0x1e, 0xb9, 0x68, 0x56, 0x95, 0x68, 0x74, 0x06, 0x53, 0x2b, 0x69, 0x55, 0x50,
  0x9d, 0x78, 0x55, 0x1d, 0x9e, 0x78, 0x55, 0x0b, 0x1f, 0x03, 0x95, 0x05, 0xa0, 0x7a, 0xef, 0x54,
  0xa5, 0x01, 0xd0, 0x9f, 0x69, 0x66, 0xd0, 0xa4, 0xb1, 0x01, 0xea, 0x4d, 0x1d, 0xf4, 0x21, 0x71,
  0xa8, 0x38, 0xe9, 0xb8, 0x0e, 0x80, 0xa6, 0xed, 0x8c, 0x54, 0xe8, 0x02, 0x91, 0x60, 0x5a, 0xae,
  0x3b, 0x63, 0x9d, 0x1a, 0x25, 0x5c, 0x09, 0xa4, 0xae, 0xfc, 0x99, 0x86, 0xac, 0x8a, 0x97, 0x7a,
  0xd4, 0x3d, 0x5d, 0x4f, 0x02, 0xb0, 0x52, 0xa9, 0xb4, 0x4e, 0x73, 0xba, 0xf4, 0xb6, 0x82, 0x20,
  0xaf, 0x1b, 0xca, 0x6b, 0xa1, 0x3d, 0x1d, 0x64, 0xb5, 0x42, 0x59, 0xaa, 0x31, 0xe8, 0xa9, 0x7e,
  0x1e, 0xaa, 0xcc, 0xa6, 0xa4, 0xb2, 0xac, 0x17, 0x62, 0x8c, 0x74, 0x00, 0xc9, 0x96, 0x11, 0x17,
  0xd7, 0x9d, 0x2b, 0xd2, 0x07, 0x4b, 0x40, 0xc5, 0x9d, 0x33, 0xaa, 0xc1, 0xc2, 0xaa, 0x14, 0x4a,
  0xca, 0xe8, 0x80, 0x9f, 0x14, 0x06, 0x4b, 0x60, 0xc5, 0x8c, 0x2e, 0x64, 0xad, 0xd0, 0x3a, 0x97,
  0x88, 0x5b, 0xc7, 0x1c, 0xb6, 0x86, 0xb1, 0x06, 0x7b, 0xa1, 0x5e, 0x02, 0x9a, 0xb3, 0x4a, 0x41,
  0x2a, 0xb3, 0x1c, 0x07, 0xe1, 0xd3, 0xe9, 0x12, 0x2a, 0xe0, 0xb0, 0x3c, 0xe6, 0x2d, 0xf0, 0xbe,
  0xce, 0x11, 0x64, 0x8f, 0xe6, 0x73, 0x8a, 0x62, 0x6a, 0x07, 0x78, 0xa1, 0x50, 0x09, 0x83, 0xc6,
  0xa1, 0x64, 0x72, 0x3f, 0x87, 0x69, 0x2b, 0x8d, 0x2b, 0xb1, 0x38, 0x9b, 0xd4, 0x8d, 0x0d, 0xb5,
  0x3e, 0x04, 0xdd, 0xd3, 0xd8, 0x18, 0xd6, 0x55, 0x5a, 0xcd, 0x16, 0x80, 0x56, 0x2b, 0x29, 0xf5,
  0xf7, 0x08, 0xf5, 0xf8, 0x28, 0x8b, 0x28, 0x6d, 0x61, 0xdc, 0xc9, 0x34, 0x10, 0x06, 0x04, 0x29,
  0xfe, 0xb6, 0x50, 0x88, 0x3e, 0x89, 0x8f, 0xa8, 0x1d, 0xd0, 0xec, 0x7c, 0xa9, 0x14, 0x53, 0xe0,
  0x29, 0x86, 0xbc, 0x3e, 0x44, 0x2c, 0x66, 0x43, 0x71, 0x39, 0x1e, 0xa2, 0x97, 0xed, 0x41, 0x8e,
  0x40, 0x0c, 0x33, 0xc5, 0x12, 0x40, 0xaf, 0x1f, 0x72, 0x3c, 0x40, 0x2f, 0x1b, 0x00, 0x07, 0x00,
  0x23, 0xac, 0xe4, 0x41, 0x54, 0x97, 0xea, 0xf0, 0x8e, 0x7c, 0x06, 0x7a, 0xa9, 0xbf, 0x1e, 0x3b,
  0x06, 0x9a, 0xcd, 0xe3, 0x13, 0x63, 0xc2, 0x28, 0x5f, 0x3a, 0x4b, 0x7c, 0x09, 0xb3, 0xd4, 0xc9,
  0x58, 0x30, 0x11, 0x31, 0x96, 0x0a, 0xbd, 0xab, 0xce, 0xba, 0x9a, 0x56, 0x8c, 0x6c, 0x55, 0x1c,
  0xa6, 0x95, 0x1c, 0xa3, 0xac, 0xa6, 0xb4, 0x5d, 0xce, 0xb8, 0x57, 0x16, 0xde, 0xff, 0xa4, 0xa2,
  0xf7, 0x4f, 0x83, 0x15, 0xbc, 0x0d, 0x7f, 0xbb, 0x62, 0x07, 0xfe, 0xb6, 0xd6, 0x79, 0x1c, 0xe6,
  0x23, 0x7e, 0x45, 0xf7, 0xe7, 0xd0, 0xeb, 0x78, 0x8f, 0x76, 0xb7, 0x4d, 0xff, 0x76, 0x68, 0x97,
  0x7d, 0x9b, 0x58, 0x5f, 0xe2, 0x6c, 0x8a, 0x18, 0xfc, 0xec, 0x2d, 0x1d, 0x7d, 0x59, 0x2a, 0x97,
  0xcb, 0x22, 0xbd, 0x94, 0x05, 0xdf, 0x0b, 0x05, 0xa9, 0x50, 0x28, 0xc0, 0xbb, 0xcc, 0xde, 0x4b,
  0x32, 0x7d, 0xee, 0xe0, 0x73, 0xd9, 0x2b, 0x8b, 0x97, 0xa6, 0xc0, 0x7b, 0xd5, 0x2b, 0xdb, 0x61,
  0xef, 0x14, 0x93, 0x0c, 0xf0, 0xd3, 0xf2, 0xac, 0xc1, 0x31, 0x0e, 0x70, 0x8c, 0xc0, 0xbe, 0x57,
  0xd6, 0xbe, 0x63, 0xa4, 0x40, 0xef, 0x86, 0x49, 0x06, 0xda, 0xb6, 0x0c, 0x3a, 0x26, 0x4e, 0x17,
  0xd0, 0x35, 0xe3, 0x0b, 0x20, 0x64, 0x5e, 0x64, 0x3d, 0x34, 0x88, 0x1e, 0x94, 0x49, 0xa6, 0x07,
  0x12, 0x1b, 0xfe, 0x40, 0x72, 0x40, 0x93, 0xa2, 0x0f, 0xb0, 0x5e, 0xfd, 0x19, 0x10, 0x97, 0x15,
  0x1b, 0xf1, 0x62, 0x23, 0xaf, 0xd8, 0xc8, 0x2b, 0xf6, 0x14, 0x3b, 0x8d, 0xe9, 0x6e, 0x6a, 0x7c,
  0x77, 0x60, 0xe6, 0x43, 0x77, 0x00, 0x76, 0xb4, 0x3b, 0x74, 0xb5, 0x8a, 0x36, 0xda, 0xe5, 0x8d,
  0x76, 0xbd, 0x46, 0xbb, 0x7e, 0xa3, 0x7c, 0x96, 0x07, 0xfa, 0xd8, 0xd4, 0x5d, 0xd4, 0x2a, 0x60,
  0x35, 0x15, 0x67, 0x96, 0x49, 0xaf, 0x5b, 0x0c, 0x14, 0x8b, 0x70, 0xb8, 0xef, 0xc2, 0x96, 0x00,
  0x37, 0x12, 0xc2, 0x6b, 0x51, 0x74, 0xed, 0xd0, 0xc3, 0x6b, 0xc7, 0xba, 0xfd, 0xe9, 0xda, 0xb1,
  0x01, 0x72, 0xca, 0x04, 0x39, 0x85, 0x96, 0xa7, 0x03, 0x42, 0xc7, 0x97, 0xa0, 0xbe, 0xfc, 0xa4,
  0x51, 0x7b, 0xb2, 0xc0, 0xcd, 0xb0, 0x05, 0xbb, 0xc9, 0xfa, 0x09, 0x03, 0x5c, 0x2d, 0xa2, 0xc2,
  0xf2, 0x5d, 0x5d, 0x9a, 0x47, 0x7e, 0xb4, 0x6f, 0xda, 0xa0, 0x12, 0x34, 0xb5, 0x24, 0xed, 0x55,
  0x21, 0x6e, 0x09, 0xa1, 0xa5, 0x97, 0xe5, 0x39, 0x88, 0xf2, 0x9f, 0xc6, 0x7a, 0x20, 0x1a, 0x43,
  0x22, 0x28, 0x66, 0xf9, 0xc2, 0xf5, 0x09, 0x8a, 0x2f, 0xc8, 0x74, 0x83, 0x49, 0x74, 0x8c, 0x43,
  0xf2, 0x02, 0xb4, 0x25, 0x7a, 0xb4, 0x92, 0x29, 0xbf, 0xb8, 0x15, 0x6c, 0x3f, 0x86, 0x07, 0xfa,
  0x04, 0x33, 0xde, 0x95, 0x38, 0x09, 0x53, 0x34, 0xd8, 0xb6, 0x0d, 0xf6, 0x92, 0x10, 0x8e, 0x2e,
  0x14, 0x75, 0x8c, 0x66, 0x0c, 0xd4, 0xf2, 0xb6, 0x3e, 0x4a, 0x2e, 0x73, 0x82, 0xbe, 0xa8, 0xa9,
  0x37, 0x69, 0x23, 0x49, 0xae, 0x6b, 0x2f, 0x95, 0x0f, 0x3e, 0x83, 0x90, 0xf4, 0xbe, 0xba, 0x90,
  0xf4, 0x95, 0x60, 0x2b, 0xa4, 0x02, 0xc3, 0x02, 0xc4, 0x6c, 0x1d, 0x66, 0x5c, 0x41, 0x0a, 0x58,
  0xc0, 0xa1, 0xdb, 0xcc, 0xf1, 0x18, 0x9d, 0xae, 0x05, 0x56, 0xce, 0x77, 0x4d, 0xd3, 0x12, 0xf9,
  0xd2, 0x9f, 0x22, 0xfd, 0xa0, 0x05, 0x7e, 0xe9, 0x52, 0xc6, 0x67, 0x4c, 0x95, 0x13, 0x95, 0x20,
  0x1d, 0xf4, 0xf3, 0x00, 0x0a, 0x7a, 0xa0, 0xea, 0x49, 0x7e, 0x3f, 0x7d, 0x72, 0x0e, 0x03, 0x06,
  0x1c, 0x78, 0x63, 0x8d, 0x1d, 0xd8, 0x1e, 0x6f, 0xef, 0x2b, 0x03, 0x0c, 0xd4, 0x76, 0x7a, 0xd7,
  0x38, 0x53, 0xfb, 0x3d, 0x37, 0x4e, 0x92, 0x9e, 0x5c, 0xf1, 0xc6, 0xcb, 0xdf, 0x3e, 0x1c, 0xf1,
  0x76, 0x2a, 0xc9, 0x3e, 0xcd, 0x0d, 0x33, 0xf7, 0xb3, 0xf9, 0x91, 0xc4, 0xd3, 0x13, 0xd6, 0x00,
  0xac, 0x19, 0x3c, 0x4e, 0x82, 0x4d, 0x24, 0x31, 0x8c, 0x50, 0x44, 0x23, 0x94, 0x8d, 0xf1, 0x54,
  0x9c, 0x79, 0xc6, 0x51, 0x1d, 0xf8, 0x83, 0x7d, 0xfa, 0xc1, 0x66, 0x26, 0x95, 0x88, 0x36, 0x68,
  0xc4, 0xe7, 0x05, 0x96, 0x9a, 0x9f, 0xd4, 0x1c, 0x75, 0x79, 0x04, 0xba, 0x97, 0x42, 0x37, 0xbe,
  0xc5, 0x49, 0x5d, 0x95, 0x26, 0xa0, 0x2c, 0xa8, 0xd2, 0x14, 0xd5, 0xd9, 0xb0, 0x46, 0xfb, 0x47,
  0xa0, 0xd1, 0xa2, 0xf7, 0x24, 0xe4, 0x09, 0x64, 0x0a, 0x2b, 0x48, 0x86, 0x54, 0xd4, 0x83, 0xe4,
  0xf1, 0xb1, 0x40, 0x57, 0x32, 0xa6, 0xca, 0x3a, 0x8a, 0x45, 0x95, 0x0c, 0x43, 0xb1, 0x17, 0x2c,
  0xd9, 0x20, 0x9c, 0xf8, 0x23, 0xd5, 0x64, 0xa5, 0xe3, 0x06, 0x1d, 0x13, 0xb9, 0xaa, 0x9c, 0xbe,
  0xa4, 0xfb, 0x04, 0x3d, 0xf1, 0x1b, 0x68, 0x5e, 0x3f, 0x53, 0x1d, 0x37, 0x8b, 0x7e, 0x20, 0x11,
  0xc3, 0xfa, 0x1d, 0x3a, 0xd5, 0x01, 0x0f, 0x4a, 0xd4, 0xef, 0xb4, 0xe8, 0xb6, 0x02, 0xc1, 0x54,
  0xcf, 0x79, 0xfe, 0x0b, 0xb0, 0x06, 0xd2, 0xea, 0x4f, 0x2a, 0x7b, 0x34, 0xcb, 0x01, 0x6a, 0xfe,
  0x44, 0x5d, 0xca, 0xf2, 0xd2, 0x1c, 0x74, 0x66, 0x40, 0x1a, 0x57, 0xc7, 0xe6, 0xd4, 0x1d, 0xf4,
  0x5f, 0xc7, 0x3e, 0xc9, 0x12, 0x4b, 0x8a, 0xf3, 0x34, 0xcc, 0xff, 0x3d, 0xf1, 0x6e, 0xd3, 0xcd,
  0x04, 0x3c, 0x10, 0xc1, 0x9e, 0xbe, 0xc5, 0x8a, 0xf9, 0x78, 0x3c, 0x2f, 0x3a, 0x12, 0x13, 0x23,
  0x10, 0x3c, 0x19, 0xd0, 0x96, 0x33, 0xa6, 0xf0, 0xcb, 0xf1, 0xe4, 0x17, 0xf7, 0xa1, 0x7c, 0xcb,
  0x51, 0xc1, 0xed, 0x28, 0x9e, 0xe3, 0xc6, 0xf0, 0xf6, 0x0e, 0x14, 0x67, 0x43, 0xa7, 0xe1, 0x4b,
  0x94, 0x73, 0xd9, 0x1d, 0x8d, 0x8e, 0x50, 0x4f, 0xe9, 0x8b, 0x02, 0x8f, 0xb2, 0x8a, 0xe2, 0xb9,
  0xee, 0x42, 0xd2, 0xce, 0x66, 0xd2, 0x8e, 0xef, 0x5f, 0x63, 0x10, 0x06, 0x46, 0xe2, 0x7d, 0x52,
  0x1f, 0x05, 0xeb, 0x02, 0x80, 0xa8, 0xb8, 0xd4, 0x59, 0xf0, 0xf7, 0x67, 0xe2, 0x72, 0xb8, 0x28,
  0x55, 0x6e, 0x91, 0x7d, 0x56, 0x0b, 0x13, 0x4f, 0x32, 0x86, 0x9d, 0x03, 0x11, 0xd7, 0x80, 0x2f,
  0x44, 0x3f, 0x16, 0x5e, 0xb4, 0x99, 0x7d, 0x58, 0x54, 0x56, 0xb5, 0xa4, 0x8a, 0xb3, 0x90, 0x93,
  0x83, 0x7d, 0x81, 0xe9, 0x21, 0x45, 0x1d, 0x2b, 0x81, 0x9f, 0x36, 0x5d, 0x93, 0x85, 0x74, 0x12,
  0xbf, 0xca, 0x94, 0x8c, 0x8a, 0xe2, 0x0f, 0xa7, 0xc4, 0xa2, 0xa4, 0x86, 0x65, 0x4e, 0x4c, 0x4c,
  0xe9, 0x35, 0x87, 0x62, 0xc2, 0xd0, 0xfb, 0x44, 0x4c, 0xa8, 0xaf, 0x43, 0x55, 0x4c, 0xe0, 0xaa,
  0x27, 0x26, 0xf0, 0xd0, 0x31, 0x08, 0x36, 0x31, 0x01, 0xe5, 0x84, 0x64, 0x3d, 0xb6, 0xb6, 0x5f,
  0x86, 0x55, 0x61, 0xd5, 0x19, 0x28, 0x0f, 0x30, 0xad, 0x3d, 0xff, 0x0c, 0x25, 0xcd, 0x40, 0x13,
  0xfc, 0x00, 0x33, 0xe1, 0xb1, 0x62, 0x3f, 0x54, 0x23, 0xe8, 0x0f, 0x33, 0xfe, 0x13, 0x1a, 0x9e,
  0xa7, 0x74, 0xf0, 0xbb, 0x34, 0x6d, 0xc2, 0x96, 0x1a, 0x31, 0xfc, 0x51, 0x78, 0xde, 0x15, 0x8e,
  0x9b, 0x63, 0xef, 0xf2, 0x71, 0xea, 0x3e, 0x58, 0xd9, 0x39, 0xbf, 0xd8, 0x57, 0xfb, 0x46, 0x35,
  0x3d, 0xd1, 0xff, 0xf0, 0x42, 0xc6, 0x91, 0x46, 0x59, 0xaa, 0x0e, 0x7e, 0x82, 0x85, 0x4d, 0x2a,
  0x19, 0x3e, 0x68, 0xc5, 0x5b, 0x36, 0x6c, 0x89, 0x7d, 0xe5, 0x29, 0xea, 0x44, 0xf4, 0x3c, 0x87,
  0x30, 0x3b, 0x2d, 0x74, 0x18, 0xae, 0x92, 0xcd, 0x0b, 0x8b, 0x4e, 0x8e, 0x2f, 0x3a, 0x84, 0x2f,
  0x3a, 0xd4, 0x5b, 0x82, 0xb2, 0xda, 0x60, 0x7b, 0x4b, 0xff, 0xee, 0x2a, 0x64, 0x3c, 0x72, 0x88,
  0x4f, 0x74, 0x39, 0x0a, 0xbd, 0x4e, 0xe7, 0x54, 0xca, 0xae, 0x58, 0xfc, 0xac, 0x70, 0x3f, 0xac,
  0x85, 0x7e, 0x30, 0x37, 0xcc, 0x7e, 0xa8, 0x37, 0x18, 0xec, 0xfa, 0x6f, 0xf5, 0xce, 0x8a, 0xf6,
  0xce, 0x0a, 0xf5, 0x2e, 0xba, 0x6a, 0x1e, 0xf3, 0x7d, 0xef, 0xe0, 0x3c, 0x98, 0xef, 0x16, 0xf2,
  0x8f, 0x1a, 0x5b, 0x9d, 0x04, 0xf7, 0xde, 0x6d, 0xb8, 0x41, 0xc8, 0xc8, 0xeb, 0x90, 0xd8, 0xd3,
  0x26, 0xbd, 0xf9, 0x0f, 0x77, 0x4f, 0x85, 0x75, 0x12, 0x39, 0xa1, 0x60, 0xd1, 0x8d, 0x5c, 0x58,
  0x5a, 0x41, 0xa6, 0xb1, 0xed, 0x72, 0x58, 0x7e, 0x78, 0x30, 0xb5, 0xb2, 0x22, 0xee, 0x84, 0x72,
  0x8f, 0x6f, 0x16, 0x44, 0x04, 0xbf, 0x1d, 0x8a, 0xc4, 0x5e, 0x7f, 0x93, 0x74, 0xdc, 0xe2, 0xd6,
  0xd9, 0x86, 0xa5, 0x83, 0x5b, 0xd4, 0xfe, 0x31, 0xba, 0x7f, 0xb1, 0xb8, 0x59, 0x20, 0xb2, 0x29,
  0xba, 0x8a, 0xe9, 0xed, 0x77, 0x3f, 0xba, 0x4f, 0xb8, 0x04, 0x83, 0xd5, 0x8a, 0x11, 0xa4, 0x18,
  0x30, 0xe1, 0x8a, 0x18, 0x55, 0x22, 0xbe, 0x06, 0x47, 0x76, 0xc8, 0xd2, 0x91, 0x1d, 0x87, 0xc1,
  0x8a, 0x44, 0xa9, 0x90, 0x70, 0x94, 0x8a, 0x68, 0x88, 0xc0, 0x63, 0xaf, 0x68, 0x08, 0x74, 0x53,
  0x86, 0xe8, 0x0a, 0xf3, 0x94, 0x99, 0xea, 0xc7, 0x2c, 0x77, 0xb3, 0x45, 0x07, 0x29, 0x1f, 0x24,
  0x68, 0x1e, 0xf3, 0x39, 0x8c, 0x02, 0xf7, 0x64, 0x44, 0x7a, 0x08, 0x1b, 0x9d, 0xdc, 0xd0, 0x19,
  0x1f, 0x45, 0x80, 0xa1, 0xf6, 0x94, 0x06, 0x12, 0x6e, 0x00, 0x71, 0x02, 0xfc, 0x2f, 0x05, 0x41,
  0x27, 0xb7, 0xcf, 0x4e, 0xb6, 0xd8, 0x5d, 0x23, 0x78, 0x56, 0x19, 0x14, 0x7d, 0xf4, 0xa4, 0x58,
  0x14, 0xe9, 0x6f, 0xe2, 0xb5, 0xb8, 0x29, 0xee, 0x8a, 0xff, 0x12, 0x5f, 0x15, 0xe8, 0xcd, 0x0d,
  0x22, 0x62, 0x4f, 0xc9, 0xe2, 0x24, 0x7e, 0x27, 0x93, 0xd4, 0x46, 0xdd, 0x79, 0xef, 0xbe, 0x9b,
  0xef, 0x83, 0xf7, 0x3f, 0x84, 0x77, 0x7b, 0xd0, 0x7b, 0xef, 0xda, 0x7a, 0xfb, 0xdd, 0x1a, 0x3b,
  0xef, 0x7d, 0x53, 0x7b, 0x37, 0xdd, 0xf1, 0x3b, 0x28, 0x85, 0x8f, 0x5a, 0xef, 0xe9, 0xfd, 0xcd,
  0xb2, 0xde, 0xff, 0x09, 0x53, 0xf9, 0xfd, 0x9f, 0x99, 0x4c, 0x56, 0x5f, 0x7f, 0x43, 0x68, 0x56,
  0x68, 0xd3, 0x1a, 0xaf, 0x6c, 0xa3, 0xe1, 0x61, 0xe1, 0x45, 0xdd, 0xdf, 0x8f, 0xc3, 0x3d, 0xf7,
  0x67, 0x8c, 0xf0, 0xc0, 0x07, 0x1a, 0x46, 0xf6, 0xe3, 0x07, 0x4b, 0xc4, 0x68, 0x1c, 0xfa, 0xc0,
  0x42, 0x3f, 0x83, 0x02, 0xb0, 0x2c, 0xc6, 0x44, 0x29, 0x60, 0x6c, 0x23, 0xc6, 0x4e, 0xe3, 0x42,
  0xe9, 0x1f, 0x06, 0x14, 0x04, 0x98, 0x2f, 0x90, 0x42, 0x42, 0x67, 0x31, 0x69, 0x2e, 0x0d, 0x24,
  0xc1, 0x07, 0x7a, 0x7e, 0xcb, 0xe4, 0xa9, 0x7d, 0xe6, 0x4f, 0x80, 0x85, 0x5b, 0x65, 0xb7, 0x00,
  0x09, 0xd1, 0xa1, 0xc0, 0x32, 0xa5, 0xf1, 0x68, 0x39, 0x25, 0x4c, 0xb9, 0x00, 0x64, 0x14, 0x10,
  0x28, 0x24, 0x5e, 0x23, 0xf2, 0x0a, 0x90, 0x3c, 0xfa, 0x56, 0x17, 0xaf, 0x91, 0x00, 0x9b, 0x4a,
  0xcc, 0xc8, 0x60, 0x0e, 0xf7, 0x61, 0x95, 0xdb, 0xe0, 0xbf, 0xa1, 0xca, 0x6e, 0x8f, 0x98, 0x52,
  0x0b, 0x26, 0x72, 0xca, 0xcb, 0xb3, 0x09, 0x68, 0x6f, 0x23, 0x1a, 0xd7, 0x0d, 0x78, 0xc7, 0x8f,
  0xb1, 0x80, 0x82, 0x2e, 0xc6, 0x1f, 0xb1, 0x7b, 0x93, 0x96, 0x2d, 0x66, 0xcf, 0x9b, 0x63, 0xaf,
  0x63, 0x18, 0xba, 0xbe, 0x8e, 0xc1, 0x6e, 0x29, 0x74, 0xaf, 0x69, 0x02, 0xe0, 0x17, 0x14, 0x75,
  0x16, 0xbd, 0xd1, 0x49, 0xd9, 0xe1, 0x48, 0x09, 0x2f, 0x64, 0x2e, 0x92, 0x18, 0x17, 0xf4, 0xba,
  0x63, 0xdb, 0x18, 0x5f, 0xed, 0xf3, 0x44, 0xea, 0x6b, 0x35, 0x70, 0x1d, 0x58, 0x88, 0xa9, 0xb5,
  0x23, 0xd1, 0x37, 0x5b, 0x18, 0x35, 0x22, 0x60, 0x00, 0xa6, 0x6e, 0x0e, 0xc1, 0x56, 0x5e, 0xce,
  0xc4, 0x33, 0x8b, 0x9e, 0x09, 0x0d, 0xad, 0xbe, 0x80, 0x2e, 0x19, 0x44, 0x02, 0x61, 0x70, 0x8d,
  0xdb, 0xb3, 0xad, 0x71, 0xc2, 0x9d, 0x8b, 0xff, 0x52, 0x5e, 0xa9, 0x1a, 0x78, 0x24, 0xde, 0x29,
  0x49, 0x98, 0x07, 0x8f, 0x99, 0x7f, 0xfc, 0x23, 0xfd, 0xb4, 0xf1, 0x8f, 0x7f, 0xb4, 0x7f, 0xfe,
  0xe3, 0x1f, 0x12, 0xfc, 0xa4, 0xff, 0xdc, 0x10, 0xde, 0x23, 0x19, 0x98, 0x92, 0x14, 0xef, 0x95,
  0xe4, 0xe3, 0x3f, 0xfe, 0xe1, 0xbc, 0xff, 0xe3, 0x1f, 0xa9, 0xa7, 0x34, 0x28, 0x31, 0x77, 0xe9,
  0xa4, 0xf0, 0x28, 0xc2, 0xab, 0xb3, 0xea, 0x15, 0x9e, 0x01, 0xa6, 0xb0, 0x91, 0x14, 0x1f, 0xfe,
  0x76, 0xdd, 0x95, 0xa0, 0x0e, 0x69, 0xb8, 0xf7, 0x25, 0xe9, 0xee, 0x4c, 0x06, 0x29, 0x74, 0x89,
  0x25, 0xd3, 0xf7, 0x82, 0x78, 0xb1, 0x98, 0xaa, 0x26, 0xd3, 0x0f, 0xc0, 0x9e, 0x6e, 0x24, 0x1d,
  0x56, 0x1f, 0x5a, 0x9a, 0x2c, 0x25, 0xb3, 0xe2, 0xa6, 0xab, 0x24, 0xff, 0x09, 0x43, 0xff, 0xbe,
  0xf1, 0x2e, 0x4f, 0x70, 0xcc, 0x36, 0x24, 0xa4, 0x1e, 0xe5, 0x4c, 0x4d, 0xcd, 0x74, 0x1a, 0x99,
  0xdd, 0xa7, 0x59, 0x6e, 0x0e, 0xa9, 0xfa, 0x62, 0x6a, 0x1e, 0x53, 0xad, 0x08, 0x50, 0xd3, 0x4d,
  0xdb, 0xde, 0x7f, 0xc9, 0x3f, 0xe8, 0x36, 0xd9, 0xaa, 0x6c, 0xaf, 0x84, 0xb1, 0x58, 0x42, 0xf7,
  0xfe, 0xa3, 0xd9, 0xea, 0xca, 0x6c, 0xaf, 0xc4, 0xd0, 0x65, 0x3e, 0x19, 0xc3, 0xea, 0x8a, 0x9a,
  0x1b, 0xf2, 0xcf, 0x88, 0x3d, 0xfe, 0xd6, 0x31, 0x2c, 0x30, 0xf9, 0xda, 0xae, 0x12, 0x3a, 0xd0,
  0xbe, 0x78, 0x86, 0x9d, 0x4e, 0xe9, 0x3f, 0x94, 0x59, 0x0f, 0xcc, 0x22, 0xe6, 0xae, 0x83, 0xc9,
  0x5d, 0xcf, 0x81, 0x88, 0xe2, 0xb3, 0x1f, 0x2f, 0x17, 0xf1, 0xa6, 0xbe, 0x65, 0xb2, 0x3d, 0x39,
  0x85, 0xb0, 0x77, 0xfe, 0x2d, 0xda, 0x1b, 0x1a, 0x1f, 0x37, 0xf1, 0x05, 0xdb, 0x1f, 0x6c, 0x25,
  0xa4, 0x47, 0xdd, 0xbd, 0xe9, 0x1d, 0x1c, 0x86, 0x02, 0x80, 0xca, 0xc2, 0x01, 0xcc, 0xa5, 0xcd,
  0x4f, 0x22, 0x64, 0x43, 0x94, 0x09, 0x23, 0xbf, 0x20, 0x56, 0xe7, 0x7f, 0x64, 0xfd, 0x83, 0x4e,
  0xb4, 0xbd, 0x1e, 0x99, 0x30, 0x35, 0x43, 0x21, 0xf5, 0xec, 0x3f, 0x91, 0x1d, 0x36, 0x16, 0x4a,
  0x40, 0x5a, 0xa8, 0x04, 0x72, 0x40, 0x50, 0xc2, 0x13, 0x9e, 0xbe, 0xb2, 0xe2, 0x1d, 0x59, 0xa2,
  0x3d, 0xb3, 0xbc, 0x88, 0x42, 0xbf, 0x67, 0x6c, 0x6e, 0x21, 0x71, 0xd8, 0x74, 0x4e, 0x1e, 0x98,
  0x23, 0x15, 0xf7, 0x96, 0xd9, 0x37, 0x2e, 0x99, 0xaf, 0x11, 0x20, 0x84, 0xf5, 0x0b, 0x97, 0x77,
  0xd4, 0x19, 0xa9, 0x7c, 0x3f, 0x06, 0xb4, 0x60, 0x0c, 0x17, 0xc4, 0x63, 0x38, 0x5d, 0xef, 0xa1,
  0x45, 0x1f, 0xfc, 0x1e, 0x43, 0x5f, 0x93, 0x3d, 0x2f, 0xcf, 0xf1, 0x1e, 0x46, 0xa1, 0x42, 0x68,
  0x5e, 0xc5, 0x16, 0x32, 0x22, 0x85, 0x0c, 0x2c, 0xc4, 0x3d, 0x72, 0xac, 0x00, 0x1b, 0x31, 0x4b,
  0x52, 0xbc, 0x4d, 0x15, 0x01, 0x57, 0x6a, 0x24, 0xcf, 0x16, 0xfb, 0x20, 0x40, 0xbc, 0x07, 0x72,
  0x1d, 0xab, 0x82, 0xba, 0x11, 0xd0, 0x1b, 0x5e, 0x44, 0x94, 0xab, 0xb3, 0x39, 0x3b, 0x92, 0x04,
  0xcb, 0xb2, 0x80, 0x90, 0xe8, 0x75, 0x35, 0x61, 0xde, 0x0b, 0x70, 0xb0, 0xc4, 0x3d, 0x58, 0x1e,
  0xf4, 0x7f, 0x93, 0x84, 0xcb, 0x7b, 0x3a, 0x2f, 0xa0, 0xda, 0x65, 0xeb, 0x0d, 0x16, 0x1b, 0x9a,
  0xb8, 0x48, 0x2c, 0xc1, 0xf5, 0x79, 0x93, 0x1f, 0xc9, 0x17, 0xb9, 0x7b, 0xf7, 0x12, 0x10, 0x19,
  0xb3, 0x5d, 0x2f, 0xf5, 0xb2, 0x65, 0x99, 0xc6, 0x76, 0x50, 0xbf, 0x04, 0x75, 0xa4, 0x50, 0x4d,
  0x1f, 0xac, 0xee, 0x1e, 0xdd, 0x4d, 0xb5, 0x14, 0xb6, 0xe9, 0x64, 0xff, 0x4c, 0xe5, 0xc0, 0xc0,
  0x46, 0x97, 0x09, 0x3e, 0x59, 0x3f, 0x71, 0x45, 0x65, 0xcf, 0xf8, 0x2a, 0xe0, 0xfb, 0x50, 0xd1,
  0xff, 0x2c, 0x8b, 0x9a, 0xf2, 0xa8, 0x8a, 0x36, 0xfc, 0x6b, 0x80, 0x1a, 0xe7, 0x3c, 0x3d, 0x0e,
  0x9f, 0xc4, 0x9e, 0xf2, 0x08, 0x8f, 0x22, 0x4f, 0xc6, 0x24, 0xcf, 0xb3, 0x61, 0xd7, 0xc7, 0xb8,
  0x2b, 0xf3, 0xf3, 0x91, 0x17, 0xc7, 0x32, 0xb4, 0x8a, 0x4c, 0x77, 0x3e, 0xc4, 0x2e, 0xcf, 0xd7,
  0xbc, 0x84, 0x16, 0x4f, 0xe8, 0xf1, 0x84, 0x39, 0x0e, 0x11, 0xd8, 0x04, 0x3d, 0xd8, 0xa3, 0xd8,
  0x21, 0xda, 0x59, 0xdc, 0x9c, 0xc1, 0x31, 0x76, 0xe9, 0x13, 0x8e, 0xb1, 0x45, 0x9f, 0xf4, 0xc0,
  0xdd, 0xcb, 0x9c, 0x12, 0x30, 0x5a, 0xdf, 0xef, 0xcb, 0x53, 0x1c, 0x45, 0xcf, 0x58, 0x30, 0x6a,
  0x8c, 0x2f, 0xd1, 0x71, 0x73, 0x83, 0x86, 0x00, 0xc9, 0x75, 0x07, 0xf4, 0x22, 0xee, 0xf8, 0xd5,
  0x99, 0xb7, 0x37, 0x61, 0xd5, 0xa1, 0x18, 0x0b, 0xfa, 0xa6, 0x6e, 0xd8, 0x04, 0x81, 0x84, 0x94,
  0x99, 0xb1, 0x85, 0xac, 0x93, 0x4e, 0x99, 0xbf, 0xec, 0x8d, 0x72, 0x5d, 0x16, 0xc2, 0x05, 0x4c,
  0x2c, 0x80, 0xc1, 0x42, 0x50, 0x20, 0x1f, 0xce, 0xb0, 0xeb, 0x34, 0xc2, 0xc5, 0xc4, 0x8c, 0xe2,
  0xdc, 0x8f, 0xe2, 0x29, 0xcb, 0x3f, 0x8d, 0x3f, 0x0b, 0x65, 0x94, 0x51, 0x63, 0xf4, 0x3f, 0xff,
  0x1c, 0x02, 0x16, 0x70, 0x7b, 0x0f, 0x04, 0x16, 0x4b, 0x50, 0x79, 0xc2, 0xdc, 0xa7, 0xfc, 0xbe,
  0x63, 0xc4, 0xa2, 0x85, 0x11, 0xdc, 0xf4, 0x09, 0x6e, 0x2b, 0xa9, 0x3c, 0x86, 0x14, 0x99, 0xe8,
  0x70, 0xf9, 0xa5, 0xe4, 0x36, 0xec, 0x7a, 0x3e, 0x63, 0xa3, 0x8b, 0xfd, 0x57, 0x8e, 0x64, 0x6a,
  0x30, 0x64, 0xf2, 0xd3, 0x84, 0x41, 0xfb, 0x9d, 0x71, 0xe9, 0x56, 0x01, 0x6b, 0xd6, 0xf2, 0xfa,
  0x61, 0x40, 0x42, 0x49, 0xfe, 0x69, 0x47, 0xbb, 0x61, 0xac, 0xa2, 0x4e, 0xfe, 0xa7, 0x2b, 0x19,
  0x8c, 0xff, 0x7e, 0xa6, 0x08, 0xb4, 0x2a, 0xcb, 0x18, 0x52, 0x27, 0xcb, 0x19, 0xb6, 0xab, 0x88,
  0xdb, 0x80, 0x69, 0xd3, 0xeb, 0x40, 0x1e, 0x3a, 0x90, 0x82, 0x77, 0x21, 0xbe, 0x13, 0x76, 0x18,
  0x19, 0xb4, 0x5c, 0x36, 0x1f, 0xee, 0x47, 0x68, 0xef, 0x69, 0xb9, 0x2b, 0x2c, 0x00, 0x5c, 0x71,
  0xb3, 0xa1, 0xed, 0x54, 0xd0, 0xe1, 0x7e, 0x95, 0xcb, 0x1b, 0xa0, 0x82, 0x32, 0x0e, 0xca, 0xe4,
  0x4a, 0x25, 0x29, 0x5f, 0x2a, 0x56, 0x4b, 0xa5, 0x72, 0xbe, 0x22, 0xd7, 0x72, 0x95, 0x5a, 0x46,
  0x2a, 0x16, 0x4b, 0xb5, 0x72, 0xad, 0x24, 0x17, 0xe1, 0x4f, 0xa5, 0x96, 0x2b, 0x14, 0x7e, 0xa6,
  0x4c, 0xe0, 0x99, 0xbc, 0x90, 0xce, 0xc9, 0x45, 0xa9, 0x58, 0xcb, 0xe7, 0xca, 0xb9, 0x5a, 0xad,
  0x50, 0x2b, 0x54, 0xab, 0xd5, 0x9f, 0x43, 0x17, 0x35, 0x51, 0xfd, 0x57, 0x5e, 0x86, 0xe1, 0x48,
  0xd5, 0x7c, 0xa5, 0x28, 0xd7, 0xca, 0x72, 0xb9, 0x28, 0xcb, 0x95, 0x42, 0xad, 0xf4, 0x13, 0xc4,
  0x87, 0x9e, 0xc9, 0xc9, 0x42, 0x06, 0x1a, 0x91, 0x2a, 0xe5, 0x5a, 0xa1, 0x94, 0xab, 0x16, 0x73,
  0x79, 0xb9, 0x26, 0xe7, 0xd3, 0xb9, 0x5c, 0x49, 0x2a, 0x57, 0x6a, 0xb5, 0x62, 0x51, 0xce, 0xc9,
  0xe5, 0x72, 0xae, 0x58, 0x41, 0x68, 0x20, 0x64, 0xea, 0xd0, 0x3f, 0x28, 0x28, 0xd5, 0xa0, 0x82,
  0x5c, 0x2a, 0x97, 0xab, 0xf0, 0xa7, 0x56, 0x48, 0x4b, 0xb9, 0x5c, 0x31, 0x0f, 0xa0, 0x4b, 0x85,
  0x0a, 0xc0, 0x28, 0x03, 0x70, 0x0c, 0x2a, 0x83, 0x19, 0x93, 0x29, 0xca, 0x30, 0x88, 0x42, 0xb9,
  0x5c, 0x90, 0x6b, 0x85, 0x42, 0x3e, 0x97, 0xa7, 0x80, 0x50, 0x9d, 0x56, 0x0a, 0xf9, 0x12, 0x8c,
  0xa7, 0x06, 0x4d, 0x96, 0x2a, 0xb9, 0x5c, 0xad, 0x52, 0x4c, 0x4b, 0x72, 0xa5, 0x56, 0x2c, 0x14,
  0x4b, 0x65, 0xac, 0x50, 0xce, 0x17, 0x8a, 0x79, 0x36, 0xbc, 0x12, 0x76, 0xb2, 0x2a, 0xc9, 0xd5,
  0x52, 0xbe, 0x56, 0x2e, 0x94, 0xa0, 0x54, 0xa9, 0xc2, 0x47, 0x47, 0xa7, 0x29, 0x9d, 0xd8, 0x4c,
  0x82, 0x84, 0x66, 0x72, 0x8f, 0x16, 0x08, 0xcd, 0xe4, 0x1e, 0x8e, 0x60, 0x69, 0x26, 0x1f, 0x31,
  0x89, 0x1c, 0x5e, 0x1e, 0xfd, 0x90, 0x6d, 0xb6, 0x31, 0x8c, 0xc1, 0x3e, 0x52, 0x0b, 0x98, 0x33,
  0x4f, 0x0a, 0x30, 0x45, 0x8b, 0xa4, 0xb8, 0x2e, 0x15, 0x7f, 0x39, 0x19, 0x6b, 0x9d, 0x91, 0x13,
  0xc3, 0x3b, 0xc3, 0x5b, 0x8d, 0xa6, 0x22, 0x01, 0x02, 0x9c, 0xb4, 0x05, 0x4a, 0xa7, 0x01, 0xb3,
  0xdf, 0x90, 0xec, 0xdf, 0x8a, 0x9e, 0xb5, 0x37, 0x1c, 0xc5, 0xac, 0x5b, 0x8a, 0xe9, 0x07, 0x5a,
  0xcd, 0xc5, 0x45, 0x71, 0x0f, 0xeb, 0x44, 0xd4, 0x15, 0xec, 0x77, 0x05, 0x26, 0xbb, 0xf9, 0x8b,
  0xac, 0x0a, 0xfc, 0xb5, 0x25, 0x62, 0x82, 0x0d, 0x67, 0xab, 0x2d, 0x83, 0x28, 0xe1, 0x17, 0x3c,
  0x52, 0x29, 0x52, 0x25, 0xb9, 0xa3, 0x77, 0x87, 0x2c, 0x1f, 0x6c, 0x89, 0x20, 0x26, 0x1f, 0xbd,
  0x88, 0xb6, 0x34, 0xb6, 0x75, 0x97, 0xe7, 0x09, 0x9e, 0xa5, 0xc9, 0xee, 0xed, 0xf1, 0x0f, 0x43,
  0xbb, 0x00, 0x86, 0x5e, 0xf9, 0x22, 0xa0, 0xe7, 0x37, 0xd0, 0x32, 0xd0, 0x07, 0x0c, 0x99, 0x8f,
  0x33, 0xbc, 0xd6, 0x05, 0x34, 0xbd, 0x51, 0x52, 0x04, 0x35, 0xbc, 0x1e, 0x5a, 0x2b, 0xb0, 0x9f,
  0x2e, 0x5b, 0x7f, 0xfe, 0x58, 0x9c, 0x4c, 0x2e, 0xdd, 0xfc, 0x73, 0x71, 0x77, 0x5f, 0x74, 0xc2,
  0xd5, 0x02, 0xe1, 0xc1, 0xea, 0x81, 0x62, 0xe0, 0xb2, 0xf5, 0x0f, 0x14, 0xa1, 0x05, 0xdd, 0xc8,
  0xf3, 0x98, 0x03, 0x54, 0x18, 0xed, 0x08, 0xff, 0x38, 0xf8, 0x47, 0x85, 0x3f, 0x73, 0x3f, 0x28,
  0xda, 0x66, 0xa7, 0x27, 0xcc, 0x47, 0xfb, 0x49, 0x71, 0xe1, 0x0f, 0x18, 0x73, 0xf0, 0x77, 0x9d,
  0x6b, 0x63, 0xae, 0x98, 0x32, 0xa5, 0xde, 0xfb, 0xbb, 0x29, 0x39, 0xf8, 0x67, 0x84, 0x7f, 0x54,
  0x81, 0x2b, 0x64, 0x5e, 0x43, 0x2c, 0x12, 0xda, 0xe4, 0x4e, 0x58, 0xaf, 0x26, 0x74, 0xdd, 0x1f,
  0xbc, 0xba, 0x34, 0x7a, 0x4e, 0xec, 0x88, 0xaa, 0xb6, 0x34, 0x54, 0x5f, 0xb5, 0x08, 0x01, 0x43,
  0xb7, 0x67, 0x3c, 0x2c, 0x06, 0x46, 0xea, 0x7d, 0x00, 0x07, 0x11, 0x3c, 0xf7, 0x61, 0x85, 0x76,
  0x8e, 0x3f, 0x06, 0xe9, 0x7c, 0x04, 0xd2, 0x09, 0x83, 0x64, 0x0c, 0xf4, 0x31, 0xb4, 0xd1, 0x47,
  0xd0, 0x46, 0x61, 0x68, 0x6c, 0xcf, 0xf1, 0x63, 0x68, 0xea, 0x07, 0xd0, 0x02, 0xec, 0xe2, 0x9e,
  0xc9, 0x4c, 0x05, 0xd8, 0x82, 0x0f, 0x9c, 0xab, 0x61, 0xab, 0xa0, 0x87, 0xc5, 0x40, 0xca, 0x53,
  0x04, 0x17, 0x69, 0xe4, 0xa9, 0xed, 0xa8, 0x23, 0x46, 0x67, 0x3b, 0x09, 0x1a, 0xc2, 0x9d, 0xd0,
  0x8f, 0xc6, 0x00, 0x95, 0x25, 0x7b, 0xc5, 0x28, 0x10, 0x70, 0x30, 0x0a, 0x78, 0x43, 0xa9, 0x16,
  0x1e, 0x05, 0xdb, 0x51, 0xfd, 0x0c, 0x7c, 0xf7, 0xeb, 0xe0, 0xbb, 0x11, 0xf0, 0xad, 0xcf, 0xc8,
  0x89, 0xd0, 0x5b, 0x5f, 0x87, 0xde, 0x8a, 0x40, 0x47, 0x2b, 0x32, 0x4e, 0x2c, 0x50, 0xad, 0x90,
  0xab, 0x8c, 0x29, 0x3e, 0x3b, 0x44, 0x93, 0x0a, 0x5d, 0x14, 0xbd, 0x5d, 0x26, 0x7a, 0x03, 0xfd,
  0x4d, 0xa3, 0x32, 0xbd, 0x8b, 0xbf, 0x36, 0x0a, 0x75, 0xf8, 0xd5, 0x85, 0xf9, 0x0a, 0x5a, 0x05,
  0x8c, 0xe1, 0xeb, 0x6c, 0xb8, 0x44, 0x00, 0x77, 0xf8, 0xae, 0x3d, 0x22, 0xa9, 0x1b, 0xb9, 0x3a,
  0xfc, 0x8d, 0xf6, 0xf5, 0x0b, 0xb3, 0x98, 0x0e, 0x12, 0xf8, 0x0c, 0x9f, 0x29, 0xf7, 0xce, 0x85,
  0x0f, 0x90, 0x13, 0x96, 0x11, 0xc6, 0xc7, 0x98, 0xc0, 0xd8, 0x88, 0x30, 0x26, 0x7a, 0x14, 0x13,
  0x0e, 0xc5, 0x84, 0x11, 0x88, 0x4f, 0x86, 0x09, 0x87, 0x63, 0xc2, 0xf8, 0x32, 0x26, 0x3c, 0xfd,
  0xe8, 0x2b, 0x98, 0xa0, 0x66, 0xfb, 0xa7, 0x98, 0x80, 0x52, 0x5f, 0xc4, 0x04, 0x9a, 0x45, 0x6e,
  0x18, 0xcf, 0xcc, 0xf8, 0xfb, 0x68, 0xc1, 0xc0, 0xa8, 0x2c, 0x1e, 0xad, 0xcb, 0x82, 0x73, 0x5c,
  0x1a, 0x55, 0x44, 0x83, 0x8a, 0xbb, 0xde, 0x03, 0x8d, 0x2b, 0x5a, 0xb1, 0x7e, 0x78, 0x27, 0x3b,
  0x95, 0x1c, 0x2e, 0x21, 0xa0, 0x96, 0x1c, 0x4a, 0x64, 0x42, 0x34, 0xf4, 0x08, 0x6d, 0xc0, 0x4a,
  0xfd, 0x92, 0xc2, 0x3b, 0x25, 0x98, 0x8e, 0x60, 0xd3, 0xb7, 0x3c, 0x7f, 0xd3, 0xe9, 0x5b, 0x81,
  0xbd, 0x51, 0xbd, 0xe7, 0xc2, 0xaf, 0x49, 0xef, 0x6b, 0xf9, 0x62, 0x55, 0x68, 0x1a, 0xdf, 0x8a,
  0x4f, 0x62, 0x0e, 0xc3, 0x38, 0x3f, 0x30, 0x66, 0x61, 0x80, 0x09, 0x6e, 0x95, 0x0b, 0xeb, 0x3e,
  0xeb, 0xcc, 0xf0, 0xdc, 0x44, 0xb7, 0x6e, 0x03, 0xb7, 0xeb, 0xb0, 0xa2, 0x59, 0xf3, 0x08, 0xa3,
  0x7e, 0x09, 0x83, 0x6a, 0x08, 0x85, 0xea, 0x6a, 0x1c, 0xb2, 0x07, 0x35, 0x1e, 0x99, 0x0b, 0x36,
  0x7d, 0x88, 0xa1, 0x3d, 0x4f, 0xc0, 0x17, 0xc9, 0xf8, 0x3d, 0x99, 0xde, 0x01, 0xfd, 0xc1, 0x16,
  0xe8, 0x4f, 0x97, 0xfd, 0xb4, 0x84, 0xcf, 0xc8, 0x07, 0xa8, 0xe4, 0x04, 0xb4, 0xdc, 0x08, 0x05,
  0x73, 0x95, 0x9f, 0x4d, 0x4a, 0x09, 0xa4, 0x02, 0x7f, 0xc9, 0x3f, 0x21, 0x11, 0xf8, 0x4b, 0xe1,
  0x89, 0x91, 0xcf, 0xf9, 0xfb, 0xf5, 0x90, 0x6d, 0xd8, 0x4b, 0x91, 0x03, 0x31, 0xa2, 0x40, 0x02,
  0x08, 0x41, 0xf5, 0x70, 0x9b, 0xaa, 0x1b, 0xe5, 0x99, 0x0f, 0xca, 0x43, 0x5b, 0x5e, 0x43, 0x1f,
  0x72, 0x09, 0xe0, 0xfb, 0x0b, 0x5c, 0x82, 0x26, 0xe7, 0x3c, 0x4c, 0xa3, 0xea, 0xdf, 0xe3, 0x94,
  0x15, 0x54, 0x82, 0x1f, 0xd0, 0xa2, 0xd1, 0x24, 0x06, 0x46, 0x11, 0x56, 0xce, 0x73, 0xdf, 0x39,
  0x14, 0x91, 0x7b, 0x9f, 0xf7, 0x00, 0x0a, 0x79, 0x1d, 0x60, 0x11, 0x5f, 0x2e, 0x8d, 0xf8, 0xa2,
  0x7c, 0x49, 0x43, 0xbe, 0xe8, 0x13, 0x8b, 0xf9, 0xfa, 0xea, 0x7c, 0x77, 0xdd, 0xb8, 0x09, 0x4f,
  0x43, 0x24, 0xfc, 0x59, 0x4b, 0x0d, 0x39, 0x7f, 0xd6, 0xd2, 0x10, 0x56, 0xa4, 0x1e, 0x71, 0x63,
  0x67, 0xfc, 0x67, 0x75, 0xbf, 0x3e, 0xe3, 0x61, 0x90, 0x0b, 0xb4, 0x44, 0x11, 0x89, 0x91, 0x71,
  0x20, 0xd9, 0x6d, 0x90, 0xea, 0x0b, 0x33, 0x1e, 0x05, 0xf2, 0x97, 0xb0, 0xa8, 0x86, 0xd0, 0xa8,
  0x7e, 0x84, 0xc7, 0xcf, 0xe7, 0x7c, 0xe0, 0xa3, 0x03, 0x62, 0x3e, 0xd1, 0x73, 0xb2, 0x82, 0xd8,
  0x71, 0xc1, 0x9a, 0xa6, 0xde, 0x8b, 0xf3, 0x03, 0x71, 0xe0, 0x2a, 0x71, 0x77, 0xe4, 0xa5, 0xdc,
  0x3f, 0x49, 0x9a, 0x08, 0x7f, 0x92, 0xb9, 0x38, 0x8a, 0x2f, 0x91, 0x08, 0x0e, 0xa7, 0xb8, 0x3f,
  0xdd, 0x34, 0xf9, 0x09, 0xba, 0x94, 0xd8, 0x75, 0x95, 0xc7, 0x64, 0xdf, 0x1a, 0x3a, 0xf4, 0x06,
  0x98, 0xa4, 0x98, 0x74, 0xad, 0xa1, 0xd6, 0xe3, 0xcf, 0x34, 0x7d, 0x38, 0xf0, 0x52, 0x89, 0xd9,
  0x4e, 0x3e, 0x89, 0x53, 0x37, 0x62, 0x61, 0x87, 0x2e, 0x00, 0xc5, 0xf5, 0x8f, 0x1f, 0x04, 0x47,
  0xc5, 0x9d, 0x78, 0xdb, 0x29, 0x7a, 0x5b, 0x61, 0x31, 0x77, 0x36, 0xfd, 0x6e, 0x5b, 0x0a, 0xaf,
  0x69, 0x0c, 0x0e, 0x07, 0x16, 0xca, 0x02, 0xde, 0x62, 0xc2, 0x08, 0x93, 0x2a, 0x05, 0x07, 0x22,
  0xf1, 0xb8, 0x95, 0xf4, 0xaf, 0x7f, 0x51, 0xd3, 0xe7, 0x5f, 0xff, 0x52, 0xf0, 0x1c, 0x6c, 0x2a,
  0xb4, 0x9d, 0xe2, 0x1d, 0xea, 0x64, 0x3b, 0x90, 0x74, 0x2f, 0x27, 0xc8, 0x14, 0x84, 0xc8, 0xc5,
  0x29, 0x44, 0x58, 0xde, 0xc3, 0x59, 0x61, 0xfb, 0xb0, 0x8d, 0x58, 0xba, 0x31, 0xc7, 0xf6, 0x6a,
  0xa8, 0x5b, 0x0e, 0x18, 0x70, 0x46, 0xb7, 0x41, 0x1d, 0xb2, 0x6d, 0x8d, 0xf1, 0x10, 0x94, 0x65,
  0x52, 0x9c, 0x38, 0xf4, 0x6c, 0x1e, 0x20, 0xdd, 0xfa, 0x3c, 0x96, 0xdd, 0xe1, 0x27, 0xac, 0x69,
  0x88, 0x2d, 0x7e, 0x64, 0x6c, 0xc3, 0x0b, 0xb7, 0x3b, 0xa1, 0xaf, 0x75, 0x2f, 0x5d, 0x04, 0xae,
  0x5c, 0x3e, 0xc4, 0x21, 0xf2, 0xaf, 0x4e, 0xd4, 0xad, 0x0d, 0x30, 0x25, 0x31, 0xca, 0x2b, 0xd3,
  0xc2, 0x98, 0x8a, 0x24, 0xaa, 0x93, 0xf8, 0xeb, 0x07, 0xec, 0xc8, 0xde, 0x39, 0x4f, 0x40, 0xa1,
  0xf1, 0x08, 0xc5, 0x19, 0xd8, 0x63, 0xd2, 0x71, 0xa1, 0x30, 0x7b, 0xb9, 0xb2, 0x06, 0xc9, 0x27,
  0xc5, 0xc1, 0x8d, 0x6e, 0xbe, 0xc3, 0x1a, 0xdc, 0xd7, 0x99, 0xf2, 0xe8, 0x86, 0x2e, 0x3d, 0xe6,
  0xea, 0x0c, 0x9f, 0x6a, 0xf5, 0x11, 0xb4, 0x02, 0x87, 0xe8, 0xf4, 0xf1, 0xf7, 0xf4, 0xbc, 0x88,
  0x18, 0x91, 0xef, 0x1e, 0xe2, 0xa6, 0x32, 0xee, 0x1c, 0x6d, 0xa2, 0x23, 0x1f, 0x28, 0xbe, 0x65,
  0x60, 0x84, 0xc4, 0x25, 0xa0, 0x28, 0x45, 0x03, 0x13, 0x6d, 0x7a, 0x6b, 0x10, 0xff, 0x54, 0x57,
  0x8a, 0xc5, 0x66, 0x62, 0xfc, 0x3c, 0xe3, 0x40, 0x07, 0x8f, 0x2f, 0x50, 0xe3, 0xb0, 0x7d, 0xc5,
  0x12, 0xf0, 0x2e, 0x44, 0x97, 0x46, 0x8b, 0x6a, 0x14, 0xd2, 0x5d, 0x06, 0x8f, 0x6b, 0x75, 0x5c,
  0x1a, 0x30, 0xca, 0x92, 0xee, 0x21, 0xc9, 0xb5, 0x06, 0x41, 0x30, 0xa7, 0x1b, 0x84, 0x71, 0x52,
  0x16, 0xc7, 0x4f, 0xce, 0xf1, 0x48, 0xca, 0x80, 0xa8, 0x49, 0x30, 0x67, 0xf1, 0xc2, 0x03, 0x7a,
  0xa1, 0x16, 0xde, 0x91, 0xd9, 0x75, 0x71, 0x47, 0x71, 0x47, 0x05, 0x10, 0x91, 0xc8, 0x86, 0xd5,
  0x1b, 0xba, 0xe8, 0x66, 0x98, 0x0d, 0x70, 0x0f, 0x99, 0x86, 0x32, 0xd0, 0xc0, 0x82, 0x90, 0x2b,
  0x30, 0x34, 0xef, 0x42, 0x8d, 0xb3, 0x77, 0xd6, 0x6c, 0x6e, 0xb9, 0x38, 0x4c, 0xc7, 0x50, 0x61,
  0x9c, 0x92, 0xbc, 0x6c, 0x1e, 0x34, 0xf5, 0xcf, 0x7a, 0x18, 0x77, 0x8f, 0x56, 0x5c, 0x27, 0xd1,
  0x4f, 0x3e, 0x4f, 0x59, 0xc2, 0xfa, 0x69, 0xe4, 0x1e, 0x5b, 0x65, 0x16, 0x3e, 0xf9, 0xe2, 0x9d,
  0x38, 0xb5, 0xeb, 0x55, 0x1a, 0xd6, 0x40, 0x99, 0x88, 0xc5, 0x33, 0xcc, 0x78, 0x1e, 0xc0, 0xb9,
  0x8d, 0x42, 0x58, 0xde, 0x57, 0x0f, 0x1d, 0xd5, 0x05, 0x46, 0xc6, 0xc0, 0xc5, 0x20, 0x04, 0xd5,
  0x37, 0x7c, 0xa3, 0xd1, 0xb5, 0xf5, 0x7c, 0x5e, 0x96, 0xc5, 0x68, 0x40, 0x6d, 0x3d, 0x97, 0x23,
  0x85, 0x39, 0xe3, 0x97, 0xd6, 0x47, 0x22, 0x8a, 0x39, 0x2f, 0x90, 0x17, 0xd7, 0xe3, 0xa4, 0x15,
  0x8b, 0x35, 0xc4, 0xdd, 0x5d, 0xee, 0xc2, 0x0f, 0x05, 0x7c, 0xe5, 0x58, 0x1a, 0xe5, 0x50, 0x47,
  0xf1, 0x34, 0x72, 0x16, 0xf5, 0xb1, 0x13, 0x4d, 0x84, 0x41, 0x13, 0x1b, 0x2c, 0xd4, 0x85, 0x64,
  0x10, 0x85, 0x04, 0xfe, 0x88, 0x29, 0xf9, 0x17, 0x59, 0x38, 0x97, 0xe3, 0xbd, 0xd7, 0x1f, 0xf9,
  0xd3, 0x93, 0x10, 0x4f, 0x4d, 0xff, 0x8c, 0x06, 0xf0, 0x1b, 0x8b, 0x6d, 0x73, 0x69, 0xc4, 0x8a,
  0xb7, 0x99, 0x15, 0x8e, 0x7a, 0x93, 0x85, 0xd0, 0x4e, 0xfc, 0x32, 0xf2, 0x81, 0xf2, 0xec, 0x83,
  0x99, 0xc1, 0xd0, 0x45, 0xde, 0x8b, 0x10, 0x32, 0x44, 0x26, 0xc8, 0xc0, 0x5c, 0x61, 0x0f, 0xf3,
  0xff, 0x7e, 0x19, 0xed, 0x0d, 0x6d, 0xf1, 0x14, 0x89, 0x6f, 0x3f, 0xd1, 0xb3, 0xb8, 0xa1, 0x3e,
  0x7a, 0x17, 0x42, 0xaf, 0x33, 0xf2, 0xe2, 0xea, 0xdf, 0xc6, 0x0d, 0x40, 0xcf, 0xa1, 0x84, 0x85,
  0x98, 0x57, 0x29, 0x24, 0xd5, 0xb9, 0x16, 0xc0, 0x21, 0x80, 0x70, 0xc5, 0x6b, 0xea, 0x88, 0x28,
  0xd3, 0x58, 0xc0, 0x50, 0x4e, 0x0c, 0x19, 0x42, 0xcb, 0x2a, 0x97, 0xb5, 0x0a, 0x09, 0x88, 0x10,
  0x0a, 0x8c, 0xf0, 0xf7, 0xce, 0x67, 0xcb, 0x88, 0x9d, 0x0b, 0x0b, 0xcc, 0xd2, 0xd7, 0xdd, 0x14,
  0xfb, 0xc8, 0x66, 0x1d, 0xf7, 0x8e, 0x92, 0xe8, 0xfc, 0x8a, 0x08, 0x5f, 0x7e, 0x91, 0xf6, 0x02,
  0x6a, 0x22, 0x0b, 0x58, 0x74, 0x34, 0x2e, 0xc8, 0x10, 0x3c, 0xb8, 0xe9, 0xed, 0x2a, 0xa5, 0xfe,
  0xc7, 0x46, 0xc6, 0x03, 0xaa, 0x14, 0x25, 0xd4, 0x2d, 0x6f, 0x55, 0xfa, 0x88, 0x55, 0x49, 0x08,
  0x09, 0x36, 0xd7, 0x4a, 0xc8, 0x02, 0x1a, 0xa2, 0x55, 0x97, 0x83, 0x3b, 0x68, 0xed, 0x30, 0x3a,
  0x70, 0x07, 0xef, 0xb3, 0x01, 0x84, 0xfa, 0x3f, 0x8f, 0xe9, 0x8b, 0xdf, 0x66, 0x32, 0x84, 0xc1,
  0xe5, 0x7e, 0xb1, 0x2f, 0xe8, 0xc4, 0x9e, 0x7e, 0xa2, 0x32, 0x67, 0x81, 0x85, 0xe5, 0x4f, 0xe9,
  0x11, 0xa2, 0x86, 0x47, 0x42, 0x9f, 0x1c, 0x21, 0x61, 0xf5, 0x9f, 0x97, 0x15, 0x64, 0xc5, 0xa0,
  0x0d, 0x23, 0x3c, 0x62, 0x67, 0x61, 0xc8, 0x96, 0xb9, 0x72, 0xac, 0xde, 0x92, 0xcf, 0xe4, 0xe5,
  0xfa, 0xd2, 0xb5, 0xa9, 0x1b, 0x6e, 0x1d, 0xa3, 0xba, 0xe2, 0x7b, 0x9e, 0xb2, 0x21, 0x0f, 0x6f,
  0x31, 0xc1, 0x9d, 0xd8, 0x47, 0x30, 0xd3, 0xf8, 0xb5, 0xa9, 0x78, 0x5f, 0x57, 0x54, 0xb8, 0x42,
  0x01, 0x7a, 0x2d, 0xd9, 0x52, 0x6a, 0x3c, 0x60, 0xc2, 0xaf, 0xd9, 0x60, 0x3a, 0x0f, 0x8b, 0xf5,
  0x5b, 0xae, 0x8b, 0x4d, 0xce, 0x17, 0x55, 0x1f, 0xab, 0xd3, 0x59, 0x4d, 0xd8, 0xbf, 0x37, 0x3c,
  0xb6, 0x9b, 0x60, 0x72, 0xdc, 0x40, 0xb9, 0x75, 0x7a, 0xfd, 0x33, 0x9f, 0xb5, 0xb6, 0x7f, 0x4d,
  0x07, 0x8c, 0x37, 0xb7, 0xdc, 0x11, 0x24, 0x91, 0x12, 0x7f, 0x8b, 0x09, 0x57, 0xc0, 0x80, 0x25,
  0x6c, 0x65, 0xf1, 0x06, 0x93, 0x4c, 0x6e, 0x5d, 0xfe, 0x65, 0xd3, 0x9b, 0x76, 0xd1, 0x2d, 0xef,
  0x67, 0x3f, 0xda, 0xe9, 0xdc, 0x93, 0xa7, 0x69, 0x2d, 0x2e, 0x69, 0xeb, 0xfa, 0xc2, 0x45, 0x26,
  0xd0, 0xde, 0x8f, 0x1f, 0x3a, 0xa3, 0x0e, 0xfe, 0xe0, 0x0e, 0x47, 0x2a, 0x44, 0x68, 0x9a, 0xf3,
  0xf8, 0xc9, 0xea, 0xe5, 0x72, 0x2a, 0xe0, 0x3e, 0x0c, 0x92, 0x80, 0x01, 0xca, 0x2d, 0x8c, 0x33,
  0x2c, 0x18, 0xe3, 0xc7, 0xfb, 0x9f, 0x1e, 0x6a, 0x94, 0xf2, 0xeb, 0x7c, 0x55, 0x11, 0x28, 0x8a,
  0xfd, 0x3e, 0x22, 0x33, 0xc1, 0x5a, 0xa5, 0xa9, 0xe8, 0x06, 0xc4, 0xfb, 0x78, 0x42, 0xa3, 0x0f,
  0x78, 0xd3, 0x5c, 0x96, 0x06, 0x67, 0xf4, 0x46, 0x66, 0x67, 0x59, 0x42, 0xf9, 0xb2, 0xc7, 0x5d,
  0x92, 0xf0, 0x8e, 0xfe, 0x46, 0x62, 0x2b, 0x70, 0x60, 0x29, 0xef, 0x7a, 0x8d, 0xf9, 0x72, 0xd5,
  0x98, 0x70, 0x84, 0x2f, 0x49, 0x16, 0x9b, 0x7d, 0x62, 0x27, 0x2c, 0x1a, 0x3e, 0x90, 0xed, 0x8b,
  0x12, 0x80, 0x86, 0x87, 0x2e, 0x77, 0x99, 0x18, 0xde, 0xed, 0xfe, 0xd1, 0x05, 0x8e, 0x5e, 0x1e,
  0xc4, 0x64, 0xca, 0x12, 0xa8, 0xd0, 0x42, 0xbd, 0x30, 0xd5, 0xbe, 0x28, 0xb2, 0x43, 0x0a, 0x9b,
  0x17, 0x05, 0x12, 0xab, 0xc3, 0xd1, 0x9e, 0xd0, 0x9c, 0x3a, 0x33, 0x28, 0xa0, 0x43, 0x34, 0x8c,
  0x73, 0x49, 0x06, 0x86, 0xb3, 0x97, 0xa7, 0x21, 0x35, 0x6e, 0x16, 0xad, 0x21, 0xec, 0x2f, 0xca,
  0x78, 0x1e, 0x15, 0x13, 0x6e, 0x8c, 0xd9, 0x16, 0x21, 0x81, 0x0a, 0x65, 0xeb, 0xb9, 0xf8, 0xb2,
  0x6c, 0xf1, 0x8b, 0x16, 0xcd, 0x2b, 0xf4, 0xd2, 0xbb, 0xa5, 0xb2, 0x68, 0x09, 0x44, 0x8b, 0x2e,
  0x32, 0xc7, 0x82, 0xd5, 0xeb, 0x89, 0x2f, 0x26, 0xa4, 0x99, 0xc3, 0x9b, 0xaa, 0x77, 0x9e, 0x15,
  0x19, 0x95, 0x67, 0xba, 0x80, 0x0c, 0xaf, 0x3c, 0xce, 0xfc, 0x58, 0xbd, 0xfa, 0x1f, 0x73, 0x31,
  0xf4, 0x76, 0x3b, 0x7f, 0xc2, 0x6b, 0xe9, 0xfc, 0x70, 0x76, 0x6d, 0x0a, 0x52, 0x82, 0x4d, 0x8c,
  0x70, 0x29, 0x91, 0x5d, 0x52, 0x0e, 0x36, 0x42, 0x58, 0xcd, 0x67, 0x3b, 0x52, 0x73, 0x16, 0x78,
  0x1d, 0x8e, 0x41, 0xa7, 0xf1, 0xe7, 0x94, 0x29, 0xce, 0x75, 0xed, 0x05, 0xe3, 0xcf, 0xf5, 0x76,
  0x9d, 0xaa, 0xd0, 0xfc, 0x9e, 0x06, 0xcf, 0x28, 0x06, 0x61, 0xc1, 0x9e, 0xc0, 0xe6, 0xd0, 0x17,
  0xef, 0xb0, 0x08, 0xce, 0x1c, 0xba, 0x41, 0xac, 0x21, 0x3d, 0x6f, 0xc2, 0x7b, 0x13, 0x1c, 0x75,
  0xb1, 0xc4, 0x18, 0x2d, 0xd9, 0x61, 0xe1, 0xbf, 0xfc, 0x13, 0x03, 0xde, 0xb1, 0x17, 0x7b, 0x81,
  0x01, 0x98, 0x66, 0x69, 0x0b, 0x22, 0x0b, 0xe7, 0xaf, 0xdb, 0x3c, 0x66, 0x5c, 0x67, 0x31, 0xdb,
  0x82, 0x67, 0x54, 0xb5, 0xdc, 0xcf, 0x6c, 0x22, 0x36, 0xc1, 0x0b, 0x60, 0xe4, 0xf0, 0x03, 0x1d,
  0xf8, 0xc8, 0xb8, 0x91, 0x5d, 0x05, 0xe0, 0x69, 0xe9, 0x20, 0xfb, 0xbc, 0x0f, 0xdc, 0x97, 0xc5,
  0x05, 0x7f, 0x03, 0x18, 0x4f, 0x20, 0xae, 0x75, 0x30, 0x71, 0xbc, 0x43, 0x3f, 0x5b, 0x61, 0x08,
  0xa1, 0x83, 0x54, 0x60, 0xac, 0x85, 0x83, 0xd4, 0xc1, 0x9e, 0x5b, 0x8e, 0x64, 0x67, 0xe6, 0x9d,
  0x1f, 0xb8, 0x1e, 0x7e, 0x3d, 0x8f, 0xda, 0x7c, 0x62, 0xf4, 0xf8, 0x02, 0xc6, 0xce, 0x07, 0xa7,
  0x43, 0xea, 0xfc, 0x25, 0xd4, 0xcb, 0xe8, 0x45, 0x3b, 0x62, 0x70, 0xed, 0x13, 0x6b, 0x23, 0xe2,
  0x21, 0xc9, 0xe5, 0x45, 0xff, 0xa6, 0x1a, 0xf6, 0xe9, 0x0d, 0x71, 0x16, 0xa0, 0xc2, 0xe3, 0x05,
  0xee, 0x0f, 0x41, 0x56, 0x61, 0x5f, 0x37, 0x61, 0xf6, 0x4b, 0x92, 0x63, 0x1d, 0xcc, 0x49, 0x06,
  0x8d, 0x02, 0x60, 0x26, 0x43, 0xdf, 0x15, 0x27, 0xae, 0x38, 0x76, 0xc5, 0x17, 0x57, 0x6c, 0xba,
  0x4a, 0xea, 0x38, 0x64, 0xc4, 0xa4, 0xfa, 0xae, 0xd2, 0x72, 0x43, 0xe6, 0xc9, 0x02, 0x8b, 0x1c,
  0x8b, 0x7d, 0x30, 0x7c, 0x8e, 0xa5, 0x03, 0x05, 0xa0, 0x1c, 0x7b, 0x11, 0x2c, 0xa9, 0xb1, 0xab,
  0x4c, 0xf0, 0xbf, 0xf7, 0xf7, 0xd9, 0x5c, 0x90, 0xf0, 0xfb, 0x42, 0x30, 0x5c, 0x25, 0x59, 0x92,
  0x4a, 0x52, 0x3e, 0x09, 0x4d, 0x49, 0x4c, 0x79, 0x6d, 0xbb, 0xfe, 0x33, 0x63, 0x71, 0xa5, 0xe9,
  0x8a, 0xa9, 0x17, 0x57, 0x81, 0xd4, 0xa1, 0x0e, 0x93, 0x8e, 0xfe, 0xd2, 0xfb, 0xb0, 0xa5, 0x9e,
  0x62, 0x42, 0x07, 0x25, 0xff, 0x22, 0xd8, 0x4d, 0xbc, 0x6a, 0x6d, 0x8a, 0x9d, 0x96, 0x18, 0xad,
  0x94, 0x53, 0x7c, 0x66, 0xa7, 0x10, 0x95, 0x5b, 0x7c, 0xa6, 0x67, 0x37, 0x94, 0x3f, 0xf0, 0x71,
  0xd3, 0x9a, 0xc4, 0x18, 0x0d, 0x27, 0xec, 0xfa, 0x06, 0xe2, 0x5f, 0xdf, 0x40, 0x82, 0xeb, 0x1b,
  0x88, 0x77, 0xf3, 0x83, 0x13, 0x9c, 0xc2, 0x33, 0xfc, 0xef, 0xfb, 0x88, 0xea, 0xc2, 0xd5, 0x13,
  0xc3, 0xe0, 0xea, 0x09, 0xf5, 0xc7, 0x0f, 0x75, 0xf5, 0xd5, 0x13, 0x6a, 0x70, 0xf5, 0x84, 0x16,
  0xeb, 0xab, 0x7c, 0xe4, 0x07, 0xbd, 0x3b, 0x9d, 0x85, 0x43, 0xc9, 0xd0, 0xb9, 0x21, 0xde, 0x54,
  0x83, 0x67, 0xd9, 0xc4, 0x92, 0x4c, 0x4f, 0x23, 0x8b, 0xc1, 0x71, 0x79, 0x59, 0xa4, 0xff, 0x06,
  0xe7, 0xa7, 0xd9, 0xb9, 0xe6, 0xa7, 0xa7, 0x39, 0x64, 0x0d, 0xf1, 0x50, 0xba, 0xf3, 0xb7, 0x4e,
  0x05, 0x9e, 0x7c, 0x78, 0xb7, 0x85, 0x8f, 0x1c, 0xc2, 0x8f, 0x1c, 0xe2, 0x31, 0x79, 0x9b, 0xde,
  0xf4, 0x35, 0xc4, 0x38, 0x21, 0xff, 0xe2, 0x04, 0xbc, 0x25, 0x21, 0xed, 0xf0, 0x03, 0x82, 0x2a,
  0x9e, 0xe8, 0x48, 0xa7, 0x86, 0xde, 0xc9, 0x9b, 0x9f, 0x43, 0x21, 0x38, 0xdd, 0xf7, 0x5f, 0x70,
  0xe6, 0x8e, 0x29, 0x37, 0xde, 0xa1, 0xb8, 0x9e, 0x7f, 0x28, 0x4e, 0xdf, 0x30, 0x16, 0x55, 0x7e,
  0x5d, 0xa8, 0xa7, 0x8c, 0xc5, 0x43, 0x6d, 0x43, 0xba, 0x81, 0x79, 0xf6, 0xd5, 0x43, 0x71, 0x9f,
  0xd4, 0xff, 0xf4, 0x50, 0x1c, 0xc1, 0xeb, 0x1f, 0x3f, 0x3f, 0x14, 0x67, 0x2c, 0x1e, 0x4a, 0xda,
  0xc4, 0xcb, 0x90, 0x3e, 0x3b, 0x12, 0x67, 0x87, 0x8e, 0xc4, 0xe9, 0x2b, 0x8e, 0xc4, 0xa9, 0x1f,
  0x9c, 0x7c, 0xfa, 0x42, 0x23, 0x5f, 0x39, 0xa3, 0x6b, 0xf1, 0x53, 0xb5, 0x91, 0x93, 0x58, 0xe1,
  0xa3, 0xba, 0xae, 0x85, 0xdf, 0x7a, 0x75, 0xad, 0x3e, 0x48, 0x76, 0xdc, 0xb2, 0xa2, 0x07, 0xef,
  0x17, 0x0a, 0xf0, 0x13, 0xba, 0x1a, 0x98, 0xf3, 0x02, 0x3d, 0xad, 0xe5, 0x7c, 0x76, 0xd0, 0x6a,
  0xf8, 0xbf, 0xc1, 0x41, 0xab, 0x5e, 0xf4, 0xa0, 0x55, 0xef, 0xab, 0x07, 0xad, 0x86, 0xe1, 0x7e,
  0x0c, 0xff, 0xbb, 0x0e, 0x5a, 0xf5, 0x1e, 0x87, 0xd1, 0xde, 0x0d, 0x17, 0x0f, 0x5a, 0xc1, 0xb2,
  0x00, 0x3f, 0xf8, 0xd9, 0x38, 0xf6, 0x75, 0xb7, 0xb8, 0xcf, 0xbc, 0x61, 0x8c, 0xd4, 0x7f, 0xc9,
  0x67, 0xde, 0xdc, 0xbf, 0xfb, 0x99, 0xb7, 0x24, 0xbd, 0x1c, 0x81, 0xba, 0xc2, 0x41, 0xfb, 0x63,
  0xdb, 0x68, 0xde, 0x37, 0xdf, 0x82, 0x2c, 0x84, 0xfb, 0xe5, 0x4f, 0xbf, 0x11, 0x36, 0x9c, 0x68,
  0x28, 0x9c, 0x1b, 0x13, 0x0a, 0xe7, 0xfe, 0x0f, 0x85, 0xc2, 0x91, 0x50, 0x28, 0x5c, 0x28, 0xb8,
  0x9f, 0xe0, 0xe7, 0x4c, 0x02, 0x76, 0xa7, 0xe1, 0x66, 0x1b, 0xab, 0x20, 0x80, 0xe0, 0x64, 0xd7,
  0xf6, 0x9b, 0x62, 0xd0, 0x45, 0x64, 0xb6, 0x70, 0xff, 0xa8, 0xa6, 0xc2, 0xfb, 0x03, 0xcf, 0x73,
  0xa1, 0x4e, 0xd0, 0xc0, 0x83, 0x2a, 0xd1, 0x2f, 0xd6, 0xb9, 0xde, 0xea, 0xc0, 0x5b, 0x83, 0xce,
  0x39, 0x30, 0xb1, 0x70, 0x07, 0x94, 0xa7, 0x74, 0xc1, 0x58, 0x0b, 0x0c, 0xe6, 0xe6, 0xb4, 0xdf,
  0xb2, 0x0c, 0xc7, 0xc3, 0xdb, 0x47, 0x65, 0x10, 0x8c, 0x4b, 0x3f, 0x4f, 0xf5, 0xe1, 0x29, 0xca,
  0x58, 0x10, 0xdb, 0x84, 0x71, 0x26, 0xba, 0x72, 0xa0, 0x8f, 0x21, 0x5a, 0xa0, 0xf2, 0x29, 0xb2,
  0xef, 0xce, 0x78, 0xce, 0x8f, 0xf0, 0x35, 0xba, 0xe1, 0x8f, 0xc9, 0x85, 0x82, 0x20, 0x6d, 0x25,
  0xb7, 0x6e, 0x2f, 0xdf, 0x82, 0x6a, 0x7b, 0x1c, 0xa0, 0xf3, 0xdb, 0x32, 0x43, 0xb6, 0xf5, 0xd3,
  0x46, 0xf8, 0xa5, 0x3e, 0x9b, 0xaf, 0xdb, 0x7f, 0xe6, 0x37, 0x4c, 0x8e, 0x16, 0x94, 0xc0, 0x40,
  0xe6, 0x18, 0x53, 0x14, 0xef, 0xd5, 0x65, 0x77, 0x83, 0x00, 0x4f, 0xe1, 0xb4, 0xab, 0x7f, 0x32,
  0x42, 0x27, 0x96, 0xd2, 0x3a, 0x01, 0x04, 0x8a, 0x9f, 0x55, 0x85, 0x6e, 0x08, 0xf5, 0x50, 0x9f,
  0x56, 0x38, 0x2a, 0x56, 0xb3, 0xd2, 0x67, 0xd8, 0xd7, 0x45, 0x97, 0xc9, 0x0e, 0xef, 0x44, 0x48,
  0xf8, 0xfb, 0x78, 0x94, 0x7d, 0x16, 0x35, 0x0e, 0x3f, 0x85, 0xd9, 0x5c, 0x1d, 0xdb, 0xea, 0xa7,
  0xe2, 0xcf, 0x69, 0x36, 0x70, 0xbf, 0x02, 0xba, 0xac, 0x9b, 0x9a, 0x31, 0xc4, 0xcf, 0xb4, 0x32,
  0x2b, 0x9a, 0x9f, 0x6c, 0x44, 0x7f, 0x16, 0x92, 0x66, 0xa8, 0xcc, 0xd0, 0xe1, 0xd7, 0x6c, 0x22,
  0x4b, 0xbb, 0xbd, 0x61, 0xbf, 0xc5, 0xf4, 0xfc, 0x5c, 0x49, 0x1c, 0xe3, 0x29, 0x2a, 0xe4, 0x6e,
  0xd1, 0x52, 0xe2, 0x56, 0x05, 0x76, 0xee, 0x8e, 0xee, 0x46, 0x04, 0x1f, 0x01, 0x64, 0x9a, 0xb6,
  0xa6, 0x44, 0x25, 0x1e, 0x3f, 0x86, 0xff, 0x2d, 0x85, 0x0e, 0x55, 0xf6, 0x75, 0x95, 0xe0, 0x3c,
  0x08, 0x48, 0x4e, 0x23, 0xae, 0x01, 0x0b, 0x9e, 0x41, 0x73, 0x60, 0xc2, 0x7c, 0x1e, 0xbe, 0x52,
  0x8c, 0x2c, 0x60, 0xc1, 0xb3, 0x3c, 0xd1, 0x92, 0x75, 0xe2, 0x8a, 0xe1, 0xdd, 0xf7, 0x78, 0x8a,
  0x13, 0xb7, 0xb2, 0xa0, 0x4c, 0x47, 0x01, 0x83, 0x44, 0x51, 0xc5, 0xb6, 0xe2, 0x88, 0xd3, 0x55,
  0xe5, 0xf9, 0xc1, 0x50, 0x28, 0xde, 0x5a, 0x59, 0x64, 0xc4, 0x0a, 0xf4, 0x95, 0x8f, 0x94, 0xc4,
  0x28, 0xca, 0x14, 0x05, 0x4c, 0x3b, 0xfc, 0x32, 0x50, 0xca, 0xa0, 0x3f, 0x2a, 0xfd, 0x8b, 0xd3,
  0x19, 0x0f, 0xe2, 0x79, 0x81, 0xc4, 0xa1, 0x9b, 0x87, 0x97, 0x10, 0xc2, 0x98, 0x6a, 0x4e, 0x8f,
  0xeb, 0x7c, 0x8b, 0x0a, 0x16, 0x5e, 0x7b, 0xbe, 0xbe, 0xcc, 0x36, 0x11, 0x79, 0x08, 0xb3, 0x28,
  0x15, 0xa5, 0x10, 0x5e, 0xbf, 0x90, 0x5a, 0xa0, 0x4b, 0x28, 0x3e, 0x02, 0x6d, 0x6f, 0x1e, 0x23,
  0xb1, 0xa5, 0x9a, 0xf8, 0x95, 0x54, 0x64, 0xa3, 0x84, 0xca, 0xbe, 0x81, 0x9a, 0x50, 0xe1, 0x3f,
  0xbf, 0xb1, 0x24, 0x70, 0x34, 0x5b, 0x42, 0x40, 0x8d, 0x99, 0xfa, 0xe7, 0x8e, 0x08, 0xc3, 0xa7,
  0x42, 0xea, 0x9d, 0xd0, 0x49, 0x23, 0x2f, 0x75, 0xc5, 0x59, 0x63, 0x74, 0xb3, 0x4c, 0x23, 0x25,
  0xa1, 0x66, 0x3f, 0x92, 0x80, 0xb1, 0x02, 0x7c, 0xf5, 0xf2, 0xa1, 0x32, 0x59, 0xad, 0xd8, 0xfc,
  0x8e, 0x84, 0xb9, 0xbf, 0x4d, 0x83, 0x7b, 0x25, 0xa9, 0x60, 0xbe, 0xe1, 0xd1, 0x60, 0x4d, 0xe1,
  0x21, 0xd2, 0xa0, 0xf1, 0x62, 0x04, 0x03, 0x93, 0xfe, 0x61, 0xf4, 0x33, 0x11, 0x9e, 0x5b, 0x12,
  0x70, 0xa1, 0xeb, 0xcd, 0x03, 0x61, 0x96, 0x0b, 0x4b, 0xb6, 0x1c, 0x4a, 0x36, 0x7e, 0xb7, 0x3e,
  0x0a, 0xfd, 0x3e, 0x25, 0x36, 0x8e, 0x7f, 0xc3, 0x52, 0xbe, 0x34, 0x83, 0x69, 0x59, 0x52, 0xff,
  0x8b, 0x6a, 0xce, 0x8f, 0xd4, 0xc8, 0x4c, 0xd2, 0x01, 0x27, 0x9f, 0xfe, 0x02, 0xe1, 0x34, 0x65,
  0xa0, 0xf0, 0x86, 0xbe, 0xf6, 0x12, 0x54, 0x22, 0xd4, 0x7b, 0x0c, 0xd5, 0x68, 0x9f, 0xf1, 0x45,
  0x62, 0x0a, 0x18, 0xed, 0xe3, 0x87, 0x07, 0xc3, 0x1f, 0xc3, 0x61, 0x37, 0x73, 0x85, 0xd1, 0xe5,
  0x73, 0x10, 0x05, 0xa0, 0x49, 0x54, 0x18, 0xfc, 0xf8, 0x81, 0xbc, 0x70, 0x32, 0x74, 0x69, 0xc8,
  0xf2, 0x59, 0xcb, 0x21, 0xf6, 0x28, 0xb2, 0xee, 0x00, 0x5f, 0x85, 0xda, 0x37, 0x57, 0x08, 0xf0,
  0x70, 0x11, 0xdc, 0x6e, 0x20, 0xfc, 0x84, 0x75, 0x7c, 0x69, 0x58, 0x82, 0xd0, 0x8b, 0x0c, 0x0b,
  0x11, 0xf6, 0x84, 0x1d, 0x80, 0x32, 0xe9, 0xed, 0x14, 0xfc, 0x3f, 0xc9, 0x62, 0x1d, 0x09, 0xb0,
  0xd8, 0xb2, 0xda, 0x53, 0xd0, 0xcf, 0x31, 0x46, 0x01, 0x67, 0x3c, 0x8a, 0x36, 0x67, 0xd8, 0x72,
  0x6d, 0xc2, 0x16, 0x6b, 0xd1, 0x5a, 0xad, 0xea, 0x52, 0xf0, 0xdc, 0xd5, 0xec, 0x87, 0xf7, 0x10,
  0x13, 0xd7, 0xc6, 0x55, 0x31, 0xc4, 0xc9, 0x70, 0x80, 0x07, 0xea, 0x2b, 0x7e, 0x3f, 0xbc, 0x07,
  0x2e, 0x4a, 0xe6, 0xf3, 0x27, 0x11, 0x48, 0xc1, 0xd9, 0x8d, 0x6d, 0xdb, 0x2d, 0x70, 0x1b, 0xc6,
  0xc5, 0xf0, 0xd6, 0xa2, 0xbc, 0x2c, 0x31, 0x29, 0xbd, 0x30, 0x6d, 0xd8, 0x37, 0xc3, 0xe8, 0xfd,
  0x99, 0x8c, 0x69, 0x14, 0xbe, 0xe3, 0x1e, 0x53, 0x68, 0x4c, 0x5a, 0x47, 0xba, 0x7b, 0xfd, 0x95,
  0xa2, 0x74, 0x38, 0x0d, 0xda, 0x23, 0x25, 0xd9, 0x57, 0x4d, 0x7d, 0x30, 0x34, 0x58, 0x94, 0x3a,
  0x9f, 0x46, 0x06, 0x0f, 0x09, 0x70, 0x52, 0xdf, 0xfc, 0xcd, 0xb8, 0xa5, 0xd9, 0xc8, 0xdc, 0xe3,
  0x3e, 0x12, 0x81, 0xc2, 0xae, 0x6d, 0x4d, 0xff, 0x1b, 0x86, 0xfc, 0xc5, 0xe1, 0x7e, 0x3e, 0xd4,
  0x98, 0xe1, 0xe5, 0x56, 0x0f, 0x8f, 0x7d, 0xb6, 0xc4, 0x1b, 0x9e, 0x5f, 0x67, 0x95, 0x04, 0x71,
  0xbd, 0x0d, 0x17, 0xb2, 0x91, 0x5c, 0x8c, 0xff, 0xc0, 0x6b, 0x62, 0x97, 0x03, 0x2e, 0x92, 0xeb,
  0x8f, 0xe1, 0x28, 0x93, 0x68, 0xc4, 0x55, 0x10, 0x67, 0x15, 0x33, 0x6d, 0x68, 0x7c, 0x15, 0xef,
  0x32, 0xe8, 0x49, 0xc0, 0xd0, 0x71, 0xcc, 0x4e, 0x3f, 0xdc, 0x85, 0x8b, 0x26, 0x28, 0x5b, 0xb9,
  0x08, 0xc3, 0x03, 0x9f, 0xc7, 0x0d, 0x03, 0x17, 0x09, 0x9f, 0x58, 0xa0, 0xb6, 0x63, 0x90, 0xfd,
  0x92, 0x1c, 0x61, 0x87, 0x73, 0xa0, 0xc7, 0x00, 0x84, 0xfa, 0x88, 0x96, 0xa2, 0x70, 0xc4, 0x61,
  0xf8, 0x32, 0x79, 0x7a, 0x3a, 0x3c, 0xf8, 0x7c, 0x58, 0xb2, 0xaf, 0x03, 0x9b, 0x81, 0x94, 0x94,
  0x41, 0x6e, 0x7e, 0x54, 0x4c, 0x9d, 0xd0, 0x62, 0xe8, 0xbb, 0xd1, 0x3e, 0x2a, 0x08, 0xb8, 0x1c,
  0xb0, 0x92, 0xf4, 0xa6, 0xa7, 0x15, 0x01, 0x45, 0xa0, 0x5e, 0xe0, 0x55, 0x6e, 0x06, 0x73, 0xdf,
  0xfc, 0x8c, 0xf0, 0x61, 0xa0, 0x16, 0x65, 0xf3, 0x42, 0xf8, 0x68, 0x98, 0xfc, 0x1b, 0xe3, 0x55,
  0xc3, 0xd5, 0x82, 0xd8, 0x22, 0x83, 0xc6, 0x16, 0xe1, 0xa7, 0xdd, 0x14, 0x19, 0x2f, 0xd1, 0xfb,
  0xc5, 0x3e, 0x26, 0x49, 0xe3, 0x10, 0x4b, 0xf2, 0x6f, 0x73, 0xc3, 0xcc, 0x28, 0xf4, 0x7a, 0xe9,
  0xfc, 0x4f, 0x53, 0xf8, 0xa9, 0xd6, 0x4b, 0xbc, 0x44, 0x5a, 0xc1, 0xc3, 0x55, 0x78, 0xb4, 0xea,
  0xa7, 0x2a, 0x88, 0xc3, 0xf4, 0xd2, 0x32, 0x9d, 0xfb, 0xed, 0x5b, 0x15, 0xcb, 0x2c, 0x96, 0x4c,
  0x7a, 0xbb, 0x4f, 0x04, 0xed, 0x79, 0x0c, 0x62, 0xca, 0xa6, 0x36, 0xea, 0xff, 0x90, 0x52, 0xff,
  0x68, 0xa7, 0x31, 0xd0, 0x72, 0xa3, 0xfe, 0x48, 0x76, 0x9e, 0x52, 0x8f, 0xe9, 0xcc, 0xd3, 0x06,
  0x4b, 0xfa, 0x23, 0xeb, 0x0b, 0x7b, 0x77, 0x23, 0x74, 0x77, 0x68, 0x0a, 0xaf, 0x6e, 0xde, 0xc0,
  0x3f, 0x7c, 0xb9, 0xab, 0xcb, 0x42, 0x06, 0x12, 0xf3, 0x4f, 0x1b, 0x69, 0xfc, 0x5b, 0xc7, 0x60,
  0x4c, 0x79, 0x1e, 0xfa, 0x18, 0x40, 0x88, 0x08, 0x38, 0xb1, 0x76, 0xf5, 0x09, 0x69, 0xe3, 0x2e,
  0xd8, 0x3c, 0x1c, 0x55, 0xc8, 0xae, 0xcd, 0x23, 0x59, 0x57, 0xf8, 0x09, 0x3a, 0x8c, 0xc9, 0xee,
  0xbc, 0xb3, 0x32, 0x43, 0x01, 0x45, 0xba, 0x7f, 0x2e, 0x26, 0x9e, 0xff, 0x42, 0x82, 0xa2, 0xc5,
  0xd4, 0x1f, 0x8f, 0xd1, 0xd0, 0xa5, 0xef, 0x89, 0x10, 0xb2, 0x14, 0x1a, 0x26, 0xfa, 0xc5, 0xd8,
  0xe7, 0x4b, 0x28, 0x71, 0xbb, 0x94, 0xf7, 0xc5, 0x25, 0xfc, 0xa2, 0x8a, 0xea, 0x21, 0x98, 0x86,
  0x86, 0xb2, 0x6f, 0xd3, 0x89, 0xb3, 0xd6, 0xb0, 0x05, 0x2d, 0x38, 0x74, 0x09, 0x59, 0x67, 0x9b,
  0x08, 0x88, 0x60, 0x96, 0x8f, 0x27, 0x86, 0x53, 0x3e, 0xdb, 0x07, 0xb3, 0x33, 0xf8, 0x8a, 0x4e,
  0x92, 0xef, 0x0e, 0xd5, 0xd9, 0x36, 0x4c, 0x12, 0xa7, 0x1b, 0xfd, 0xe8, 0x6d, 0xca, 0x0c, 0xf9,
  0x8b, 0x2d, 0xc0, 0x03, 0x4d, 0xc3, 0x6f, 0xd6, 0xba, 0x7c, 0x42, 0x59, 0xa2, 0x36, 0xa7, 0x5b,
  0x6e, 0x71, 0xce, 0x05, 0x7a, 0xd2, 0xcd, 0xd2, 0xf4, 0x81, 0x08, 0x7f, 0xe9, 0xa5, 0x17, 0xd6,
  0x29, 0x19, 0x37, 0x49, 0xd7, 0xc1, 0x17, 0xdd, 0x39, 0x33, 0x69, 0xa2, 0xd1, 0x60, 0xaf, 0xc7,
  0x23, 0xf6, 0x7b, 0x60, 0x76, 0x2c, 0xf6, 0x44, 0x17, 0x5f, 0x7c, 0x74, 0xa6, 0xa6, 0xd6, 0x84,
  0x4e, 0x7b, 0xcf, 0x57, 0x5d, 0xfc, 0x14, 0xd9, 0x08, 0x8d, 0xf1, 0x9e, 0xea, 0xdc, 0xf6, 0x74,
  0x97, 0xee, 0x8a, 0xc1, 0xf3, 0xe5, 0xde, 0x26, 0x7f, 0xda, 0xda, 0xba, 0xc2, 0xa7, 0x31, 0x66,
  0x3a, 0xca, 0x23, 0xf5, 0xa9, 0x3e, 0x89, 0x5e, 0xb4, 0x81, 0xf7, 0xbe, 0xf0, 0xfb, 0x24, 0x92,
  0xc9, 0x40, 0x35, 0x61, 0xe1, 0x57, 0x1e, 0xbf, 0xe5, 0x9e, 0xc4, 0x01, 0x7e, 0x75, 0x90, 0xbe,
  0x40, 0x19, 0xd3, 0xd8, 0x1e, 0xda, 0x0a, 0x1e, 0x48, 0x36, 0xae, 0x54, 0x1b, 0x3f, 0x56, 0x6c,
  0x9c, 0x40, 0x0f, 0x69, 0xa7, 0xa8, 0x24, 0x27, 0xed, 0xdd, 0x89, 0x22, 0xaf, 0x23, 0x91, 0xe1,
  0x21, 0xc3, 0xef, 0xf6, 0xe2, 0x59, 0x3b, 0x9d, 0x0e, 0xfc, 0xa2, 0x57, 0x8e, 0x7e, 0xea, 0x27,
  0xe9, 0xed, 0x12, 0xe0, 0x6d, 0x29, 0xb6, 0x65, 0xd0, 0x04, 0x5e, 0xf4, 0x5c, 0xc5, 0x03, 0xbd,
  0x1a, 0xbc, 0xe2, 0x0f, 0xfb, 0x18, 0xcb, 0x39, 0xdb, 0x19, 0x05, 0xa0, 0x08, 0xfe, 0xbc, 0xe9,
  0x83, 0xb7, 0xfa, 0x03, 0x28, 0x05, 0xca, 0x2e, 0xff, 0xa4, 0x1a, 0xbc, 0x38, 0xa4, 0xbb, 0x45,
  0xb7, 0x33, 0xf1, 0x2e, 0xb5, 0xb6, 0xff, 0x08, 0x63, 0x81, 0x42, 0x26, 0x06, 0x0b, 0x2a, 0x34,
  0xf4, 0x0c, 0x48, 0x81, 0xe9, 0xec, 0x67, 0xa0, 0x79, 0x83, 0x61, 0x4f, 0x94, 0x2a, 0x08, 0x76,
  0x0c, 0x99, 0xae, 0xad, 0x54, 0xc0, 0x28, 0xf1, 0xd4, 0x86, 0x75, 0x6a, 0x58, 0x25, 0xe8, 0x92,
  0xe3, 0x28, 0x81, 0x93, 0x46, 0xa2, 0x9a, 0x6a, 0x2a, 0x56, 0x27, 0x04, 0xed, 0x8d, 0x6d, 0x53,
  0x0c, 0x54, 0x83, 0xb8, 0x40, 0x93, 0x6d, 0xd5, 0x55, 0xc5, 0xb1, 0x23, 0x0e, 0x0e, 0x1d, 0x58,
  0xe2, 0x40, 0xb7, 0x1b, 0x9c, 0x22, 0x12, 0x06, 0x07, 0xd8, 0x99, 0xd3, 0x61, 0x1f, 0x7f, 0xfa,
  0xae, 0x92, 0xc3, 0xbf, 0xc7, 0x4d, 0xf6, 0x76, 0x0c, 0xfd, 0xe1, 0xa3, 0xd5, 0x91, 0x4d, 0xa0,
  0x56, 0x67, 0x82, 0x0b, 0x9c, 0xd2, 0x0e, 0xdd, 0xef, 0xbd, 0x39, 0x3d, 0x68, 0xa7, 0x92, 0x2c,
  0x23, 0x89, 0x5b, 0x59, 0xc6, 0x8a, 0x22, 0x3c, 0x07, 0xca, 0x68, 0x9d, 0xae, 0x32, 0x73, 0x7b,
  0x90, 0x57, 0x9f, 0x61, 0x78, 0x27, 0x68, 0x05, 0xaa, 0xfd, 0x92, 0x14, 0x5b, 0xdd, 0xfa, 0x0c,
  0xdd, 0x70, 0x49, 0x74, 0xb2, 0xe2, 0x06, 0x1f, 0x64, 0x77, 0xeb, 0x52, 0x59, 0x74, 0xd5, 0x56,
  0x5d, 0xaa, 0xce, 0xf9, 0x8e, 0x16, 0x26, 0x26, 0xf1, 0x8a, 0x72, 0xdc, 0x99, 0xab, 0x7b, 0xdb,
  0x39, 0xb3, 0x01, 0xdd, 0x0c, 0x41, 0x2d, 0xcf, 0xee, 0xb6, 0xd0, 0x3f, 0xf9, 0x3a, 0x84, 0x14,
  0x7c, 0xef, 0x91, 0x09, 0x06, 0x2a, 0xc2, 0x48, 0x5a, 0xc4, 0xa0, 0xfb, 0x4b, 0x03, 0xad, 0xdf,
  0xb2, 0x5c, 0x2c, 0x34, 0xd0, 0xdb, 0x54, 0x31, 0x24, 0x5d, 0x10, 0x6f, 0x98, 0xa0, 0xb1, 0x1d,
  0xa8, 0x5e, 0x5b, 0x9d, 0xe2, 0x29, 0x45, 0x68, 0xa6, 0x07, 0x0c, 0x83, 0x3c, 0x9c, 0xcb, 0x89,
  0xf9, 0xa2, 0x58, 0x14, 0xe9, 0x87, 0xb6, 0x9c, 0x7a, 0x36, 0xab, 0xea, 0xb6, 0x66, 0x59, 0xd6,
  0x8b, 0x4e, 0xa4, 0xae, 0x0e, 0xcb, 0x43, 0x4b, 0xd2, 0xad, 0xec, 0xa4, 0xaf, 0x3a, 0xd2, 0xc0,
  0xec, 0x26, 0x29, 0x9f, 0xe7, 0xc5, 0x5c, 0x45, 0xcc, 0x05, 0x55, 0x74, 0xbc, 0x64, 0x8c, 0x1f,
  0xc4, 0xd1, 0x80, 0xf0, 0x36, 0x2e, 0x2f, 0xfd, 0x6c, 0xb1, 0x96, 0xc3, 0xff, 0x73, 0xf9, 0x82,
  0xf4, 0x3c, 0xa0, 0x55, 0xf3, 0x72, 0x3e, 0x2f, 0x16, 0xb0, 0x76, 0xfe, 0x93, 0x06, 0x09, 0xd0,
  0x87, 0xd8, 0x5e, 0x93, 0x50, 0xaf, 0x00, 0xf5, 0x6a, 0x7f, 0xbf, 0x5a, 0x11, 0xaa, 0x14, 0x72,
  0x7f, 0xab, 0xde, 0x53, 0xe0, 0x05, 0xec, 0x1e, 0xb4, 0x43, 0x3a, 0xc5, 0x12, 0xf5, 0xf9, 0x55,
  0x50, 0x2e, 0xbf, 0xb1, 0x46, 0x43, 0x62, 0x51, 0xb9, 0xaa, 0xdb, 0x56, 0x78, 0x2f, 0x2b, 0x95,
  0xfc, 0x3e, 0xe0, 0xfb, 0xb6, 0xdc, 0x5d, 0x9e, 0x2f, 0xcb, 0x4b, 0x1b, 0x84, 0xb9, 0xf0, 0x06,
  0x61, 0xbe, 0xb2, 0xbc, 0x45, 0x18, 0xda, 0x1e, 0xe4, 0x7b, 0x79, 0xe1, 0x7d, 0x68, 0x6c, 0x73,
  0xa8, 0xb3, 0x9d, 0xae, 0x60, 0x7b, 0x19, 0xe4, 0x30, 0xa8, 0x40, 0x28, 0x12, 0xe9, 0xe6, 0xc3,
  0xae, 0x4e, 0x0c, 0x94, 0x81, 0xc1, 0x10, 0x99, 0x27, 0xf8, 0x06, 0xa3, 0xab, 0x75, 0x43, 0x77,
  0xa7, 0xfc, 0xd0, 0xa9, 0x30, 0xfb, 0xd6, 0x96, 0x7a, 0x3a, 0x18, 0x30, 0x26, 0x33, 0x4c, 0x60,
  0xae, 0x91, 0x4c, 0x20, 0x23, 0x7e, 0x17, 0x48, 0xe1, 0xc7, 0x0f, 0x9b, 0x80, 0x51, 0xe7, 0xfc,
  0x7f, 0xed, 0x7d, 0xdb, 0x7a, 0xdb, 0x48, 0x92, 0xe6, 0xfd, 0x3e, 0x05, 0x84, 0x72, 0x4b, 0x80,
  0x09, 0x91, 0x20, 0x65, 0xb9, 0x6c, 0x52, 0x20, 0xc7, 0x96, 0xed, 0x2a, 0xef, 0xb8, 0x5c, 0x1a,
  0xcb, 0xd5, 0x55, 0xfd, 0xa9, 0xf5, 0xb5, 0x40, 0x12, 0x94, 0x30, 0x02, 0x01, 0x1a, 0x00, 0x75,
  0x28, 0x89, 0x0f, 0xb2, 0x7b, 0xb3, 0x57, 0x7b, 0xb3, 0xfb, 0x56, 0xfb, 0x04, 0xfb, 0x08, 0x1b,
  0x11, 0x79, 0x40, 0x26, 0x0e, 0x14, 0x65, 0x77, 0x4f, 0xf7, 0xec, 0xd7, 0x3d, 0x53, 0x16, 0x98,
  0xc8, 0x4c, 0xe4, 0x21, 0x32, 0x32, 0x22, 0x32, 0xf2, 0x8f, 0x1c, 0x97, 0x1f, 0x8b, 0x0e, 0x5d,
  0xd8, 0x78, 0x32, 0xe8, 0x3f, 0xdb, 0x77, 0xa6, 0x65, 0x5d, 0x81, 0x8b, 0xa7, 0x7a, 0xd4, 0x63,
  0x35, 0x3a, 0x6a, 0x98, 0xbd, 0x9d, 0x2f, 0x30, 0x55, 0x0e, 0xbd, 0x2b, 0x6d, 0x03, 0x65, 0x73,
  0x80, 0x52, 0xe8, 0xd3, 0xf9, 0xf8, 0x75, 0xe4, 0x4f, 0x2e, 0x35, 0xeb, 0x92, 0x8b, 0xc1, 0xc7,
  0xf2, 0x53, 0x0a, 0xe8, 0x2b, 0x9e, 0xbb, 0xca, 0x73, 0xef, 0x54, 0x31, 0xfc, 0xd1, 0x55, 0x23,
  0xb5, 0x38, 0xbf, 0x00, 0xc6, 0x6b, 0xa0, 0xf3, 0x08, 0x5e, 0x43, 0xf1, 0xdc, 0x3b, 0xd5, 0xa3,
  0x3d, 0x40, 0x91, 0xd7, 0xa9, 0x66, 0xe2, 0x6a, 0xf7, 0xba, 0xbd, 0xe7, 0x4f, 0x45, 0x25, 0xed,
  0xef, 0xbb, 0xfb, 0xbd, 0xa7, 0xa2, 0x9a, 0xb6, 0xfb, 0x7d, 0x8f, 0xff, 0x52, 0x9b, 0x82, 0x3e,
  0x74, 0xc7, 0x1f, 0x0a, 0xe1, 0x67, 0xaa, 0x07, 0x1f, 0x38, 0x14, 0xe7, 0x33, 0x16, 0x50, 0x85,
  0x89, 0x78, 0x1c, 0x20, 0x7c, 0xb3, 0x8d, 0x0a, 0x9e, 0x07, 0x6c, 0x1b, 0xc3, 0x70, 0xbf, 0xc5,
  0xa0, 0xf0, 0x83, 0x4b, 0x50, 0xa4, 0x2d, 0x31, 0x03, 0xc5, 0x31, 0x8c, 0xc7, 0xbb, 0x2e, 0x33,
  0x39, 0x22, 0x0f, 0x73, 0x22, 0xe4, 0x7d, 0x92, 0xaf, 0x87, 0xdd, 0xde, 0xf7, 0x23, 0x76, 0xac,
  0x28, 0x4e, 0xd2, 0xc5, 0x36, 0x0a, 0xe4, 0x32, 0x74, 0x29, 0xe4, 0x59, 0xe5, 0x23, 0x67, 0xec,
  0x20, 0xa7, 0x40, 0x04, 0xec, 0xbe, 0x70, 0xa7, 0xc1, 0xb9, 0x63, 0x3c, 0xb9, 0x2b, 0x7f, 0x7f,
  0x65, 0xec, 0x21, 0x28, 0xad, 0x7c, 0x71, 0x72, 0x12, 0x3b, 0xf0, 0x7f, 0xb0, 0xbd, 0xba, 0x20,
  0x2c, 0x9c, 0xe1, 0x5d, 0x19, 0xf1, 0xc1, 0xfb, 0x7b, 0x90, 0x3d, 0xdd, 0xa2, 0xc5, 0xd5, 0x5e,
  0xa9, 0x85, 0x4b, 0x1d, 0x8b, 0xab, 0x3d, 0xb1, 0xff, 0x49, 0x53, 0xff, 0xa4, 0xa9, 0xbf, 0x1d,
  0x4d, 0xd1, 0xd1, 0xc3, 0xe1, 0xec, 0x1c, 0x58, 0xec, 0xe4, 0x33, 0x8a, 0x0b, 0x78, 0xbe, 0x89,
  0x67, 0x9a, 0xc0, 0xe2, 0x40, 0x86, 0x68, 0x93, 0x08, 0xc1, 0x50, 0x07, 0x79, 0x4c, 0x91, 0x22,
  0x95, 0xb9, 0x0f, 0x8f, 0xcf, 0x07, 0x30, 0x22, 0xc4, 0x60, 0xcd, 0xdd, 0xdd, 0xc9, 0x6e, 0x17,
  0x5d, 0x83, 0xa5, 0x44, 0x03, 0x8c, 0x71, 0x9a, 0x6d, 0x6f, 0x2f, 0x89, 0x4d, 0xff, 0xf2, 0x9e,
  0x5f, 0x1e, 0xc9, 0xa9, 0x16, 0xdc, 0x2d, 0xda, 0x4c, 0x60, 0x18, 0x88, 0xf2, 0xf9, 0x78, 0x61,
  0x3a, 0xf9, 0xc8, 0xec, 0x3e, 0x5b, 0xdc, 0x18, 0xec, 0x1f, 0x97, 0x3f, 0x99, 0x78, 0x90, 0x0b,
  0xcf, 0xbd, 0x1e, 0xfc, 0xf3, 0x8c, 0x3f, 0x20, 0xea, 0x15, 0x2f, 0x3a, 0xe6, 0x45, 0x5f, 0xc2,
  0x2b, 0xd7, 0xf8, 0x1e, 0xff, 0x15, 0x45, 0x5c, 0xca, 0xef, 0xaa, 0x99, 0x2f, 0xa6, 0x94, 0x59,
  0xdc, 0xd6, 0x21, 0x0b, 0x8d, 0xf2, 0x7a, 0x9e, 0xd3, 0x6b, 0x97, 0x3e, 0xbb, 0xaf, 0x7d, 0x27,
  0xdf, 0x1d, 0x9b, 0x4e, 0x31, 0x0a, 0x24, 0x67, 0x80, 0x3a, 0x32, 0x86, 0x1c, 0xe1, 0xef, 0x18,
  0xce, 0x9b, 0x42, 0x95, 0x1e, 0xe7, 0x49, 0x0a, 0x72, 0x08, 0xee, 0x2b, 0xef, 0xf3, 0x60, 0x6e,
  0x99, 0xd7, 0x30, 0x12, 0xbf, 0x84, 0x30, 0xd4, 0xa6, 0xf3, 0x5f, 0x8f, 0x7f, 0xfe, 0xd8, 0x66,
  0x97, 0xab, 0xc2, 0xd9, 0xad, 0x05, 0x75, 0xa9, 0xe8, 0x91, 0xf9, 0x79, 0xf4, 0x63, 0x80, 0xa1,
  0xf2, 0xe4, 0x18, 0x71, 0x8f, 0x0d, 0x90, 0xb1, 0xbc, 0xad, 0x9a, 0x44, 0xa7, 0x98, 0x44, 0xad,
  0x16, 0x36, 0x9f, 0xac, 0x9e, 0x62, 0x1e, 0xbd, 0xa6, 0x09, 0x1e, 0x31, 0x11, 0xb1, 0xcf, 0xdf,
  0x37, 0xd5, 0xfa, 0x81, 0x26, 0x4c, 0x6d, 0x1e, 0x9b, 0x42, 0xa5, 0x69, 0x2c, 0xa1, 0xb6, 0x02,
  0x4e, 0x64, 0xb0, 0xea, 0x83, 0x91, 0xa5, 0x11, 0x8d, 0xf9, 0x5d, 0x10, 0xa8, 0x53, 0x30, 0xd9,
  0x9d, 0x99, 0xdc, 0x57, 0x44, 0x4d, 0xec, 0x61, 0xe2, 0x74, 0x3a, 0xd5, 0x12, 0xf7, 0x30, 0x71,
  0x3c, 0x1e, 0x6b, 0x89, 0xcf, 0x30, 0xd1, 0xf7, 0x7d, 0x2d, 0x71, 0x1f, 0x13, 0x5f, 0xbe, 0x7c,
  0xa9, 0x25, 0x3e, 0xaf, 0x4b, 0x7c, 0x81, 0x89, 0x2f, 0x5e, 0xbc, 0xd0, 0x12, 0xc7, 0x98, 0xf8,
  0xec, 0xd9, 0x33, 0x2d, 0x71, 0x82, 0x89, 0x7b, 0x7b, 0x7b, 0x5a, 0x22, 0x5a, 0x8e, 0xbe, 0xeb,
  0x76, 0xbb, 0x5a, 0xe2, 0x14, 0x13, 0x7b, 0xbd, 0x9e, 0x96, 0x88, 0xae, 0x04, 0xdf, 0x4d, 0x9e,
  0xe9, 0x89, 0x89, 0xc9, 0xbd, 0x67, 0x7a, 0xee, 0x33, 0xc7, 0x28, 0xfe, 0x71, 0xdb, 0x2f, 0x6d,
  0x2d, 0x63, 0x36, 0xe6, 0xa3, 0xb4, 0x57, 0x4a, 0xbe, 0xe0, 0xe9, 0xcf, 0xb5, 0xf4, 0x7c, 0xdc,
  0x50, 0x31, 0x2c, 0x4b, 0x8b, 0x68, 0xdb, 0xb6, 0x4b, 0x05, 0x7c, 0x51, 0xa2, 0x0b, 0x52, 0xa0,
  0x51, 0xfc, 0xd3, 0x5c, 0xe2, 0x62, 0xa3, 0x6f, 0x54, 0xd5, 0x97, 0x70, 0x7e, 0x7e, 0x6d, 0xda,
  0x9c, 0x7b, 0x31, 0x2b, 0xba, 0x07, 0x3a, 0x3c, 0xba, 0xcc, 0x59, 0x6e, 0xfb, 0x05, 0x14, 0xea,
  0x97, 0x69, 0xa6, 0x3c, 0xc2, 0x44, 0x33, 0xc4, 0xe3, 0xca, 0x34, 0x53, 0x1e, 0xf6, 0xbd, 0xba,
  0x59, 0x7b, 0x56, 0x37, 0xbf, 0x44, 0x33, 0xfb, 0xfb, 0xfb, 0x55, 0x9a, 0x79, 0xfe, 0xfc, 0xf9,
  0x86, 0x34, 0x53, 0x26, 0x4e, 0xa2, 0x99, 0xc9, 0x64, 0x52, 0xa5, 0x99, 0xf2, 0x2a, 0x98, 0xd6,
  0x11, 0x3c, 0xd1, 0xcc, 0x8b, 0xbd, 0x6e, 0x3d, 0xcd, 0xec, 0xc1, 0x58, 0x8b, 0xff, 0x1a, 0x08,
  0x06, 0x86, 0xa8, 0x96, 0x60, 0x20, 0x7d, 0xbf, 0x81, 0x60, 0xd4, 0x5a, 0x37, 0xa1, 0x16, 0xb7,
  0x07, 0x84, 0x22, 0xff, 0xd9, 0x80, 0x5a, 0xf6, 0xbb, 0x8e, 0x21, 0xfe, 0xfb, 0x2a, 0x52, 0x59,
  0xc6, 0x68, 0xce, 0x52, 0xb8, 0x0d, 0x42, 0xbf, 0xbe, 0x3e, 0x47, 0x6e, 0x03, 0x2a, 0xba, 0x51,
  0xa7, 0x31, 0x8f, 0xcf, 0x4d, 0x04, 0x99, 0x98, 0x96, 0x41, 0x73, 0xa1, 0x7e, 0x93, 0xbc, 0x07,
  0xe2, 0x76, 0x96, 0x4e, 0xbc, 0xc0, 0x31, 0x81, 0x61, 0x06, 0xb6, 0x38, 0x87, 0xcf, 0x3c, 0xa1,
  0x85, 0x20, 0x56, 0xd9, 0x20, 0x3a, 0x00, 0x05, 0x56, 0x1c, 0xc6, 0x47, 0xe2, 0x30, 0xde, 0x47,
  0xf4, 0x32, 0x78, 0x71, 0x12, 0xa1, 0x54, 0x34, 0x22, 0x43, 0xd8, 0x3b, 0xd0, 0x4b, 0xfe, 0x04,
  0x12, 0x82, 0x65, 0xf7, 0xe5, 0x1b, 0x3c, 0xb6, 0xe2, 0xb5, 0x59, 0xbe, 0xc3, 0x93, 0xbb, 0xa7,
  0xe2, 0x89, 0xdd, 0x91, 0x97, 0x39, 0x12, 0x68, 0x16, 0xee, 0x2a, 0xf4, 0x23, 0x24, 0xc0, 0x4f,
  0x7c, 0xb2, 0x5b, 0x3c, 0x3b, 0x5e, 0xa4, 0xcf, 0x86, 0x18, 0xab, 0x35, 0x3b, 0xa0, 0xf8, 0x88,
  0xac, 0x07, 0xfc, 0xed, 0xb3, 0x53, 0x7b, 0x15, 0xd7, 0xc0, 0xdc, 0xe2, 0x48, 0xc1, 0xc6, 0xed,
  0x0d, 0xef, 0x58, 0xf7, 0x14, 0x0b, 0x63, 0x79, 0xab, 0x1b, 0x9f, 0x43, 0x0b, 0x40, 0x34, 0xfb,
  0x68, 0x65, 0x36, 0x85, 0x55, 0x6f, 0x3f, 0x2f, 0x64, 0x0e, 0x8e, 0x61, 0xed, 0x65, 0x35, 0xc2,
  0xca, 0x7b, 0x54, 0xcc, 0xbd, 0xb3, 0x65, 0x1a, 0x59, 0x4f, 0xee, 0xa8, 0x55, 0x20, 0xe7, 0xc0,
  0xe0, 0x33, 0x97, 0x4f, 0x7d, 0xd6, 0x8e, 0x2f, 0xc3, 0xf8, 0xf0, 0xf8, 0x58, 0xd8, 0xc2, 0x6b,
  0x94, 0x5d, 0x29, 0x37, 0xae, 0x8f, 0x87, 0x76, 0x11, 0x40, 0xc7, 0xf0, 0xba, 0x15, 0xce, 0x72,
  0x03, 0x42, 0x32, 0x06, 0x5b, 0x83, 0xd9, 0x8e, 0xe9, 0x2a, 0xa0, 0x13, 0xb7, 0xd3, 0x20, 0xf2,
  0x4c, 0x6a, 0x7d, 0x06, 0xfa, 0x2b, 0x5e, 0xf9, 0x62, 0xf1, 0xe7, 0x4d, 0x8c, 0x14, 0xdf, 0x99,
  0x20, 0xae, 0x77, 0xdc, 0xbe, 0x48, 0x83, 0x99, 0x67, 0xc1, 0x5e, 0x3f, 0x12, 0x51, 0xc1, 0xcd,
  0x16, 0x59, 0x07, 0xfb, 0x66, 0x1b, 0x43, 0xee, 0x75, 0x32, 0xe8, 0x42, 0x9b, 0x67, 0x9e, 0x07,
  0xd3, 0xd0, 0xf7, 0x4c, 0x9f, 0xee, 0xed, 0x68, 0x90, 0xce, 0x5a, 0x08, 0xe2, 0x24, 0x46, 0x90,
  0x61, 0x74, 0x03, 0x02, 0x92, 0x0e, 0xfa, 0x40, 0x72, 0xa5, 0xd8, 0x6a, 0x32, 0x80, 0x1a, 0x3a,
  0xf9, 0xa1, 0x11, 0xd2, 0x75, 0x2c, 0xfa, 0xa8, 0xa7, 0x09, 0x1d, 0xe7, 0x42, 0xe8, 0x80, 0xd4,
  0xf7, 0xcc, 0x26, 0xcf, 0xb3, 0x41, 0x79, 0x50, 0x66, 0x2d, 0xf3, 0x1d, 0xd4, 0x6f, 0xa0, 0x59,
  0xac, 0x6d, 0x1c, 0x45, 0x01, 0xa1, 0xe7, 0xc5, 0xb0, 0x86, 0x8c, 0x5f, 0x3f, 0xbc, 0x7d, 0x63,
  0xbc, 0x3f, 0xda, 0x32, 0x9b, 0xc4, 0x18, 0x56, 0xa3, 0x43, 0xb5, 0xd9, 0xb6, 0x10, 0x0a, 0xeb,
  0xbf, 0x5e, 0x88, 0x3c, 0x36, 0xca, 0x88, 0x48, 0x49, 0xde, 0x3c, 0x48, 0xcf, 0x83, 0x37, 0x41,
  0xb0, 0xc0, 0x5f, 0x4c, 0x12, 0x22, 0x5a, 0xc3, 0x19, 0xb5, 0x1d, 0x32, 0x0a, 0x1e, 0xfd, 0x92,
  0x87, 0x11, 0x1e, 0x14, 0x48, 0xf9, 0xc1, 0x91, 0xa2, 0x05, 0xd9, 0x8c, 0x46, 0xb3, 0x00, 0xed,
  0xed, 0xeb, 0x06, 0xff, 0x02, 0x03, 0x2f, 0x42, 0xd6, 0xf6, 0xbf, 0x67, 0x08, 0xf9, 0x74, 0x37,
  0x0f, 0xf2, 0x8b, 0x64, 0xca, 0xce, 0x5b, 0x56, 0x36, 0xc1, 0xfe, 0x5a, 0x40, 0xed, 0x01, 0xbd,
  0xb7, 0xec, 0x22, 0xe5, 0xae, 0xec, 0xe8, 0x00, 0xed, 0x46, 0xeb, 0x14, 0x1e, 0xde, 0xb4, 0x19,
  0xdc, 0xad, 0x76, 0xc2, 0x83, 0x96, 0xc3, 0x04, 0xc8, 0x3c, 0x4a, 0xce, 0x2d, 0xf3, 0x63, 0x62,
  0xf8, 0x58, 0xcc, 0x48, 0x66, 0x86, 0x68, 0x01, 0x3a, 0x41, 0x69, 0xad, 0x69, 0x1b, 0xdc, 0x5c,
  0x9e, 0x11, 0xa5, 0x07, 0xd3, 0xb6, 0x49, 0x87, 0xab, 0xb3, 0x30, 0x06, 0xfa, 0xb8, 0xb5, 0x54,
  0x77, 0x30, 0xce, 0xc0, 0x14, 0x41, 0xed, 0x1c, 0x83, 0x2f, 0x92, 0x3b, 0x4e, 0xd3, 0xbb, 0x62,
  0xb0, 0x26, 0x08, 0x54, 0xaf, 0xae, 0x26, 0x13, 0x69, 0xf2, 0x10, 0x48, 0xd2, 0xe6, 0xb6, 0xd9,
  0xe3, 0x28, 0xc9, 0xf1, 0x96, 0x1f, 0x93, 0xcf, 0x3f, 0xfb, 0x63, 0x5c, 0x0a, 0x19, 0xa6, 0xd0,
  0x4c, 0xf0, 0x89, 0x20, 0x53, 0x52, 0x1b, 0x1a, 0xa4, 0xde, 0x6b, 0x50, 0x9b, 0x29, 0xee, 0xd8,
  0x59, 0x74, 0xb8, 0xa5, 0xe4, 0xd7, 0x6f, 0x6b, 0xb0, 0xaf, 0x1c, 0x31, 0x57, 0xe8, 0xcc, 0xe6,
  0x86, 0xd0, 0x66, 0xda, 0x39, 0x9a, 0xe7, 0xd4, 0x52, 0x81, 0xc2, 0xac, 0x0d, 0x4d, 0xd9, 0xda,
  0xc3, 0x4e, 0xd6, 0x9c, 0x7d, 0x17, 0xb7, 0x8b, 0x2a, 0x83, 0xbb, 0x92, 0x36, 0x25, 0xd1, 0x9a,
  0x7a, 0x5b, 0x13, 0x56, 0x23, 0x04, 0xf9, 0xea, 0x76, 0x31, 0xb9, 0x92, 0x9b, 0x8e, 0xe0, 0x74,
  0xae, 0x63, 0xe6, 0x29, 0x05, 0x9c, 0xaf, 0xef, 0xc8, 0x62, 0x32, 0x37, 0x11, 0x45, 0x2d, 0x39,
  0x3f, 0x8f, 0x82, 0x23, 0x32, 0x45, 0xe3, 0x59, 0xee, 0x40, 0x68, 0xbd, 0x15, 0x47, 0x84, 0x7a,
  0x0f, 0x04, 0x09, 0xe2, 0x16, 0x1b, 0xe4, 0x32, 0x52, 0xc7, 0xc4, 0xd9, 0x71, 0x07, 0x1f, 0xe6,
  0xd7, 0x74, 0x88, 0x82, 0xce, 0x5d, 0x4e, 0x5d, 0x5e, 0xf5, 0xb8, 0x93, 0xb5, 0x8d, 0x15, 0x58,
  0x93, 0x9b, 0x5d, 0x67, 0x51, 0xf3, 0x16, 0x9c, 0xab, 0x44, 0x40, 0x1b, 0x68, 0xf5, 0x39, 0xcf,
  0x6b, 0xd6, 0x74, 0x4d, 0x3a, 0xfc, 0x7a, 0xca, 0x33, 0xb0, 0xe5, 0x05, 0xe8, 0xf9, 0x50, 0xd4,
  0xf0, 0xf9, 0xa5, 0x4f, 0x13, 0x0a, 0x33, 0xeb, 0x3e, 0x42, 0x9d, 0x9f, 0x04, 0xa7, 0x45, 0xee,
  0x96, 0x27, 0xb3, 0x29, 0xcd, 0x4c, 0x80, 0xf1, 0x42, 0x23, 0xd1, 0x74, 0x81, 0x37, 0xdb, 0xee,
  0x58, 0xe1, 0xed, 0xed, 0xad, 0x1c, 0x6f, 0xd2, 0x10, 0x61, 0xc2, 0x0e, 0xf0, 0x97, 0x43, 0x56,
  0x0f, 0xf6, 0xbf, 0xcd, 0x3a, 0x0c, 0x4b, 0x67, 0x9e, 0x24, 0x39, 0xc8, 0x2a, 0x48, 0x1f, 0x90,
  0xa1, 0x6a, 0x35, 0x04, 0x71, 0x26, 0x34, 0x1d, 0x56, 0x49, 0x65, 0x45, 0x05, 0xaa, 0x86, 0x97,
  0x5d, 0x24, 0xd7, 0x9f, 0x13, 0x3f, 0xcb, 0x65, 0x3b, 0xd0, 0xbf, 0xb0, 0x86, 0xda, 0x92, 0x38,
  0x06, 0xfe, 0x2f, 0x49, 0xae, 0xd8, 0x4a, 0xd9, 0x35, 0x05, 0x2e, 0x02, 0xf2, 0xfb, 0xd5, 0xd5,
  0xf2, 0x39, 0x7e, 0x83, 0x6d, 0x6c, 0x31, 0x4c, 0x23, 0x9d, 0xd3, 0xe0, 0xfe, 0x56, 0x0c, 0x2f,
  0xa8, 0xb8, 0x01, 0x3a, 0x1b, 0x81, 0xd6, 0x87, 0x8d, 0x02, 0xbd, 0x16, 0x36, 0x83, 0x54, 0x2c,
  0x37, 0x6e, 0x4a, 0x46, 0x92, 0x60, 0x0d, 0xf0, 0xe3, 0x70, 0xee, 0xb3, 0x13, 0x7c, 0xe6, 0xd2,
  0x50, 0x7d, 0xc1, 0xae, 0x70, 0xb2, 0x82, 0x5e, 0xc3, 0xd2, 0x7d, 0x70, 0x82, 0x59, 0x5b, 0x4c,
  0xe4, 0x8b, 0x4e, 0xef, 0xa5, 0xeb, 0x96, 0xc6, 0x8e, 0xfc, 0xa3, 0xd8, 0x00, 0x22, 0x1f, 0xc0,
  0x61, 0x82, 0xd5, 0xf3, 0xeb, 0x31, 0x2c, 0xd9, 0x62, 0x68, 0xcd, 0x43, 0x96, 0x4c, 0x6a, 0x6b,
  0x62, 0x90, 0x52, 0x6b, 0xcc, 0x7c, 0xd8, 0xf7, 0xa6, 0x5b, 0x26, 0x2e, 0x0b, 0x45, 0x29, 0xc5,
  0x4e, 0x6b, 0x95, 0x36, 0x8e, 0xa5, 0xd2, 0xf2, 0x0d, 0xf2, 0x14, 0x3d, 0x62, 0xa3, 0x4c, 0x5d,
  0x2a, 0xec, 0xf9, 0x41, 0xfe, 0x69, 0x19, 0xe3, 0x58, 0x91, 0x4d, 0x4e, 0x2c, 0x19, 0x19, 0xc8,
  0x9d, 0x30, 0x42, 0x0b, 0x4c, 0x6d, 0x2b, 0xef, 0xbc, 0x40, 0xe8, 0x52, 0x04, 0xc9, 0x55, 0x52,
  0xad, 0x7c, 0x97, 0x92, 0x9f, 0xc6, 0x36, 0x86, 0x3d, 0x42, 0x50, 0xd8, 0xfa, 0xd7, 0xbb, 0xf8,
  0xf6, 0x69, 0x66, 0x77, 0x78, 0x6c, 0xa4, 0x51, 0xcc, 0x22, 0xf0, 0x76, 0x3d, 0x78, 0x06, 0xdd,
  0xff, 0xd6, 0xc4, 0x43, 0xa2, 0xdb, 0xcc, 0x64, 0x81, 0x71, 0xfb, 0xa6, 0x59, 0x44, 0x4c, 0xf3,
  0x10, 0x12, 0x72, 0x94, 0xc9, 0x02, 0x19, 0xec, 0xbb, 0xc9, 0x12, 0xc9, 0x06, 0xff, 0x40, 0x11,
  0xc8, 0xed, 0x6c, 0xc5, 0x20, 0x73, 0x02, 0x21, 0x43, 0x76, 0xac, 0x00, 0x84, 0xc2, 0xe1, 0xfe,
  0x4b, 0x58, 0x5b, 0x31, 0x4b, 0x8b, 0xa0, 0x34, 0xb9, 0x1c, 0x38, 0xf9, 0x01, 0x36, 0x05, 0x78,
  0x22, 0xbd, 0x57, 0xf2, 0xf3, 0x74, 0x4c, 0xc9, 0x77, 0x11, 0x7d, 0x17, 0x8a, 0x64, 0x01, 0x2a,
  0x49, 0xbe, 0x62, 0x06, 0x8d, 0x81, 0x5f, 0x24, 0xd7, 0xcc, 0xd9, 0x18, 0x5d, 0x49, 0xb8, 0x0d,
  0xf2, 0xec, 0x20, 0x4f, 0x87, 0x07, 0xf9, 0x94, 0x79, 0xca, 0x79, 0xe6, 0x65, 0x70, 0x9b, 0x4f,
  0xcd, 0xe1, 0x93, 0xbb, 0x60, 0x75, 0xd0, 0xc9, 0xa7, 0xea, 0xab, 0x2b, 0x3f, 0x62, 0xaf, 0xf2,
  0x15, 0x48, 0xa2, 0xfc, 0x75, 0x07, 0x8a, 0x9f, 0x55, 0x3e, 0xd3, 0x2d, 0xec, 0xfe, 0xc5, 0x07,
  0x92, 0x28, 0x5b, 0xf8, 0xb1, 0xd7, 0xab, 0xd4, 0x17, 0xd4, 0xd7, 0x05, 0x33, 0xfd, 0x41, 0x39,
  0xad, 0x3c, 0x92, 0x88, 0x77, 0x5d, 0xc9, 0xfb, 0xc8, 0x59, 0x9a, 0x8e, 0x0e, 0xed, 0x9c, 0x45,
  0x89, 0x6d, 0xb5, 0x24, 0x7c, 0xf9, 0xb0, 0xb7, 0xef, 0xd2, 0xd5, 0xf4, 0x1e, 0x6e, 0x6f, 0x8a,
  0xef, 0x2a, 0x30, 0xe5, 0xc9, 0xe5, 0x2f, 0x50, 0x65, 0x3d, 0xc7, 0x25, 0xb2, 0x3c, 0x5b, 0x60,
  0xbb, 0xc2, 0xe9, 0x99, 0xcd, 0x0e, 0xe5, 0x07, 0x5b, 0xf4, 0x19, 0xba, 0x2e, 0xeb, 0xb2, 0x78,
  0x0e, 0xf0, 0xc1, 0x51, 0x43, 0xb9, 0x6b, 0x1f, 0x3a, 0x6e, 0x2b, 0x0c, 0xc4, 0x34, 0xfb, 0x9b,
  0x66, 0x3d, 0xdb, 0xfe, 0xee, 0x25, 0x68, 0xc3, 0x03, 0xe3, 0x67, 0x50, 0xe1, 0xd1, 0x8b, 0x3b,
  0x8c, 0xcf, 0x8d, 0x27, 0x77, 0x0b, 0xda, 0x00, 0x72, 0x7b, 0xb5, 0xa5, 0x0c, 0x11, 0x4b, 0x2c,
  0xdc, 0x2b, 0xd8, 0xf9, 0x30, 0x86, 0xb3, 0x96, 0x4e, 0x0f, 0xd4, 0x6a, 0xe0, 0xf1, 0x48, 0x4f,
  0xb0, 0x4c, 0xe4, 0x4f, 0x44, 0x64, 0x52, 0x8c, 0xe4, 0x47, 0x91, 0x7f, 0x8b, 0xa7, 0xa0, 0xca,
  0x81, 0x8d, 0xcc, 0xbb, 0xe0, 0xef, 0xb6, 0xb7, 0x2b, 0x49, 0xed, 0x45, 0xa6, 0xb4, 0xc6, 0x5f,
  0x84, 0x7f, 0xf4, 0x23, 0xa1, 0x7e, 0x88, 0xcc, 0xdc, 0x05, 0x07, 0x56, 0x06, 0x6b, 0x65, 0xe5,
  0xfe, 0x89, 0xcc, 0x28, 0x1d, 0x3d, 0xda, 0xd7, 0x84, 0x29, 0x04, 0xff, 0xf6, 0xad, 0x29, 0xec,
  0xf2, 0x79, 0x00, 0x69, 0xb1, 0x23, 0x1f, 0x17, 0xc5, 0xe3, 0x97, 0xa8, 0x6c, 0x19, 0xcc, 0xd5,
  0x5d, 0xe3, 0x4b, 0x24, 0x86, 0xa8, 0xd4, 0x2b, 0xa5, 0x33, 0x5f, 0xa2, 0x91, 0xf2, 0x8c, 0x47,
  0xb8, 0x05, 0xa9, 0x2c, 0x5e, 0x4f, 0x2e, 0x25, 0xe1, 0xd5, 0x68, 0xc2, 0x13, 0xd4, 0x81, 0x70,
  0x4b, 0x8b, 0x98, 0x9f, 0x0e, 0x8b, 0x3b, 0x42, 0xbf, 0xa0, 0x3c, 0x1d, 0x8a, 0x5b, 0xae, 0xf3,
  0x92, 0xfe, 0x87, 0xb2, 0x11, 0x02, 0x83, 0x1d, 0x26, 0xf3, 0x39, 0x88, 0x51, 0xb8, 0x55, 0x2d,
  0x6e, 0xcd, 0x12, 0xfb, 0x5d, 0x84, 0xc1, 0x14, 0x59, 0xef, 0x24, 0x0a, 0x17, 0xe3, 0xc4, 0x4f,
  0x81, 0xef, 0x2a, 0xdd, 0x59, 0xd0, 0x04, 0x33, 0x57, 0x57, 0x39, 0xed, 0xe8, 0x3f, 0x01, 0x14,
  0x36, 0xc0, 0x10, 0x19, 0x56, 0xbc, 0x4e, 0x34, 0x04, 0xa5, 0x86, 0x2b, 0xdc, 0xc3, 0x2e, 0x19,
  0xe3, 0xf1, 0xb6, 0x42, 0x11, 0x8f, 0x62, 0xc5, 0xd4, 0xd8, 0x9d, 0x83, 0x69, 0x78, 0x25, 0x56,
  0x29, 0x7e, 0xd1, 0x98, 0x98, 0xc3, 0x9d, 0x41, 0xd6, 0x42, 0xdf, 0xb0, 0x3f, 0x25, 0x4b, 0xe3,
  0xc2, 0xbf, 0x0a, 0x8c, 0x38, 0xe1, 0xad, 0xc9, 0x8c, 0xdb, 0x20, 0xdf, 0x02, 0xae, 0x76, 0x9c,
  0xa4, 0xe9, 0xad, 0x63, 0x80, 0x5c, 0x9d, 0x06, 0xc6, 0x35, 0x3a, 0xdd, 0x22, 0x65, 0x65, 0xcb,
  0xc0, 0xe0, 0xd1, 0x64, 0x8c, 0x5b, 0xe0, 0x7b, 0xa2, 0x14, 0xec, 0x27, 0xb8, 0x81, 0x43, 0xad,
  0xe6, 0xc1, 0x18, 0x58, 0x04, 0xfc, 0x67, 0x3a, 0xec, 0x1b, 0x3f, 0xc2, 0xb2, 0x07, 0xe2, 0x17,
  0x55, 0x85, 0x99, 0x81, 0x9b, 0xf8, 0x72, 0xc1, 0x8b, 0x1a, 0x20, 0x24, 0xf8, 0x28, 0xf5, 0xf8,
  0x98, 0x70, 0x15, 0x26, 0xcb, 0x8c, 0x79, 0x06, 0x47, 0xcc, 0x0d, 0xd0, 0xf0, 0xaf, 0x60, 0xc7,
  0x42, 0x7f, 0x9b, 0x36, 0xd6, 0x6a, 0xfc, 0x39, 0x36, 0x0c, 0xc3, 0x3a, 0xf6, 0xaf, 0xb0, 0x09,
  0xbe, 0xa8, 0x04, 0xe3, 0x96, 0x1b, 0x17, 0x20, 0x76, 0x10, 0x4e, 0x29, 0xb4, 0x75, 0x6a, 0x24,
  0x7c, 0xc5, 0x61, 0x52, 0xc0, 0xbf, 0x89, 0x41, 0xb9, 0x7e, 0xe4, 0xad, 0xf0, 0x45, 0x3b, 0x50,
  0xe2, 0x82, 0x1c, 0x68, 0xaf, 0x37, 0x2e, 0xe3, 0xe4, 0x1a, 0x98, 0x55, 0x92, 0x4c, 0x0d, 0xc2,
  0xe4, 0xe8, 0x53, 0x2f, 0x76, 0x0e, 0x50, 0xed, 0xf5, 0x41, 0x65, 0x36, 0x40, 0x3f, 0x26, 0x3a,
  0x41, 0x06, 0xc7, 0xd3, 0x86, 0x45, 0xbb, 0x0e, 0xc6, 0xcb, 0x3c, 0xa7, 0xed, 0x94, 0x86, 0x7b,
  0x9c, 0xc7, 0x06, 0xfc, 0xb7, 0xbb, 0x30, 0x41, 0xaf, 0x05, 0x1a, 0x98, 0x5c, 0x7a, 0x26, 0x27,
  0x42, 0x73, 0x08, 0xd4, 0x71, 0xab, 0xd1, 0xc6, 0x41, 0x87, 0x95, 0x1e, 0xee, 0xd8, 0x0e, 0x0d,
  0x64, 0x07, 0x66, 0x0e, 0x86, 0xb1, 0xc6, 0xc9, 0x01, 0x83, 0x94, 0x98, 0x2a, 0x9f, 0xc9, 0x9c,
  0x7a, 0xf9, 0x89, 0x48, 0x9a, 0x7b, 0x22, 0xc5, 0x25, 0x03, 0x03, 0xe3, 0x2f, 0x20, 0x98, 0x31,
  0xef, 0x42, 0xee, 0x8f, 0x84, 0x0e, 0x1a, 0x1e, 0xa9, 0x25, 0xf4, 0x3c, 0x74, 0x85, 0xd3, 0xdd,
  0x22, 0x21, 0xcf, 0xcc, 0x40, 0x14, 0x43, 0xb1, 0x5a, 0xf8, 0x6f, 0xc0, 0x5f, 0x16, 0xef, 0x08,
  0x74, 0x06, 0x34, 0x19, 0x81, 0x30, 0x0a, 0x49, 0x5b, 0x1e, 0x7f, 0x0f, 0x52, 0x66, 0x91, 0x91,
  0x33, 0x0e, 0xb3, 0xc3, 0x49, 0x87, 0xe9, 0xa7, 0x03, 0x20, 0x74, 0xa2, 0xe1, 0x33, 0xae, 0xcd,
  0x3e, 0xb9, 0x23, 0x6d, 0x76, 0xa5, 0x65, 0x3b, 0xb3, 0x1d, 0xa6, 0xf8, 0xe6, 0x8d, 0xfa, 0xac,
  0x05, 0x7a, 0xc9, 0xe5, 0xfd, 0x7d, 0x59, 0x48, 0x72, 0xa4, 0x9e, 0xab, 0x28, 0xba, 0xcc, 0x4f,
  0x25, 0x70, 0xca, 0x5d, 0x6b, 0x50, 0x74, 0x55, 0xa1, 0x15, 0x7b, 0xaf, 0x2a, 0xbe, 0x18, 0xd9,
  0x4e, 0x59, 0xce, 0xcc, 0xc7, 0xb1, 0x50, 0x68, 0x6d, 0xf8, 0x1a, 0x9e, 0x11, 0x15, 0xd2, 0x60,
  0x00, 0x7c, 0x04, 0x2f, 0xcc, 0xd1, 0x32, 0xc5, 0xa6, 0x89, 0x38, 0x3b, 0x8b, 0x7f, 0xfb, 0xe0,
  0x9d, 0x28, 0x3e, 0x0f, 0xa2, 0x71, 0xff, 0xf6, 0x41, 0xb2, 0x2e, 0x60, 0x0f, 0x30, 0xc8, 0x90,
  0x51, 0xac, 0x7f, 0xd7, 0xbe, 0x0b, 0x90, 0x4c, 0x17, 0x82, 0xf2, 0xd8, 0xf9, 0x83, 0x39, 0xfc,
  0x37, 0xf4, 0x4e, 0xa1, 0xd9, 0x3e, 0xe8, 0x2c, 0x60, 0xd9, 0xb3, 0xb1, 0x77, 0x75, 0x7d, 0x03,
  0x2a, 0x22, 0x68, 0x0c, 0xa8, 0xe2, 0xac, 0x44, 0xc1, 0x37, 0x37, 0x19, 0x52, 0xb0, 0xb1, 0xc8,
  0xf2, 0xcc, 0x24, 0xe2, 0x87, 0x7d, 0x2e, 0x3e, 0x71, 0x4f, 0x57, 0x5f, 0xa2, 0xb1, 0x42, 0xd5,
  0xa4, 0x05, 0x10, 0x5a, 0x03, 0x7f, 0x6d, 0x0f, 0x50, 0x18, 0x88, 0x4f, 0xba, 0xa7, 0x2b, 0x49,
  0xd7, 0x67, 0x4e, 0xab, 0x95, 0x0f, 0x9f, 0xd1, 0x34, 0xbb, 0x4e, 0xc0, 0x79, 0x05, 0xb0, 0x5c,
  0xd8, 0x83, 0x09, 0xb3, 0x49, 0xa6, 0x38, 0xf5, 0xbd, 0x01, 0xdd, 0x50, 0x30, 0x1c, 0xea, 0xce,
  0xaa, 0x66, 0x69, 0x7c, 0x89, 0xb4, 0x85, 0xa1, 0x48, 0x0a, 0xe5, 0x59, 0x0e, 0x08, 0x6a, 0xdd,
  0x62, 0x44, 0xa0, 0x98, 0x61, 0xd6, 0xb3, 0x5c, 0x5b, 0xec, 0x56, 0x6c, 0x97, 0x71, 0x4f, 0x05,
  0x3d, 0x83, 0x2a, 0x20, 0x76, 0x43, 0x68, 0x4d, 0x8a, 0xb7, 0x7e, 0x98, 0x30, 0x03, 0xca, 0x47,
  0x96, 0xa4, 0xb9, 0x35, 0x99, 0x2f, 0x8e, 0x6c, 0x31, 0xbd, 0x8c, 0x39, 0xe3, 0x3c, 0xf3, 0x99,
  0x88, 0x60, 0x26, 0x2c, 0xee, 0x24, 0x15, 0xd3, 0x74, 0xb0, 0x8d, 0x37, 0xcc, 0xf8, 0x95, 0xa0,
  0x08, 0x6f, 0x60, 0x16, 0xe1, 0x89, 0xd0, 0x9c, 0x1b, 0x14, 0x92, 0x72, 0x84, 0xf7, 0x2f, 0x07,
  0xcc, 0xe6, 0x8a, 0x39, 0x61, 0xef, 0x1b, 0xf8, 0xb0, 0x82, 0x81, 0x46, 0x58, 0x78, 0xeb, 0xc0,
  0xf1, 0xd1, 0x2c, 0x2a, 0xf1, 0x6a, 0x72, 0x9c, 0xec, 0xd2, 0xd6, 0x20, 0x67, 0x38, 0x58, 0x25,
  0x26, 0x4c, 0x97, 0x34, 0xa3, 0x2c, 0x42, 0xf2, 0x97, 0x2e, 0x17, 0x09, 0xa5, 0xc4, 0x87, 0x9c,
  0xea, 0xac, 0x5a, 0xe9, 0x93, 0x3b, 0x4d, 0x18, 0x19, 0x99, 0x8b, 0x28, 0x86, 0x1d, 0x1c, 0xb8,
  0xf0, 0x82, 0xfe, 0xae, 0x1a, 0x48, 0x28, 0x58, 0xd9, 0x58, 0x73, 0xa9, 0xf0, 0x41, 0xc8, 0xeb,
  0xdd, 0x09, 0x71, 0xe9, 0x11, 0x6b, 0xc5, 0xa7, 0x9d, 0xe1, 0xf6, 0x77, 0x37, 0x41, 0x77, 0xef,
  0xe5, 0xe0, 0xa0, 0x13, 0x0e, 0x51, 0x6c, 0x5f, 0x09, 0x11, 0x0b, 0x14, 0x74, 0xd6, 0x38, 0xc6,
  0x9f, 0x0d, 0x59, 0x85, 0xc9, 0xaa, 0x08, 0xa8, 0x02, 0x63, 0x16, 0xa5, 0x20, 0x95, 0x09, 0x47,
  0xc1, 0x93, 0xa0, 0xd5, 0x75, 0xdd, 0x53, 0x50, 0x0c, 0x6f, 0x16, 0x54, 0x1b, 0x1b, 0x97, 0x2c,
  0x38, 0x0f, 0x20, 0x13, 0xbe, 0x53, 0xdb, 0xcd, 0x4a, 0x59, 0xe2, 0x0d, 0x34, 0x1c, 0x5b, 0xb3,
  0xf7, 0x72, 0x9f, 0x5a, 0x23, 0xbe, 0xab, 0x0c, 0x0a, 0xd4, 0x03, 0x3a, 0x80, 0xa8, 0x52, 0xd6,
  0x38, 0x54, 0x1b, 0xca, 0x9e, 0x71, 0x31, 0x9c, 0x91, 0xe7, 0x5c, 0xab, 0xb5, 0x02, 0x62, 0xd8,
  0x64, 0x27, 0xc8, 0x29, 0x3f, 0x72, 0x04, 0x62, 0xe2, 0xc4, 0x83, 0xb7, 0xb7, 0x5d, 0xfe, 0xd7,
  0x6a, 0x3e, 0x99, 0x45, 0x53, 0x13, 0x32, 0x74, 0xdb, 0x11, 0x94, 0x8d, 0xbe, 0x78, 0x6b, 0xf2,
  0x57, 0x4e, 0x71, 0x19, 0xb9, 0xdb, 0xc2, 0xaa, 0x85, 0xbc, 0x5e, 0x50, 0x77, 0x02, 0x3c, 0x27,
  0x39, 0x90, 0xb7, 0xf5, 0x12, 0x3c, 0x20, 0x60, 0x14, 0x9c, 0x9d, 0x24, 0xa7, 0x83, 0xd2, 0xc8,
  0x83, 0xe8, 0xcf, 0x06, 0x95, 0x7e, 0x92, 0xa6, 0xca, 0x6e, 0x77, 0x6b, 0x2c, 0xd6, 0xb5, 0x07,
  0xdc, 0x9c, 0xf6, 0xca, 0xb2, 0x1d, 0x95, 0x4d, 0x56, 0xd7, 0x3c, 0x7a, 0xa0, 0xaa, 0x9e, 0xcb,
  0x84, 0xaa, 0x3d, 0x4b, 0x83, 0xe0, 0x22, 0xf0, 0x17, 0x9d, 0x6e, 0xb0, 0x37, 0x00, 0xbd, 0x5d,
  0xfa, 0x11, 0x77, 0x6d, 0xbe, 0x3e, 0xd1, 0xb5, 0x18, 0x24, 0x11, 0xcc, 0x34, 0x74, 0x47, 0xca,
  0x2f, 0x2c, 0xd2, 0xdf, 0xed, 0x0e, 0x32, 0x2f, 0x2b, 0x97, 0x8a, 0x10, 0xb2, 0x24, 0x98, 0xc2,
  0x4a, 0xbb, 0x4e, 0x41, 0xc9, 0x34, 0x3f, 0xb2, 0x0b, 0x4c, 0x13, 0x6a, 0xc7, 0x14, 0x36, 0xba,
  0x21, 0x94, 0x1d, 0xf9, 0x9e, 0x15, 0xc1, 0xff, 0x77, 0x3c, 0xf8, 0x61, 0xcb, 0x2a, 0xe0, 0x1d,
  0xc6, 0xe9, 0xe8, 0xda, 0xa0, 0x80, 0x1a, 0xaf, 0xcc, 0x7e, 0x44, 0x5e, 0x16, 0x94, 0x77, 0xdf,
  0x7d, 0xaa, 0xf8, 0x34, 0x47, 0x1d, 0x50, 0x83, 0x30, 0xd3, 0xfc, 0x15, 0xb7, 0x7e, 0x24, 0x7c,
  0x57, 0x08, 0xda, 0x4b, 0x3a, 0xa3, 0x21, 0x7f, 0xce, 0x13, 0xd0, 0x0f, 0x4f, 0x81, 0xc3, 0x97,
  0xf8, 0x12, 0xe6, 0xb1, 0x91, 0x37, 0x8f, 0x92, 0x96, 0x27, 0x94, 0x49, 0xc8, 0x4a, 0x67, 0x04,
  0xc8, 0x66, 0xfa, 0x7a, 0xba, 0xc0, 0xbb, 0x34, 0xff, 0x75, 0xb9, 0xbc, 0xf0, 0x2f, 0x97, 0x26,
  0x08, 0xc9, 0x20, 0x5d, 0xb5, 0xc9, 0x78, 0x96, 0xfd, 0x1a, 0xe6, 0x17, 0x96, 0xe9, 0xb6, 0xbb,
  0x7b, 0x6d, 0x34, 0xf3, 0x59, 0x90, 0xef, 0x73, 0x72, 0x19, 0xb6, 0x8e, 0x3f, 0x21, 0x23, 0x6f,
  0x4f, 0x62, 0x4a, 0xc3, 0x07, 0xc6, 0x20, 0xae, 0x80, 0xe4, 0xb1, 0xf8, 0xca, 0xd8, 0x8e, 0xc7,
  0xd9, 0x62, 0x70, 0x00, 0x6b, 0x16, 0xd6, 0xfa, 0xca, 0xc4, 0xf5, 0x72, 0xb0, 0x18, 0x5a, 0x68,
  0x81, 0x3f, 0xfe, 0xf4, 0x17, 0x99, 0x0d, 0x1f, 0xd2, 0x20, 0x5a, 0x21, 0x92, 0x89, 0x8d, 0x8c,
  0x1f, 0x32, 0x1d, 0x04, 0xf3, 0xe1, 0x78, 0x19, 0x46, 0x53, 0x7a, 0x7b, 0x15, 0x4e, 0x61, 0x9d,
  0x43, 0x12, 0xbe, 0x35, 0xa4, 0x3c, 0x76, 0x40, 0x97, 0x66, 0xe5, 0x8a, 0x87, 0x0e, 0xe5, 0x26,
  0x7b, 0xf3, 0xe7, 0x9b, 0xbd, 0xc9, 0xd6, 0xee, 0xae, 0xc1, 0x3e, 0x65, 0x8c, 0x71, 0x49, 0xee,
  0xee, 0x42, 0x6a, 0x40, 0xaf, 0xa1, 0x39, 0xbc, 0xf7, 0xe6, 0xab, 0xe5, 0x34, 0x4c, 0x8c, 0x63,
  0x90, 0x75, 0x27, 0x08, 0xf9, 0xd6, 0xf6, 0xf1, 0xf7, 0x67, 0x8a, 0x79, 0xc1, 0x9e, 0x11, 0xf9,
  0x67, 0x99, 0xd9, 0x2b, 0x5e, 0x90, 0xa7, 0xfe, 0x0a, 0x9a, 0x20, 0x2c, 0x8b, 0x91, 0xd4, 0xa1,
  0x4d, 0x6c, 0x31, 0x3f, 0x68, 0x40, 0xc0, 0x08, 0x35, 0x57, 0xcb, 0xb4, 0x32, 0xdb, 0xd8, 0xa2,
  0x1e, 0x90, 0x21, 0xa1, 0x54, 0xd9, 0x0f, 0x3e, 0x68, 0x50, 0xb0, 0xfc, 0x70, 0xea, 0x5f, 0x9d,
  0x4f, 0x80, 0x14, 0x8b, 0xe6, 0xfd, 0x70, 0x68, 0xe0, 0x6b, 0xd9, 0x34, 0xfc, 0xe1, 0x98, 0x37,
  0x50, 0x8d, 0xcc, 0xf3, 0x93, 0x1f, 0x2f, 0xfd, 0xa8, 0x29, 0x5b, 0xe5, 0x6b, 0x47, 0x69, 0x32,
  0x09, 0xb2, 0xac, 0xf8, 0xc6, 0x31, 0x7e, 0xd7, 0xe0, 0xc9, 0x84, 0x3b, 0xac, 0xe7, 0x44, 0x9b,
  0x8e, 0x52, 0x8d, 0x2c, 0xf7, 0xcb, 0x9b, 0x23, 0x83, 0x95, 0x3d, 0xbe, 0x8d, 0x27, 0x58, 0x2a,
  0x43, 0x57, 0x6f, 0xb4, 0x37, 0x8a, 0x67, 0x75, 0xf0, 0x9e, 0xdc, 0x25, 0x2b, 0x3e, 0x6d, 0x25,
  0x23, 0xc3, 0xf0, 0xe0, 0x02, 0x56, 0x23, 0x9a, 0xd9, 0x3c, 0x93, 0x23, 0x1a, 0x74, 0x17, 0x37,
  0x03, 0x1e, 0x15, 0x9a, 0x79, 0x70, 0xba, 0x03, 0x66, 0x69, 0x3f, 0x4f, 0xfd, 0xdb, 0x41, 0x61,
  0x26, 0xdc, 0x2d, 0x52, 0x49, 0x66, 0xe7, 0x96, 0x89, 0x3a, 0x22, 0x08, 0x20, 0x37, 0x23, 0x01,
  0x83, 0x35, 0xa7, 0x18, 0x00, 0xd0, 0x6d, 0x7d, 0x42, 0x69, 0x26, 0xf6, 0x85, 0x3d, 0xb9, 0x0e,
  0x67, 0x61, 0x3b, 0xa3, 0xf4, 0x96, 0xf9, 0x07, 0x83, 0x30, 0x40, 0x28, 0x2d, 0x85, 0x21, 0x72,
  0x4c, 0x63, 0xfa, 0x7a, 0x6e, 0x9b, 0xa2, 0x5f, 0xc5, 0x88, 0x2c, 0xd0, 0xd6, 0x45, 0x77, 0xbb,
  0x54, 0xbb, 0x57, 0x7b, 0x49, 0xe9, 0xb6, 0x5d, 0x19, 0xc2, 0xb7, 0x59, 0x8e, 0x66, 0x45, 0xd0,
  0x22, 0xb9, 0xd3, 0xb8, 0x89, 0xc0, 0x10, 0xe5, 0x5c, 0xef, 0x52, 0xd8, 0xeb, 0x32, 0xa3, 0x83,
  0x96, 0xa2, 0x04, 0x4d, 0xd4, 0x9c, 0x03, 0xcd, 0x16, 0x82, 0x2e, 0xff, 0xe3, 0x06, 0x55, 0x6b,
  0xd8, 0x4f, 0xaf, 0x0e, 0x0d, 0x7f, 0x3a, 0x4d, 0x29, 0x10, 0x70, 0xd0, 0x9e, 0xfb, 0x93, 0xca,
  0x90, 0xe0, 0x31, 0x5c, 0x76, 0x9b, 0xc1, 0xb6, 0x82, 0x39, 0x66, 0x59, 0x7b, 0xd9, 0x32, 0x3b,
  0x38, 0x9a, 0xf0, 0x98, 0x03, 0x83, 0xbb, 0x7c, 0x8d, 0x83, 0xab, 0xb0, 0x3e, 0xbc, 0xc4, 0xc1,
  0x32, 0x76, 0x58, 0x26, 0x9b, 0xa0, 0xc0, 0x2b, 0x15, 0xbf, 0x8d, 0xaf, 0xc2, 0x34, 0x89, 0xe7,
  0x34, 0x68, 0x40, 0xb0, 0xe9, 0xe4, 0x82, 0x8c, 0x77, 0xe8, 0xb5, 0x95, 0x06, 0xf0, 0x48, 0x73,
  0x16, 0x5d, 0x87, 0x0b, 0x74, 0xed, 0xe3, 0xe3, 0xf4, 0x20, 0x5f, 0xc8, 0xd4, 0xc5, 0xf7, 0x19,
  0xb7, 0x03, 0x03, 0xf7, 0x03, 0x50, 0x13, 0x1d, 0x6c, 0xab, 0xb6, 0x10, 0xb4, 0xbc, 0x68, 0xa2,
  0xe2, 0x59, 0x2d, 0x4b, 0xd9, 0x49, 0x76, 0x8b, 0x7d, 0xc8, 0xee, 0x68, 0x9b, 0x41, 0xd7, 0x16,
  0x55, 0x2a, 0x13, 0x1d, 0x04, 0xbc, 0x92, 0x98, 0xbf, 0x2c, 0x16, 0xef, 0x1c, 0xb2, 0xf1, 0x9a,
  0x46, 0xca, 0xda, 0xbf, 0xa1, 0x02, 0x06, 0x5a, 0xdd, 0xaa, 0x9f, 0x56, 0xca, 0x34, 0x7e, 0x5d,
  0x65, 0x10, 0xf9, 0x02, 0x48, 0xad, 0x3c, 0x00, 0x47, 0xc7, 0x9f, 0x5e, 0xfd, 0x04, 0x75, 0xf3,
  0xd7, 0x9d, 0xae, 0xdb, 0x7b, 0xf6, 0x50, 0x45, 0x8b, 0x0c, 0x2b, 0xe2, 0x25, 0x76, 0xf9, 0xef,
  0x61, 0xf7, 0xf9, 0xde, 0x8b, 0xbd, 0xd2, 0x98, 0x89, 0xda, 0xad, 0x52, 0x66, 0xbb, 0xf1, 0x3b,
  0xb5, 0xe5, 0x4b, 0xa5, 0x21, 0x6f, 0xb5, 0x49, 0x38, 0x46, 0xe5, 0x66, 0xf1, 0xb4, 0x72, 0xd3,
  0x70, 0x5c, 0xa9, 0x66, 0x75, 0x60, 0xcb, 0x85, 0x36, 0x68, 0x62, 0xb9, 0x9e, 0x9a, 0x5a, 0x4a,
  0x4d, 0xfd, 0xa6, 0x85, 0x7c, 0x1c, 0xf8, 0x3f, 0x60, 0x0c, 0x99, 0xea, 0x62, 0x16, 0x6f, 0x2a,
  0x0b, 0x1a, 0x87, 0x26, 0xd8, 0xeb, 0xcd, 0x81, 0x6b, 0x47, 0xb2, 0xff, 0x45, 0x92, 0x43, 0x8f,
  0xb8, 0xa4, 0xd0, 0x36, 0x8e, 0x7f, 0x61, 0x2f, 0x33, 0x1d, 0xb6, 0xd2, 0xe0, 0x4d, 0xb6, 0x08,
  0x82, 0x29, 0xbc, 0xf9, 0xe9, 0xe2, 0xf7, 0xd2, 0x78, 0xc3, 0xcb, 0x19, 0xec, 0xcc, 0x17, 0xc5,
  0xa0, 0xbe, 0xc3, 0x9f, 0xa2, 0x20, 0xbd, 0x6b, 0x99, 0x3f, 0xbd, 0x46, 0x54, 0x92, 0x40, 0x4b,
  0xc5, 0x04, 0xe5, 0x27, 0x1a, 0x62, 0x9c, 0xe2, 0x27, 0x7d, 0xd1, 0x29, 0x7f, 0x71, 0x3d, 0xb3,
  0x07, 0x81, 0x9b, 0x64, 0x05, 0x2e, 0x72, 0x57, 0x05, 0xed, 0xcb, 0x2b, 0x5d, 0xca, 0xae, 0x8a,
  0x98, 0xc7, 0xc1, 0x39, 0x1d, 0xf1, 0xa9, 0x62, 0x26, 0x69, 0x69, 0xb1, 0x27, 0x5c, 0x41, 0x07,
  0xea, 0x35, 0x1e, 0xfd, 0xee, 0x0e, 0xbb, 0xb2, 0x33, 0x28, 0xbc, 0x6b, 0xdc, 0x41, 0x76, 0x60,
  0xa1, 0xc8, 0x7d, 0xce, 0x60, 0x2b, 0xb9, 0xe4, 0x9c, 0xa1, 0xe4, 0x2c, 0xaa, 0x69, 0xb5, 0xa4,
  0xc4, 0x09, 0x49, 0x27, 0xd9, 0x29, 0x7d, 0xcf, 0x57, 0xb4, 0x42, 0x04, 0x36, 0x1a, 0xf0, 0x2b,
  0x4f, 0x27, 0xfe, 0xa9, 0x17, 0xb5, 0x93, 0x18, 0x84, 0x52, 0x4f, 0xfd, 0x3a, 0x69, 0x05, 0x4a,
  0x63, 0xfc, 0x16, 0xd0, 0xa9, 0x3f, 0xc4, 0x16, 0xe1, 0x2b, 0x6c, 0x98, 0xaf, 0xa8, 0x76, 0x79,
  0x98, 0x23, 0xa5, 0xbd, 0xbb, 0x79, 0x72, 0x17, 0xb5, 0x67, 0x37, 0xab, 0xbe, 0x81, 0x0f, 0x24,
  0x0a, 0xae, 0x76, 0xd9, 0x63, 0xb2, 0x58, 0x19, 0x16, 0x3e, 0xce, 0xc3, 0x15, 0xbd, 0x4d, 0x83,
  0x2b, 0xf9, 0xd0, 0x7b, 0xc3, 0x1f, 0x93, 0x1c, 0x1e, 0x6d, 0x53, 0x51, 0x8b, 0x20, 0xdd, 0xc7,
  0x3b, 0x6c, 0x73, 0x10, 0x4e, 0xe0, 0xe7, 0xc8, 0x14, 0xd7, 0xa7, 0x98, 0x16, 0x26, 0x36, 0x18,
  0x98, 0x2d, 0xb2, 0x08, 0x88, 0x92, 0x74, 0x04, 0x60, 0x64, 0x93, 0x8b, 0xcb, 0x48, 0xc9, 0x63,
  0x70, 0xf1, 0x52, 0x49, 0x38, 0xa0, 0xe3, 0x61, 0x83, 0x9d, 0x2b, 0x53, 0xa9, 0x71, 0x72, 0xa3,
  0x68, 0x62, 0xfe, 0x0a, 0x3e, 0x48, 0xaa, 0x1d, 0x83, 0x7a, 0xc4, 0xef, 0x43, 0xf7, 0x2d, 0x7c,
  0x03, 0x0d, 0xa5, 0xce, 0xc1, 0x22, 0x60, 0x45, 0x79, 0xab, 0xd4, 0x0f, 0x1e, 0xe0, 0x82, 0xd4,
  0x5a, 0x35, 0xf7, 0x53, 0xd6, 0x32, 0x5c, 0x56, 0xf8, 0x56, 0xe9, 0x43, 0x87, 0x3a, 0x21, 0x14,
  0xbe, 0x06, 0xc5, 0x34, 0xfd, 0x5d, 0x6b, 0x1f, 0xfd, 0x2e, 0x54, 0x4f, 0xc2, 0xf7, 0xab, 0x80,
  0xd3, 0xe7, 0xe7, 0x11, 0x6e, 0x14, 0xbf, 0x07, 0xac, 0xe1, 0x03, 0x53, 0x70, 0x07, 0x81, 0x44,
  0x47, 0x33, 0x97, 0xfe, 0x2e, 0x00, 0xfb, 0x85, 0xf3, 0xef, 0x8a, 0x54, 0x57, 0x74, 0x4c, 0x8a,
  0x08, 0xa7, 0x92, 0xfd, 0x85, 0x2f, 0x7b, 0x9e, 0x0f, 0xca, 0xf0, 0xb3, 0x2e, 0x7a, 0x13, 0xc3,
  0x2a, 0xdb, 0x37, 0x57, 0xaa, 0x6e, 0x5b, 0xd1, 0x6e, 0x49, 0xb5, 0xd7, 0xc6, 0xa5, 0xf4, 0x3e,
  0xbf, 0xc9, 0x35, 0xc5, 0x1f, 0x07, 0xf9, 0xed, 0x0d, 0x1f, 0xe6, 0x21, 0xb6, 0x2e, 0x1e, 0xc1,
  0x7f, 0x7d, 0x93, 0xaf, 0x29, 0x58, 0xfc, 0xbe, 0xae, 0xc7, 0xd7, 0xea, 0xf2, 0xd3, 0x30, 0x67,
  0xa3, 0xa6, 0xa8, 0xf2, 0x3e, 0x53, 0xe3, 0xe9, 0x87, 0xae, 0xcb, 0xe3, 0xd7, 0x62, 0x2c, 0xa3,
  0x34, 0x05, 0x46, 0x0e, 0x3e, 0x19, 0x8b, 0x96, 0xa0, 0x22, 0xdf, 0x9b, 0x3c, 0x2f, 0x75, 0x56,
  0x6f, 0xc7, 0x66, 0x16, 0x05, 0xbf, 0xc1, 0x9a, 0xe0, 0xd7, 0x5a, 0x12, 0xfc, 0x06, 0x2b, 0x42,
  0x8d, 0x1d, 0x61, 0xf3, 0xbe, 0xea, 0x33, 0xa2, 0xae, 0x04, 0xe4, 0x9f, 0x72, 0x19, 0x2e, 0x60,
  0x72, 0x80, 0x5e, 0xe0, 0x9f, 0x38, 0xa1, 0xeb, 0x8c, 0x5a, 0x25, 0x90, 0xcf, 0x5f, 0xa2, 0xfb,
  0xd5, 0x7c, 0x81, 0x46, 0x30, 0xcf, 0x4c, 0x66, 0x33, 0x50, 0x42, 0xfd, 0x1b, 0xc6, 0x9e, 0xbc,
  0xbd, 0x1e, 0x0b, 0xc4, 0x8b, 0xa6, 0x1f, 0x39, 0x8b, 0xd8, 0x10, 0x3a, 0x04, 0xbe, 0x48, 0x22,
  0x44, 0x00, 0x04, 0xd1, 0x0c, 0x1d, 0xad, 0x90, 0x4c, 0xda, 0xed, 0x36, 0x0e, 0xc0, 0x2c, 0x99,
  0x2c, 0xe1, 0xdb, 0xf4, 0xe7, 0xe7, 0xd8, 0xda, 0xc1, 0x57, 0x3b, 0x36, 0xbe, 0x19, 0x47, 0xcb,
  0x54, 0xbc, 0x98, 0xcd, 0xe4, 0x9b, 0x4e, 0x23, 0x79, 0x8d, 0x33, 0x73, 0x2d, 0x91, 0xb0, 0xe9,
  0x01, 0xdd, 0x1c, 0x8f, 0xe1, 0x24, 0x63, 0x1c, 0x99, 0xfe, 0x24, 0xaf, 0x8e, 0x19, 0x64, 0xd3,
  0x2d, 0x54, 0x40, 0x1d, 0x47, 0xd7, 0xa9, 0x3a, 0x45, 0xee, 0x8b, 0x99, 0x3e, 0x45, 0xa5, 0xf6,
  0x90, 0xa7, 0xcf, 0x75, 0x0a, 0x12, 0x58, 0x08, 0x1a, 0xc4, 0xb5, 0xde, 0x3a, 0x39, 0x11, 0xca,
  0x37, 0xc7, 0x69, 0x28, 0x27, 0x43, 0x4e, 0x81, 0xca, 0x92, 0xb0, 0x11, 0x78, 0x51, 0x83, 0x73,
  0xa5, 0x24, 0xa6, 0x2a, 0x3c, 0x93, 0xfb, 0x5b, 0xa4, 0x7e, 0xc8, 0x82, 0x07, 0xd8, 0x34, 0x31,
  0x9e, 0xd9, 0xdb, 0xdf, 0xa7, 0x63, 0x67, 0xcf, 0xec, 0x9a, 0x86, 0xea, 0x53, 0xa3, 0x4e, 0x15,
  0x7c, 0x15, 0xba, 0xde, 0x29, 0x35, 0xae, 0xd2, 0x11, 0xce, 0x41, 0x74, 0x63, 0x55, 0xdd, 0xb2,
  0xa8, 0x4b, 0x68, 0xd4, 0xc6, 0x8b, 0x1c, 0xa9, 0x9e, 0x80, 0x49, 0x53, 0x85, 0xde, 0xf1, 0x88,
  0xf9, 0x18, 0x77, 0x1a, 0x03, 0x76, 0x71, 0x92, 0x53, 0x1e, 0xcc, 0xfe, 0xa4, 0xf0, 0xd2, 0x67,
  0xd7, 0x2f, 0x47, 0xe6, 0x07, 0xa6, 0xc5, 0x01, 0x7b, 0x81, 0x9d, 0x0a, 0x6b, 0x32, 0x57, 0x9b,
  0xd5, 0x05, 0x14, 0x08, 0xc3, 0x5f, 0xcd, 0xab, 0x6a, 0x3f, 0x8f, 0xe8, 0x09, 0x9f, 0x7b, 0x7d,
  0xae, 0x0d, 0x64, 0x90, 0xfa, 0x9e, 0x24, 0x66, 0x2d, 0x5e, 0xce, 0xc7, 0x41, 0xca, 0xe7, 0xd2,
  0xe5, 0xb3, 0x0b, 0x93, 0xc7, 0x2f, 0x04, 0xef, 0x76, 0x57, 0xda, 0x94, 0xb2, 0x2d, 0xb9, 0x42,
  0x20, 0xd0, 0xfb, 0x82, 0x74, 0x2e, 0x83, 0x5b, 0x0c, 0x33, 0x42, 0xdf, 0xa2, 0x55, 0x59, 0xbc,
  0x2a, 0xad, 0x49, 0x99, 0x5e, 0x5a, 0x91, 0x7c, 0x29, 0x6c, 0x36, 0x80, 0x1b, 0xf6, 0x38, 0xd8,
  0xb4, 0xc7, 0x56, 0x79, 0x6e, 0x79, 0xaf, 0xfb, 0xae, 0x5d, 0x1e, 0x8b, 0x64, 0xf1, 0x40, 0xee,
  0xff, 0x7c, 0xc3, 0x94, 0xcc, 0xca, 0xe3, 0xa4, 0xf4, 0x38, 0x99, 0x3d, 0xd0, 0xa7, 0x6f, 0x6d,
  0x78, 0x99, 0xe8, 0x85, 0x04, 0xfd, 0xd7, 0x5f, 0xf1, 0x3f, 0x80, 0x9e, 0xb2, 0x08, 0xe3, 0xf3,
  0xcd, 0x06, 0xef, 0x18, 0xbd, 0x12, 0x37, 0xcd, 0xfc, 0x0a, 0x1d, 0x6c, 0xff, 0xa3, 0x17, 0xf4,
  0x79, 0xba, 0xa8, 0x25, 0xf0, 0xae, 0xca, 0xb0, 0x95, 0xa9, 0x84, 0xfc, 0xff, 0x29, 0xe9, 0x33,
  0x5b, 0x4c, 0xd6, 0x2e, 0xe4, 0x72, 0x3f, 0x21, 0xff, 0x3f, 0x5a, 0x3f, 0x6b, 0x85, 0x87, 0x49,
  0x3c, 0x93, 0xfd, 0x9c, 0x94, 0x64, 0x38, 0xb6, 0x3d, 0xeb, 0x32, 0x9c, 0x4b, 0x02, 0xc2, 0xd7,
  0xad, 0x20, 0x65, 0x07, 0xbe, 0xd0, 0x06, 0x37, 0x62, 0xaa, 0x7a, 0x79, 0x8f, 0xad, 0x51, 0x8c,
  0x40, 0x3d, 0xa8, 0xa8, 0x46, 0x86, 0xf1, 0x09, 0x9d, 0x32, 0xb2, 0xc0, 0x98, 0x8a, 0xfb, 0xec,
  0xc6, 0x6f, 0x75, 0x82, 0xc9, 0x1a, 0x5d, 0x09, 0xea, 0x2d, 0x09, 0x26, 0x50, 0xa7, 0xaa, 0x2b,
  0x41, 0x86, 0x66, 0x5d, 0xe9, 0x91, 0xda, 0x52, 0x59, 0x5f, 0xfa, 0xe6, 0xde, 0xfe, 0xe9, 0xf1,
  0xbd, 0xed, 0xbd, 0x29, 0xf5, 0x97, 0xd2, 0x4a, 0x3d, 0xee, 0xbd, 0xf9, 0x87, 0xe9, 0x73, 0xc2,
  0xb0, 0xd3, 0x1e, 0xdb, 0x51, 0xd4, 0xcb, 0xcb, 0x13, 0x8b, 0x69, 0x5a, 0x47, 0x31, 0xe1, 0x1f,
  0xa5, 0xa3, 0x3f, 0x85, 0x78, 0x20, 0x68, 0x04, 0x04, 0xc7, 0xf2, 0xc8, 0xde, 0xce, 0xc3, 0x52,
  0x57, 0x7f, 0x0a, 0xd5, 0x7e, 0xce, 0xc3, 0xbf, 0x71, 0x27, 0x95, 0xf5, 0x3d, 0x0d, 0xca, 0x1d,
  0x6b, 0x70, 0xc6, 0x88, 0x93, 0x5d, 0x06, 0x15, 0x2f, 0x7b, 0x92, 0x32, 0x2e, 0xc4, 0x4d, 0x33,
  0x9f, 0x82, 0x45, 0xe0, 0xe7, 0x06, 0x1e, 0x30, 0x44, 0x68, 0xe8, 0x52, 0xd8, 0x53, 0xba, 0x50,
  0xd9, 0x53, 0x99, 0xbf, 0x15, 0x15, 0x33, 0xd5, 0xb7, 0x37, 0xe5, 0x9c, 0x8b, 0x3b, 0x70, 0x7c,
  0x5d, 0xe3, 0xa6, 0x5a, 0xe3, 0xde, 0x90, 0xf7, 0x84, 0xd2, 0xa4, 0xa9, 0x6a, 0x63, 0x79, 0xa8,
  0x49, 0xee, 0xde, 0xf7, 0x8d, 0x4d, 0xe2, 0x5e, 0x08, 0x4e, 0xf7, 0xc5, 0xf7, 0x9e, 0x87, 0xa6,
  0xa9, 0x51, 0x5e, 0x75, 0x68, 0x81, 0x26, 0xaa, 0xfa, 0x3e, 0x79, 0xb6, 0x1f, 0xbe, 0x7d, 0x3b,
  0x0d, 0x11, 0x01, 0x72, 0x47, 0x51, 0x5a, 0x05, 0x2a, 0xff, 0x6a, 0x07, 0x6f, 0xa8, 0x53, 0xdb,
  0x5e, 0x7d, 0xfa, 0xfc, 0x7e, 0xf7, 0xdd, 0x6f, 0x06, 0xcb, 0x2d, 0x9b, 0x50, 0xb8, 0x7f, 0x35,
  0x69, 0x3e, 0xda, 0x79, 0x7e, 0x3f, 0x97, 0xbe, 0x5d, 0x0d, 0x59, 0xcc, 0x1a, 0xbf, 0x16, 0xdc,
  0x6a, 0xaa, 0x47, 0xfd, 0xaa, 0xdd, 0x6e, 0xe8, 0x31, 0xfc, 0x9f, 0x91, 0x55, 0x5b, 0x7a, 0x09,
  0xc4, 0xa0, 0x95, 0xde, 0xd1, 0xa8, 0xf7, 0xc2, 0x1c, 0xfe, 0xe4, 0xdf, 0x84, 0xf3, 0xe5, 0xdc,
  0x60, 0x7b, 0x35, 0x3a, 0x06, 0x65, 0xdc, 0xa4, 0x09, 0xeb, 0xce, 0x07, 0xf2, 0x9e, 0xb6, 0x39,
  0x4d, 0xef, 0xa8, 0xb8, 0x4f, 0xae, 0xdd, 0x97, 0xbf, 0x10, 0x23, 0x58, 0xb9, 0x35, 0xa3, 0xa2,
  0x43, 0x15, 0x77, 0x1c, 0x7c, 0xcf, 0x1d, 0xf8, 0x07, 0x1e, 0xce, 0xfa, 0xc0, 0x47, 0x73, 0x66,
  0xb1, 0xd1, 0xfb, 0xf2, 0xd6, 0x00, 0x69, 0xb1, 0x55, 0x2f, 0xdb, 0x42, 0x47, 0x3e, 0xb3, 0x6d,
  0xee, 0x03, 0x53, 0xdb, 0xdd, 0xd4, 0x6c, 0xf9, 0xec, 0xca, 0x55, 0xc0, 0x1d, 0xf4, 0xb9, 0xea,
  0xca, 0xfd, 0xf6, 0xed, 0x95, 0x30, 0xa2, 0x1e, 0xf4, 0x6a, 0x3d, 0xe7, 0x90, 0x70, 0xcd, 0x16,
  0x36, 0xd2, 0xae, 0xaf, 0xc0, 0xd9, 0x52, 0xbb, 0x5d, 0x56, 0x2d, 0xa4, 0x09, 0xb6, 0xa1, 0x0f,
  0x58, 0xf1, 0x2a, 0x13, 0x0e, 0xc9, 0x36, 0xa8, 0x20, 0xad, 0x8d, 0x8a, 0x04, 0xb2, 0xc8, 0x81,
  0xd0, 0x82, 0x9a, 0x9a, 0x9f, 0x36, 0x34, 0x9f, 0x1b, 0xfd, 0xea, 0x2e, 0xf7, 0xa4, 0x19, 0xae,
  0x8f, 0x72, 0x09, 0x31, 0x52, 0xc3, 0x6e, 0xc5, 0x62, 0x58, 0xb1, 0x82, 0x33, 0x4c, 0x2c, 0xc5,
  0x08, 0xce, 0xfc, 0x4f, 0x91, 0x15, 0x30, 0xfe, 0x9c, 0x05, 0x78, 0x12, 0x87, 0x11, 0x15, 0xa5,
  0xb0, 0x95, 0xfb, 0xb7, 0xa0, 0x9e, 0x49, 0xb1, 0xb2, 0xc6, 0x28, 0xc5, 0x0a, 0x95, 0xac, 0x48,
  0xc7, 0x3c, 0x51, 0x0a, 0x8c, 0x2c, 0x97, 0xb0, 0x7d, 0x70, 0x5b, 0x46, 0x99, 0xa1, 0xb0, 0x4c,
  0x24, 0xc8, 0x71, 0x96, 0xe2, 0x77, 0x19, 0x4b, 0xa9, 0xcf, 0x38, 0x41, 0x88, 0xda, 0x88, 0xe5,
  0x57, 0xbc, 0x38, 0x29, 0xf5, 0x58, 0xfd, 0x20, 0x13, 0xf6, 0xb8, 0x35, 0x88, 0x2d, 0xe6, 0x1d,
  0x74, 0x26, 0xbe, 0x08, 0x67, 0x68, 0x94, 0x45, 0xea, 0x67, 0x57, 0x70, 0xdd, 0x41, 0x7e, 0x20,
  0xb0, 0x77, 0x07, 0x39, 0x2c, 0x00, 0xc2, 0xf3, 0xbe, 0x0b, 0xa7, 0x7d, 0x49, 0x01, 0xb9, 0xdd,
  0xea, 0x3a, 0x68, 0xea, 0x22, 0xac, 0xef, 0x15, 0x56, 0x43, 0x1e, 0x64, 0x40, 0x60, 0x7e, 0x1a,
  0xa0, 0x57, 0xc5, 0x32, 0x66, 0x15, 0x63, 0x31, 0x97, 0x65, 0x35, 0x8f, 0xf1, 0x8e, 0xdd, 0xbf,
  0x0c, 0xb6, 0x06, 0x78, 0x89, 0x85, 0xa2, 0xd4, 0x64, 0x39, 0xb4, 0xf6, 0xd6, 0x5c, 0x15, 0x9f,
  0x67, 0x77, 0x75, 0x03, 0xf5, 0xa6, 0x2e, 0x3a, 0x8d, 0x9c, 0x44, 0xa7, 0x6d, 0xb2, 0xc7, 0x89,
  0x08, 0x5f, 0xb0, 0x89, 0x10, 0xd0, 0xe9, 0xd4, 0xb4, 0x0f, 0x5c, 0x01, 0x51, 0x57, 0x93, 0xed,
  0x5f, 0xd0, 0xe5, 0x19, 0x4f, 0x3a, 0xe2, 0xa1, 0x3b, 0xca, 0x94, 0x1c, 0x2c, 0x78, 0xae, 0x15,
  0x03, 0x77, 0xf0, 0x5e, 0xbe, 0x7c, 0x89, 0xe7, 0x07, 0xe7, 0x78, 0x93, 0x0a, 0x57, 0x7a, 0x98,
  0x91, 0x1f, 0xd1, 0x8f, 0xf9, 0x3c, 0x42, 0x50, 0x2f, 0xd3, 0xa1, 0x62, 0xe1, 0xd4, 0xa9, 0x14,
  0xa7, 0xa0, 0x87, 0xb8, 0x2d, 0xff, 0x86, 0x37, 0x47, 0xd8, 0x7b, 0xea, 0x9b, 0x93, 0xd9, 0x2b,
  0x06, 0x07, 0xb6, 0xfe, 0x54, 0xe6, 0x88, 0x43, 0x93, 0x91, 0xb7, 0xdf, 0x7f, 0xe4, 0x64, 0xbc,
  0x11, 0x51, 0x5d, 0x2a, 0x53, 0xa1, 0xae, 0x0b, 0x8d, 0xbe, 0x71, 0x51, 0xfc, 0x2d, 0x16, 0xc1,
  0xdf, 0x77, 0x09, 0x88, 0xb1, 0x66, 0x90, 0xfd, 0x81, 0x0a, 0xd9, 0xdf, 0x48, 0x13, 0x1c, 0x50,
  0x0e, 0x27, 0x3c, 0xe6, 0x84, 0x11, 0x33, 0xc2, 0x20, 0x62, 0x38, 0x12, 0xaf, 0x35, 0x67, 0xc3,
  0x08, 0x6a, 0x58, 0x90, 0x52, 0xc2, 0x8f, 0x3b, 0x9e, 0xdc, 0x41, 0xed, 0x90, 0xf7, 0x08, 0x12,
  0x0f, 0x33, 0x20, 0x01, 0x56, 0x99, 0x2d, 0x7d, 0xed, 0xce, 0x58, 0xbd, 0x54, 0xde, 0x1e, 0x70,
  0xe8, 0xb8, 0x7a, 0x7a, 0x4a, 0xf1, 0x28, 0xf6, 0x9a, 0x57, 0x66, 0x09, 0xe7, 0xb5, 0x9a, 0xbb,
  0x8b, 0xe6, 0x77, 0xbc, 0x1e, 0xa3, 0x8d, 0x0d, 0x32, 0xd7, 0x12, 0xdb, 0x1d, 0x1b, 0x18, 0xa4,
  0xab, 0x36, 0xfa, 0xc1, 0x43, 0xdf, 0x28, 0x88, 0x14, 0x4b, 0xd1, 0xe1, 0xa9, 0xcd, 0xb6, 0xec,
  0xa0, 0x3d, 0xc0, 0x2d, 0x27, 0x63, 0x6c, 0xda, 0xd3, 0x3b, 0x89, 0x18, 0x98, 0xea, 0xb5, 0x1b,
  0x6d, 0x00, 0xc8, 0xa5, 0x54, 0x45, 0xeb, 0x2b, 0x6e, 0x5c, 0x15, 0x69, 0x08, 0x2e, 0x44, 0xe8,
  0xab, 0xe2, 0xae, 0x87, 0x38, 0x36, 0x32, 0x88, 0xe7, 0x0f, 0xba, 0x14, 0x45, 0x9a, 0xa3, 0x52,
  0x13, 0x72, 0xa7, 0x97, 0xa3, 0xe7, 0x58, 0x29, 0xd2, 0x20, 0xfa, 0x91, 0xf1, 0xf7, 0xe8, 0x4b,
  0x08, 0xca, 0xbe, 0x2d, 0xee, 0xe9, 0x71, 0xb7, 0x57, 0x36, 0x86, 0xee, 0x20, 0x28, 0x02, 0x39,
  0x04, 0x38, 0x28, 0x0c, 0x8a, 0x30, 0xf3, 0xf0, 0x3a, 0x23, 0xed, 0xf1, 0x91, 0xe3, 0x3b, 0x89,
  0x13, 0x22, 0x4e, 0x1a, 0x34, 0x4c, 0xff, 0x4e, 0x66, 0xdb, 0xa1, 0x87, 0x48, 0xaf, 0x18, 0xed,
  0xfe, 0x29, 0xba, 0x0b, 0x46, 0x1e, 0x82, 0x61, 0x3b, 0x3e, 0xfc, 0xe9, 0x21, 0xb2, 0x40, 0x76,
  0xb2, 0x77, 0x3a, 0x20, 0xf7, 0x41, 0x28, 0x6c, 0xa6, 0xa6, 0xe7, 0x65, 0x76, 0x84, 0xed, 0x79,
  0xaa, 0x85, 0xff, 0x86, 0x02, 0xd5, 0xb4, 0xa4, 0x9a, 0x26, 0xab, 0xe2, 0x81, 0x27, 0xa5, 0x1f,
  0x63, 0xf7, 0x74, 0xb7, 0x3b, 0x88, 0x3c, 0x1e, 0x4c, 0x28, 0x20, 0x5c, 0x03, 0x5f, 0xf9, 0xd9,
  0xc5, 0xc6, 0x14, 0x3f, 0x7b, 0xa7, 0xab, 0x2d, 0x8c, 0x56, 0x13, 0x32, 0xf7, 0xb8, 0x8e, 0x18,
  0x83, 0xa7, 0x04, 0xdb, 0xca, 0xe2, 0x22, 0x58, 0x67, 0x88, 0x4d, 0x05, 0x5b, 0xff, 0xca, 0x41,
  0xb1, 0xc7, 0x41, 0x17, 0x29, 0x1b, 0x9d, 0x5c, 0x56, 0x7f, 0x38, 0x13, 0x50, 0xa7, 0x67, 0x4a,
  0xf0, 0x16, 0xa3, 0x0c, 0xbe, 0x24, 0x02, 0xb4, 0x38, 0x78, 0xaa, 0xf7, 0xef, 0x49, 0x18, 0xa3,
  0x6f, 0xfb, 0xe0, 0x4c, 0xa7, 0x90, 0xea, 0x02, 0xa4, 0x8b, 0x65, 0x0e, 0x46, 0x55, 0x02, 0xa6,
  0xeb, 0xe3, 0x3f, 0x89, 0x76, 0xcd, 0x4c, 0x6c, 0xe9, 0xe8, 0xa9, 0x8b, 0x57, 0xc8, 0x4c, 0x75,
  0x0d, 0x92, 0x1a, 0x30, 0xbb, 0xc1, 0x7f, 0x99, 0xe4, 0x8f, 0x94, 0xbd, 0xcb, 0xb2, 0x33, 0x7b,
  0xf4, 0x21, 0xe3, 0x20, 0x4f, 0xee, 0xb2, 0x95, 0x85, 0x69, 0x8e, 0xb1, 0x83, 0x97, 0xd0, 0x76,
  0xe8, 0x6f, 0xb2, 0xda, 0xb1, 0x1b, 0x8f, 0x7a, 0xb1, 0x5f, 0x09, 0x54, 0x5e, 0xd1, 0x02, 0x35,
  0xb6, 0x49, 0xb9, 0x14, 0xd3, 0x12, 0x7e, 0x15, 0x99, 0x07, 0x6b, 0xb0, 0xd9, 0x78, 0x64, 0x4b,
  0xe5, 0x50, 0x85, 0x7b, 0xe8, 0xb4, 0xb6, 0x5c, 0x10, 0xbb, 0x5d, 0x39, 0xf5, 0xc4, 0x2e, 0x29,
  0xe5, 0xf5, 0xfa, 0x70, 0x4e, 0x85, 0x67, 0x16, 0xe3, 0x45, 0xc5, 0x94, 0x8c, 0xb1, 0x17, 0x74,
  0xe1, 0x80, 0x85, 0x06, 0xe7, 0x51, 0xc1, 0x8d, 0xbd, 0x5e, 0x9f, 0xaf, 0xc8, 0xb7, 0xc7, 0x47,
  0x7b, 0x3d, 0x93, 0xe2, 0x6f, 0x1b, 0x2f, 0xd4, 0xd4, 0x17, 0xbd, 0xe7, 0xcf, 0x4d, 0x4e, 0x18,
  0xe6, 0x48, 0x91, 0xcf, 0xc6, 0xb1, 0x76, 0x73, 0xca, 0x44, 0x37, 0x08, 0xc4, 0xf3, 0x20, 0xa6,
  0x3a, 0x82, 0x0d, 0x7d, 0xd1, 0x67, 0xcf, 0xd5, 0x2d, 0x94, 0x30, 0x5b, 0xd5, 0x00, 0x23, 0x88,
  0x6b, 0x8a, 0xff, 0xa0, 0x2c, 0x01, 0xeb, 0x20, 0x6f, 0xc7, 0x04, 0xa9, 0x7e, 0xc7, 0x1f, 0xd8,
  0xf6, 0x48, 0x05, 0x10, 0x5e, 0x80, 0xb6, 0x73, 0x72, 0x23, 0x0e, 0x0e, 0xd9, 0x96, 0x89, 0x25,
  0x7c, 0x74, 0x77, 0x2b, 0xa9, 0x04, 0xa2, 0x3c, 0xe7, 0x05, 0xbe, 0x40, 0x11, 0xc1, 0xf8, 0x78,
  0xf4, 0xe6, 0xc4, 0x27, 0xce, 0x94, 0xb0, 0xe2, 0x59, 0xe1, 0xa3, 0x5a, 0xa3, 0xe5, 0x15, 0x9a,
  0xa3, 0x91, 0xfb, 0xea, 0x55, 0x05, 0x09, 0x24, 0xc1, 0xef, 0xac, 0xed, 0xc8, 0x0b, 0x27, 0x09,
  0x8c, 0x02, 0x10, 0x1f, 0xdd, 0x5c, 0x60, 0xe3, 0x95, 0xd8, 0xea, 0xed, 0x85, 0x33, 0x48, 0xa6,
  0xa9, 0x49, 0x58, 0xac, 0xf6, 0x15, 0x5d, 0x75, 0x0a, 0x21, 0xb7, 0xeb, 0x79, 0x09, 0x3a, 0xa1,
  0x8e, 0xcc, 0x8f, 0x9d, 0x57, 0x66, 0x3f, 0xe1, 0x0e, 0xa9, 0x21, 0xfa, 0xc4, 0x83, 0x88, 0xb5,
  0x5a, 0xc1, 0x30, 0x4c, 0x27, 0x07, 0xee, 0x28, 0x06, 0xdd, 0xef, 0x3d, 0x8f, 0x7b, 0x60, 0xe0,
  0x92, 0xc3, 0x9b, 0x48, 0x02, 0x4f, 0xb8, 0x6d, 0xf6, 0xa1, 0xa2, 0x88, 0x21, 0x33, 0x23, 0x92,
  0x42, 0x82, 0x57, 0xa6, 0x64, 0x9c, 0x84, 0xcc, 0x98, 0xe1, 0x22, 0x6f, 0x23, 0x5c, 0x0b, 0x2a,
  0xb6, 0x0d, 0xc6, 0x75, 0x5c, 0x55, 0xf4, 0x47, 0xba, 0xd5, 0x1c, 0x32, 0xd7, 0x41, 0x59, 0x51,
  0x1f, 0xdd, 0x8c, 0x68, 0x08, 0x31, 0xa3, 0xb0, 0x3a, 0xd6, 0x7a, 0xbd, 0xc4, 0x9a, 0xca, 0x18,
  0xeb, 0x17, 0x88, 0x18, 0x61, 0xc8, 0x4b, 0x29, 0x1d, 0xbc, 0xc5, 0xd2, 0xa1, 0x89, 0x12, 0xd7,
  0x79, 0x82, 0xea, 0x75, 0x9e, 0x22, 0x93, 0xbc, 0xcc, 0x13, 0x6c, 0x72, 0x99, 0x47, 0xde, 0xa9,
  0x5b, 0x46, 0x53, 0x03, 0x83, 0x42, 0x60, 0x0b, 0x0c, 0x6c, 0x82, 0x81, 0xbb, 0x2d, 0xbb, 0xd0,
  0x5c, 0x7f, 0xcb, 0x47, 0xa3, 0x63, 0xe1, 0x8b, 0xe3, 0x04, 0x5f, 0x75, 0xcb, 0x67, 0x65, 0x57,
  0xaf, 0xfc, 0x93, 0xae, 0xca, 0xf6, 0x56, 0x1e, 0xa8, 0x44, 0x6c, 0xab, 0x01, 0x06, 0xa9, 0x2d,
  0x03, 0x89, 0xc3, 0x6a, 0xf3, 0x45, 0x12, 0xc6, 0x7d, 0xbb, 0x61, 0x0a, 0x5d, 0x1f, 0x76, 0x1a,
  0x87, 0x40, 0xbb, 0x9f, 0x06, 0x2c, 0xa5, 0x93, 0x0f, 0xac, 0xb8, 0x70, 0xe6, 0x81, 0x9d, 0xfd,
  0x80, 0x2e, 0xc1, 0x22, 0x6e, 0xb7, 0xf0, 0x50, 0xaf, 0xc0, 0xed, 0xbd, 0x64, 0x68, 0x7b, 0x0c,
  0x3d, 0x68, 0x7c, 0x6e, 0x13, 0x1b, 0xfa, 0x83, 0x48, 0x98, 0xec, 0x3e, 0xe3, 0x29, 0xf6, 0x19,
  0x08, 0xb2, 0x2c, 0x62, 0x1e, 0x0e, 0x4c, 0x23, 0x48, 0x81, 0x7e, 0xee, 0x8b, 0x30, 0x32, 0x55,
  0x08, 0xbe, 0x6c, 0x55, 0x1e, 0x13, 0x86, 0x8e, 0x60, 0x29, 0x03, 0xc1, 0x41, 0xb1, 0x9b, 0xbe,
  0x28, 0xd1, 0x6a, 0x92, 0x65, 0x4e, 0x88, 0xd5, 0x78, 0xb3, 0x26, 0x27, 0x88, 0x41, 0xe5, 0x32,
  0x8f, 0x06, 0xad, 0xad, 0x82, 0xb2, 0x29, 0x90, 0x0c, 0x4c, 0xd2, 0xaf, 0x7e, 0xae, 0x24, 0x4d,
  0x89, 0xef, 0xd4, 0xe0, 0x1c, 0x30, 0x98, 0x55, 0xb3, 0x32, 0xd1, 0x68, 0xa1, 0x60, 0xd3, 0xdc,
  0xa0, 0xa1, 0x07, 0xa8, 0xd1, 0x57, 0x2e, 0xb1, 0xaf, 0xcb, 0xcc, 0x7b, 0xe2, 0xc4, 0x1b, 0x64,
  0x2f, 0x54, 0xff, 0xea, 0x49, 0xa6, 0xdb, 0xcf, 0x49, 0x0f, 0xe3, 0x17, 0x6c, 0x6d, 0xba, 0x0a,
  0x10, 0x83, 0xc2, 0x9e, 0x79, 0x78, 0xc7, 0x1d, 0x98, 0x7d, 0x66, 0x62, 0x3c, 0xd7, 0x98, 0xe0,
  0x8a, 0xcc, 0x2e, 0x9d, 0x7a, 0xc3, 0x67, 0x89, 0x5c, 0x1b, 0xbf, 0x78, 0x9e, 0x2e, 0x44, 0x7f,
  0xa2, 0x0d, 0x1a, 0x48, 0xd9, 0x45, 0x8f, 0xfc, 0x4d, 0x06, 0x60, 0x31, 0x91, 0x05, 0x06, 0x9c,
  0xf5, 0x45, 0x5e, 0x57, 0x5c, 0x68, 0x20, 0xb1, 0x6b, 0x12, 0xc0, 0xe2, 0x8a, 0x3b, 0x56, 0xd4,
  0xf2, 0x61, 0xc3, 0xd8, 0x62, 0xb0, 0x4b, 0x09, 0x4a, 0x96, 0xd1, 0xb0, 0x7b, 0x7f, 0xef, 0x0f,
  0x5d, 0x9b, 0x5d, 0x3c, 0x3d, 0x43, 0x97, 0xb3, 0x64, 0x65, 0x5c, 0x85, 0x69, 0xbe, 0xf4, 0x23,
  0x1b, 0x04, 0xa4, 0xc6, 0x0f, 0xc3, 0x90, 0x69, 0xd7, 0xb4, 0x55, 0x02, 0x16, 0x27, 0x48, 0x38,
  0xd3, 0x25, 0x98, 0x5e, 0xb7, 0x9c, 0x6b, 0x36, 0xab, 0xcb, 0xd6, 0x2d, 0x13, 0x0e, 0x5e, 0x50,
  0xa9, 0xb9, 0x75, 0xac, 0x2f, 0x34, 0xba, 0x80, 0x65, 0x2b, 0xb7, 0xe1, 0x31, 0x58, 0x9b, 0x9d,
  0x2b, 0xf4, 0xc9, 0xc2, 0x36, 0x58, 0x85, 0x57, 0x5c, 0x39, 0xf7, 0xba, 0xda, 0xf1, 0x02, 0x9f,
  0xfd, 0x50, 0x75, 0x28, 0xd5, 0xaa, 0xe0, 0xe4, 0x43, 0xa9, 0xfa, 0xd7, 0x5e, 0x78, 0xd7, 0xf2,
  0xae, 0x92, 0x33, 0x7b, 0x10, 0x23, 0x4e, 0xbe, 0xf0, 0x47, 0xd2, 0x5e, 0xf3, 0x8b, 0x3d, 0xb1,
  0xd2, 0x00, 0x7f, 0x3a, 0x55, 0xbf, 0xee, 0x58, 0x1b, 0x7d, 0xe6, 0x4b, 0x34, 0x3e, 0xc3, 0xf8,
  0x45, 0x6b, 0x6a, 0xaa, 0xb0, 0x23, 0x84, 0xdd, 0xac, 0x41, 0xb4, 0x60, 0x3b, 0xfb, 0x11, 0x7a,
  0x01, 0x69, 0xb8, 0x16, 0x08, 0x64, 0x4f, 0x1e, 0x41, 0x88, 0x9d, 0x82, 0xb8, 0x0e, 0x4d, 0x45,
  0x3f, 0x46, 0x5a, 0xb9, 0x38, 0x7a, 0xb5, 0x51, 0x31, 0xba, 0x0e, 0xa1, 0x16, 0x14, 0x68, 0xf8,
  0x5a, 0x69, 0xd6, 0xf4, 0xe3, 0x02, 0x41, 0x1e, 0x35, 0x34, 0xcb, 0x2e, 0xa5, 0xbf, 0xbb, 0xb1,
  0x1e, 0x30, 0x9a, 0x72, 0x16, 0xfe, 0x3a, 0x0d, 0x81, 0x00, 0x36, 0xca, 0x4a, 0xc4, 0xfc, 0x21,
  0xb8, 0x0a, 0xa2, 0x4d, 0x4b, 0x1c, 0xa3, 0xcf, 0xed, 0xe6, 0xd5, 0xe7, 0x41, 0x9c, 0x85, 0xf9,
  0xed, 0xa6, 0x05, 0x0e, 0x97, 0x59, 0x9e, 0xcc, 0xbb, 0x8f, 0xcb, 0xde, 0x7b, 0x5c, 0xf6, 0x3d,
  0xcc, 0x5e, 0xcd, 0x72, 0x8d, 0xae, 0x5b, 0x15, 0x8b, 0xa8, 0x80, 0xa5, 0x2d, 0xa1, 0xa7, 0xd6,
  0x95, 0x1f, 0xfb, 0x51, 0x5d, 0xf1, 0xc3, 0xc3, 0xcf, 0xa5, 0xc2, 0x0a, 0xb8, 0xac, 0x82, 0x6e,
  0x3a, 0xa8, 0x56, 0x79, 0x11, 0xdc, 0x5c, 0x57, 0xaa, 0xc4, 0xf0, 0xb8, 0x37, 0x0f, 0x37, 0x67,
  0xd1, 0xd4, 0x1d, 0x82, 0x12, 0x06, 0x81, 0x80, 0x60, 0xd1, 0x1f, 0xae, 0xe7, 0x72, 0x6d, 0x3d,
  0x5b, 0xac, 0x83, 0x8f, 0xa9, 0x10, 0xf4, 0xdc, 0x07, 0x9a, 0x06, 0x39, 0x1e, 0xae, 0xe6, 0xcb,
  0x24, 0xdb, 0xbd, 0x5e, 0x53, 0x09, 0xa1, 0xf5, 0x6f, 0x30, 0x4c, 0x7e, 0xb4, 0xa6, 0x35, 0xe5,
  0xf2, 0xca, 0x2d, 0x44, 0x1d, 0xdf, 0xcb, 0xaa, 0x88, 0x10, 0x95, 0xd5, 0x7c, 0x27, 0xac, 0x4e,
  0xba, 0x78, 0x72, 0xc6, 0x10, 0xb0, 0x98, 0xd2, 0x2a, 0xac, 0x61, 0xa7, 0x27, 0x52, 0xa3, 0x55,
  0xe2, 0x4a, 0xac, 0xcc, 0x53, 0xd8, 0xcb, 0xf8, 0x21, 0xa5, 0x47, 0x51, 0x06, 0x22, 0xde, 0x19,
  0xaf, 0xbe, 0x72, 0xb3, 0xad, 0x30, 0xdd, 0x22, 0x37, 0x5e, 0x4f, 0x17, 0xcf, 0x6b, 0xb7, 0x09,
  0xa7, 0xa1, 0xcd, 0x64, 0xa0, 0x3a, 0x51, 0xb4, 0xfd, 0x6a, 0x2b, 0x1b, 0x39, 0x76, 0xc3, 0x38,
  0x21, 0x77, 0xe3, 0x3b, 0x27, 0xb7, 0xf6, 0xae, 0x19, 0xa7, 0xd9, 0x4d, 0xdd, 0x10, 0xbd, 0xbb,
  0xa1, 0x6f, 0x0f, 0x28, 0x7a, 0xa0, 0x1c, 0xa5, 0xbe, 0x54, 0x03, 0xd3, 0x20, 0x22, 0xc4, 0x41,
  0x6e, 0x97, 0xad, 0xfd, 0x8c, 0x3a, 0x62, 0x28, 0x95, 0x3e, 0xb0, 0x8d, 0xf2, 0x88, 0x39, 0x37,
  0x8f, 0x1a, 0x24, 0xd1, 0x4e, 0x14, 0xdc, 0x24, 0x40, 0x54, 0xdd, 0x58, 0x71, 0xc9, 0xbf, 0x28,
  0xb7, 0xe5, 0xb1, 0xf8, 0x24, 0xdb, 0xdb, 0xbb, 0x20, 0xe2, 0x69, 0xbb, 0x25, 0xe8, 0xe8, 0x2c,
  0xb8, 0xc8, 0x96, 0x9e, 0x5e, 0x93, 0x15, 0x3f, 0x8c, 0x57, 0x4d, 0xf5, 0x18, 0x26, 0x71, 0x1b,
  0x04, 0x65, 0x26, 0x25, 0x49, 0x28, 0xa7, 0xce, 0xb6, 0x3f, 0x5f, 0x0c, 0x3a, 0xe7, 0x8e, 0xb9,
  0x6d, 0x52, 0xd0, 0xc7, 0xe2, 0x2c, 0xc0, 0x46, 0x89, 0xa1, 0x21, 0x3e, 0x8a, 0x56, 0x31, 0x37,
  0xf0, 0x87, 0xf1, 0xb9, 0xe5, 0x3a, 0xbe, 0xb8, 0xb9, 0x5e, 0xfa, 0x78, 0x53, 0x09, 0x5f, 0xf9,
  0xea, 0x8e, 0x6d, 0x82, 0xca, 0xbe, 0x59, 0x39, 0xf8, 0xd2, 0x6e, 0x97, 0x07, 0x8a, 0xde, 0x3c,
  0x88, 0xcb, 0x00, 0xaf, 0x1c, 0x53, 0xae, 0x23, 0x1f, 0x2f, 0xda, 0xe5, 0xb8, 0xb2, 0x8b, 0xd1,
  0x77, 0xea, 0x6b, 0xd2, 0xab, 0x71, 0xb2, 0xfb, 0xfb, 0x48, 0x95, 0x4b, 0x38, 0x47, 0xf9, 0x84,
  0x28, 0x25, 0x22, 0x2c, 0x43, 0x85, 0x27, 0xe2, 0x4b, 0xc9, 0x83, 0xf2, 0xd4, 0x8f, 0x33, 0x90,
  0xf7, 0xe6, 0x78, 0xbf, 0x98, 0xfc, 0xf3, 0x5d, 0x32, 0xc4, 0x26, 0x29, 0x32, 0x36, 0xee, 0xa9,
  0x7f, 0xe0, 0x8e, 0x4c, 0xca, 0x88, 0x0a, 0xef, 0x9f, 0x2c, 0x77, 0x71, 0x83, 0x90, 0x27, 0x4a,
  0x0a, 0x06, 0x82, 0xb6, 0x4d, 0x4e, 0xa1, 0x58, 0x6c, 0x31, 0xa2, 0x7f, 0x11, 0xeb, 0x2a, 0x16,
  0x70, 0x12, 0x3d, 0x0a, 0x1f, 0x65, 0x1a, 0x18, 0x36, 0xcf, 0x30, 0x5b, 0x71, 0xdd, 0xc6, 0x18,
  0xe9, 0x17, 0x62, 0xce, 0x08, 0x36, 0x33, 0xc4, 0xa3, 0x62, 0x90, 0xd8, 0x09, 0x9c, 0x05, 0x9b,
  0x44, 0x17, 0x7d, 0xa2, 0xf9, 0x8a, 0x6c, 0x80, 0xa8, 0x77, 0xd6, 0x59, 0x19, 0xa8, 0x9f, 0xe8,
  0x89, 0x59, 0xb3, 0xab, 0xb1, 0x9e, 0x52, 0x37, 0x4b, 0x6c, 0x57, 0xc1, 0xf5, 0xe1, 0x66, 0x25,
  0x35, 0x24, 0x00, 0x33, 0x70, 0x1c, 0x30, 0x4b, 0xd3, 0x68, 0xb7, 0xdb, 0x57, 0x84, 0x72, 0x04,
  0x62, 0x28, 0x22, 0x51, 0x06, 0x88, 0x96, 0x10, 0x0b, 0x94, 0x93, 0x00, 0xf4, 0xce, 0x21, 0x9a,
  0xb3, 0x79, 0x40, 0x1c, 0x34, 0xce, 0xe3, 0x7b, 0x8c, 0x2c, 0x06, 0x93, 0x39, 0x0d, 0x5e, 0x11,
  0x5a, 0x24, 0x1a, 0xa7, 0xab, 0xc9, 0x83, 0x1b, 0x2f, 0x1e, 0x3e, 0xfb, 0x1e, 0x64, 0xd3, 0x83,
  0xfd, 0x17, 0xf7, 0xf7, 0xf1, 0xf0, 0xf9, 0x33, 0x7c, 0x7e, 0xd9, 0xc5, 0xe7, 0x97, 0xcf, 0xf1,
  0xb9, 0xdb, 0xdb, 0xc3, 0x1f, 0xa0, 0xeb, 0x8f, 0x4c, 0x0f, 0xba, 0x32, 0x34, 0x9d, 0x5b, 0x2f,
  0xa3, 0x42, 0x19, 0x15, 0xca, 0xa8, 0x50, 0x46, 0x85, 0x32, 0x2a, 0x94, 0xb1, 0x42, 0x99, 0x5a,
  0x88, 0x83, 0x2b, 0x59, 0x16, 0xb5, 0x4e, 0x00, 0x38, 0x8d, 0xcc, 0x03, 0xb3, 0x7f, 0x63, 0xb7,
  0x78, 0x97, 0x4a, 0x56, 0x37, 0x32, 0xc5, 0xeb, 0x79, 0x6f, 0xed, 0x16, 0xeb, 0x07, 0x43, 0x6f,
  0x71, 0x9d, 0x3b, 0x8a, 0xce, 0x1b, 0x4e, 0x28, 0xf0, 0x94, 0x7a, 0xfa, 0xa1, 0x20, 0xcc, 0xdd,
  0x5d, 0x67, 0xdb, 0xdb, 0xd7, 0x19, 0x30, 0xa8, 0x24, 0x43, 0x79, 0xf4, 0x3a, 0x63, 0x90, 0x77,
  0xc2, 0xb2, 0xb2, 0xbd, 0x2d, 0xa1, 0xef, 0xaf, 0xb3, 0xe1, 0x6e, 0x57, 0x83, 0x3d, 0x99, 0xfb,
  0x97, 0xc1, 0xaf, 0xc7, 0xce, 0xbe, 0x86, 0x68, 0xc7, 0x12, 0xa9, 0xe6, 0xfb, 0x7b, 0xcb, 0xba,
  0x66, 0xd8, 0xc2, 0xbf, 0x06, 0xe3, 0x63, 0x98, 0xef, 0x20, 0xb7, 0x2c, 0x1e, 0x2c, 0x66, 0x0d,
  0x1a, 0xec, 0xc8, 0xbc, 0xce, 0x40, 0xc5, 0x85, 0x7f, 0x11, 0xbc, 0x8d, 0xd0, 0x50, 0x09, 0x1c,
  0x95, 0x41, 0xa2, 0x96, 0x4b, 0x5d, 0x24, 0x59, 0x4e, 0x06, 0xb0, 0x96, 0xd9, 0xc1, 0x12, 0x36,
  0x5e, 0x2d, 0xf7, 0xd3, 0xdb, 0xcf, 0x64, 0x3e, 0x26, 0x00, 0xd3, 0xf1, 0x12, 0x96, 0x73, 0x6a,
  0x42, 0xef, 0xda, 0x78, 0x89, 0x34, 0xcb, 0x10, 0xb9, 0xb7, 0x1c, 0xa0, 0xce, 0x0a, 0xe8, 0xd8,
  0x46, 0x0d, 0x65, 0x4a, 0xa7, 0x12, 0xaf, 0xa9, 0xb0, 0x34, 0x05, 0xa8, 0x18, 0xaf, 0x54, 0xc0,
  0x1e, 0x68, 0x28, 0x83, 0x0a, 0xfc, 0x8b, 0xed, 0x28, 0x3f, 0xd8, 0xb8, 0x56, 0xb0, 0xf9, 0x9c,
  0xaf, 0xc1, 0x49, 0x74, 0xbf, 0x7f, 0x29, 0x96, 0x3d, 0x9a, 0x54, 0x66, 0xc9, 0xa0, 0x51, 0xa9,
  0x21, 0x0b, 0x5e, 0x79, 0x29, 0xc6, 0x68, 0xc1, 0x44, 0x38, 0x02, 0x3e, 0x96, 0xb4, 0xf4, 0x29,
  0x50, 0xdd, 0xf0, 0xfb, 0xef, 0xdd, 0xb2, 0x48, 0x24, 0xc3, 0x39, 0xc5, 0x3c, 0xfc, 0xd7, 0xf6,
  0xb6, 0x06, 0xc5, 0x10, 0xd3, 0x12, 0x6a, 0x13, 0xc6, 0x92, 0xa3, 0xf1, 0xc2, 0xd8, 0xc9, 0x10,
  0x7a, 0xd5, 0x9f, 0xe2, 0xd5, 0xf0, 0xc0, 0xe2, 0x79, 0x30, 0x5c, 0x1b, 0xcd, 0x04, 0x11, 0x9d,
  0x87, 0x66, 0x3d, 0x4e, 0x85, 0x98, 0xf5, 0x96, 0xf2, 0x7a, 0x9e, 0x27, 0x49, 0xa6, 0xfd, 0xf3,
  0xd1, 0xdb, 0x8f, 0x40, 0x4b, 0x5f, 0x8b, 0x28, 0x29, 0x88, 0xda, 0xe6, 0x9f, 0x45, 0xd4, 0x4c,
  0xfa, 0x6a, 0x1a, 0x7c, 0xc9, 0x3e, 0x04, 0xe7, 0x7e, 0xe4, 0x95, 0x57, 0x88, 0x68, 0xb1, 0x00,
  0xb4, 0xa4, 0x68, 0x68, 0x01, 0xde, 0xb7, 0x5b, 0xab, 0x91, 0x71, 0x70, 0xa6, 0x00, 0x6f, 0x60,
  0x38, 0x9b, 0x28, 0x64, 0xb2, 0x40, 0x28, 0x13, 0x29, 0xe2, 0x1a, 0x70, 0x3c, 0xba, 0xdd, 0xc7,
  0x62, 0x9a, 0xd1, 0xaf, 0xe9, 0x32, 0xe5, 0x91, 0xcd, 0xe8, 0x67, 0x8e, 0x9f, 0xe0, 0x11, 0xce,
  0x28, 0x01, 0xef, 0x51, 0x16, 0x91, 0xd8, 0x82, 0xf6, 0x72, 0xba, 0x88, 0x41, 0xd2, 0x89, 0xa7,
  0x0e, 0x8f, 0x48, 0xa6, 0xcb, 0x12, 0x7a, 0xdc, 0x32, 0xbc, 0xa1, 0x8a, 0x51, 0xc4, 0xf8, 0xce,
  0x14, 0xe2, 0x30, 0xd4, 0x74, 0x20, 0xcf, 0x65, 0x93, 0xf3, 0xb4, 0xd3, 0x75, 0x4b, 0xb1, 0x8f,
  0xee, 0xef, 0x6b, 0xee, 0x4f, 0x72, 0x3a, 0x05, 0x51, 0xd6, 0x73, 0x79, 0x9c, 0x13, 0xa9, 0x72,
  0x79, 0x32, 0x10, 0x5c, 0xe9, 0x60, 0xb5, 0xe6, 0xb2, 0x64, 0xce, 0xbc, 0x1b, 0x60, 0x9f, 0xcc,
  0x70, 0x8f, 0xc4, 0x3b, 0x92, 0x39, 0x9e, 0x00, 0x2b, 0x77, 0x0c, 0x69, 0xa7, 0xcb, 0xe1, 0x43,
  0x5d, 0x06, 0xf7, 0x46, 0x39, 0x60, 0x47, 0x07, 0x29, 0xe6, 0x80, 0x6d, 0x83, 0x64, 0x58, 0xeb,
  0xf1, 0x8b, 0x96, 0x5a, 0x50, 0x0f, 0x32, 0xbe, 0x4d, 0x4e, 0x94, 0x8a, 0x45, 0x54, 0x96, 0x7b,
  0xaf, 0xbb, 0x1d, 0xc9, 0x68, 0x29, 0xf7, 0x5e, 0x8f, 0xfd, 0x82, 0x76, 0xdf, 0x7b, 0xcf, 0xb6,
  0xa3, 0x15, 0x93, 0x76, 0x58, 0xc1, 0x98, 0xce, 0x34, 0x10, 0x51, 0xd2, 0xbe, 0xab, 0xff, 0x80,
  0xaf, 0xd4, 0xac, 0x55, 0xac, 0xd4, 0x4b, 0xd5, 0x22, 0x4b, 0xf2, 0xc5, 0x4e, 0xa6, 0x18, 0xcd,
  0x3f, 0x26, 0x86, 0x18, 0x5d, 0x6e, 0x27, 0x27, 0x76, 0xaf, 0x84, 0x24, 0xe1, 0x41, 0xf4, 0x7c,
  0xd4, 0x3a, 0x4b, 0x67, 0xb3, 0x7b, 0x74, 0x28, 0x4b, 0x6f, 0x10, 0x53, 0x8f, 0x8b, 0x08, 0x7b,
  0x30, 0x36, 0x32, 0x16, 0x4d, 0x61, 0xea, 0x13, 0xd9, 0x10, 0x83, 0x9d, 0x70, 0x8b, 0x59, 0x80,
  0x1b, 0xec, 0xa1, 0x02, 0xb7, 0x8c, 0x71, 0xf0, 0x84, 0xf1, 0x11, 0x4a, 0x4c, 0x40, 0x1c, 0xa5,
  0x3f, 0x43, 0xcf, 0xad, 0x77, 0x66, 0xa2, 0x45, 0xf0, 0x4a, 0x12, 0x12, 0x65, 0xb6, 0x9d, 0x07,
  0x8c, 0x11, 0x32, 0x73, 0x76, 0xe3, 0x6c, 0x60, 0x8a, 0x90, 0xd9, 0xc3, 0xe6, 0xec, 0xd2, 0x10,
  0x51, 0x34, 0xa4, 0xfb, 0x50, 0xee, 0x9e, 0x9a, 0xbb, 0xf7, 0x50, 0xee, 0x3d, 0x35, 0xf7, 0xde,
  0x0d, 0x5e, 0x6b, 0x46, 0xce, 0x4f, 0x08, 0x3e, 0xfc, 0x59, 0x1c, 0x8a, 0xa1, 0x64, 0xca, 0x0f,
  0x08, 0xc5, 0x0b, 0x3a, 0x10, 0xec, 0xba, 0x7d, 0x78, 0x59, 0x1c, 0x94, 0xcc, 0xd1, 0x77, 0xcb,
  0x98, 0x49, 0x9c, 0x85, 0x2d, 0x73, 0x30, 0x06, 0x76, 0x75, 0xc9, 0x8e, 0x0f, 0xbb, 0x5d, 0xcc,
  0x8d, 0x20, 0x35, 0x41, 0x9c, 0x2c, 0xcf, 0x2f, 0x8c, 0x6c, 0x01, 0x32, 0x3e, 0x02, 0xd3, 0x65,
  0x08, 0x0c, 0xc8, 0x10, 0x77, 0x4a, 0x45, 0x7a, 0x58, 0x84, 0xc3, 0x53, 0xe2, 0x17, 0xf8, 0xb9,
  0x94, 0x96, 0xe7, 0x25, 0xe6, 0x79, 0xa5, 0x7c, 0xd6, 0xa0, 0x36, 0x1a, 0x40, 0xae, 0x46, 0x32,
  0x01, 0x56, 0x82, 0xe7, 0x5d, 0x2b, 0x85, 0x48, 0x69, 0x87, 0x63, 0xd7, 0xbc, 0xf1, 0x09, 0x36,
  0x71, 0xf8, 0x91, 0x10, 0xf8, 0x0f, 0x0f, 0xbf, 0x58, 0x23, 0x73, 0x63, 0x5c, 0x45, 0x1f, 0xb6,
  0xd6, 0x48, 0x8d, 0xd7, 0xe8, 0xb7, 0x67, 0x37, 0x4e, 0x41, 0xdc, 0x5a, 0xc0, 0xa5, 0x8a, 0x20,
  0xcf, 0x8f, 0xba, 0x89, 0x65, 0xb3, 0x35, 0xee, 0xe2, 0x89, 0xf7, 0xc3, 0x80, 0xd6, 0x78, 0x24,
  0xfe, 0x2f, 0x90, 0x25, 0x2e, 0x7c, 0x95, 0xba, 0x18, 0xa6, 0x00, 0xc3, 0x24, 0x58, 0x71, 0x91,
  0xdc, 0xb5, 0xed, 0xd1, 0xc9, 0x69, 0x1f, 0x7e, 0x2f, 0xa2, 0x10, 0xfa, 0x39, 0x80, 0xa2, 0x29,
  0xc6, 0x45, 0x08, 0x65, 0xfc, 0x75, 0x2c, 0x12, 0x62, 0x80, 0x04, 0xc8, 0x17, 0xd2, 0x09, 0x0b,
  0xcb, 0xea, 0x60, 0x18, 0x43, 0x99, 0xef, 0xa0, 0x27, 0x72, 0x76, 0x79, 0xce, 0xae, 0x96, 0x73,
  0x51, 0xe4, 0xdc, 0x13, 0x39, 0x7b, 0x3c, 0x67, 0x4f, 0xcb, 0x79, 0xee, 0xe1, 0x15, 0x72, 0x0c,
  0x46, 0x57, 0xe2, 0xa1, 0xfb, 0xcc, 0x2b, 0x05, 0xc7, 0x61, 0xe9, 0x35, 0x11, 0xaa, 0xd9, 0x82,
  0xb5, 0x37, 0x6f, 0x7c, 0x4d, 0xd1, 0x71, 0x30, 0x0f, 0x39, 0x91, 0xc0, 0xc6, 0x8f, 0xac, 0x19,
  0x44, 0xd8, 0x17, 0xa3, 0x5e, 0x7f, 0xdf, 0xbe, 0xbf, 0x4f, 0x05, 0x0b, 0x81, 0x55, 0x6f, 0x9a,
  0x5b, 0x5e, 0x0a, 0xac, 0x93, 0xa4, 0xa9, 0x79, 0xd9, 0x51, 0x91, 0x89, 0x14, 0x8e, 0x5a, 0x20,
  0x25, 0x3e, 0x2b, 0x14, 0x4e, 0xcf, 0xb4, 0x85, 0x85, 0x7a, 0xe6, 0x55, 0x5e, 0x39, 0x57, 0x9e,
  0x12, 0x62, 0x96, 0x3d, 0x86, 0xb1, 0x85, 0xc7, 0x6c, 0x92, 0x5f, 0x51, 0x21, 0x3e, 0x51, 0xb3,
  0x16, 0x4c, 0x95, 0x4d, 0x07, 0x11, 0xf9, 0xc8, 0xca, 0xd6, 0x70, 0x22, 0x9d, 0xc1, 0x5c, 0xc1,
  0x80, 0x22, 0xa7, 0x06, 0x3e, 0x03, 0xcf, 0x78, 0xca, 0xf2, 0x40, 0xf1, 0x2a, 0xd3, 0x91, 0x55,
  0x84, 0x54, 0xc5, 0xda, 0xd2, 0x8c, 0x4f, 0x80, 0x78, 0x9b, 0x83, 0x2e, 0x5b, 0xae, 0xe0, 0xc4,
  0x9c, 0xf0, 0x37, 0x2d, 0xf3, 0xc6, 0x3c, 0xc5, 0x74, 0xec, 0xa2, 0xa7, 0xf4, 0x93, 0x29, 0xc2,
  0x33, 0x7b, 0xa5, 0x4d, 0xc4, 0x16, 0x9f, 0x89, 0xd1, 0x5c, 0x51, 0xea, 0x30, 0xa1, 0xaf, 0x26,
  0xd0, 0xd0, 0x98, 0x6c, 0x0d, 0x19, 0x84, 0xb3, 0x60, 0xb2, 0xfe, 0x8a, 0xb4, 0x50, 0x76, 0xad,
  0x6f, 0x6a, 0x0d, 0x75, 0xfc, 0x91, 0x9c, 0xe0, 0x3c, 0x59, 0x20, 0x14, 0xf2, 0xe2, 0x06, 0xe4,
  0xc4, 0x96, 0xd7, 0x73, 0x1d, 0xf1, 0xe2, 0xf7, 0xf7, 0x38, 0x7d, 0x78, 0x11, 0x0a, 0xc6, 0x40,
  0xcd, 0x6d, 0xe2, 0xa5, 0x63, 0xb3, 0x92, 0x0f, 0xe3, 0x22, 0x2d, 0x1b, 0xa8, 0x66, 0x59, 0xfb,
  0xb1, 0x3d, 0x17, 0x5f, 0x68, 0x31, 0x9b, 0xc9, 0x2f, 0x1d, 0xeb, 0x96, 0xdd, 0xe4, 0x16, 0x82,
  0x65, 0xad, 0xdf, 0xaf, 0x33, 0xaf, 0x4d, 0xa6, 0x2d, 0xfd, 0xb6, 0x66, 0x51, 0x10, 0x48, 0x06,
  0x2d, 0x09, 0xdb, 0xb9, 0xa8, 0x79, 0x5f, 0xf6, 0x8a, 0xb5, 0x07, 0x17, 0x22, 0xaa, 0x38, 0x0a,
  0xd7, 0x9e, 0xd9, 0xdb, 0xc3, 0x10, 0x5c, 0x38, 0x7e, 0xb7, 0x4d, 0xe3, 0x77, 0x5b, 0x1e, 0xbf,
  0xef, 0x5d, 0xd3, 0xb9, 0xa8, 0xcd, 0xfd, 0xcc, 0x95, 0x2f, 0xd4, 0xdc, 0x30, 0xde, 0xb7, 0xd5,
  0xf1, 0xbe, 0xad, 0x8c, 0xb7, 0x56, 0x2b, 0xcf, 0x75, 0x51, 0x33, 0x2b, 0x75, 0xb1, 0x5b, 0xdd,
  0xc2, 0x94, 0x21, 0x9b, 0x44, 0x62, 0xd5, 0xb8, 0x1a, 0x7c, 0x86, 0xf2, 0xc1, 0x58, 0x8c, 0x55,
  0xd8, 0x65, 0x32, 0x9d, 0x49, 0x4b, 0x9c, 0x71, 0xa7, 0x3a, 0x3e, 0x89, 0xe3, 0xed, 0x7d, 0x7b,
  0x00, 0xb5, 0xe3, 0xd6, 0x61, 0x45, 0xad, 0x67, 0xae, 0x8d, 0x5f, 0x19, 0x8c, 0x13, 0xd0, 0x6b,
  0xe6, 0x7d, 0x63, 0xb7, 0x8b, 0xc0, 0x28, 0x2b, 0xf6, 0xd5, 0xf7, 0x65, 0xef, 0x3d, 0xf8, 0x2a,
  0x85, 0x39, 0x86, 0xcf, 0xbe, 0x57, 0x0f, 0x8e, 0x51, 0x4e, 0x4c, 0xf3, 0xd7, 0xc1, 0x0c, 0xb1,
  0x4d, 0xc6, 0xce, 0x7b, 0x26, 0x9e, 0x3e, 0x41, 0x53, 0xd1, 0x5b, 0xdc, 0x84, 0xeb, 0xc4, 0x25,
  0xe2, 0x49, 0x97, 0x5e, 0x9d, 0xfa, 0x01, 0x82, 0xd6, 0x6b, 0xd2, 0xb3, 0x60, 0xab, 0x63, 0x27,
  0x6e, 0x62, 0x1d, 0x06, 0x8c, 0x21, 0x4e, 0x10, 0x3d, 0x19, 0xd2, 0x2f, 0x1b, 0x1c, 0xb7, 0x1d,
  0xad, 0xc0, 0x96, 0x28, 0x41, 0x9f, 0x7c, 0x4d, 0xcf, 0xc5, 0x8e, 0xd4, 0xb3, 0x07, 0x97, 0xca,
  0x10, 0xbe, 0x76, 0x5e, 0xb3, 0xdc, 0xc0, 0x5f, 0x9e, 0xb4, 0xbc, 0xb7, 0xad, 0xd7, 0x2d, 0xe0,
  0x94, 0x2d, 0x4c, 0xc1, 0xbe, 0x20, 0x04, 0x39, 0xa3, 0xfd, 0x4b, 0x7d, 0xd1, 0x07, 0x23, 0xf3,
  0xdd, 0x0d, 0x2d, 0x75, 0x78, 0x7a, 0x7d, 0x8e, 0x8b, 0x3b, 0x33, 0xc9, 0x11, 0x6e, 0x2b, 0x01,
  0x09, 0x5e, 0xc2, 0x90, 0x8e, 0x9a, 0x1b, 0x7d, 0xa9, 0x01, 0x68, 0xb7, 0x10, 0xda, 0xcf, 0xb6,
  0xfb, 0x97, 0xf5, 0x8b, 0xa9, 0x61, 0xdc, 0x7e, 0x8e, 0x7f, 0x9e, 0xcd, 0xd8, 0xfe, 0xa2, 0xda,
  0x9e, 0x9e, 0xd0, 0x84, 0xdc, 0xd4, 0x47, 0x03, 0x46, 0xcb, 0x39, 0x2f, 0xc2, 0x36, 0x24, 0xb5,
  0xbd, 0x6c, 0xc0, 0x17, 0x14, 0x38, 0x92, 0x9d, 0x2c, 0xe3, 0xb3, 0x2d, 0xdc, 0x24, 0xc9, 0x7e,
  0x5b, 0xcf, 0x5e, 0x6e, 0x1a, 0xd2, 0xd5, 0xba, 0xb1, 0xae, 0xca, 0x66, 0x35, 0xf3, 0x2a, 0xc9,
  0x9b, 0x6c, 0x54, 0x54, 0xa8, 0xb4, 0x51, 0x61, 0xaf, 0xaf, 0x2b, 0x54, 0x7c, 0x26, 0x1d, 0x50,
  0x1f, 0x38, 0x43, 0xb8, 0x62, 0xf6, 0x66, 0x54, 0xa3, 0x51, 0x98, 0x57, 0x8f, 0x10, 0xd8, 0x66,
  0x04, 0x65, 0x70, 0x03, 0xc1, 0x4f, 0x7b, 0xca, 0xf7, 0xe5, 0x06, 0xa2, 0x8d, 0xe3, 0x16, 0x1f,
  0xc8, 0xd1, 0x8d, 0x32, 0x33, 0x98, 0xd0, 0x57, 0x13, 0x4c, 0x52, 0xb2, 0x45, 0xc0, 0x68, 0x93,
  0xa3, 0x3a, 0xd6, 0x8f, 0x34, 0x63, 0xb7, 0x37, 0xf5, 0xc9, 0xf5, 0x73, 0xb8, 0xa5, 0x4c, 0x22,
  0x8c, 0xbf, 0x3a, 0x78, 0xf6, 0x96, 0xa7, 0x08, 0x8d, 0xd0, 0xe1, 0xa2, 0x8f, 0x7a, 0x3e, 0x60,
  0x20, 0xd0, 0xe0, 0x49, 0xb4, 0x44, 0x6f, 0x21, 0xf3, 0xff, 0xfc, 0xb7, 0xff, 0x65, 0x82, 0xd0,
  0xa2, 0x27, 0xfd, 0x6f, 0xd3, 0xae, 0x82, 0xc5, 0x9b, 0xd3, 0xf0, 0x4a, 0xd3, 0xd3, 0x6b, 0x17,
  0xc2, 0x2e, 0xb7, 0x93, 0x3c, 0xba, 0x38, 0xeb, 0xf6, 0x96, 0x08, 0xc5, 0x4b, 0xad, 0xb7, 0x29,
  0xda, 0x80, 0x1a, 0x06, 0xe6, 0x9c, 0x45, 0x40, 0x56, 0xac, 0x14, 0x4a, 0x68, 0x61, 0x35, 0x23,
  0x59, 0x29, 0xdc, 0x7a, 0x67, 0x96, 0x0d, 0x6c, 0x24, 0xfe, 0x4b, 0xd8, 0x0b, 0xb6, 0x02, 0x90,
  0xe6, 0xc4, 0x97, 0x40, 0x79, 0x2d, 0x02, 0x96, 0xcb, 0xd0, 0x60, 0x8a, 0x31, 0xeb, 0xfe, 0x5e,
  0xb5, 0x73, 0xa9, 0x81, 0x31, 0x74, 0xac, 0x66, 0x67, 0x2f, 0xd8, 0x93, 0x9e, 0xc2, 0x64, 0x00,
  0xcb, 0x50, 0xc0, 0x60, 0x8e, 0x63, 0x59, 0x68, 0xf6, 0x03, 0xf9, 0x03, 0xed, 0x2d, 0xc0, 0x8b,
  0x3a, 0x2a, 0x82, 0x74, 0x56, 0x71, 0x39, 0x43, 0x87, 0xb8, 0x33, 0x81, 0xcd, 0x89, 0xd0, 0xd4,
  0xb9, 0x8d, 0x96, 0xa3, 0x87, 0xac, 0x47, 0xa0, 0x05, 0xc0, 0x97, 0x16, 0x49, 0x86, 0xb8, 0x20,
  0xe8, 0x97, 0x46, 0xe8, 0x9a, 0xe8, 0x5b, 0x44, 0x51, 0xea, 0x61, 0x17, 0x83, 0xe6, 0xab, 0x71,
  0x26, 0xb0, 0xc3, 0xed, 0x38, 0xb9, 0xb6, 0x18, 0x92, 0x1a, 0x77, 0x62, 0xa9, 0xb7, 0x88, 0x30,
  0x37, 0x46, 0x58, 0x8a, 0xe1, 0x14, 0x84, 0x25, 0xf6, 0xb0, 0xbd, 0xcd, 0x8c, 0xb0, 0x9e, 0xa7,
  0xd9, 0x54, 0x18, 0x63, 0x0f, 0x0b, 0x2a, 0xed, 0xba, 0x4f, 0x13, 0xe1, 0x34, 0x13, 0x6e, 0x79,
  0x79, 0x4a, 0x97, 0x9c, 0x8a, 0x02, 0x5e, 0x68, 0xaf, 0x2c, 0x8e, 0x68, 0x5c, 0x80, 0xb3, 0x06,
  0x0a, 0x5a, 0x3c, 0x86, 0x8a, 0xb6, 0x90, 0x36, 0xec, 0x55, 0x34, 0xba, 0xce, 0xc8, 0xe4, 0x63,
  0xc5, 0xf7, 0xf7, 0x3b, 0x77, 0xe6, 0x95, 0xd9, 0x47, 0xd5, 0x67, 0xb5, 0x63, 0xf7, 0x99, 0x73,
  0x5e, 0x26, 0x9d, 0xf3, 0x7c, 0x07, 0x23, 0x89, 0x05, 0x18, 0x05, 0x1d, 0x23, 0x8b, 0x80, 0xa0,
  0x97, 0xef, 0xa2, 0x1f, 0x24, 0x0c, 0x0f, 0xc6, 0xa9, 0x0a, 0x99, 0x6d, 0x95, 0x26, 0x63, 0x60,
  0xa0, 0x5d, 0x1c, 0xad, 0x44, 0xbf, 0x7c, 0x7e, 0xb7, 0xfb, 0xc2, 0x5c, 0x39, 0xe3, 0x64, 0x7a,
  0xdb, 0x8f, 0xbf, 0x02, 0xa7, 0x3b, 0xf6, 0x86, 0x48, 0xa4, 0x7f, 0x07, 0x7b, 0x29, 0x50, 0x78,
  0xac, 0xf9, 0x1e, 0xd2, 0xca, 0x83, 0x55, 0x94, 0x2d, 0x92, 0x18, 0x83, 0x7e, 0xa3, 0x21, 0x65,
  0x0b, 0xf5, 0xbc, 0x09, 0xa2, 0x60, 0xda, 0x3c, 0x6e, 0x5c, 0x8c, 0x73, 0x2b, 0x97, 0x05, 0xf0,
  0xa4, 0x6b, 0x5a, 0xa3, 0x6a, 0x88, 0x96, 0x2d, 0x22, 0xc2, 0x3b, 0x5c, 0x12, 0xe5, 0x7b, 0x53,
  0x71, 0x9b, 0x0b, 0x84, 0x05, 0xa2, 0xad, 0xbc, 0xc2, 0x12, 0xb7, 0x85, 0x9b, 0x7e, 0x63, 0x48,
  0x28, 0x15, 0xd7, 0xbd, 0x92, 0xae, 0xf8, 0xf8, 0x6b, 0x2f, 0xa9, 0x85, 0x71, 0x5b, 0xb5, 0xd8,
  0x0b, 0x8b, 0x3c, 0xba, 0x3b, 0xda, 0x14, 0x83, 0x66, 0x1f, 0xad, 0xb2, 0x85, 0xed, 0x53, 0xac,
  0x27, 0x56, 0x0c, 0xd6, 0x4a, 0x44, 0x27, 0x2d, 0x35, 0x46, 0x65, 0x4c, 0x8e, 0x2a, 0x7b, 0xb6,
  0xef, 0x98, 0x6f, 0xe8, 0xd7, 0x18, 0xf9, 0x1a, 0x90, 0xbc, 0x4f, 0x2a, 0x4f, 0x7d, 0x64, 0xf2,
  0xe2, 0xe8, 0xcb, 0x4c, 0x13, 0x32, 0xb2, 0xb2, 0xa0, 0xc2, 0x18, 0x18, 0x31, 0xe2, 0x47, 0x44,
  0x16, 0x28, 0xed, 0xd6, 0x07, 0x78, 0xb4, 0x11, 0x2d, 0x8a, 0x62, 0xb7, 0x89, 0x44, 0x9e, 0x32,
  0x6d, 0xb3, 0x2b, 0xa8, 0xbe, 0x23, 0x6e, 0xce, 0x79, 0x11, 0x33, 0xb3, 0x4d, 0xf0, 0x07, 0x19,
  0x42, 0x3f, 0x9f, 0x47, 0x9f, 0x82, 0xc9, 0x95, 0x87, 0xc8, 0x20, 0xa9, 0xc3, 0x2e, 0x54, 0x8a,
  0x5c, 0xf0, 0x0b, 0x78, 0x2e, 0x82, 0x1b, 0xe3, 0xed, 0xd2, 0xac, 0x8d, 0xa0, 0xf7, 0x59, 0x32,
  0x5f, 0x88, 0xf7, 0xf8, 0x0c, 0x53, 0x0b, 0x0a, 0xaf, 0x76, 0xe2, 0xa1, 0x4c, 0x89, 0xc3, 0xc2,
  0x46, 0x3c, 0xc6, 0xec, 0x1e, 0x7d, 0x9d, 0xd9, 0x3d, 0xaa, 0x37, 0xbb, 0x47, 0xb6, 0x6e, 0x6c,
  0x47, 0xde, 0x1a, 0x0b, 0x0b, 0x7b, 0x61, 0xc2, 0xa6, 0xe0, 0xcc, 0x5f, 0xeb, 0x1d, 0x5b, 0xf6,
  0xca, 0x24, 0xf7, 0xaa, 0x52, 0xb4, 0xb2, 0xbb, 0x24, 0xee, 0x93, 0x7d, 0x1c, 0xe1, 0xcd, 0xe3,
  0x55, 0xc5, 0x93, 0xf3, 0x63, 0x64, 0xa9, 0x9f, 0xb2, 0xd0, 0xbe, 0xbd, 0x05, 0xff, 0xd8, 0xa3,
  0x33, 0x1c, 0xd6, 0x94, 0xc7, 0xb5, 0x6a, 0x1b, 0x7f, 0xc2, 0x18, 0x14, 0x2c, 0xb0, 0x11, 0x85,
  0x80, 0x20, 0xcb, 0xe7, 0x93, 0x3b, 0x32, 0x7a, 0x83, 0x38, 0x6a, 0xc2, 0xbe, 0xd0, 0x27, 0x8c,
  0xaa, 0x15, 0xa5, 0xa2, 0xe9, 0x1b, 0x12, 0xf1, 0x58, 0x15, 0x98, 0xd6, 0x2c, 0x87, 0xbf, 0xec,
  0xc5, 0x9b, 0x65, 0xba, 0x42, 0x70, 0x0a, 0x72, 0xc9, 0x3d, 0xeb, 0x9b, 0xec, 0x2b, 0xd3, 0x80,
  0xbe, 0x83, 0xf8, 0xab, 0xe8, 0x75, 0xad, 0xf5, 0x20, 0x8e, 0xfa, 0xd8, 0x0b, 0x68, 0xd4, 0xaa,
  0xda, 0x7e, 0x74, 0xf0, 0xd2, 0x7b, 0x20, 0xad, 0xec, 0x5b, 0xe2, 0xc9, 0x1e, 0x99, 0x3f, 0x93,
  0x7f, 0x37, 0x35, 0x9f, 0x82, 0xe4, 0x61, 0x18, 0x8a, 0x38, 0xc8, 0xaf, 0x93, 0xf4, 0x92, 0x75,
  0x07, 0x76, 0x13, 0x03, 0xf3, 0xa3, 0x39, 0x8e, 0x02, 0x5b, 0xc0, 0x2c, 0xb7, 0xa1, 0xe9, 0x9f,
  0xf1, 0x99, 0x75, 0x9b, 0x42, 0x5d, 0x3c, 0x5c, 0x8f, 0x11, 0x25, 0xf1, 0x39, 0x64, 0xc2, 0xda,
  0xda, 0xa6, 0x08, 0x5a, 0x78, 0x87, 0x16, 0xff, 0xfe, 0x1d, 0xf2, 0xff, 0xbe, 0x68, 0xd7, 0x6a,
  0x35, 0x50, 0x56, 0x02, 0xed, 0x2d, 0x74, 0x2e, 0x90, 0xe2, 0xba, 0x90, 0x8d, 0xd7, 0x06, 0xa3,
  0xea, 0x8a, 0x8b, 0x0b, 0xf1, 0x2a, 0x0c, 0x60, 0x2f, 0xbc, 0x13, 0x84, 0xc8, 0x5e, 0x10, 0x19,
  0xda, 0x40, 0x9d, 0x44, 0xee, 0x22, 0x95, 0x7b, 0x92, 0x43, 0xf2, 0x87, 0x2b, 0xa4, 0x89, 0x0f,
  0x57, 0xbc, 0x81, 0x66, 0xc4, 0x2b, 0xa2, 0xdd, 0xd7, 0x05, 0x19, 0x0e, 0x16, 0x19, 0x0b, 0x55,
  0x51, 0xbc, 0xeb, 0xbd, 0x31, 0xa9, 0x64, 0xdd, 0x19, 0xfa, 0xa5, 0x92, 0x49, 0xbf, 0xfd, 0x1c,
  0xce, 0xd0, 0x06, 0x48, 0xd7, 0x58, 0x94, 0x3c, 0x06, 0x46, 0x0a, 0x35, 0xfd, 0x31, 0xac, 0xdc,
  0xfe, 0x38, 0xf2, 0x63, 0xba, 0x0a, 0xc2, 0xb2, 0x0e, 0x77, 0x56, 0xe7, 0xa4, 0xd1, 0x6b, 0x55,
  0x96, 0x39, 0x14, 0x36, 0x64, 0xa3, 0x33, 0x78, 0xaa, 0x2c, 0x28, 0xaf, 0x77, 0x56, 0xbc, 0xea,
  0x18, 0x96, 0x37, 0x04, 0xda, 0xa4, 0x50, 0x8f, 0x18, 0x22, 0x48, 0xd4, 0x06, 0xcd, 0xa7, 0x3a,
  0xf2, 0xbe, 0xd6, 0x0b, 0xe7, 0x5c, 0x71, 0x3f, 0x2c, 0x7b, 0x3b, 0xe2, 0x27, 0x15, 0xc7, 0x43,
  0x9a, 0x80, 0x4d, 0x44, 0x24, 0x7a, 0x4f, 0xc2, 0x03, 0x48, 0x0e, 0x11, 0x88, 0x0e, 0x33, 0x1f,
  0xe4, 0xf9, 0xd5, 0x8e, 0x08, 0x1f, 0x58, 0xa6, 0x0a, 0x36, 0xf9, 0x77, 0x6b, 0x26, 0x5f, 0xa4,
  0x15, 0xf4, 0xe3, 0x58, 0x8c, 0x80, 0x90, 0x2c, 0xf0, 0xaf, 0x5d, 0x66, 0x69, 0x9c, 0xe5, 0xd5,
  0x86, 0xc8, 0x85, 0xf4, 0xda, 0x29, 0xc2, 0x92, 0x1b, 0x4d, 0x52, 0x23, 0xb7, 0x7e, 0x5f, 0x1a,
  0x42, 0x56, 0x63, 0x31, 0x88, 0x15, 0x8e, 0xc6, 0xef, 0x4a, 0x34, 0xac, 0x86, 0xda, 0x9e, 0xf3,
  0x71, 0xc2, 0x9e, 0xd3, 0x43, 0x4d, 0x63, 0x62, 0x6d, 0xd3, 0x50, 0xbb, 0x48, 0x25, 0xbe, 0xad,
  0x8f, 0x62, 0x47, 0x52, 0xfb, 0xc9, 0xab, 0x55, 0xa8, 0x45, 0xce, 0xa6, 0x72, 0x25, 0x44, 0x3f,
  0xda, 0x47, 0x78, 0x07, 0xe1, 0xc5, 0x45, 0x37, 0x86, 0x34, 0xd8, 0x02, 0x77, 0x53, 0x87, 0x79,
  0xb5, 0xd4, 0x6e, 0xb7, 0x70, 0x87, 0x77, 0xba, 0xae, 0xdd, 0x7a, 0xfc, 0x05, 0x7c, 0xbd, 0xb6,
  0x4c, 0xad, 0xad, 0x0f, 0xe2, 0x4d, 0xae, 0xde, 0xaf, 0x0f, 0xbc, 0x9c, 0x29, 0x56, 0xb1, 0x1e,
  0xdf, 0x02, 0x6a, 0x32, 0xd7, 0xc2, 0x60, 0x02, 0x1b, 0xbe, 0xd6, 0x33, 0x19, 0xc6, 0x47, 0x50,
  0x8e, 0x38, 0xb2, 0x82, 0xa1, 0xb7, 0x63, 0xb5, 0x11, 0xba, 0xa5, 0x84, 0x78, 0xac, 0xc3, 0xad,
  0xd4, 0xaa, 0xdb, 0x14, 0xc2, 0x52, 0x05, 0xb0, 0xa8, 0x22, 0x4c, 0xca, 0xef, 0x7d, 0x3b, 0x80,
  0xa4, 0xd6, 0xba, 0xcd, 0xb1, 0x24, 0xd7, 0xc2, 0x47, 0x76, 0xfe, 0xff, 0xc2, 0x18, 0xfc, 0x3b,
  0x20, 0x92, 0x69, 0xb3, 0xf2, 0x75, 0x68, 0x83, 0x41, 0x13, 0x70, 0x57, 0x89, 0x1e, 0x1b, 0x30,
  0xbc, 0xca, 0x54, 0xfb, 0x57, 0x84, 0x21, 0xd3, 0xaa, 0xfe, 0x7a, 0x60, 0xc1, 0xa0, 0x0c, 0x29,
  0xf8, 0x50, 0xce, 0xbf, 0xc3, 0x68, 0x6c, 0x02, 0x56, 0xa6, 0xd5, 0x5d, 0x87, 0x5b, 0xa6, 0x7f,
  0x7c, 0x60, 0x28, 0x78, 0x2e, 0x83, 0xbf, 0x21, 0xa0, 0x99, 0xf6, 0x59, 0xc2, 0x36, 0x53, 0xc6,
  0x38, 0x58, 0xe1, 0x0a, 0x52, 0x13, 0x10, 0x8a, 0x24, 0xa3, 0x7d, 0xb6, 0xcc, 0xcb, 0xb4, 0x68,
  0x3f, 0xec, 0x66, 0xed, 0x60, 0x33, 0x40, 0x9c, 0x58, 0xf5, 0xe6, 0x91, 0x9d, 0xbe, 0xdb, 0x14,
  0x4d, 0xa7, 0x3e, 0xf4, 0x1b, 0x8f, 0x52, 0xa4, 0x8c, 0xb4, 0xdc, 0x11, 0xab, 0x53, 0x26, 0x02,
  0x1a, 0xb1, 0x71, 0xee, 0xbe, 0xf0, 0x69, 0x9c, 0x5f, 0x4d, 0xa7, 0x62, 0xbf, 0xd0, 0x30, 0x87,
  0x76, 0x68, 0x47, 0x5a, 0x44, 0x14, 0xbf, 0xea, 0xce, 0xed, 0xdf, 0x2d, 0xb2, 0x3e, 0xde, 0x39,
  0x9f, 0x2e, 0xd3, 0xfe, 0x09, 0xde, 0xb6, 0x71, 0x0a, 0x9b, 0x50, 0xff, 0x64, 0xb7, 0x7b, 0x0a,
  0x32, 0x3b, 0x02, 0x43, 0xf5, 0x5d, 0x27, 0xed, 0x6f, 0x75, 0x1d, 0x14, 0xfa, 0x5d, 0x3c, 0x02,
  0x56, 0xf7, 0xea, 0x23, 0xd8, 0x48, 0x22, 0xd8, 0xef, 0xc4, 0x71, 0x38, 0xa1, 0x98, 0x97, 0x23,
  0x5e, 0xc9, 0xe8, 0x61, 0xf5, 0x01, 0xaf, 0x1c, 0x86, 0x5e, 0x1e, 0x6b, 0x98, 0xe5, 0xdc, 0x5c,
  0x70, 0x92, 0x9d, 0x92, 0xc3, 0xe1, 0x48, 0x3e, 0xf5, 0x8b, 0x40, 0x97, 0x94, 0x06, 0xf5, 0xa3,
  0x12, 0x2d, 0xde, 0x17, 0xf1, 0x2a, 0xcb, 0x29, 0xed, 0x05, 0x7a, 0x0b, 0x12, 0xc6, 0x53, 0xb2,
  0xa0, 0x0e, 0xb0, 0xd5, 0x89, 0x61, 0xc7, 0xa8, 0x9e, 0x15, 0xd2, 0x10, 0x10, 0x08, 0x7b, 0x3b,
  0x94, 0x37, 0xe6, 0x0d, 0x0d, 0xd7, 0x61, 0x06, 0x5f, 0xbf, 0x38, 0x8a, 0xde, 0xae, 0x89, 0x1f,
  0x6a, 0xc2, 0x06, 0x25, 0x4e, 0x6b, 0x72, 0xfb, 0xae, 0xe8, 0x3e, 0xdd, 0x84, 0xc6, 0xbe, 0xb2,
  0x59, 0xa0, 0x60, 0x9a, 0x99, 0xda, 0xed, 0xb8, 0xe5, 0xb1, 0x51, 0x85, 0xb5, 0x9d, 0xde, 0x82,
  0xce, 0x9c, 0x31, 0xf3, 0xb2, 0xa4, 0x39, 0x6e, 0x46, 0xc9, 0x1b, 0x2f, 0x6e, 0x51, 0xfc, 0xc0,
  0x68, 0x77, 0x4a, 0x07, 0x18, 0x91, 0x74, 0x05, 0x40, 0x03, 0x5e, 0x71, 0x17, 0xb3, 0x04, 0x4d,
  0xc4, 0xbd, 0xa9, 0x6b, 0x29, 0x97, 0x1d, 0xbd, 0xb8, 0xae, 0x6d, 0x37, 0x5f, 0xf9, 0xa4, 0x6f,
  0x49, 0x28, 0x7a, 0x0a, 0xce, 0x68, 0x67, 0x12, 0xa0, 0xe2, 0x8a, 0xcc, 0xe7, 0x52, 0xbe, 0xd2,
  0x5e, 0xd8, 0x88, 0x02, 0xc3, 0xcf, 0xa4, 0xb5, 0x17, 0x7d, 0x75, 0x84, 0x4e, 0x8a, 0x57, 0x74,
  0x0e, 0xa2, 0x38, 0x10, 0xf1, 0xc2, 0x9a, 0x1d, 0xc1, 0x9f, 0x4e, 0x8f, 0x22, 0xe6, 0xb0, 0xab,
  0x8d, 0x33, 0x7a, 0x34, 0x4c, 0x02, 0xa0, 0x80, 0xae, 0xe3, 0x3a, 0x18, 0x8d, 0x50, 0xbe, 0x84,
  0x25, 0xa0, 0xbf, 0xd5, 0x5e, 0xa1, 0xc3, 0x81, 0x92, 0x52, 0xac, 0x92, 0xa6, 0x32, 0x45, 0x0e,
  0x2a, 0xaa, 0xd1, 0x8c, 0xe2, 0xd2, 0x1d, 0x44, 0xb5, 0xcd, 0x2c, 0xbc, 0x37, 0xac, 0xda, 0xe6,
  0xa3, 0xdb, 0x48, 0x7d, 0xd3, 0xf5, 0x37, 0x35, 0xed, 0xc4, 0x0c, 0x5a, 0x6b, 0xd4, 0xd0, 0x57,
  0x51, 0x70, 0xc4, 0xdd, 0x5b, 0xf4, 0x06, 0xa1, 0x3f, 0x40, 0x71, 0xa9, 0xb8, 0x72, 0x97, 0x16,
  0xca, 0xbd, 0x59, 0xa6, 0xa2, 0x60, 0x5c, 0x31, 0x52, 0x5b, 0xe5, 0xb1, 0x54, 0x6d, 0xe0, 0x5d,
  0xf7, 0x69, 0x2c, 0x67, 0x50, 0xad, 0xf2, 0xf3, 0x66, 0x35, 0x6a, 0x23, 0xbd, 0x49, 0xc5, 0x9f,
  0x94, 0xa8, 0xd1, 0xa2, 0x16, 0x58, 0x61, 0x69, 0xdd, 0x4d, 0xc2, 0x08, 0xe5, 0x94, 0x14, 0x64,
  0xe5, 0xe2, 0xbe, 0x8c, 0xd3, 0x98, 0x6d, 0xa1, 0xe5, 0x1b, 0x59, 0x78, 0xd1, 0x03, 0xb9, 0xa7,
  0xe7, 0x16, 0xe1, 0x6a, 0xd1, 0x53, 0xb2, 0xa9, 0x82, 0xa4, 0x7b, 0xd6, 0x00, 0x1c, 0xd6, 0x2f,
  0xea, 0x5a, 0xa3, 0xa4, 0x88, 0x66, 0x14, 0x37, 0x6a, 0xe9, 0x7b, 0x0f, 0x17, 0xc1, 0x4b, 0x3c,
  0xf1, 0xb4, 0x28, 0xf6, 0x98, 0x06, 0x32, 0xbb, 0x43, 0x49, 0x7d, 0x3b, 0xd2, 0xb1, 0x1f, 0x38,
  0x13, 0x64, 0xc6, 0xee, 0x62, 0xe6, 0x58, 0x8f, 0x46, 0xe5, 0x84, 0xbe, 0x3b, 0x28, 0xe9, 0x4c,
  0xb3, 0x30, 0xcd, 0x72, 0x0c, 0x42, 0x2b, 0x62, 0xfb, 0x19, 0x6f, 0xd9, 0xee, 0x21, 0xb7, 0x6e,
  0x09, 0x2f, 0x02, 0x74, 0xc3, 0x00, 0x3b, 0x8a, 0x57, 0x0f, 0x81, 0x42, 0x1e, 0x5f, 0x2c, 0x67,
  0xb3, 0x88, 0xa2, 0xf5, 0xac, 0x01, 0x7f, 0x2c, 0x48, 0x41, 0x45, 0x7f, 0x44, 0x6a, 0x62, 0xb1,
  0x07, 0x11, 0x1b, 0xbe, 0xe8, 0x48, 0x0d, 0x04, 0xe4, 0x86, 0xc8, 0x8f, 0x0a, 0x6a, 0xc8, 0x83,
  0x2d, 0xe7, 0xa8, 0x8d, 0xc8, 0x10, 0x67, 0x61, 0x1c, 0xe6, 0x41, 0x74, 0xbb, 0x59, 0x2f, 0x16,
  0xeb, 0xba, 0x01, 0xba, 0x3a, 0xb4, 0x5a, 0xb4, 0xff, 0xab, 0x1b, 0x5f, 0xcc, 0x08, 0x23, 0x9d,
  0x9a, 0x90, 0x12, 0x59, 0xf9, 0x7e, 0x06, 0xeb, 0x96, 0x3a, 0xf5, 0x30, 0xe9, 0xbc, 0x97, 0xb5,
  0xa2, 0x7b, 0x59, 0x38, 0x57, 0xfb, 0xa8, 0x08, 0xd4, 0x4a, 0xff, 0x50, 0x6c, 0xef, 0xf6, 0xbe,
  0x27, 0x31, 0xde, 0x95, 0xdb, 0x3f, 0xc6, 0x5d, 0xca, 0xfa, 0x5d, 0xe8, 0x2c, 0x1e, 0xd1, 0x15,
  0x74, 0x05, 0x84, 0x36, 0xe5, 0x0e, 0x8d, 0x7d, 0xa1, 0xf3, 0x1e, 0xb0, 0x43, 0x61, 0x55, 0x6c,
  0x83, 0x14, 0xfc, 0x6f, 0x17, 0x37, 0x7d, 0xa5, 0x0d, 0x6c, 0x5d, 0x35, 0x0c, 0x34, 0xdd, 0xe7,
  0x82, 0xef, 0x7b, 0x2a, 0xe1, 0xe0, 0x85, 0x5e, 0xed, 0x17, 0x88, 0x5b, 0x1c, 0x94, 0x4e, 0x13,
  0x58, 0xdc, 0xe1, 0x47, 0x18, 0x30, 0x29, 0xa7, 0xf0, 0x00, 0x39, 0x85, 0x34, 0x86, 0x2e, 0x90,
  0xd4, 0xd6, 0x0e, 0x6b, 0x2c, 0x9b, 0x1c, 0xb1, 0x22, 0xea, 0xe5, 0xce, 0xb0, 0x12, 0x78, 0x38,
  0x07, 0xf9, 0x1a, 0xf6, 0x27, 0x6c, 0xb0, 0x63, 0x70, 0xbc, 0xae, 0xcd, 0x22, 0x6a, 0x7e, 0x86,
  0x92, 0x05, 0x0c, 0x0a, 0x3b, 0xb3, 0xc7, 0x45, 0xfd, 0x10, 0x45, 0xbf, 0x67, 0x47, 0xe6, 0xc6,
  0x98, 0x20, 0x88, 0xe2, 0x20, 0xcb, 0x1e, 0x22, 0x68, 0x0a, 0xd3, 0x3e, 0x26, 0x7a, 0xe6, 0x24,
  0xfb, 0xb7, 0x5a, 0x6d, 0xc7, 0xe8, 0xdc, 0x2a, 0xac, 0x30, 0x63, 0x3c, 0xf8, 0xdb, 0xa8, 0x71,
  0xd9, 0x37, 0x37, 0xee, 0x6c, 0x20, 0x40, 0x94, 0xd6, 0x5b, 0x50, 0x34, 0xe3, 0x09, 0x7d, 0x9b,
  0xa2, 0xa6, 0x6c, 0x1c, 0x7d, 0x23, 0x80, 0x45, 0x20, 0x62, 0xa0, 0x3e, 0x18, 0x82, 0xa3, 0x23,
  0x40, 0x4c, 0x4b, 0xab, 0xb5, 0x08, 0x1f, 0x6c, 0x50, 0xeb, 0xfb, 0x6b, 0xec, 0x3e, 0x5f, 0x22,
  0xad, 0xd9, 0x4a, 0xab, 0x8a, 0x46, 0xc9, 0x00, 0xee, 0x2b, 0xa5, 0x5f, 0x5f, 0xa2, 0xba, 0x6e,
  0x75, 0x86, 0xfa, 0x7e, 0x50, 0xe0, 0x94, 0x5a, 0x51, 0x80, 0x93, 0x17, 0xd0, 0x69, 0x2c, 0x48,
  0xa9, 0x78, 0xba, 0xa1, 0x34, 0x94, 0xd1, 0xa9, 0xad, 0x97, 0x7e, 0x72, 0x97, 0xd3, 0x7d, 0xb9,
  0x60, 0xc4, 0x5c, 0xcb, 0xbc, 0x1d, 0xc1, 0xb8, 0x90, 0x57, 0xed, 0x28, 0x8c, 0xfd, 0x41, 0xd4,
  0x61, 0xa8, 0x6a, 0x64, 0x1e, 0x5f, 0x24, 0xd7, 0x86, 0x50, 0x44, 0xc8, 0x36, 0x97, 0xa4, 0x66,
  0x1f, 0xc7, 0xdc, 0xfc, 0x59, 0xc6, 0x1d, 0xbf, 0x0e, 0xf3, 0x0b, 0x43, 0x38, 0x29, 0xfc, 0x02,
  0x8b, 0x86, 0x5f, 0xa0, 0xe0, 0x69, 0x3c, 0x9c, 0xd7, 0x03, 0x14, 0x37, 0xc9, 0x4a, 0xec, 0x1d,
  0x7e, 0x1e, 0x66, 0x05, 0x83, 0xc7, 0x4e, 0xdd, 0xdf, 0xe7, 0x75, 0x30, 0xc5, 0x9b, 0xc2, 0x13,
  0x0b, 0xd2, 0x14, 0x34, 0x50, 0x37, 0xee, 0x8b, 0xa4, 0xa7, 0x46, 0x07, 0xee, 0xb1, 0xc1, 0x78,
  0x75, 0xf4, 0x1e, 0x6f, 0xdf, 0xcd, 0xfd, 0x78, 0x2a, 0x19, 0xaa, 0x0c, 0x95, 0x5e, 0x66, 0xee,
  0xb2, 0xb4, 0xbf, 0x08, 0xb5, 0xf8, 0xe9, 0xcd, 0xdf, 0xec, 0xaa, 0xdf, 0xec, 0xb2, 0x6f, 0x72,
  0x58, 0xad, 0xda, 0x12, 0x40, 0xb2, 0xb4, 0xb0, 0xf3, 0xc4, 0x78, 0xff, 0xa6, 0x69, 0x93, 0x29,
  0x38, 0xcd, 0xb4, 0xbc, 0xe3, 0xc8, 0x3d, 0x86, 0x46, 0x0b, 0xc3, 0xc7, 0xa9, 0x3b, 0x4d, 0x6f,
  0xdf, 0xa5, 0x9d, 0xa6, 0x2b, 0x77, 0x1a, 0x9c, 0xf0, 0xa0, 0x0f, 0xf2, 0xd5, 0x07, 0xc5, 0x7c,
  0x71, 0x64, 0xd9, 0xab, 0x61, 0x53, 0xf3, 0x68, 0x88, 0x36, 0x65, 0xd9, 0xe8, 0x81, 0x7f, 0xc4,
  0x38, 0x36, 0x82, 0x98, 0x3d, 0x68, 0x31, 0x10, 0x96, 0x19, 0x1a, 0x03, 0xa2, 0x53, 0x41, 0xa2,
  0x9c, 0x36, 0x19, 0x0d, 0xa1, 0xe1, 0x84, 0x6d, 0x83, 0xe6, 0x4a, 0x03, 0x52, 0x66, 0x1d, 0xda,
  0x79, 0xa8, 0x7d, 0x34, 0x80, 0x3b, 0xad, 0xa0, 0xb5, 0x33, 0xe5, 0xe1, 0xb2, 0x24, 0x92, 0xf3,
  0x91, 0x45, 0xe9, 0x0f, 0xb6, 0x54, 0xe0, 0x38, 0x33, 0x34, 0x68, 0x63, 0xa7, 0x65, 0x69, 0x8d,
  0x15, 0xcd, 0xb3, 0xfb, 0x4d, 0x8d, 0x51, 0x87, 0x89, 0xf2, 0x1e, 0x31, 0x73, 0x8d, 0x39, 0x3c,
  0x24, 0x5c, 0xca, 0x1d, 0xad, 0x67, 0xf5, 0xe4, 0x75, 0xed, 0xa7, 0xa2, 0xcf, 0xe6, 0x98, 0xc5,
  0x66, 0x02, 0xb9, 0xb4, 0xa0, 0x0f, 0x7c, 0xcf, 0x66, 0x4c, 0xa9, 0x41, 0x8c, 0x91, 0xce, 0x93,
  0x80, 0xda, 0xb0, 0xe3, 0x1c, 0xd7, 0x99, 0xaa, 0x3a, 0x2b, 0x49, 0xd1, 0x8d, 0xe6, 0xa4, 0x45,
  0xc5, 0x98, 0x54, 0x0d, 0xcc, 0x5d, 0x11, 0xa5, 0x16, 0xd5, 0xd3, 0x05, 0x3c, 0x57, 0x60, 0xe3,
  0x56, 0x48, 0x3c, 0x0f, 0x59, 0xf3, 0xb9, 0x98, 0x61, 0xb9, 0x22, 0x4e, 0x76, 0x05, 0x8c, 0x4e,
  0x37, 0x5f, 0xc8, 0x0b, 0xb6, 0x67, 0x95, 0x06, 0x45, 0x68, 0x04, 0xba, 0x35, 0x05, 0xeb, 0x59,
  0x23, 0x56, 0xe9, 0x32, 0x14, 0x6a, 0xa9, 0x92, 0xc4, 0x1d, 0x8e, 0x5b, 0x5a, 0x2b, 0x4f, 0x91,
  0xea, 0xba, 0xe2, 0x70, 0x82, 0xe4, 0x6b, 0x8c, 0x45, 0xaa, 0xf2, 0x12, 0x8f, 0x89, 0xa9, 0x8a,
  0x4b, 0x8d, 0x70, 0xe5, 0x8a, 0x79, 0x45, 0x27, 0xe4, 0x68, 0xed, 0xba, 0xdb, 0x08, 0x96, 0x5c,
  0xa3, 0x11, 0xd8, 0x2d, 0x62, 0xd8, 0x42, 0x40, 0xb5, 0x26, 0x37, 0x29, 0x3e, 0xda, 0x35, 0x39,
  0x3e, 0x4b, 0x15, 0xb8, 0x3e, 0x0f, 0xf0, 0xce, 0xef, 0xa0, 0x55, 0xad, 0xee, 0xaa, 0x40, 0x0c,
  0x57, 0x77, 0x92, 0x92, 0x39, 0x1c, 0x2a, 0xad, 0x18, 0xbd, 0x81, 0x97, 0x3d, 0xdf, 0xdf, 0xdf,
  0x6b, 0x33, 0x76, 0xe6, 0xb6, 0x7b, 0xb0, 0x23, 0x05, 0x0b, 0x78, 0xe8, 0xaa, 0x52, 0x36, 0x99,
  0x01, 0x2a, 0x33, 0x23, 0x58, 0x5f, 0xd9, 0x0a, 0xd0, 0xe9, 0x4a, 0xe1, 0xf6, 0x71, 0xed, 0x90,
  0xad, 0x70, 0xeb, 0x5b, 0xf1, 0x79, 0xa3, 0x46, 0x68, 0x86, 0x03, 0xd6, 0x96, 0x6c, 0x83, 0x79,
  0xf7, 0xa7, 0xea, 0x31, 0x1a, 0x33, 0x34, 0x3d, 0x62, 0xde, 0x85, 0x89, 0x76, 0xcd, 0xbc, 0xa7,
  0xbf, 0xab, 0x61, 0x3a, 0x1a, 0x96, 0x17, 0xe7, 0x0d, 0x18, 0xb9, 0xfd, 0xa0, 0x3b, 0x52, 0x5c,
  0xce, 0x78, 0xc0, 0x68, 0xcc, 0x65, 0xf8, 0x7c, 0x75, 0x1b, 0xa4, 0x41, 0x6f, 0xa1, 0x21, 0x81,
  0xf7, 0xdf, 0xd5, 0xfa, 0xef, 0x9e, 0x1e, 0xb8, 0x85, 0x51, 0xa5, 0xfc, 0xce, 0xcb, 0xd3, 0xba,
  0xa3, 0xf2, 0xbf, 0x2a, 0x13, 0xe2, 0x7c, 0x7c, 0x23, 0x36, 0x24, 0x8e, 0x00, 0xba, 0xae, 0x5b,
  0x62, 0x49, 0x74, 0xf5, 0x4b, 0xe3, 0x4a, 0xaa, 0xad, 0xcb, 0xb5, 0xed, 0x92, 0xbd, 0xfe, 0x31,
  0x1c, 0xf6, 0x71, 0xe6, 0x7a, 0xb9, 0xb7, 0x6c, 0x66, 0xb0, 0x3f, 0xa4, 0xbb, 0x0c, 0x92, 0x17,
  0xeb, 0x61, 0x02, 0x1e, 0xf7, 0xe1, 0xa8, 0xf2, 0xe5, 0x3f, 0x97, 0x54, 0xb5, 0x3f, 0xeb, 0xba,
  0x9a, 0xf8, 0xb6, 0x9c, 0x02, 0xed, 0xc0, 0xa0, 0x70, 0x4a, 0x20, 0x21, 0xb2, 0xd9, 0xe2, 0x7d,
  0x56, 0xc8, 0x9e, 0x85, 0x11, 0x6c, 0xd0, 0x90, 0xad, 0xc6, 0x92, 0x94, 0x3f, 0x88, 0xb1, 0xc3,
  0x8b, 0xf6, 0xea, 0x8a, 0x52, 0x91, 0x3e, 0xaf, 0x41, 0x6b, 0x34, 0x9d, 0x72, 0x07, 0x35, 0x73,
  0x2c, 0x90, 0xdd, 0xf2, 0x06, 0xab, 0x9b, 0x27, 0xa1, 0x03, 0xa0, 0x20, 0x22, 0x22, 0x2c, 0xf3,
  0x60, 0x7a, 0x8c, 0x19, 0xad, 0x75, 0x75, 0xd9, 0xa2, 0x9a, 0x66, 0xe4, 0x7b, 0x19, 0xbe, 0x52,
  0x8e, 0x26, 0x5d, 0xae, 0x3b, 0x39, 0x5d, 0x95, 0xa0, 0xaf, 0x59, 0xc4, 0x03, 0xc2, 0xbd, 0x66,
  0xae, 0xe7, 0x08, 0xf0, 0x8b, 0x90, 0xe1, 0x31, 0x5e, 0x5e, 0xec, 0xc7, 0x20, 0xc8, 0xaf, 0xec,
  0x81, 0xea, 0x57, 0x95, 0xdb, 0xe5, 0xcf, 0x30, 0x04, 0x57, 0xc5, 0x0d, 0x8d, 0xee, 0xf1, 0x41,
  0x1d, 0x01, 0xd5, 0xd1, 0x8c, 0xb4, 0x17, 0x28, 0xf3, 0xb8, 0x5a, 0x39, 0xe8, 0xfa, 0x5b, 0xac,
  0x1e, 0x16, 0x14, 0x64, 0x0d, 0x35, 0x28, 0x83, 0xcb, 0x9c, 0x24, 0xe2, 0xc7, 0xc1, 0x1b, 0x66,
  0x8f, 0x82, 0x37, 0x14, 0xae, 0x5e, 0xe2, 0xd0, 0xa8, 0xb1, 0x08, 0x28, 0x66, 0x8a, 0x29, 0xd7,
  0x6f, 0xce, 0x38, 0x0f, 0x95, 0x7c, 0x89, 0xb7, 0xd9, 0x30, 0x39, 0xa1, 0xa7, 0x0c, 0x6f, 0xdc,
  0xcf, 0x1d, 0x16, 0x2d, 0x0e, 0xa6, 0x0b, 0xaf, 0x18, 0x55, 0x0e, 0x7e, 0x63, 0x0c, 0xe2, 0x90,
  0x01, 0x8f, 0xba, 0xea, 0x47, 0xce, 0x3c, 0xec, 0xfb, 0x4e, 0x12, 0xf7, 0x45, 0x88, 0xc9, 0xe0,
  0xd4, 0x19, 0xa7, 0x61, 0xff, 0xe1, 0x61, 0xa0, 0xd0, 0x16, 0x72, 0xdc, 0x60, 0x4e, 0x93, 0xd5,
  0x6a, 0xb0, 0x0e, 0x72, 0x52, 0x01, 0x69, 0x4c, 0x1f, 0x0b, 0xd2, 0x38, 0x79, 0x24, 0x48, 0xa3,
  0xb3, 0xd8, 0xa0, 0x40, 0x32, 0x53, 0x66, 0x92, 0x28, 0x1d, 0xbe, 0xe9, 0xa5, 0x0e, 0x7b, 0x86,
  0xea, 0xbc, 0x09, 0x7f, 0x4e, 0x66, 0xde, 0x62, 0xc5, 0x1e, 0x81, 0x06, 0xc9, 0xab, 0x9e, 0x85,
  0x40, 0x0d, 0x74, 0xff, 0xc2, 0x50, 0x3d, 0x0d, 0xfa, 0x27, 0xb5, 0xfe, 0x93, 0x5a, 0xff, 0xf3,
  0x50, 0x2b, 0xf7, 0xab, 0xf8, 0x87, 0xa2, 0xd6, 0x12, 0x29, 0x90, 0x61, 0x2c, 0xbb, 0xbf, 0xdf,
  0xaa, 0xa4, 0x67, 0x07, 0x5e, 0x6c, 0x4f, 0xc5, 0xc6, 0x43, 0xf7, 0xfd, 0x38, 0x91, 0x7f, 0x05,
  0xa9, 0x6d, 0x4e, 0x18, 0xfe, 0x63, 0x09, 0x23, 0x79, 0x2c, 0x61, 0x84, 0x8f, 0x24, 0x8c, 0x48,
  0x12, 0x86, 0xef, 0x44, 0x92, 0x30, 0x12, 0xfe, 0x0c, 0x84, 0x11, 0xae, 0x54, 0x0a, 0xd0, 0x91,
  0xbe, 0xe4, 0xc6, 0x5d, 0x44, 0x1c, 0x52, 0x45, 0xfc, 0x3f, 0x25, 0x4b, 0x10, 0xa1, 0x83, 0x29,
  0x1a, 0xad, 0x2e, 0xd0, 0x70, 0x33, 0x5f, 0x46, 0x79, 0x08, 0x8a, 0x4f, 0x11, 0x7e, 0x09, 0xde,
  0xf0, 0x33, 0x47, 0x10, 0x3d, 0x48, 0xf0, 0x97, 0x18, 0xab, 0xc1, 0xa9, 0xb7, 0xd5, 0x75, 0x44,
  0xcd, 0xbb, 0xbb, 0x4e, 0x93, 0x74, 0x80, 0x33, 0xe3, 0xb2, 0x9d, 0x5f, 0x47, 0x44, 0xc0, 0xa0,
  0x7d, 0xcd, 0x52, 0x05, 0xf2, 0x87, 0xcd, 0x38, 0x5a, 0x59, 0xaa, 0x90, 0xf1, 0xf1, 0xd6, 0x56,
  0xde, 0x7b, 0xb3, 0xb6, 0xfa, 0xde, 0x9b, 0xb5, 0x1f, 0xf8, 0x29, 0x5c, 0x53, 0x3b, 0x30, 0xb5,
  0x8d, 0x58, 0x6c, 0x4d, 0xbd, 0x2c, 0xde, 0xdd, 0x9a, 0x86, 0xe3, 0xfb, 0x35, 0x0d, 0xc7, 0xd7,
  0x6b, 0x3f, 0xc0, 0xe3, 0x48, 0x37, 0x7f, 0x01, 0x98, 0xf1, 0x56, 0xc1, 0x8d, 0xb5, 0x2b, 0x06,
  0x45, 0x04, 0xe8, 0xe6, 0xe2, 0x8f, 0xe7, 0xde, 0xfa, 0x2d, 0x06, 0x19, 0x41, 0x3e, 0x60, 0x30,
  0x48, 0xaa, 0x64, 0x7b, 0x37, 0x4b, 0x7f, 0xef, 0x9b, 0xb9, 0x09, 0x0b, 0x9a, 0x41, 0xb8, 0x78,
  0x01, 0xe1, 0x74, 0x13, 0x7e, 0xc1, 0xd4, 0x0b, 0x14, 0x20, 0xb0, 0xc0, 0x53, 0x00, 0x6d, 0x18,
  0x42, 0x9d, 0x82, 0x0e, 0xc6, 0x2f, 0xee, 0x40, 0xb5, 0x51, 0x92, 0xf6, 0xbb, 0x2b, 0x5b, 0xe7,
  0xa3, 0xba, 0xf4, 0x9b, 0xff, 0xc6, 0xdb, 0xc2, 0xbd, 0x08, 0xe0, 0x09, 0x2f, 0xca, 0x8d, 0x02,
  0x75, 0x29, 0xeb, 0x37, 0x61, 0x77, 0xbe, 0x63, 0x10, 0x8c, 0x46, 0x19, 0x24, 0xb2, 0xcf, 0x27,
  0x66, 0x47, 0x86, 0xdf, 0xda, 0xb8, 0xa8, 0xb8, 0x3e, 0xbb, 0xd3, 0x0a, 0x54, 0xd0, 0x4d, 0x8e,
  0xc9, 0x58, 0xb9, 0x51, 0x2e, 0xaa, 0x51, 0xf1, 0x23, 0x33, 0x60, 0xac, 0xeb, 0xf1, 0x35, 0xab,
  0x57, 0x7a, 0x45, 0x35, 0x65, 0xf0, 0xc8, 0xe0, 0x01, 0x5c, 0xcd, 0x1a, 0x76, 0x30, 0xbb, 0x29,
  0x28, 0xa3, 0x34, 0xed, 0x45, 0x68, 0x1d, 0x39, 0xd6, 0x9b, 0x8e, 0xf4, 0xda, 0x3b, 0xc7, 0x9b,
  0x8c, 0xf7, 0x46, 0x97, 0x96, 0xeb, 0x46, 0x3d, 0xae, 0x19, 0x75, 0x19, 0x82, 0x47, 0x19, 0xf6,
  0x58, 0x87, 0x8c, 0xde, 0x68, 0xd8, 0xb5, 0x50, 0x3e, 0xdf, 0x38, 0xee, 0x50, 0x57, 0x3f, 0x28,
  0x0f, 0x37, 0xae, 0xe2, 0xd2, 0x22, 0x5e, 0xbf, 0x74, 0xab, 0xd0, 0x61, 0x76, 0xa9, 0xca, 0xe2,
  0x12, 0x71, 0xb9, 0xe6, 0x02, 0x30, 0xec, 0xe1, 0x0f, 0x54, 0x11, 0xc7, 0xca, 0xdf, 0x21, 0x10,
  0x14, 0xab, 0x8e, 0x03, 0x65, 0x37, 0x0f, 0xd7, 0xaf, 0x41, 0xa8, 0xd8, 0x35, 0x1c, 0x52, 0x82,
  0xa4, 0xd4, 0x7e, 0x22, 0xbc, 0xd9, 0xa4, 0x0b, 0x25, 0x98, 0x95, 0xba, 0xcf, 0x7c, 0x48, 0xaa,
  0x5c, 0x18, 0xb9, 0x51, 0x50, 0xea, 0x2d, 0x47, 0x7e, 0xaa, 0x6d, 0xcc, 0xa4, 0xbb, 0x41, 0x6b,
  0x4a, 0xd0, 0x51, 0x95, 0x85, 0xc7, 0xc1, 0xa2, 0xea, 0x3f, 0xd0, 0xdb, 0xf8, 0x03, 0xbd, 0x07,
  0x3e, 0xb0, 0x57, 0xff, 0x81, 0xbd, 0x8d, 0x3f, 0xb0, 0xd7, 0xf8, 0x01, 0xe6, 0xc6, 0xa9, 0x98,
  0x41, 0x16, 0x19, 0x0c, 0xe3, 0x20, 0xcc, 0x84, 0xa3, 0x0f, 0xbc, 0xa2, 0x8d, 0x22, 0x89, 0xf1,
  0x02, 0xa9, 0xa3, 0xc8, 0x40, 0x1f, 0x12, 0x7f, 0x8a, 0x90, 0xa1, 0x0b, 0xe1, 0x09, 0x2a, 0x4e,
  0xae, 0x5b, 0xa6, 0x61, 0x99, 0x78, 0xb0, 0x62, 0x9b, 0x6b, 0x36, 0x07, 0x3a, 0x26, 0xa3, 0xc3,
  0x09, 0x6b, 0xcb, 0x5a, 0xbc, 0x5f, 0xeb, 0x23, 0xc5, 0x0e, 0xfe, 0xe4, 0xb6, 0x67, 0xdf, 0xdf,
  0x2f, 0xde, 0x1f, 0x74, 0xb1, 0x61, 0x50, 0xb0, 0xe9, 0x3c, 0xcf, 0x76, 0x08, 0xd5, 0x69, 0xf1,
  0xb1, 0xc9, 0x52, 0x96, 0xdf, 0x48, 0xf9, 0x9d, 0xaa, 0xfa, 0xe8, 0xe1, 0x81, 0x96, 0xf4, 0x70,
  0x32, 0x0b, 0x27, 0x57, 0xbb, 0xb5, 0x78, 0x2f, 0x6e, 0xb7, 0xdf, 0x35, 0x88, 0xc4, 0x75, 0xc6,
  0x37, 0x3b, 0x1f, 0xe1, 0x05, 0x60, 0x5e, 0x63, 0xe1, 0x78, 0xe5, 0xc4, 0x6c, 0x3c, 0xf1, 0x2f,
  0x05, 0xe3, 0x84, 0x5c, 0xe1, 0xb8, 0xa9, 0x9d, 0xe4, 0x5c, 0xa1, 0x28, 0x8d, 0x71, 0x3b, 0x6b,
  0xcc, 0x9b, 0xe9, 0x79, 0x15, 0xf9, 0x3f, 0x6b, 0x2a, 0xe2, 0x2f, 0xa4, 0x40, 0x31, 0xc8, 0xd3,
  0xdb, 0xbb, 0x58, 0x85, 0xbe, 0xcc, 0xec, 0x15, 0xbb, 0x50, 0xca, 0x80, 0x57, 0xe3, 0xf6, 0x75,
  0x18, 0x7b, 0x99, 0x53, 0x38, 0x48, 0x0a, 0xe4, 0x3a, 0xbc, 0x06, 0xdf, 0x34, 0x2a, 0x78, 0x26,
  0xa7, 0x85, 0x6e, 0x30, 0xb7, 0xbf, 0x7b, 0xf9, 0xe2, 0xc5, 0x8b, 0x81, 0xc1, 0x4d, 0xe5, 0x01,
  0x39, 0x36, 0xdc, 0xe2, 0xbd, 0x50, 0xe5, 0x74, 0x9a, 0xd9, 0xcc, 0xd9, 0xbd, 0xfb, 0xac, 0x00,
  0xdf, 0xb8, 0x33, 0xed, 0xe1, 0x6e, 0xf7, 0xdb, 0xbe, 0x7b, 0x7c, 0x1b, 0xe7, 0xfe, 0x0d, 0x47,
  0x37, 0x0b, 0x63, 0x63, 0x42, 0xcb, 0xc4, 0xc0, 0x8e, 0xab, 0x2d, 0x60, 0xdf, 0x46, 0x4d, 0xab,
  0xf8, 0x3c, 0x6b, 0xb2, 0x69, 0xff, 0x55, 0x3a, 0xce, 0x6d, 0xe3, 0x74, 0xf9, 0x73, 0xe1, 0x9f,
  0x07, 0xc6, 0x98, 0x10, 0x6b, 0x8c, 0x79, 0x32, 0x0d, 0x67, 0xb7, 0xb8, 0xba, 0xe8, 0x06, 0xa9,
  0x38, 0x59, 0x5d, 0x31, 0x7a, 0x81, 0x3f, 0x0b, 0x5c, 0x3f, 0xde, 0xe2, 0x3d, 0x10, 0x03, 0xa8,
  0x9e, 0x1f, 0x07, 0x4d, 0x66, 0x0c, 0xee, 0xac, 0x21, 0x27, 0x38, 0x52, 0x20, 0x38, 0x60, 0x36,
  0xbf, 0x44, 0x5e, 0xa4, 0x2d, 0xea, 0x63, 0x9f, 0x60, 0x80, 0x71, 0x31, 0xb3, 0x65, 0xbc, 0x78,
  0x5f, 0x5d, 0xc7, 0x31, 0x86, 0x3a, 0x4b, 0x46, 0xcc, 0x73, 0xfc, 0x64, 0xf1, 0xfe, 0xd4, 0x8b,
  0x1d, 0xcd, 0xdd, 0x1c, 0x92, 0x58, 0x0b, 0xab, 0xc9, 0x49, 0x35, 0xe9, 0xaa, 0x9a, 0x84, 0x3e,
  0x60, 0x78, 0x54, 0x22, 0x3f, 0x70, 0x17, 0xf7, 0x17, 0x1f, 0x1d, 0x20, 0xbe, 0xbe, 0xd9, 0x34,
  0x74, 0x88, 0x7e, 0x17, 0x04, 0x6c, 0xc0, 0xe2, 0xe0, 0x3a, 0xba, 0x25, 0x1e, 0x33, 0x15, 0x73,
  0xd9, 0x36, 0x57, 0x0e, 0x91, 0x2f, 0x2e, 0x75, 0xf9, 0x21, 0x24, 0x67, 0x4a, 0xc5, 0x2e, 0x7d,
  0x89, 0xb4, 0x77, 0x5f, 0xf0, 0xa6, 0xfc, 0x97, 0xc8, 0x56, 0x6e, 0xf5, 0xf3, 0x5b, 0xfa, 0x38,
  0x1c, 0xc5, 0xe1, 0x85, 0x22, 0x82, 0x33, 0x77, 0x2d, 0x01, 0x53, 0x4c, 0x41, 0xf7, 0x84, 0xd3,
  0x34, 0xbe, 0x13, 0x34, 0xa3, 0xa7, 0x7a, 0xae, 0xa3, 0xba, 0x97, 0x9b, 0x9b, 0x3b, 0x78, 0x99,
  0x0c, 0x13, 0x12, 0xf5, 0xc4, 0x23, 0xbc, 0xeb, 0x51, 0xaa, 0xb7, 0xfb, 0x98, 0x7a, 0x45, 0x08,
  0x48, 0xbc, 0xfb, 0x64, 0x16, 0xbc, 0x6e, 0x2d, 0xfb, 0xd2, 0x89, 0x42, 0x61, 0xee, 0xbc, 0x41,
  0xfa, 0xae, 0x25, 0x2a, 0x42, 0x0c, 0xbb, 0x92, 0x0b, 0xf6, 0x83, 0xa7, 0x1a, 0x53, 0x34, 0x9b,
  0x0d, 0xb4, 0x01, 0x9d, 0xc4, 0xb3, 0x91, 0xa5, 0x7f, 0x00, 0x72, 0xa1, 0x10, 0xa0, 0xd3, 0x13,
  0xb4, 0xb7, 0x32, 0x7f, 0xe4, 0xcf, 0xcb, 0x8e, 0x1c, 0x26, 0x1c, 0x3b, 0x62, 0xe6, 0xba, 0xe6,
  0x63, 0xc6, 0x4b, 0x1c, 0x1f, 0x1f, 0x26, 0x31, 0xf0, 0xa9, 0x39, 0x57, 0xf6, 0xb1, 0x0a, 0xa5,
  0x81, 0x9e, 0x2e, 0xb9, 0x48, 0x30, 0x4d, 0x8c, 0x0e, 0x07, 0x3f, 0xbd, 0x60, 0x50, 0xed, 0xb5,
  0xee, 0xd7, 0x3f, 0x51, 0xdd, 0xfa, 0x63, 0x74, 0xeb, 0xcf, 0xed, 0xf5, 0x22, 0xf1, 0x20, 0x3f,
  0xc1, 0xba, 0x4f, 0xd7, 0x08, 0xba, 0x48, 0xbb, 0x14, 0xe3, 0xc1, 0x4a, 0xcf, 0xc7, 0xc7, 0x79,
  0xca, 0xc3, 0x22, 0x3a, 0x84, 0xf1, 0x69, 0x3b, 0xc0, 0xf0, 0x26, 0x18, 0x03, 0x82, 0x8d, 0x0d,
  0xe3, 0x1c, 0xdb, 0xdb, 0xe5, 0x30, 0x09, 0x8d, 0xa0, 0x98, 0xbf, 0x4a, 0x88, 0x3c, 0x0e, 0x36,
  0x4a, 0xcd, 0xd9, 0x28, 0xac, 0xc7, 0xaf, 0x26, 0xe9, 0x93, 0x5a, 0xd8, 0x4e, 0xba, 0x31, 0x83,
  0xfa, 0xe7, 0x85, 0xe7, 0x16, 0xf7, 0x5e, 0x16, 0x87, 0x1c, 0xcf, 0xd9, 0x4c, 0x81, 0x4f, 0x7b,
  0x18, 0xbe, 0x0b, 0xf4, 0x9f, 0xbb, 0x8b, 0xbe, 0xeb, 0x64, 0xf0, 0xdf, 0x55, 0xbf, 0xeb, 0xba,
  0x2b, 0xbb, 0x9d, 0xa9, 0xfe, 0xe8, 0xfb, 0xae, 0x1e, 0x15, 0xb2, 0xb5, 0xef, 0xda, 0x83, 0x69,
  0x72, 0x17, 0xb4, 0x2f, 0xd4, 0x6c, 0x7b, 0xcf, 0x4b, 0xf9, 0xec, 0x15, 0x74, 0x24, 0x0a, 0x2c,
  0x4a, 0xf4, 0xc7, 0x99, 0x05, 0x05, 0x76, 0xa9, 0x45, 0x18, 0xdc, 0xcb, 0x1e, 0xb0, 0xc6, 0x41,
  0xe2, 0xaa, 0x18, 0xd8, 0x80, 0x21, 0xa9, 0xe2, 0x00, 0x5a, 0x6e, 0x25, 0x54, 0x42, 0x31, 0x8a,
  0xfc, 0x8a, 0xad, 0x3a, 0xde, 0x30, 0x27, 0x4e, 0xde, 0x08, 0xd5, 0xf8, 0x09, 0x67, 0x58, 0xe2,
  0x09, 0xa7, 0xda, 0xb0, 0xd2, 0xdd, 0x02, 0xab, 0xb9, 0xec, 0x0f, 0xa6, 0x5d, 0x40, 0x11, 0x9f,
  0x97, 0x8a, 0xf6, 0xd6, 0x16, 0x7d, 0xad, 0x16, 0x1d, 0x97, 0x8a, 0xee, 0x09, 0xe1, 0x48, 0xed,
  0xc6, 0x45, 0x70, 0x73, 0x4c, 0x48, 0x36, 0x0a, 0x04, 0x55, 0x17, 0x4d, 0x9f, 0x2a, 0x55, 0x0c,
  0xb2, 0x21, 0x8f, 0x8e, 0x96, 0xb5, 0xf3, 0xe4, 0x98, 0xe7, 0x7a, 0x5e, 0x1b, 0xd6, 0x05, 0x2a,
  0x9c, 0x48, 0xd2, 0x8a, 0x1b, 0x32, 0xc4, 0xb3, 0x66, 0x7c, 0x18, 0x81, 0x37, 0xb7, 0xc7, 0xc1,
  0xf4, 0xa3, 0xc6, 0xde, 0xfe, 0x91, 0xee, 0xed, 0xb0, 0x2f, 0x55, 0x96, 0x02, 0xbf, 0xa9, 0x03,
  0xb4, 0xa6, 0x75, 0x77, 0x19, 0x00, 0xe5, 0xa9, 0x29, 0x99, 0x9f, 0x73, 0xc7, 0x11, 0x4e, 0x8e,
  0x4e, 0xe2, 0x85, 0x69, 0xd2, 0x3e, 0x64, 0xf9, 0xb3, 0xab, 0xcf, 0xc9, 0xa7, 0xf3, 0x31, 0xc6,
  0x4f, 0x0f, 0x3d, 0x8c, 0xa5, 0x02, 0xbb, 0x6d, 0xd2, 0x4e, 0x5b, 0xa6, 0x83, 0x7f, 0xcf, 0xf9,
  0xdf, 0x31, 0x6e, 0xbf, 0xd0, 0x96, 0x6f, 0x89, 0xfa, 0x46, 0x72, 0x7e, 0xb2, 0x08, 0x52, 0x50,
  0xcc, 0x4c, 0x0c, 0x30, 0x67, 0x3a, 0xa1, 0x1e, 0x66, 0x27, 0x6a, 0x5e, 0xcd, 0xff, 0x2a, 0x87,
  0x5c, 0xed, 0xdb, 0x65, 0x10, 0x81, 0xa0, 0x50, 0x90, 0x35, 0x0c, 0x3d, 0xbb, 0x09, 0x59, 0x77,
  0x94, 0xbf, 0xe9, 0xbc, 0x3c, 0xb7, 0x4d, 0xa7, 0xbb, 0x07, 0x6b, 0xf9, 0x0a, 0x61, 0x64, 0x2e,
  0x83, 0x5b, 0x04, 0xe9, 0xdf, 0xde, 0xc6, 0x88, 0x06, 0x3f, 0x06, 0x37, 0x3a, 0x28, 0x2c, 0xbf,
  0x78, 0x09, 0xcb, 0xbe, 0xa6, 0x84, 0x34, 0xe0, 0x7f, 0x4b, 0x09, 0xf9, 0xd9, 0x9a, 0x28, 0x60,
  0x55, 0x82, 0x1c, 0xa8, 0x54, 0x5d, 0x28, 0x33, 0x81, 0x42, 0xfc, 0xcf, 0x6d, 0x07, 0x28, 0x9b,
  0x64, 0xec, 0x82, 0x4f, 0x98, 0xdf, 0x21, 0x7a, 0xae, 0x0a, 0xd2, 0x06, 0xc4, 0xcf, 0x65, 0x6e,
  0x32, 0x3f, 0x17, 0x19, 0x67, 0x33, 0xdf, 0x87, 0x4d, 0xca, 0x5e, 0x31, 0xc0, 0x34, 0xf5, 0x83,
  0x76, 0x81, 0xec, 0xcc, 0x1a, 0xe0, 0x2a, 0xec, 0xa7, 0x57, 0x52, 0xf9, 0x04, 0x83, 0xe2, 0x3b,
  0x2e, 0xe2, 0x7e, 0x49, 0xb2, 0xc4, 0x23, 0x03, 0xce, 0x5d, 0x40, 0xad, 0xd2, 0xa8, 0x39, 0xc0,
  0xa8, 0xda, 0xfd, 0x52, 0xd2, 0xe1, 0x85, 0x0f, 0x1b, 0x66, 0x04, 0x63, 0x91, 0x5d, 0x01, 0xc1,
  0xc2, 0x7f, 0x6e, 0x69, 0x08, 0xff, 0x08, 0x03, 0xf8, 0x60, 0xa1, 0x35, 0xeb, 0xb0, 0x72, 0xd7,
  0x09, 0x2b, 0xfd, 0xd7, 0x6a, 0xa5, 0xd6, 0x1d, 0xa3, 0xc9, 0xfe, 0x83, 0x84, 0xbc, 0x2a, 0x55,
  0x86, 0x8b, 0x50, 0x1d, 0x69, 0x1e, 0xbf, 0x77, 0x0d, 0x03, 0xe6, 0xf5, 0x38, 0xcd, 0x99, 0x7e,
  0xd8, 0x24, 0xd3, 0xeb, 0xa2, 0x45, 0x67, 0x25, 0xbd, 0x9f, 0xcf, 0xc5, 0x5d, 0x97, 0x0c, 0xb5,
  0xb8, 0x21, 0xb3, 0x18, 0xc4, 0x34, 0xbb, 0x04, 0x9b, 0x57, 0x4e, 0xeb, 0xd6, 0xa4, 0xf5, 0x20,
  0xed, 0xc1, 0xb1, 0xa7, 0xd0, 0xc5, 0xbd, 0x2d, 0x32, 0x08, 0xd7, 0x13, 0xf1, 0x83, 0x1b, 0xbd,
  0x2d, 0x02, 0xf1, 0x94, 0xb6, 0xb1, 0x81, 0xda, 0x1a, 0xef, 0x04, 0xa4, 0x15, 0x10, 0x8f, 0xce,
  0xe1, 0xbf, 0xb1, 0xa3, 0x7e, 0xe9, 0x54, 0x80, 0x8e, 0x93, 0xfc, 0x21, 0x64, 0x4f, 0x66, 0xe4,
  0x48, 0xa2, 0xfe, 0xc9, 0xc9, 0xa9, 0x43, 0xff, 0x7f, 0x8a, 0xd6, 0x6b, 0x32, 0x59, 0x23, 0x60,
  0x39, 0xab, 0x54, 0xfd, 0x42, 0xb3, 0x3c, 0x1a, 0xe4, 0xaf, 0xfd, 0x08, 0x7d, 0x4c, 0xeb, 0xcd,
  0xef, 0x93, 0x49, 0x5e, 0xb6, 0xaf, 0x62, 0x23, 0x2e, 0x26, 0xaa, 0xc4, 0x81, 0xe1, 0x04, 0x7e,
  0xf8, 0x11, 0x03, 0x5e, 0x30, 0x9f, 0x14, 0xfc, 0x2d, 0x82, 0x5c, 0x74, 0x3a, 0xe7, 0x61, 0x7e,
  0xb1, 0x1c, 0xe3, 0x11, 0x5a, 0x07, 0xd8, 0x3e, 0x7a, 0x9d, 0x74, 0x30, 0xba, 0x4a, 0xe7, 0x3a,
  0xbc, 0x0c, 0x61, 0xc9, 0x72, 0xe3, 0x58, 0x0a, 0xc3, 0xa5, 0xc1, 0x78, 0x09, 0x68, 0x11, 0xcb,
  0xba, 0x98, 0xb4, 0xbc, 0xee, 0x0b, 0x7b, 0xb8, 0xe7, 0xe2, 0x86, 0x88, 0x9f, 0xb6, 0x9d, 0x8b,
  0xc9, 0xb0, 0x27, 0x7e, 0xee, 0xb9, 0xc8, 0x3f, 0x9e, 0x3d, 0xf3, 0xbc, 0x8b, 0x09, 0xa5, 0xb4,
  0xbc, 0x3d, 0x4c, 0x71, 0x5f, 0x28, 0x29, 0x50, 0x41, 0xed, 0xbe, 0xe8, 0xa7, 0xb9, 0x64, 0xbf,
  0x4c, 0xe0, 0x3d, 0xbb, 0xc8, 0xd0, 0x6b, 0xee, 0x62, 0xb2, 0x72, 0x0c, 0x84, 0x14, 0x71, 0x8c,
  0x7d, 0xf7, 0x0f, 0x48, 0x86, 0xb6, 0xf3, 0xb2, 0xcb, 0x91, 0xc2, 0x80, 0x69, 0xa7, 0x1a, 0x18,
  0x21, 0x24, 0x7c, 0x22, 0x7b, 0x11, 0x8b, 0xa4, 0x81, 0xef, 0x9b, 0xb9, 0x23, 0xc9, 0xda, 0x20,
  0x33, 0x9b, 0xf6, 0x40, 0xc6, 0x77, 0xa9, 0x11, 0xb9, 0x03, 0x1d, 0x69, 0x92, 0x09, 0xd3, 0x9f,
  0x82, 0x71, 0x92, 0x70, 0xf5, 0xc6, 0x62, 0xcd, 0x00, 0xbe, 0x52, 0x89, 0x08, 0x02, 0x3a, 0xa0,
  0x67, 0x76, 0xb8, 0x57, 0xb4, 0x68, 0xf1, 0xb1, 0x8e, 0x9f, 0x08, 0x6c, 0x3d, 0x5b, 0xc3, 0xc3,
  0xd3, 0x8c, 0x35, 0x51, 0xf4, 0xe7, 0xd8, 0x7e, 0x74, 0x63, 0xd9, 0xf7, 0x8b, 0xb6, 0x1e, 0x13,
  0xd4, 0x9a, 0x68, 0x8a, 0x53, 0xa9, 0x68, 0x36, 0x2b, 0x55, 0x44, 0x63, 0x2a, 0x4f, 0x0e, 0x05,
  0x76, 0x10, 0xf3, 0x48, 0xba, 0x63, 0xc7, 0xb4, 0x2e, 0x3b, 0x0c, 0x14, 0x97, 0xe9, 0xe9, 0xd8,
  0x7e, 0xcb, 0x5d, 0x29, 0xfe, 0x4a, 0x81, 0xd7, 0x1d, 0x04, 0xdc, 0x5f, 0x29, 0x28, 0xf9, 0x2b,
  0xf1, 0x83, 0xc4, 0x66, 0x47, 0xa5, 0x0a, 0xd4, 0x9c, 0x38, 0x42, 0x2a, 0x87, 0x9e, 0x67, 0x83,
  0xc3, 0x5b, 0x58, 0x0f, 0xb4, 0x7e, 0x1d, 0x11, 0x5a, 0xe7, 0x8d, 0xc9, 0xaf, 0x5e, 0xe3, 0x7e,
  0xa7, 0x85, 0x53, 0xc9, 0xed, 0x81, 0xc0, 0x9a, 0xa4, 0x1c, 0x18, 0x2a, 0xe8, 0x0a, 0x03, 0x3c,
  0xc8, 0x43, 0x26, 0xf8, 0x25, 0xa6, 0x41, 0xfd, 0x3a, 0x28, 0x7f, 0x0b, 0x36, 0xcc, 0xc0, 0xab,
  0x02, 0x4b, 0xdd, 0x27, 0x57, 0x5a, 0xbe, 0xbb, 0x95, 0x73, 0x2e, 0x8f, 0x45, 0x58, 0x87, 0x5c,
  0x47, 0x87, 0xd6, 0x53, 0x5a, 0x9e, 0x55, 0x5a, 0xee, 0x94, 0x70, 0x18, 0xef, 0x16, 0x7d, 0xb5,
  0x7e, 0x07, 0xda, 0xd7, 0x57, 0x1b, 0xbb, 0xaa, 0x6a, 0x2d, 0x4e, 0xa0, 0x01, 0xca, 0x05, 0x08,
  0x23, 0xa7, 0xc5, 0x21, 0x2e, 0x37, 0x50, 0xbd, 0xaf, 0xc9, 0xa0, 0x32, 0xe1, 0x93, 0x37, 0x23,
  0x34, 0x6d, 0x78, 0x88, 0x15, 0xc5, 0xb0, 0xf1, 0xe2, 0x1a, 0xa4, 0xcc, 0x78, 0x25, 0xa3, 0x32,
  0xc7, 0x7a, 0x54, 0xe6, 0x6f, 0x00, 0x7f, 0xfc, 0x4a, 0xd4, 0x47, 0x6d, 0x1a, 0x38, 0xd0, 0x00,
  0x8f, 0xd9, 0x0d, 0x93, 0xa2, 0x0d, 0x62, 0xdc, 0x5e, 0x40, 0x1d, 0x07, 0x71, 0x7b, 0x3e, 0xaa,
  0x8c, 0x45, 0xab, 0x0b, 0xa3, 0xd1, 0xcf, 0xad, 0x6f, 0x0f, 0xf7, 0xcc, 0x40, 0xba, 0xd5, 0xa0,
  0xc6, 0xb4, 0x63, 0x81, 0xb2, 0xf1, 0xcb, 0x02, 0x24, 0xe2, 0x43, 0x1f, 0xc3, 0x21, 0xc9, 0xa8,
  0xca, 0x02, 0xc2, 0xb0, 0xf9, 0x96, 0x3d, 0xd6, 0xb6, 0x3b, 0xa1, 0xeb, 0x0a, 0xcc, 0x8b, 0xd4,
  0xae, 0xde, 0xe8, 0xcf, 0x85, 0x75, 0xb4, 0x2b, 0xdd, 0x22, 0xb9, 0x23, 0xa2, 0x8c, 0xe1, 0xa5,
  0x7f, 0x4e, 0xff, 0xa5, 0x1d, 0x68, 0xbd, 0x8a, 0x60, 0xaf, 0xa6, 0xa3, 0x2c, 0x6e, 0x07, 0x08,
  0x11, 0x8e, 0xa9, 0xc0, 0x69, 0x08, 0x05, 0x4e, 0x43, 0xe6, 0xc5, 0x27, 0x21, 0xe8, 0x53, 0x95,
  0x28, 0x78, 0x32, 0xce, 0x3d, 0x37, 0x44, 0x7e, 0x0e, 0x6e, 0x72, 0xbd, 0xfb, 0xd2, 0xb8, 0x99,
  0xa3, 0x65, 0x75, 0x94, 0x95, 0x9d, 0x31, 0xcd, 0x7e, 0x56, 0x0f, 0xf9, 0xac, 0x84, 0xe7, 0xa2,
  0x11, 0x39, 0xae, 0x0c, 0xf6, 0x63, 0x86, 0x95, 0xc7, 0x8f, 0x6e, 0x0b, 0x00, 0x21, 0x87, 0xcf,
  0x5d, 0x8e, 0xd7, 0xa8, 0x29, 0x76, 0xaf, 0xaa, 0x02, 0x20, 0x64, 0x96, 0x9f, 0xbf, 0x4a, 0x0b,
  0x49, 0xd6, 0xa1, 0x81, 0x95, 0x50, 0x0e, 0xc8, 0xd1, 0x29, 0xb0, 0x53, 0x3b, 0xcc, 0xe8, 0x2f,
  0xc6, 0x71, 0x5a, 0x8a, 0x00, 0x4f, 0x99, 0x47, 0xbf, 0x06, 0x4c, 0x96, 0xce, 0x28, 0x1e, 0xb1,
  0x47, 0xa2, 0x10, 0xa5, 0x7b, 0x27, 0xd9, 0x29, 0x86, 0x66, 0xb1, 0x72, 0x96, 0x8f, 0x57, 0x6a,
  0x1f, 0xc4, 0xb6, 0x30, 0xc6, 0x44, 0x30, 0x11, 0xd1, 0x41, 0xbc, 0x9b, 0x0f, 0x22, 0x98, 0x03,
  0x96, 0x8b, 0xd8, 0x6d, 0xc0, 0xbc, 0xeb, 0x77, 0xbb, 0xa7, 0x76, 0x6d, 0x23, 0x14, 0x98, 0x58,
  0x20, 0x65, 0x0d, 0x37, 0x56, 0x6f, 0x0e, 0x7a, 0x7d, 0x6b, 0x20, 0xb1, 0x6a, 0xa3, 0x14, 0x64,
  0x01, 0xbd, 0x6d, 0xe5, 0x76, 0x29, 0x19, 0x79, 0xf3, 0x54, 0xbf, 0x7b, 0x6c, 0x65, 0x31, 0xa8,
  0xc2, 0x39, 0x8a, 0x1b, 0x30, 0x11, 0xec, 0x54, 0xf3, 0x5a, 0x51, 0x7e, 0xd4, 0x6a, 0x8c, 0x08,
  0x55, 0x51, 0x81, 0xc7, 0x53, 0x0a, 0x3d, 0x1c, 0xc5, 0x13, 0xaa, 0x08, 0x94, 0x3a, 0x94, 0x00,
  0x7a, 0x6a, 0x2d, 0x25, 0x44, 0xd1, 0xbe, 0x48, 0x60, 0x3f, 0x81, 0xab, 0xe0, 0x4c, 0x36, 0xba,
  0x50, 0xc4, 0x78, 0xf7, 0xef, 0x6c, 0x6d, 0x33, 0x75, 0xc7, 0xe1, 0xe2, 0x14, 0x05, 0x48, 0x6c,
  0x17, 0xea, 0x6e, 0x3c, 0x02, 0x8a, 0x31, 0xa2, 0x72, 0x35, 0xd8, 0xba, 0x52, 0xf7, 0xfd, 0x7d,
  0x5c, 0x8a, 0xeb, 0x38, 0x92, 0x0a, 0x70, 0x0f, 0xbb, 0xa2, 0x6a, 0xc3, 0x78, 0x82, 0xd5, 0x3c,
  0xcc, 0x45, 0xf0, 0x83, 0x3b, 0xe5, 0xc0, 0x2e, 0xb6, 0x47, 0xe2, 0x1e, 0x41, 0x0c, 0x42, 0x3c,
  0x7f, 0x90, 0x66, 0x5c, 0xa7, 0x58, 0x38, 0x32, 0x17, 0xc1, 0xd6, 0x21, 0x06, 0xb7, 0x48, 0xe0,
  0x40, 0x00, 0x76, 0x71, 0x25, 0x41, 0xa6, 0x79, 0x05, 0x68, 0x07, 0xa6, 0x15, 0x00, 0x19, 0xf8,
  0x0b, 0x21, 0x68, 0x2a, 0x75, 0x21, 0xf4, 0xa4, 0x56, 0x11, 0x42, 0x22, 0xb8, 0xeb, 0xe8, 0xa7,
  0x90, 0x8d, 0xd8, 0xb5, 0x82, 0x98, 0xb8, 0xbc, 0x72, 0x91, 0x00, 0x56, 0x4e, 0xff, 0x11, 0xc5,
  0x45, 0xf8, 0xcd, 0x85, 0xbf, 0x08, 0xff, 0x08, 0x12, 0x38, 0x24, 0x34, 0xcc, 0x9e, 0x72, 0x18,
  0xe6, 0x65, 0x4e, 0xfd, 0xc9, 0x4f, 0x5d, 0x9c, 0x0f, 0x56, 0xba, 0x74, 0xfc, 0x47, 0x27, 0xa6,
  0xcc, 0x6b, 0x1f, 0xb4, 0x11, 0x35, 0xc0, 0x75, 0x4c, 0xec, 0xac, 0x30, 0x02, 0xae, 0x77, 0x19,
  0x18, 0x47, 0xcb, 0x74, 0x8d, 0xbd, 0x55, 0x3b, 0xf6, 0x7f, 0x20, 0xaf, 0x38, 0xc2, 0x7f, 0xb0,
  0xca, 0xe2, 0x18, 0xfe, 0x81, 0xac, 0xc5, 0x19, 0xf9, 0x46, 0x19, 0x7b, 0x9b, 0x66, 0xdc, 0x93,
  0x19, 0x57, 0x2c, 0xaa, 0xe3, 0x5f, 0x0e, 0xab, 0x4e, 0x23, 0x20, 0x54, 0xc7, 0xb9, 0x0f, 0x2b,
  0x35, 0x35, 0x6d, 0xe7, 0xa3, 0xf7, 0x6c, 0x80, 0x92, 0xf0, 0xb5, 0x13, 0xd2, 0xc8, 0x7a, 0xae,
  0x73, 0xe3, 0x72, 0x34, 0xf2, 0x49, 0x9a, 0x44, 0xd1, 0x31, 0xa4, 0x20, 0xfb, 0xc1, 0x99, 0x51,
  0x54, 0x84, 0x65, 0xcc, 0xb0, 0xb6, 0x8b, 0x30, 0x94, 0xec, 0xa2, 0xdb, 0xf4, 0x73, 0xb2, 0x84,
  0x99, 0xcc, 0x46, 0xe5, 0x04, 0x04, 0xc8, 0x0f, 0x14, 0xdb, 0x97, 0x9f, 0xbd, 0x4f, 0x13, 0xda,
  0xce, 0xb0, 0x16, 0x19, 0xde, 0x9d, 0xa2, 0xf3, 0x04, 0x6a, 0x5c, 0x33, 0xc2, 0x40, 0xa5, 0xa8,
  0x2e, 0x28, 0xd4, 0x67, 0xbf, 0x82, 0xce, 0x68, 0x99, 0x50, 0x56, 0x9e, 0x26, 0x82, 0x48, 0xcf,
  0x1f, 0xba, 0xaa, 0x70, 0x3e, 0xb9, 0x14, 0xc1, 0x0b, 0x17, 0x13, 0x84, 0xc3, 0x2d, 0xf6, 0x57,
  0xa8, 0xe7, 0x3c, 0x50, 0x22, 0xdb, 0xd2, 0x1e, 0xc8, 0x13, 0xf5, 0xbd, 0x57, 0x66, 0x81, 0x1d,
  0x96, 0x8f, 0x5a, 0x66, 0xc9, 0x0b, 0xb6, 0xf6, 0xfd, 0xbd, 0xda, 0x8d, 0xbc, 0xf4, 0x3b, 0x86,
  0xdf, 0x16, 0x0c, 0xa6, 0x18, 0x2a, 0xa8, 0x2d, 0x84, 0x4a, 0x7f, 0x93, 0x03, 0xdb, 0x7c, 0x80,
  0x91, 0xfb, 0xe3, 0x09, 0x93, 0x3d, 0x61, 0x7f, 0x67, 0x13, 0x03, 0xfd, 0xa7, 0x62, 0x9f, 0x93,
  0x85, 0xf3, 0x97, 0x43, 0xe5, 0x9c, 0x82, 0xa1, 0x69, 0x02, 0x1d, 0xcc, 0x41, 0xfb, 0xbb, 0x30,
  0x9d, 0x2d, 0x4b, 0x4c, 0x97, 0x6b, 0x6b, 0xe8, 0x42, 0x74, 0xe6, 0xc1, 0x86, 0x84, 0xe5, 0xd8,
  0xde, 0x2e, 0x0d, 0x4d, 0xa5, 0xa5, 0xb1, 0x97, 0xef, 0xde, 0x60, 0x74, 0x3a, 0xb2, 0xe2, 0x93,
  0x44, 0x1a, 0xdb, 0x4e, 0xe4, 0xb5, 0xac, 0xec, 0x69, 0xdc, 0xb9, 0x06, 0x19, 0x36, 0x79, 0x17,
  0xde, 0x04, 0x53, 0xab, 0x67, 0x0f, 0xdc, 0x2d, 0x0f, 0x11, 0x24, 0x59, 0x6b, 0x87, 0x2e, 0xc8,
  0xbe, 0x07, 0xae, 0x2d, 0x13, 0x0e, 0x28, 0xb0, 0x27, 0x26, 0x44, 0xc3, 0x76, 0xb7, 0xb7, 0xbd,
  0xfd, 0xb5, 0x9d, 0x07, 0xee, 0xc2, 0x86, 0x0f, 0xaa, 0x86, 0x71, 0xa8, 0x35, 0xd6, 0x86, 0x26,
  0xa7, 0xe6, 0x5d, 0x2f, 0xc3, 0xe6, 0x76, 0x77, 0x23, 0x61, 0xb9, 0xf5, 0xc7, 0xb0, 0x47, 0x5d,
  0x66, 0xbc, 0x55, 0xa0, 0x82, 0x34, 0xd5, 0x01, 0xfa, 0x66, 0x64, 0x6f, 0x3a, 0xd2, 0x5d, 0xa8,
  0x88, 0x2f, 0x1b, 0xd5, 0x25, 0x9a, 0xb0, 0x61, 0xef, 0xae, 0xbd, 0x0a, 0xa4, 0xf5, 0x63, 0xb1,
  0xb1, 0x85, 0xda, 0x24, 0x20, 0xb2, 0x6b, 0x20, 0xb1, 0x07, 0x4d, 0xca, 0x3a, 0x1e, 0x4d, 0x8a,
  0x19, 0xfd, 0x31, 0x40, 0x80, 0x8a, 0x41, 0x76, 0x98, 0x44, 0xd8, 0x47, 0xec, 0x44, 0x40, 0xe1,
  0x69, 0x6c, 0x47, 0xa4, 0x8d, 0x2f, 0x6a, 0x71, 0x52, 0x93, 0xbc, 0x54, 0x09, 0x2f, 0xc6, 0x10,
  0x5d, 0x2d, 0x18, 0xe9, 0x67, 0x45, 0x1d, 0xf9, 0xa2, 0xa8, 0x97, 0x63, 0x63, 0x13, 0x9d, 0x55,
  0x81, 0x72, 0x79, 0x3a, 0x83, 0x61, 0x43, 0x63, 0x1a, 0x23, 0xc8, 0x57, 0x1e, 0xa7, 0xcc, 0x57,
  0x4e, 0xbd, 0xd6, 0x89, 0x81, 0xc9, 0x1c, 0x9e, 0xc5, 0xe6, 0x0f, 0x9e, 0xfc, 0x7d, 0x7d, 0xd0,
  0xed, 0xed, 0xbb, 0x92, 0xbc, 0xef, 0xef, 0xb7, 0xc8, 0x4e, 0xc7, 0x53, 0x71, 0x34, 0xd9, 0xf3,
  0xfd, 0xfd, 0xf5, 0xd0, 0x53, 0x12, 0xd9, 0x0f, 0x5c, 0xb6, 0x68, 0xa7, 0x02, 0x5a, 0x61, 0x77,
  0xf3, 0x78, 0x7d, 0x23, 0xfe, 0x99, 0xad, 0x6e, 0x9f, 0x7f, 0x09, 0xbe, 0x50, 0xb4, 0xb9, 0xf8,
  0x7c, 0x89, 0xd4, 0xdc, 0x66, 0x28, 0xf4, 0x23, 0x8c, 0xaf, 0xa6, 0xc0, 0xce, 0xb2, 0x2a, 0x34,
  0xd4, 0xd9, 0xa6, 0xb9, 0x60, 0x14, 0x72, 0x41, 0x73, 0xc1, 0xcb, 0x41, 0x73, 0xa4, 0x47, 0x3a,
  0x0c, 0x10, 0xe4, 0x1b, 0x99, 0x2e, 0xea, 0xad, 0x14, 0xbd, 0xe8, 0x2b, 0x27, 0x58, 0xae, 0x0f,
  0x16, 0xa5, 0x49, 0xb4, 0x10, 0xcd, 0x5f, 0x50, 0xf5, 0x33, 0xfc, 0x43, 0x7e, 0xb0, 0x40, 0xe5,
  0xca, 0xec, 0x86, 0x19, 0xd3, 0x63, 0xd5, 0x1d, 0x62, 0x7b, 0xdb, 0x4c, 0x28, 0x11, 0xe4, 0x33,
  0xd4, 0xa8, 0x93, 0x19, 0xa6, 0x95, 0x25, 0x7d, 0x15, 0x93, 0x29, 0x00, 0x96, 0xfc, 0x26, 0x08,
  0x16, 0x20, 0x5b, 0xb7, 0xdb, 0x6d, 0x1e, 0xc6, 0x58, 0x28, 0x8a, 0xd2, 0xe6, 0x24, 0x03, 0x18,
  0xe7, 0xed, 0xec, 0x22, 0x9c, 0x81, 0x02, 0x8c, 0x92, 0xa6, 0xd2, 0x02, 0x0c, 0x79, 0xc3, 0x7f,
  0x80, 0x0c, 0x84, 0x5b, 0x0d, 0x2b, 0x81, 0x3e, 0x98, 0x46, 0x6c, 0x17, 0x2f, 0x11, 0xf4, 0x6c,
  0x44, 0x9b, 0xcd, 0xfd, 0xbd, 0xae, 0x87, 0x07, 0xce, 0x1d, 0x86, 0x08, 0xc3, 0x43, 0x78, 0x47,
  0x69, 0x16, 0xa4, 0x39, 0x54, 0xca, 0xee, 0xd7, 0xe6, 0xc7, 0x77, 0x2b, 0x69, 0xca, 0xab, 0xf4,
  0x67, 0xc5, 0x38, 0x44, 0x23, 0x0f, 0x8a, 0x4d, 0x07, 0x56, 0x15, 0xe7, 0x1e, 0xfe, 0x74, 0xfa,
  0x16, 0xcf, 0x5f, 0x90, 0x15, 0x05, 0x31, 0x1e, 0x6e, 0x80, 0x60, 0x07, 0xe5, 0x4d, 0xc2, 0xa0,
  0x46, 0x7f, 0x3f, 0xac, 0xa7, 0x9a, 0x6b, 0x9e, 0xa0, 0x6f, 0x57, 0x72, 0x0d, 0x95, 0x21, 0xbf,
  0x68, 0xce, 0x98, 0xe3, 0x46, 0x4d, 0x9b, 0xec, 0x43, 0x39, 0xa9, 0xca, 0x64, 0x09, 0xf9, 0x70,
  0x4f, 0x79, 0x20, 0xdf, 0x72, 0xf1, 0x50, 0x36, 0xfa, 0x30, 0xc8, 0xb7, 0x45, 0xbe, 0xff, 0x72,
  0xd0, 0x61, 0x21, 0xaa, 0x86, 0xc6, 0x01, 0x7f, 0xf8, 0x2f, 0x14, 0x1c, 0x24, 0x3b, 0x7c, 0xfb,
  0x96, 0x30, 0x48, 0x34, 0x61, 0x84, 0xf1, 0x12, 0xf1, 0x8a, 0x6b, 0x62, 0x8f, 0x40, 0x63, 0xb7,
  0xd4, 0x7a, 0x8b, 0x67, 0x05, 0x81, 0x5b, 0xab, 0xbb, 0x2e, 0xcc, 0x46, 0xc0, 0xde, 0xd7, 0x22,
  0x54, 0x8b, 0xc2, 0x9b, 0xa1, 0xa5, 0x17, 0xca, 0x3a, 0x5a, 0xa7, 0x5e, 0xc5, 0xd3, 0xb7, 0x37,
  0xc1, 0x64, 0xc9, 0xe2, 0xed, 0x3a, 0x09, 0xba, 0x84, 0x33, 0xb3, 0x55, 0xd0, 0xca, 0x75, 0xc3,
  0x95, 0x62, 0x7d, 0x42, 0xe3, 0x13, 0x48, 0x60, 0x08, 0x3c, 0x62, 0xa1, 0xa3, 0x9c, 0x65, 0xbe,
  0x0b, 0xa3, 0xc0, 0x30, 0x5b, 0xb0, 0xaa, 0x8b, 0x40, 0x96, 0x26, 0x7a, 0xfb, 0xd9, 0x45, 0xa9,
  0xbb, 0x84, 0x0c, 0x41, 0x75, 0xc6, 0xa3, 0x58, 0x84, 0xad, 0x84, 0x0f, 0xe5, 0xcc, 0xd9, 0x29,
  0x47, 0x9b, 0x51, 0x7b, 0x16, 0xc6, 0x7e, 0x14, 0xdd, 0x5a, 0x96, 0x0d, 0xe5, 0x57, 0x25, 0xeb,
  0xe8, 0x87, 0xe4, 0x1c, 0xbf, 0x5b, 0x98, 0xe9, 0xea, 0xa2, 0xc4, 0x4c, 0x02, 0xc8, 0xf6, 0x2a,
  0x0d, 0x7c, 0xb4, 0xd5, 0x94, 0xba, 0x5c, 0x0f, 0x05, 0xdf, 0x66, 0x58, 0xf0, 0x4e, 0xa0, 0x98,
  0x27, 0x61, 0x58, 0x50, 0xef, 0x8b, 0x47, 0x39, 0xa8, 0xb1, 0x23, 0x2b, 0x11, 0x06, 0x91, 0x76,
  0xf1, 0x3f, 0x53, 0x3b, 0x31, 0xcc, 0x5b, 0x5d, 0x3d, 0xb8, 0x08, 0x76, 0xa0, 0xd4, 0x68, 0xc8,
  0xb2, 0x72, 0x30, 0xc4, 0x8d, 0xdd, 0x97, 0x15, 0x46, 0xc9, 0x79, 0x31, 0x82, 0x06, 0x85, 0x56,
  0x30, 0xba, 0xae, 0x91, 0x61, 0xdc, 0x93, 0x69, 0x66, 0xca, 0x8c, 0x31, 0x70, 0x8a, 0x26, 0xfb,
  0xdb, 0x5a, 0xe3, 0xdb, 0x72, 0x81, 0xad, 0xc0, 0x26, 0xa0, 0xa8, 0x8b, 0x86, 0x27, 0x75, 0xfc,
  0xd0, 0x08, 0xfc, 0xdb, 0x4f, 0x1f, 0x7e, 0x84, 0x21, 0xf9, 0xc4, 0xec, 0xd2, 0x83, 0xa4, 0x66,
  0x49, 0x61, 0x15, 0xa6, 0x66, 0xbd, 0x2d, 0x3e, 0x8f, 0xce, 0x5e, 0x6d, 0x11, 0xdc, 0x05, 0xeb,
  0x27, 0xb0, 0x01, 0x0a, 0x8e, 0xb1, 0xcc, 0x86, 0xde, 0x33, 0x8c, 0x58, 0x0e, 0xf2, 0x4c, 0x5d,
  0xb5, 0xe4, 0xfb, 0x67, 0x36, 0xf6, 0x0b, 0xeb, 0x40, 0xbe, 0x21, 0x2a, 0x60, 0xa7, 0x3d, 0x47,
  0x3f, 0x1f, 0x7f, 0x06, 0xad, 0xbc, 0xc3, 0x3a, 0x66, 0xca, 0x88, 0x47, 0xd0, 0x93, 0x77, 0xb0,
  0x40, 0xc8, 0xae, 0xe9, 0xd3, 0xcf, 0xd7, 0x51, 0x32, 0xb6, 0x90, 0xa7, 0xde, 0xe1, 0xfe, 0xa0,
  0x1b, 0x5c, 0x09, 0x82, 0x69, 0x85, 0xae, 0x10, 0x54, 0x10, 0x67, 0xe8, 0xc4, 0x3f, 0x75, 0x02,
  0x7b, 0x10, 0xb7, 0x21, 0x1f, 0x62, 0xf3, 0x9b, 0xfc, 0x0b, 0x18, 0x58, 0x3b, 0xe1, 0xb1, 0x7e,
  0x4a, 0xde, 0xb3, 0x87, 0x6f, 0xd9, 0x60, 0xd6, 0x79, 0xef, 0x05, 0xcd, 0x91, 0x8c, 0x26, 0x01,
  0xb0, 0xe5, 0xf3, 0xd4, 0x9f, 0x73, 0x3a, 0xad, 0x99, 0x23, 0x0a, 0x4e, 0xe0, 0x88, 0x78, 0x45,
  0xf5, 0xb7, 0x93, 0x72, 0xe6, 0x02, 0x87, 0x87, 0x10, 0xab, 0x7a, 0x2e, 0x22, 0x97, 0x82, 0xa4,
  0x5f, 0x73, 0x3d, 0x91, 0xb6, 0x4c, 0xa4, 0x21, 0xd3, 0x11, 0x94, 0xaa, 0x40, 0x46, 0xd6, 0xb1,
  0xae, 0xbb, 0x47, 0xae, 0x30, 0xa8, 0x1e, 0x0d, 0xfc, 0xea, 0x94, 0x27, 0xc2, 0xe2, 0x7e, 0xf6,
  0xea, 0xd3, 0xe7, 0xf7, 0xbb, 0xef, 0x7e, 0x33, 0x58, 0xfd, 0x1a, 0xb8, 0xba, 0xc0, 0x4e, 0x1f,
  0xa2, 0xe9, 0x88, 0xaa, 0x20, 0xf4, 0x88, 0x9a, 0x2c, 0x65, 0x14, 0xa5, 0x09, 0x91, 0x24, 0xa6,
  0x30, 0xc4, 0x04, 0x7d, 0xe8, 0xa1, 0xbe, 0x64, 0xa5, 0x20, 0x2a, 0xd5, 0xd5, 0x58, 0xc5, 0x1d,
  0x40, 0xd9, 0x19, 0x4f, 0xac, 0x14, 0x8c, 0x38, 0x7d, 0xc7, 0x40, 0x34, 0x1d, 0x8c, 0xb7, 0xae,
  0xc3, 0x5b, 0x3c, 0xb2, 0x4e, 0x4e, 0x5f, 0x3b, 0xb2, 0xcb, 0x3b, 0x8e, 0xc1, 0xd1, 0x35, 0x08,
  0xa7, 0x08, 0xbd, 0x73, 0x3f, 0x2d, 0xe3, 0x32, 0x4e, 0xc2, 0xa3, 0xbf, 0x83, 0x7b, 0x39, 0xd2,
  0xc0, 0xe1, 0x5b, 0x22, 0x81, 0x9d, 0xc3, 0xb7, 0x3b, 0x8e, 0xf2, 0x51, 0xf8, 0xdc, 0x1b, 0x9e,
  0xc3, 0x50, 0x46, 0xff, 0x1b, 0x3a, 0xc6, 0x3e, 0xf6, 0x39, 0x98, 0x2f, 0x90, 0x9e, 0x58, 0x07,
  0xf1, 0x33, 0xe8, 0xcc, 0x6e, 0xe4, 0x3c, 0xf9, 0x6f, 0xd3, 0x2d, 0x6c, 0xfb, 0x95, 0xbb, 0xb7,
  0x47, 0xa7, 0x26, 0x5a, 0xd7, 0xf0, 0x8d, 0x81, 0xa9, 0xdf, 0xd4, 0xb5, 0xda, 0x8f, 0x32, 0xcf,
  0xe1, 0xac, 0xfa, 0x4d, 0xf5, 0xc5, 0x37, 0xf7, 0x57, 0x3f, 0x91, 0xdd, 0xa9, 0x39, 0x13, 0xff,
  0x29, 0x49, 0x62, 0x90, 0xb6, 0x97, 0x51, 0x90, 0xd1, 0xb9, 0xf8, 0x2e, 0x8f, 0x9d, 0xd5, 0xc9,
  0xd3, 0x20, 0xe8, 0xcc, 0x81, 0x7b, 0x05, 0x69, 0x07, 0x17, 0xe1, 0xbb, 0xdf, 0x3a, 0x34, 0xf5,
  0x02, 0x77, 0x86, 0x7d, 0xde, 0x1c, 0x8a, 0x05, 0xfa, 0x21, 0x1c, 0xa7, 0x7e, 0x7a, 0xfb, 0xf8,
  0x91, 0x22, 0xf7, 0xcd, 0x9b, 0xec, 0xe1, 0x56, 0xcf, 0xe7, 0xed, 0xcb, 0x38, 0x21, 0x52, 0x03,
  0xae, 0xd6, 0x01, 0x05, 0x39, 0x9e, 0xf3, 0x96, 0x83, 0x3c, 0x19, 0xee, 0xce, 0x6e, 0x2a, 0x8d,
  0x1b, 0xad, 0x1f, 0xc1, 0x74, 0x78, 0x80, 0x7e, 0xa2, 0xf3, 0x05, 0x0a, 0x2e, 0x7c, 0xe9, 0x18,
  0xc0, 0xf6, 0xbe, 0x9e, 0x8f, 0x08, 0xde, 0x3a, 0x7c, 0x80, 0x7f, 0x84, 0x43, 0xfc, 0x14, 0xee,
  0xf3, 0x43, 0x63, 0x4f, 0x6c, 0xec, 0x20, 0x7a, 0x1a, 0xb8, 0xa3, 0xa0, 0xc7, 0xf4, 0x71, 0x90,
  0x86, 0x7e, 0x64, 0xfc, 0xbc, 0x5c, 0x2c, 0xf3, 0x76, 0x53, 0x7b, 0x7c, 0x83, 0x9d, 0xb4, 0x7f,
  0xb7, 0x86, 0xda, 0x7e, 0x7c, 0xfd, 0xba, 0x42, 0x6e, 0x42, 0x59, 0xa0, 0x08, 0x33, 0x03, 0x18,
  0x34, 0x0a, 0xe5, 0x65, 0x4a, 0x1a, 0xfc, 0xf1, 0xb5, 0xef, 0x67, 0xc6, 0x6b, 0xf4, 0xe6, 0xe6,
  0x05, 0xcd, 0xe1, 0xff, 0xfd, 0x1f, 0xff, 0xf3, 0xbf, 0x1f, 0x74, 0xfc, 0xaf, 0x6c, 0xc3, 0xdb,
  0xaf, 0x6c, 0x03, 0xa7, 0xc6, 0x6a, 0x33, 0xea, 0x70, 0xe8, 0x2f, 0x15, 0x09, 0x59, 0x41, 0x05,
  0xdf, 0x78, 0x13, 0x2c, 0x6f, 0x7a, 0x44, 0x69, 0x62, 0xe7, 0xfb, 0x4a, 0x49, 0xab, 0x34, 0x14,
  0xb4, 0x3f, 0x9a, 0x87, 0x6f, 0x4d, 0x76, 0xcf, 0x13, 0xbe, 0x2b, 0xa8, 0x3b, 0xf5, 0xaf, 0xdb,
  0x6c, 0x5d, 0x82, 0x3e, 0x93, 0x72, 0xe3, 0xd4, 0xfa, 0x25, 0x5a, 0x5d, 0x9d, 0x1d, 0x14, 0xb7,
  0x61, 0xc6, 0xff, 0x9a, 0xd5, 0x73, 0xdf, 0xec, 0xce, 0x8f, 0xaf, 0xff, 0xc2, 0x1e, 0x8f, 0x40,
  0xfe, 0xea, 0x75, 0xdd, 0x17, 0xee, 0x8b, 0xbf, 0xec, 0xf5, 0x6e, 0xf6, 0x7a, 0x7f, 0xe9, 0x3e,
  0x07, 0xe1, 0xa3, 0x83, 0xe4, 0xf2, 0x87, 0x9e, 0xbb, 0x80, 0xb7, 0xbc, 0x19, 0x6f, 0xff, 0x1e,
  0xcd, 0xe0, 0xc5, 0x94, 0x96, 0xd4, 0xe9, 0x38, 0xda, 0x5c, 0xa2, 0xb3, 0xb2, 0xb6, 0x09, 0xa0,
  0xf1, 0xe0, 0xfe, 0xde, 0x54, 0x09, 0x16, 0x93, 0xb8, 0x73, 0x0d, 0xf3, 0x2e, 0xb1, 0x4c, 0xa0,
  0x1f, 0xbc, 0x1a, 0x63, 0x64, 0xcb, 0x94, 0x2e, 0x39, 0x88, 0xa9, 0xee, 0x24, 0x12, 0xb4, 0x92,
  0x94, 0xa1, 0x91, 0xb4, 0x22, 0x37, 0xc9, 0x74, 0x39, 0x86, 0x88, 0xa3, 0xa3, 0xac, 0x07, 0xc5,
  0x42, 0xe1, 0xea, 0xbb, 0xfa, 0x5a, 0x82, 0x2c, 0x6d, 0xb4, 0x75, 0xf0, 0x3f, 0x0d, 0xdf, 0x3c,
  0xeb, 0x3c, 0xe5, 0x8b, 0x5f, 0xf0, 0x7c, 0x51, 0x0b, 0x25, 0x3f, 0xed, 0xd0, 0x9f, 0x05, 0x2b,
  0x49, 0x62, 0x01, 0x25, 0xdc, 0xf1, 0x42, 0x0a, 0xbe, 0x54, 0x3c, 0x0d, 0xd2, 0x77, 0x18, 0x05,
  0xcc, 0xb2, 0xf9, 0xcb, 0x3b, 0xc9, 0x56, 0xc8, 0xdd, 0xef, 0x26, 0x88, 0x98, 0xa7, 0x1d, 0x05,
  0x13, 0x0c, 0x52, 0xc7, 0x20, 0x27, 0x9d, 0x77, 0x69, 0x32, 0x17, 0x77, 0x6a, 0x95, 0x37, 0xf4,
  0x60, 0x8b, 0xaa, 0xd8, 0x57, 0x57, 0x67, 0x2b, 0x55, 0xc1, 0xef, 0x60, 0xc8, 0x4c, 0xfc, 0x7b,
  0x91, 0xcf, 0xa3, 0xa1, 0xf1, 0xff, 0x00, 0x19, 0x75, 0x36, 0xdf, 0x9c, 0xe2, 0x01, 0x00
};

=== ./hue.cpp ===

#include "wled.h"

/*
 * Sync to Philips hue lights
 */

#ifndef WLED_DISABLE_HUESYNC

void handleHue()
{
  if (hueReceived)
  {
    colorUpdated(CALL_MODE_HUE); hueReceived = false;
    if (hueStoreAllowed && hueNewKey)
    {
      serializeConfigSec(); //save api key
      hueStoreAllowed = false;
      hueNewKey = false;
    }
  }
  
  if (!WLED_CONNECTED || hueClient == nullptr || millis() - hueLastRequestSent < huePollIntervalMs) return;

  hueLastRequestSent = millis();
  if (huePollingEnabled)
  {
    reconnectHue();
  } else {
    hueClient->close();
    if (hueError == HUE_ERROR_ACTIVE) hueError = HUE_ERROR_INACTIVE;
  }
}

void reconnectHue()
{
  if (!WLED_CONNECTED || !huePollingEnabled) return;
  DEBUG_PRINTLN(F("Hue reconnect"));
  if (hueClient == nullptr) {
    hueClient = new AsyncClient();
    hueClient->onConnect(&onHueConnect, hueClient);
    hueClient->onData(&onHueData, hueClient);
    hueClient->onError(&onHueError, hueClient);
    hueAuthRequired = (strlen(hueApiKey)<20);
  }
  hueClient->connect(hueIP, 80);
}

void onHueError(void* arg, AsyncClient* client, int8_t error)
{
  DEBUG_PRINTLN(F("Hue err"));
  hueError = HUE_ERROR_TIMEOUT;
}

void onHueConnect(void* arg, AsyncClient* client)
{
  DEBUG_PRINTLN(F("Hue connect"));
  sendHuePoll();
}

void sendHuePoll()
{
  if (hueClient == nullptr || !hueClient->connected()) return;
  String req = "";
  if (hueAuthRequired)
  {
    req += F("POST /api HTTP/1.1\r\nHost: ");
    req += hueIP.toString();
    req += F("\r\nContent-Length: 25\r\n\r\n{\"devicetype\":\"wled#esp\"}");
  } else
  {
    req += F("GET /api/");
    req += hueApiKey;
    req += F("/lights/");
    req += String(huePollLightId);
    req += F(" HTTP/1.1\r\nHost: ");
    req += hueIP.toString();
    req += "\r\n\r\n";
  }
  hueClient->add(req.c_str(), req.length());
  hueClient->send();
  hueLastRequestSent = millis();
}

void onHueData(void* arg, AsyncClient* client, void *data, size_t len)
{
  if (!len) return;
  char* str = (char*)data;
  DEBUG_PRINTLN(hueApiKey);
  DEBUG_PRINTLN(str);
  //only get response body
  str = strstr(str,"\r\n\r\n");
  if (str == nullptr) return;
  str += 4;

  StaticJsonDocument<1024> root;
  if (str[0] == '[') //is JSON array
  {
    auto error = deserializeJson(root, str);
    if (error)
    {
      hueError = HUE_ERROR_JSON_PARSING; return;
    }
    
    int hueErrorCode = root[0][F("error")][F("type")];
    if (hueErrorCode)//hue bridge returned error
    {
      hueError = hueErrorCode;
      switch (hueErrorCode)
      {
        case 1:   hueAuthRequired = true;    break; //Unauthorized user
        case 3:   huePollingEnabled = false; break; //Invalid light ID
        case 101: hueAuthRequired = true;    break; //link button not presset
      }
      return;
    }
    
    if (hueAuthRequired)
    {
      const char* apikey = root[0][F("success")][F("username")];
      if (apikey != nullptr && strlen(apikey) < sizeof(hueApiKey))
      {
        strlcpy(hueApiKey, apikey, sizeof(hueApiKey));
        hueAuthRequired = false;
        hueNewKey = true;
      }
    }
    return;
  }

  //else, assume it is JSON object, look for state and only parse that
  str = strstr(str,"state");
  if (str == nullptr) return;
  str = strstr(str,"{");
  
  auto error = deserializeJson(root, str);
  if (error)
  {
    hueError = HUE_ERROR_JSON_PARSING; return;
  }

  float hueX=0, hueY=0;
  uint16_t hueHue=0, hueCt=0;
  byte hueBri=0, hueSat=0, hueColormode=0;

  if (root["on"]) {
    if (root.containsKey("bri")) //Dimmable device
    {
      hueBri = root["bri"];
      hueBri++;
      const char* cm =root[F("colormode")];
      if (cm != nullptr) //Color device
      {
        if (strstr(cm,("ct")) != nullptr) //ct mode
        {
          hueCt = root["ct"];
          hueColormode = 3;
        } else if (strstr(cm,"xy") != nullptr) //xy mode
        {
          hueX = root["xy"][0]; // 0.5051
          hueY = root["xy"][1]; // 0.4151
          hueColormode = 1;
        } else //hs mode
        {
          hueHue = root["hue"];
          hueSat = root[F("sat")];
          hueColormode = 2;
        }
      }
    } else //On/Off device
    {
      hueBri = briLast;
    }
  } else
  {
    hueBri = 0;
  }

  hueError = HUE_ERROR_ACTIVE;
  
  //apply vals
  if (hueBri != hueBriLast)
  {
    if (hueApplyOnOff)
    {
      if (hueBri==0) {bri = 0;}
      else if (bri==0 && hueBri>0) bri = briLast;
    }
    if (hueApplyBri)
    {
      if (hueBri>0) bri = hueBri;
    }
    hueBriLast = hueBri;
  }
  if (hueApplyColor)
  {
    switch(hueColormode)
    {
      case 1: if (hueX != hueXLast || hueY != hueYLast) colorXYtoRGB(hueX,hueY,col); hueXLast = hueX; hueYLast = hueY; break;
      case 2: if (hueHue != hueHueLast || hueSat != hueSatLast) colorHStoRGB(hueHue,hueSat,col); hueHueLast = hueHue; hueSatLast = hueSat; break;
      case 3: if (hueCt != hueCtLast) colorCTtoRGB(hueCt,col); hueCtLast = hueCt; break;
    }
  }
  hueReceived = true;
}
#else
void handleHue(){}
void reconnectHue(){}
#endif

=== ./improv.cpp ===

#include "wled.h"

#ifdef WLED_DEBUG_IMPROV
  #define DIMPROV_PRINT(x) Serial.print(x)
  #define DIMPROV_PRINTLN(x) Serial.println(x)
  #define DIMPROV_PRINTF(x...) Serial.printf(x)
#else
  #define DIMPROV_PRINT(x)
  #define DIMPROV_PRINTLN(x)
  #define DIMPROV_PRINTF(x...)
#endif

#define IMPROV_VERSION 1

void parseWiFiCommand(char *rpcData);

enum ImprovPacketType {
  Current_State = 0x01,
  Error_State = 0x02,
  RPC_Command = 0x03,
  RPC_Response = 0x04
};

enum ImprovPacketByte {
  Version = 6,
  PacketType = 7,
  Length = 8,
  RPC_CommandType = 9
};

enum ImprovRPCType {
  Command_Wifi = 0x01,
  Request_State = 0x02,
  Request_Info = 0x03
};

//File dbgf;

//blocking function to parse an Improv Serial packet
void handleImprovPacket() {
  uint8_t header[6] = {'I','M','P','R','O','V'};

  //dbgf = WLED_FS.open("/improv.log","a");

  bool timeout = false;
  uint8_t waitTime = 25;
  uint16_t packetByte = 0;
  uint8_t packetLen = 9;
  uint8_t checksum = 0;

  uint8_t rpcCommandType = 0;
  char rpcData[128];
  rpcData[0] = 0;

  while (!timeout) {
    if (Serial.available() < 1) {
      delay(1);
      waitTime--;
      if (!waitTime) timeout = true;
      continue;
    }
    byte next = Serial.read();

    DIMPROV_PRINT("Received improv byte: "); DIMPROV_PRINTF("%x\r\n",next);
    //f.write(next);
    switch (packetByte) {
      case ImprovPacketByte::Version: {
        if (next != IMPROV_VERSION) {
          DIMPROV_PRINTLN(F("Invalid version"));
          //dbgf.close();
          return;
        }
        break;
      }
      case ImprovPacketByte::PacketType: {
        if (next != ImprovPacketType::RPC_Command) {
          DIMPROV_PRINTF("Non RPC-command improv packet type %i\n",next);
          //dbgf.close();
          return;
        }
        if (!improvActive) improvActive = 1;
        break;
      }
      case ImprovPacketByte::Length: packetLen = 9 + next; break;
      case ImprovPacketByte::RPC_CommandType: rpcCommandType = next; break;
      default: {
        if (packetByte >= packetLen) { //end of packet, check checksum match

          if (checksum != next) {
            DIMPROV_PRINTF("Got RPC checksum %i, expected %i",next,checksum);
            sendImprovStateResponse(0x01, true);
            //dbgf.close();
            return;
          }

          switch (rpcCommandType) {
            case ImprovRPCType::Command_Wifi: parseWiFiCommand(rpcData); break;
            case ImprovRPCType::Request_State: {
              uint8_t improvState = 0x02; //authorized
              if (WLED_WIFI_CONFIGURED) improvState = 0x03; //provisioning
              if (Network.isConnected()) improvState = 0x04; //provisioned
              sendImprovStateResponse(improvState, false);
              if (improvState == 0x04) sendImprovRPCResponse(ImprovRPCType::Request_State);
              break;
            }
            case ImprovRPCType::Request_Info: sendImprovInfoResponse(); break;
            default: {
              DIMPROV_PRINTF("Unknown RPC command %i\n",next);
              sendImprovStateResponse(0x02, true);
            }
          }
          //dbgf.close();
          return;
        }
        if (packetByte < 6) { //check header
          if (next != header[packetByte]) {
            DIMPROV_PRINTLN(F("Invalid improv header"));
            //dbgf.close();
            return;
          }
        } else if (packetByte > 9) { //RPC data
          rpcData[packetByte - 10] = next;
          if (packetByte > 137) return; //prevent buffer overflow
        }
      }
    }

    checksum += next;
    packetByte++;
  }
  //dbgf.close();
}

void sendImprovStateResponse(uint8_t state, bool error) {
  if (!error && improvError > 0 && improvError < 3) sendImprovStateResponse(0x00, true);
  if (error) improvError = state;
  char out[11] = {'I','M','P','R','O','V'};
  out[6] = IMPROV_VERSION;
  out[7] = error? ImprovPacketType::Error_State : ImprovPacketType::Current_State;
  out[8] = 1;
  out[9] = state;

  uint8_t checksum = 0;
  for (uint8_t i = 0; i < 10; i++) checksum += out[i];
  out[10] = checksum;
  Serial.write((uint8_t*)out, 11);
  Serial.write('\n');
}

void sendImprovRPCResponse(byte commandId) {
  if (improvError > 0 && improvError < 3) sendImprovStateResponse(0x00, true);
  uint8_t packetLen = 12;
  char out[64] = {'I','M','P','R','O','V'};
  out[6] = IMPROV_VERSION;
  out[7] = ImprovPacketType::RPC_Response;
  out[8] = 2; //Length (set below)
  out[9] = commandId;
  out[10] = 0; //Data len (set below)
  out[11] = '\0'; //URL len (set below)

  if (Network.isConnected())
  {
    IPAddress localIP = Network.localIP();
    uint8_t len = sprintf(out+12, "http://%d.%d.%d.%d", localIP[0], localIP[1], localIP[2], localIP[3]);
    if (len > 24) return; //sprintf fail?
    out[11] = len;
    out[10] = 1 + len;
    out[8] = 3 + len; //RPC command type + data len + url len + url
    packetLen = 13 + len;
  }

  uint8_t checksum = 0;
  for (uint8_t i = 0; i < packetLen -1; i++) checksum += out[i];
  out[packetLen -1] = checksum;
  Serial.write((uint8_t*)out, packetLen);
  Serial.write('\n');
  improvActive = 1; //no longer provisioning
}

void sendImprovInfoResponse() {
  if (improvError > 0 && improvError < 3) sendImprovStateResponse(0x00, true);
  uint8_t packetLen = 12;
  char out[128] = {'I','M','P','R','O','V'};
  out[6] = IMPROV_VERSION;
  out[7] = ImprovPacketType::RPC_Response;
  //out[8] = 2; //Length (set below)
  out[9] = ImprovRPCType::Request_Info;
  //out[10] = 0; //Data len (set below)
  out[11] = 4; //Firmware len ("WLED")
  out[12] = 'W'; out[13] = 'L'; out[14] = 'E'; out[15] = 'D';
  uint8_t lengthSum = 17;
  uint8_t vlen = sprintf_P(out+lengthSum,PSTR("0.13.4/%i"),VERSION);
  out[16] = vlen; lengthSum += vlen;
  uint8_t hlen = 7;
  #ifdef ESP8266
  strcpy(out+lengthSum+1,"esp8266");
  #else
  hlen = 5;
  strcpy(out+lengthSum+1,"esp32");
  #endif
  out[lengthSum] = hlen;
  lengthSum += hlen + 1;
  //Use serverDescription if it has been changed from the default "WLED", else mDNS name
  bool useMdnsName = (strcmp(serverDescription, "WLED") == 0 && strlen(cmDNS) > 0);
  strcpy(out+lengthSum+1,useMdnsName ? cmDNS : serverDescription);
  uint8_t nlen = strlen(useMdnsName ? cmDNS : serverDescription);
  out[lengthSum] = nlen;
  lengthSum += nlen + 1;

  packetLen = lengthSum +1;
  out[8] = lengthSum -9;
  out[10] = lengthSum -11;

  uint8_t checksum = 0;
  for (uint8_t i = 0; i < packetLen -1; i++) checksum += out[i];
  out[packetLen -1] = checksum;
  Serial.write((uint8_t*)out, packetLen);
  Serial.write('\n');
  DIMPROV_PRINT("Info checksum");
  DIMPROV_PRINTLN(checksum);
}

void parseWiFiCommand(char* rpcData) {
  uint8_t len = rpcData[0];
  if (!len || len > 126) return;

  uint8_t ssidLen = rpcData[1];
  if (ssidLen > len -1 || ssidLen > 32) return;
  memset(clientSSID, 0, 32);
  memcpy(clientSSID, rpcData+2, ssidLen);

  memset(clientPass, 0, 64);
  if (len > ssidLen +1) {
    uint8_t passLen = rpcData[2+ssidLen];
    memset(clientPass, 0, 64);
    memcpy(clientPass, rpcData+3+ssidLen, passLen);
  }

  sendImprovStateResponse(0x03); //provisioning
  improvActive = 2;

  forceReconnect = true;
  serializeConfig();
}
=== ./ir.cpp ===

#include "wled.h"

/*
 * Infrared sensor support for generic 24/40/44 key RGB remotes
 */

#if defined(WLED_DISABLE_INFRARED)
void handleIR(){}
#else
#warning IR enabled. IR Remotes are not officially supported in WLED-SR

IRrecv* irrecv;
//change pin in NpbWrapper.h

decode_results results;

unsigned long irCheckedTime = 0;
uint32_t lastValidCode = 0;
byte lastRepeatableAction = ACTION_NONE;
uint8_t lastRepeatableValue = 0;
uint16_t irTimesRepeated = 0;
uint8_t lastIR6ColourIdx = 0;


// brightnessSteps: a static array of brightness levels following a geometric
// progression.  Can be generated from the following Python, adjusting the
// arbitrary 4.5 value to taste:
//
// def values(level):
//     while level >= 5:
//         yield int(level)
//         level -= level / 4.5
// result = [v for v in reversed(list(values(255)))]
// print("%d values: %s" % (len(result), result))
//
// It would be hard to maintain repeatable steps if calculating this on the fly.
const byte brightnessSteps[] = {
  5, 7, 9, 12, 16, 20, 26, 34, 43, 56, 72, 93, 119, 154, 198, 255
};
const size_t numBrightnessSteps = sizeof(brightnessSteps) / sizeof(uint8_t);

// increment `bri` to the next `brightnessSteps` value
void incBrightness()
{
  // dumb incremental search is efficient enough for so few items
  for (uint8_t index = 0; index < numBrightnessSteps; ++index)
  {
    if (brightnessSteps[index] > bri)
    {
      bri = brightnessSteps[index];
      lastRepeatableAction = ACTION_BRIGHT_UP;
      break;
    }
  }
}

// decrement `bri` to the next `brightnessSteps` value
void decBrightness()
{
  // dumb incremental search is efficient enough for so few items
  for (int index = numBrightnessSteps - 1; index >= 0; --index)
  {
    if (brightnessSteps[index] < bri)
    {
      bri = brightnessSteps[index];
      lastRepeatableAction = ACTION_BRIGHT_DOWN;
      break;
    }
  }
}

byte relativeChange(byte property, int8_t amount, byte lowerBoundary, byte higherBoundary)
{
  int16_t new_val = (int16_t) property + amount;
  if (lowerBoundary >= higherBoundary) return property;
  if (new_val > higherBoundary) new_val = higherBoundary;
  if (new_val < lowerBoundary)  new_val = lowerBoundary;
  return (byte)constrain(new_val, 0, 255);
}

void changeEffect(uint8_t fx)
{
  if (irApplyToAllSelected) {
    for (uint8_t i = 0; i < strip.getMaxSegments(); i++) {
      WS2812FX::Segment& seg = strip.getSegment(i);
      if (!seg.isActive() || !seg.isSelected()) continue;
      strip.setMode(i, fx);
    }
    setValuesFromFirstSelectedSeg();
  } else {
    strip.setMode(strip.getMainSegmentId(), fx);
    setValuesFromMainSeg();
  }
  stateChanged = true;
}

void changePalette(uint8_t pal)
{
  if (irApplyToAllSelected) {
    for (uint8_t i = 0; i < strip.getMaxSegments(); i++) {
      WS2812FX::Segment& seg = strip.getSegment(i);
      if (!seg.isActive() || !seg.isSelected()) continue;
      seg.palette = pal;
    }
    setValuesFromFirstSelectedSeg();
  } else {
    strip.getMainSegment().palette = pal;
    setValuesFromMainSeg();
  }
  stateChanged = true;
}

// apply preset or fallback to a effect and palette if it doesn't exist
void presetFallback(uint8_t presetID, uint8_t effectID, uint8_t paletteID)
{
  byte prevError = errorFlag;
  if (!applyPreset(presetID, CALL_MODE_BUTTON_PRESET)) {
    effectCurrent = effectID;
    effectPalette = paletteID;
    errorFlag = prevError; //clear error 12 from non-existent preset
    changeEffect(effectCurrent);
    changePalette(effectPalette);
  }
}

void changeEffectSpeed(int8_t amount)
{
  if (effectCurrent != 0) {
    int16_t new_val = (int16_t) effectSpeed + amount;
    effectSpeed = (byte)constrain(new_val,0,255);
    if (irApplyToAllSelected) {
      for (uint8_t i = 0; i < strip.getMaxSegments(); i++) {
        WS2812FX::Segment& seg = strip.getSegment(i);
        if (!seg.isActive() || !seg.isSelected()) continue;
        seg.speed = effectSpeed;
      }
      setValuesFromFirstSelectedSeg();
    } else {
      strip.getMainSegment().speed = effectSpeed;
      setValuesFromMainSeg();
    }
  } else { // if Effect == "solid Color", change the hue of the primary color
    WS2812FX::Segment& sseg = irApplyToAllSelected ? strip.getFirstSelectedSeg() : strip.getMainSegment();
    CRGB fastled_col;
    fastled_col.red   = R(sseg.colors[0]);
    fastled_col.green = G(sseg.colors[0]);
    fastled_col.blue  = B(sseg.colors[0]);
    CHSV prim_hsv = rgb2hsv_approximate(fastled_col);
    int16_t new_val = (int16_t)prim_hsv.h + amount;
    if (new_val > 255) new_val -= 255;  // roll-over if  bigger than 255
    if (new_val < 0) new_val += 255;    // roll-over if smaller than 0
    prim_hsv.h = (byte)new_val;
    hsv2rgb_rainbow(prim_hsv, fastled_col);
    if (irApplyToAllSelected) {
      for (uint8_t i = 0; i < strip.getMaxSegments(); i++) {
        WS2812FX::Segment& seg = strip.getSegment(i);
        if (!seg.isActive() || !seg.isSelected()) continue;
        seg.colors[0] = RGBW32(fastled_col.red, fastled_col.green, fastled_col.blue, W(sseg.colors[0]));
      }
      setValuesFromFirstSelectedSeg();
    } else {
      strip.getMainSegment().colors[0] = RGBW32(fastled_col.red, fastled_col.green, fastled_col.blue, W(sseg.colors[0]));
      setValuesFromMainSeg();
    }
  }
  stateChanged = true;

  if(amount > 0) lastRepeatableAction = ACTION_SPEED_UP;
  if(amount < 0) lastRepeatableAction = ACTION_SPEED_DOWN;
  lastRepeatableValue = amount;
}

void changeEffectIntensity(int8_t amount)
{
  if (effectCurrent != 0) {
    int16_t new_val = (int16_t) effectIntensity + amount;
    effectIntensity = (byte)constrain(new_val,0,255);
    if (irApplyToAllSelected) {
      for (uint8_t i = 0; i < strip.getMaxSegments(); i++) {
        WS2812FX::Segment& seg = strip.getSegment(i);
        if (!seg.isActive() || !seg.isSelected()) continue;
        seg.intensity = effectIntensity;
      }
      setValuesFromFirstSelectedSeg();
    } else {
      strip.getMainSegment().speed = effectIntensity;
      setValuesFromMainSeg();
    }
  } else { // if Effect == "solid Color", change the saturation of the primary color
    WS2812FX::Segment& sseg = irApplyToAllSelected ? strip.getFirstSelectedSeg() : strip.getMainSegment();
    CRGB fastled_col;
    fastled_col.red   = R(sseg.colors[0]);
    fastled_col.green = G(sseg.colors[0]);
    fastled_col.blue  = B(sseg.colors[0]);
    CHSV prim_hsv = rgb2hsv_approximate(fastled_col);
    int16_t new_val = (int16_t) prim_hsv.s + amount;
    prim_hsv.s = (byte)constrain(new_val,0,255);  // constrain to 0-255
    hsv2rgb_rainbow(prim_hsv, fastled_col);
    if (irApplyToAllSelected) {
      for (uint8_t i = 0; i < strip.getMaxSegments(); i++) {
        WS2812FX::Segment& seg = strip.getSegment(i);
        if (!seg.isActive() || !seg.isSelected()) continue;
        seg.colors[0] = RGBW32(fastled_col.red, fastled_col.green, fastled_col.blue, W(sseg.colors[0]));
      }
      setValuesFromFirstSelectedSeg();
    } else {
      strip.getMainSegment().colors[0] = RGBW32(fastled_col.red, fastled_col.green, fastled_col.blue, W(sseg.colors[0]));
      setValuesFromMainSeg();
    }
  }
  stateChanged = true;

  if(amount > 0) lastRepeatableAction = ACTION_INTENSITY_UP;
  if(amount < 0) lastRepeatableAction = ACTION_INTENSITY_DOWN;
  lastRepeatableValue = amount;
}

void changeColor(uint32_t c, int16_t cct=-1)
{
  if (irApplyToAllSelected) {
    // main segment may not be selected!
    for (uint8_t i = 0; i < strip.getMaxSegments(); i++) {
      WS2812FX::Segment& seg = strip.getSegment(i);
      if (!seg.isActive() || !seg.isSelected()) continue;
      byte capabilities = seg.getLightCapabilities();
      uint32_t mask = 0;
      bool isRGB = GET_BIT(capabilities, 0); // when RGBW_MODE_AUTO_ACCURATE this is always true
      bool hasW  = GET_BIT(capabilities, 1);
      bool isCCT = GET_BIT(capabilities, 2);
      if (isRGB) mask |= 0x00FFFFFF; // RGB
      if (hasW)  mask |= 0xFF000000; // white
      if (hasW && (strip.autoWhiteMode == RGBW_MODE_AUTO_ACCURATE) && (c & 0xFF000000)) { // white channel & white specified
        seg.setColor(0, c | 0xFFFFFF, i); // for accurate mode we fake white
      } else if (c & mask) seg.setColor(0, c & mask, i); // only apply if not black
      if (isCCT && cct >= 0) seg.setCCT(cct, i);
    }
    setValuesFromFirstSelectedSeg();
  } else {
    byte i = strip.getMainSegmentId();
    WS2812FX::Segment& seg = strip.getSegment(i);
    byte capabilities = seg.getLightCapabilities();
    uint32_t mask = 0;
    bool isRGB = GET_BIT(capabilities, 0);
    bool hasW  = GET_BIT(capabilities, 1);
    bool isCCT = GET_BIT(capabilities, 2);
    if (isRGB) mask |= 0x00FFFFFF; // RGB
    if (hasW)  mask |= 0xFF000000; // white
    if (hasW && (strip.autoWhiteMode == RGBW_MODE_AUTO_ACCURATE) && (c & 0xFF000000)) { // white channel & white specified
      seg.setColor(0, c | 0xFFFFFF, i); // for accurate mode we fake white
    } else if (c & mask) seg.setColor(0, c & mask, i); // only apply if not black
    if (isCCT && cct >= 0) seg.setCCT(cct, i);
    setValuesFromMainSeg();
  }
  stateChanged = true;
}

void changeWhite(int8_t amount, int16_t cct=-1)
{
  WS2812FX::Segment& seg = irApplyToAllSelected ? strip.getFirstSelectedSeg() : strip.getMainSegment();
  byte r = R(seg.colors[0]);
  byte g = G(seg.colors[0]);
  byte b = B(seg.colors[0]);
  byte w = relativeChange(W(seg.colors[0]), amount, 5);
  changeColor(RGBW32(r, g, b, w), cct);
}

void decodeIR(uint32_t code)
{
  if (code == 0xFFFFFFFF) {
    //repeated code, continue brightness up/down
    irTimesRepeated++;
    applyRepeatActions();
    return;
  }
  lastValidCode = 0; irTimesRepeated = 0;
  lastRepeatableAction = ACTION_NONE;

  if (irEnabled == 8) { // any remote configurable with ir.json file
    decodeIRJson(code);
    stateUpdated(CALL_MODE_BUTTON);
    return;
  }
  if (code > 0xFFFFFF) return; //invalid code

  switch (irEnabled) {
    case 1:
      if (code > 0xF80000) decodeIR24OLD(code); // white 24-key remote (old) - it sends 0xFF0000 values
      else                 decodeIR24(code);    // 24-key remote - 0xF70000 to 0xF80000
      break;
    case 2: decodeIR24CT(code); break; // white 24-key remote with CW, WW, CT+ and CT- keys
    case 3: decodeIR40(code);   break; // blue  40-key remote with 25%, 50%, 75% and 100% keys
    case 4: decodeIR44(code);   break; // white 44-key remote with color-up/down keys and DIY1 to 6 keys
    case 5: decodeIR21(code);   break; // white 21-key remote
    case 6: decodeIR6(code);    break; // black 6-key learning remote defaults: "CH" controls brightness,
                                       // "VOL +" controls effect, "VOL -" controls colour/palette, "MUTE"
                                       // sets bright plain white
    case 7: decodeIR9(code);    break;
    //case 8: return; // ir.json file, handled above switch statement
  }

  if (nightlightActive && bri == 0) nightlightActive = false;
  stateUpdated(CALL_MODE_BUTTON); //for notifier, IR is considered a button input
}

void applyRepeatActions()
{
  if (irEnabled == 8) {
    decodeIRJson(lastValidCode);
    return;
  } else switch (lastRepeatableAction) {
    case ACTION_BRIGHT_UP :      incBrightness();                            stateUpdated(CALL_MODE_BUTTON); return;
    case ACTION_BRIGHT_DOWN :    decBrightness();                            stateUpdated(CALL_MODE_BUTTON); return;
    case ACTION_SPEED_UP :       changeEffectSpeed(lastRepeatableValue);     stateUpdated(CALL_MODE_BUTTON); return;
    case ACTION_SPEED_DOWN :     changeEffectSpeed(lastRepeatableValue);     stateUpdated(CALL_MODE_BUTTON); return;
    case ACTION_INTENSITY_UP :   changeEffectIntensity(lastRepeatableValue); stateUpdated(CALL_MODE_BUTTON); return;
    case ACTION_INTENSITY_DOWN : changeEffectIntensity(lastRepeatableValue); stateUpdated(CALL_MODE_BUTTON); return;
    default: break;
  }
  if (lastValidCode == IR40_WPLUS) {
    changeWhite(10);
    stateUpdated(CALL_MODE_BUTTON);
  } else if (lastValidCode == IR40_WMINUS) {
    changeWhite(-10);
    stateUpdated(CALL_MODE_BUTTON);
  } else if ((lastValidCode == IR24_ON || lastValidCode == IR40_ON) && irTimesRepeated > 7 ) {
    nightlightActive = true;
    nightlightStartTime = millis();
    stateUpdated(CALL_MODE_BUTTON);
  }
}

void decodeIR24(uint32_t code)
{
  switch (code) {
    case IR24_BRIGHTER  : incBrightness();                                         break;
    case IR24_DARKER    : decBrightness();                                         break;
    case IR24_OFF    : if (bri > 0) briLast = bri; bri = 0;                        break;
    case IR24_ON        : bri = briLast;                                           break;
    case IR24_RED       : changeColor(COLOR_RED);                                  break;
    case IR24_REDDISH   : changeColor(COLOR_REDDISH);                              break;
    case IR24_ORANGE    : changeColor(COLOR_ORANGE);                               break;
    case IR24_YELLOWISH : changeColor(COLOR_YELLOWISH);                            break;
    case IR24_YELLOW    : changeColor(COLOR_YELLOW);                               break;
    case IR24_GREEN     : changeColor(COLOR_GREEN);                                break;
    case IR24_GREENISH  : changeColor(COLOR_GREENISH);                             break;
    case IR24_TURQUOISE : changeColor(COLOR_TURQUOISE);                            break;
    case IR24_CYAN      : changeColor(COLOR_CYAN);                                 break;
    case IR24_AQUA      : changeColor(COLOR_AQUA);                                 break;
    case IR24_BLUE      : changeColor(COLOR_BLUE);                                 break;
    case IR24_DEEPBLUE  : changeColor(COLOR_DEEPBLUE);                             break;
    case IR24_PURPLE    : changeColor(COLOR_PURPLE);                               break;
    case IR24_MAGENTA   : changeColor(COLOR_MAGENTA);                              break;
    case IR24_PINK      : changeColor(COLOR_PINK);                                 break;
    case IR24_WHITE     : changeColor(COLOR_WHITE); changeEffect(FX_MODE_STATIC);  break;
    case IR24_FLASH     : presetFallback(1, FX_MODE_COLORTWINKLE, effectPalette);  break;
    case IR24_STROBE    : presetFallback(2, FX_MODE_RAINBOW_CYCLE, effectPalette); break;
    case IR24_FADE      : presetFallback(3, FX_MODE_BREATH, effectPalette);        break;
    case IR24_SMOOTH    : presetFallback(4, FX_MODE_RAINBOW, effectPalette);       break;
    default: return;
  }
  lastValidCode = code;
}

void decodeIR24OLD(uint32_t code)
{
  switch (code) {
    case IR24_OLD_BRIGHTER  : incBrightness();                                        break;
    case IR24_OLD_DARKER    : decBrightness();                                        break;
    case IR24_OLD_OFF       : if (bri > 0) briLast = bri; bri = 0;                    break;
    case IR24_OLD_ON        : bri = briLast;                                          break;
    case IR24_OLD_RED       : changeColor(COLOR_RED);                                 break;
    case IR24_OLD_REDDISH   : changeColor(COLOR_REDDISH);                             break;
    case IR24_OLD_ORANGE    : changeColor(COLOR_ORANGE);                              break;
    case IR24_OLD_YELLOWISH : changeColor(COLOR_YELLOWISH);                           break;
    case IR24_OLD_YELLOW    : changeColor(COLOR_YELLOW);                              break;
    case IR24_OLD_GREEN     : changeColor(COLOR_GREEN);                               break;
    case IR24_OLD_GREENISH  : changeColor(COLOR_GREENISH);                            break;
    case IR24_OLD_TURQUOISE : changeColor(COLOR_TURQUOISE);                           break;
    case IR24_OLD_CYAN      : changeColor(COLOR_CYAN);                                break;
    case IR24_OLD_AQUA      : changeColor(COLOR_AQUA);                                break;
    case IR24_OLD_BLUE      : changeColor(COLOR_BLUE);                                break;
    case IR24_OLD_DEEPBLUE  : changeColor(COLOR_DEEPBLUE);                            break;
    case IR24_OLD_PURPLE    : changeColor(COLOR_PURPLE);                              break;
    case IR24_OLD_MAGENTA   : changeColor(COLOR_MAGENTA);                             break;
    case IR24_OLD_PINK      : changeColor(COLOR_PINK);                                break;
    case IR24_OLD_WHITE     : changeColor(COLOR_WHITE); changeEffect(FX_MODE_STATIC); break;
    case IR24_OLD_FLASH     : presetFallback(1, FX_MODE_COLORTWINKLE, 0);             break;
    case IR24_OLD_STROBE    : presetFallback(2, FX_MODE_RAINBOW_CYCLE, 0);            break;
    case IR24_OLD_FADE      : presetFallback(3, FX_MODE_BREATH, 0);                   break;
    case IR24_OLD_SMOOTH    : presetFallback(4, FX_MODE_RAINBOW, 0);                  break;
    default: return;
  }
  lastValidCode = code;
}

void decodeIR24CT(uint32_t code)
{
  switch (code) {
    case IR24_CT_BRIGHTER   : incBrightness();                     break;
    case IR24_CT_DARKER     : decBrightness();                     break;
    case IR24_CT_OFF        : if (bri > 0) briLast = bri; bri = 0; break;
    case IR24_CT_ON         : bri = briLast;                       break;
    case IR24_CT_RED        : changeColor(COLOR_RED);              break;
    case IR24_CT_REDDISH    : changeColor(COLOR_REDDISH);          break;
    case IR24_CT_ORANGE     : changeColor(COLOR_ORANGE);           break;
    case IR24_CT_YELLOWISH  : changeColor(COLOR_YELLOWISH);        break;
    case IR24_CT_YELLOW     : changeColor(COLOR_YELLOW);           break;
    case IR24_CT_GREEN      : changeColor(COLOR_GREEN);            break;
    case IR24_CT_GREENISH   : changeColor(COLOR_GREENISH);         break;
    case IR24_CT_TURQUOISE  : changeColor(COLOR_TURQUOISE);        break;
    case IR24_CT_CYAN       : changeColor(COLOR_CYAN);             break;
    case IR24_CT_AQUA       : changeColor(COLOR_AQUA);             break;
    case IR24_CT_BLUE       : changeColor(COLOR_BLUE);             break;
    case IR24_CT_DEEPBLUE   : changeColor(COLOR_DEEPBLUE);         break;
    case IR24_CT_PURPLE     : changeColor(COLOR_PURPLE);           break;
    case IR24_CT_MAGENTA    : changeColor(COLOR_MAGENTA);          break;
    case IR24_CT_PINK       : changeColor(COLOR_PINK);             break;
    case IR24_CT_COLDWHITE  : changeColor(COLOR_COLDWHITE2,                                             255); changeEffect(FX_MODE_STATIC); break;
    case IR24_CT_WARMWHITE  : changeColor(COLOR_WARMWHITE2,                                               0); changeEffect(FX_MODE_STATIC); break;
    case IR24_CT_CTPLUS     : changeColor(COLOR_COLDWHITE, strip.getSegment(strip.getMainSegmentId()).cct+1); changeEffect(FX_MODE_STATIC); break;
    case IR24_CT_CTMINUS    : changeColor(COLOR_WARMWHITE, strip.getSegment(strip.getMainSegmentId()).cct-1); changeEffect(FX_MODE_STATIC); break;
    case IR24_CT_MEMORY     : changeColor(COLOR_NEUTRALWHITE,                                           127); changeEffect(FX_MODE_STATIC); break;
    default: return;
  }
  lastValidCode = code;
}

void decodeIR40(uint32_t code)
{
  WS2812FX::Segment& seg = irApplyToAllSelected ? strip.getFirstSelectedSeg() : strip.getMainSegment();
  byte r = R(seg.colors[0]);
  byte g = G(seg.colors[0]);
  byte b = B(seg.colors[0]);
  byte w = W(seg.colors[0]);
  switch (code) {
    case IR40_BPLUS        : incBrightness();                            break;
    case IR40_BMINUS       : decBrightness();                            break;
    case IR40_OFF          : if (bri > 0) briLast = bri; bri = 0;        break;
    case IR40_ON           : bri = briLast;                              break;
    case IR40_RED          : changeColor(COLOR_RED);                     break;
    case IR40_REDDISH      : changeColor(COLOR_REDDISH);                 break;
    case IR40_ORANGE       : changeColor(COLOR_ORANGE);                  break;
    case IR40_YELLOWISH    : changeColor(COLOR_YELLOWISH);               break;
    case IR40_YELLOW       : changeColor(COLOR_YELLOW);                  break;
    case IR40_GREEN        : changeColor(COLOR_GREEN);                   break;
    case IR40_GREENISH     : changeColor(COLOR_GREENISH);                break;
    case IR40_TURQUOISE    : changeColor(COLOR_TURQUOISE);               break;
    case IR40_CYAN         : changeColor(COLOR_CYAN);                    break;
    case IR40_AQUA         : changeColor(COLOR_AQUA);                    break;
    case IR40_BLUE         : changeColor(COLOR_BLUE);                    break;
    case IR40_DEEPBLUE     : changeColor(COLOR_DEEPBLUE);                break;
    case IR40_PURPLE       : changeColor(COLOR_PURPLE);                  break;
    case IR40_MAGENTA      : changeColor(COLOR_MAGENTA);                 break;
    case IR40_PINK         : changeColor(COLOR_PINK);                    break;
    case IR40_WARMWHITE2   : changeColor(COLOR_WARMWHITE2,     0); changeEffect(FX_MODE_STATIC); break;
    case IR40_WARMWHITE    : changeColor(COLOR_WARMWHITE,     63); changeEffect(FX_MODE_STATIC); break;
    case IR40_WHITE        : changeColor(COLOR_NEUTRALWHITE, 127); changeEffect(FX_MODE_STATIC); break;
    case IR40_COLDWHITE    : changeColor(COLOR_COLDWHITE,    191); changeEffect(FX_MODE_STATIC); break;
    case IR40_COLDWHITE2   : changeColor(COLOR_COLDWHITE2,   255); changeEffect(FX_MODE_STATIC); break;
    case IR40_WPLUS        : changeWhite(10);                            break;
    case IR40_WMINUS       : changeWhite(-10);                           break;
    case IR40_WOFF         : if (w) whiteLast = w; changeColor(RGBW32(r, g, b, 0));              break;
    case IR40_WON          : changeColor(RGBW32(r, g, b, whiteLast));    break;
    case IR40_W25          : bri = 63;                                   break;
    case IR40_W50          : bri = 127;                                  break;
    case IR40_W75          : bri = 191;                                  break;
    case IR40_W100         : bri = 255;                                  break;
    case IR40_QUICK        : changeEffectSpeed( 16);                     break;
    case IR40_SLOW         : changeEffectSpeed(-16);                     break;
    case IR40_JUMP7        : changeEffectIntensity( 16);                 break;
    case IR40_AUTO         : changeEffectIntensity(-16);                 break;
    case IR40_JUMP3        : presetFallback(1, FX_MODE_STATIC,       0); break;
    case IR40_FADE3        : presetFallback(2, FX_MODE_BREATH,       0); break;
    case IR40_FADE7        : presetFallback(3, FX_MODE_FIRE_FLICKER, 0); break;
    case IR40_FLASH        : presetFallback(4, FX_MODE_RAINBOW,      0); break;
    default: return;
  }
  lastValidCode = code;
}

void decodeIR44(uint32_t code)
{
  switch (code) {
    case IR44_BPLUS       : incBrightness();                             break;
    case IR44_BMINUS      : decBrightness();                             break;
    case IR44_OFF         : if (bri > 0) briLast = bri; bri = 0;         break;
    case IR44_ON          : bri = briLast;                               break;
    case IR44_RED         : changeColor(COLOR_RED);                      break;
    case IR44_REDDISH     : changeColor(COLOR_REDDISH);                  break;
    case IR44_ORANGE      : changeColor(COLOR_ORANGE);                   break;
    case IR44_YELLOWISH   : changeColor(COLOR_YELLOWISH);                break;
    case IR44_YELLOW      : changeColor(COLOR_YELLOW);                   break;
    case IR44_GREEN       : changeColor(COLOR_GREEN);                    break;
    case IR44_GREENISH    : changeColor(COLOR_GREENISH);                 break;
    case IR44_TURQUOISE   : changeColor(COLOR_TURQUOISE);                break;
    case IR44_CYAN        : changeColor(COLOR_CYAN);                     break;
    case IR44_AQUA        : changeColor(COLOR_AQUA);                     break;
    case IR44_BLUE        : changeColor(COLOR_BLUE);                     break;
    case IR44_DEEPBLUE    : changeColor(COLOR_DEEPBLUE);                 break;
    case IR44_PURPLE      : changeColor(COLOR_PURPLE);                   break;
    case IR44_MAGENTA     : changeColor(COLOR_MAGENTA);                  break;
    case IR44_PINK        : changeColor(COLOR_PINK);                     break;
    case IR44_WHITE       : changeColor(COLOR_NEUTRALWHITE, 127); changeEffect(FX_MODE_STATIC);  break;
    case IR44_WARMWHITE2  : changeColor(COLOR_WARMWHITE2,     0); changeEffect(FX_MODE_STATIC);  break;
    case IR44_WARMWHITE   : changeColor(COLOR_WARMWHITE,     63); changeEffect(FX_MODE_STATIC);  break;
    case IR44_COLDWHITE   : changeColor(COLOR_COLDWHITE,    191); changeEffect(FX_MODE_STATIC);  break;
    case IR44_COLDWHITE2  : changeColor(COLOR_COLDWHITE2,   255); changeEffect(FX_MODE_STATIC);  break;
    case IR44_REDPLUS     : changeEffect(relativeChange(effectCurrent,  1, 0, MODE_COUNT -1));               break;
    case IR44_REDMINUS    : changeEffect(relativeChange(effectCurrent, -1, 0, MODE_COUNT -1));               break;
    case IR44_GREENPLUS   : changePalette(relativeChange(effectPalette,  1, 0, strip.getPaletteCount() -1)); break;
    case IR44_GREENMINUS  : changePalette(relativeChange(effectPalette, -1, 0, strip.getPaletteCount() -1)); break;
    case IR44_BLUEPLUS    : changeEffectIntensity( 16);                  break;
    case IR44_BLUEMINUS   : changeEffectIntensity(-16);                  break;
    case IR44_QUICK       : changeEffectSpeed( 16);                      break;
    case IR44_SLOW        : changeEffectSpeed(-16);                      break;
    case IR44_DIY1        : presetFallback(1, FX_MODE_STATIC,        0); break;
    case IR44_DIY2        : presetFallback(2, FX_MODE_BREATH,        0); break;
    case IR44_DIY3        : presetFallback(3, FX_MODE_FIRE_FLICKER,  0); break;
    case IR44_DIY4        : presetFallback(4, FX_MODE_RAINBOW,       0); break;
    case IR44_DIY5        : presetFallback(5, FX_MODE_METEOR_SMOOTH, 0); break;
    case IR44_DIY6        : presetFallback(6, FX_MODE_RAIN,          0); break;
    case IR44_AUTO        : changeEffect(FX_MODE_STATIC);                break;
    case IR44_FLASH       : changeEffect(FX_MODE_PALETTE);               break;
    case IR44_JUMP3       : bri = 63;                                    break;
    case IR44_JUMP7       : bri = 127;                                   break;
    case IR44_FADE3       : bri = 191;                                   break;
    case IR44_FADE7       : bri = 255;                                   break;
    default: return;
  }
  lastValidCode = code;
}

void decodeIR21(uint32_t code)
{
    switch (code) {
      case IR21_BRIGHTER:  incBrightness();                                        break;
      case IR21_DARKER:    decBrightness();                                        break;
      case IR21_OFF:       if (bri > 0) briLast = bri; bri = 0;                    break;
      case IR21_ON:        bri = briLast;                                          break;
      case IR21_RED:       changeColor(COLOR_RED);                                 break;
      case IR21_REDDISH:   changeColor(COLOR_REDDISH);                             break;
      case IR21_ORANGE:    changeColor(COLOR_ORANGE);                              break;
      case IR21_YELLOWISH: changeColor(COLOR_YELLOWISH);                           break;
      case IR21_GREEN:     changeColor(COLOR_GREEN);                               break;
      case IR21_GREENISH:  changeColor(COLOR_GREENISH);                            break;
      case IR21_TURQUOISE: changeColor(COLOR_TURQUOISE);                           break;
      case IR21_CYAN:      changeColor(COLOR_CYAN);                                break;
      case IR21_BLUE:      changeColor(COLOR_BLUE);                                break;
      case IR21_DEEPBLUE:  changeColor(COLOR_DEEPBLUE);                            break;
      case IR21_PURPLE:    changeColor(COLOR_PURPLE);                              break;
      case IR21_PINK:      changeColor(COLOR_PINK);                                break;
      case IR21_WHITE:     changeColor(COLOR_WHITE); changeEffect(FX_MODE_STATIC); break;
      case IR21_FLASH:     presetFallback(1, FX_MODE_COLORTWINKLE,  0);            break;
      case IR21_STROBE:    presetFallback(2, FX_MODE_RAINBOW_CYCLE, 0);            break;
      case IR21_FADE:      presetFallback(3, FX_MODE_BREATH,        0);            break;
      case IR21_SMOOTH:    presetFallback(4, FX_MODE_RAINBOW,       0);            break;
      default: return;
    }
    lastValidCode = code;
}

void decodeIR6(uint32_t code)
{
  switch (code) {
    case IR6_POWER:        toggleOnOff();                                                    break;
    case IR6_CHANNEL_UP:   incBrightness();                                                  break;
    case IR6_CHANNEL_DOWN: decBrightness();                                                  break;
    case IR6_VOLUME_UP:    changeEffect(relativeChange(effectCurrent, 1, 0, MODE_COUNT -1)); break;
    case IR6_VOLUME_DOWN:  changePalette(relativeChange(effectPalette, 1, 0, strip.getPaletteCount() -1));
      switch(lastIR6ColourIdx) {
        case 0: changeColor(COLOR_RED);       break;
        case 1: changeColor(COLOR_REDDISH);   break;
        case 2: changeColor(COLOR_ORANGE);    break;
        case 3: changeColor(COLOR_YELLOWISH); break;
        case 4: changeColor(COLOR_GREEN);     break;
        case 5: changeColor(COLOR_GREENISH);  break;
        case 6: changeColor(COLOR_TURQUOISE); break;
        case 7: changeColor(COLOR_CYAN);      break;
        case 8: changeColor(COLOR_BLUE);      break;
        case 9: changeColor(COLOR_DEEPBLUE);  break;
        case 10:changeColor(COLOR_PURPLE);    break;
        case 11:changeColor(COLOR_PINK);      break;
        case 12:changeColor(COLOR_WHITE);     break;
        default:                              break;
      }
      lastIR6ColourIdx++;
      if(lastIR6ColourIdx > 12) lastIR6ColourIdx = 0;
      break;
    case IR6_MUTE: changeEffect(FX_MODE_STATIC); changePalette(0); changeColor(COLOR_WHITE); bri=255; break;
    default: return;
  }
  lastValidCode = code;
}

void decodeIR9(uint32_t code)
{
  switch (code) {
    case IR9_POWER      : toggleOnOff();                                                    break;
    case IR9_A          : presetFallback(1, FX_MODE_COLORTWINKLE, effectPalette);           break;
    case IR9_B          : presetFallback(2, FX_MODE_RAINBOW_CYCLE, effectPalette);          break;
    case IR9_C          : presetFallback(3, FX_MODE_BREATH, effectPalette);                 break;
    case IR9_UP         : incBrightness();                                                  break;
    case IR9_DOWN       : decBrightness();                                                  break;
    case IR9_LEFT       : changeEffectSpeed(-16);                                           break;
    case IR9_RIGHT      : changeEffectSpeed(16);                                            break;
    case IR9_SELECT     : changeEffect(relativeChange(effectCurrent, 1, 0, MODE_COUNT -1)); break;
    default: return;
  }
  lastValidCode = code;
}


/*
This allows users to customize IR actions without the need to edit C code and compile.
From the https://github.com/Aircoookie/WLED/wiki/Infrared-Control page, download the starter
ir.json file that corresponds to the number of buttons on your remote.
Many of the remotes with the same number of buttons emit the same codes, but will have
different labels or colors. Once you edit the ir.json file, upload it to your controller
using the /edit page.

Each key should be the hex encoded IR code. The "cmd" property should be the HTTP API
or JSON API command to execute on button press. If the command contains a relative change (SI=~16),
it will register as a repeatable command. If the command doesn't contain a "~" but is repeatable, add "rpt" property
set to true. Other properties are ignored but having labels and positions can assist with editing
the json file.

Sample:
{
  "0xFF629D": {"cmd": "T=2", "rpt": true, "label": "Toggle on/off"},  // HTTP command
  "0xFF9867": {"cmd": "A=~16", "label": "Inc brightness"},            // HTTP command with incrementing
  "0xFF38C7": {"cmd": {"bri": 10}, "label": "Dim to 10"},             // JSON command
  "0xFF22DD": {"cmd": "!presetFallback", "PL": 1, "FX": 16, "FP": 6,  // Custom command
               "label": "Preset 1, fallback to Saw - Party if not found"},
}
*/
void decodeIRJson(uint32_t code)
{
  char objKey[10];
  String cmdStr;
  JsonObject fdo;
  JsonObject jsonCmdObj;

  #ifdef WLED_USE_DYNAMIC_JSON
  DynamicJsonDocument doc(JSON_BUFFER_SIZE);
  #else
  if (!requestJSONBufferLock(13)) return;
  #endif

  sprintf_P(objKey, PSTR("\"0x%lX\":"), (unsigned long)code);

  // attempt to read command from ir.json
  // this may fail for two reasons: ir.json does not exist or IR code not found
  // if the IR code is not found readObjectFromFile() will clean() doc JSON document
  // so we can differentiate between the two
  readObjectFromFile("/ir.json", objKey, &doc);
  fdo = doc.as<JsonObject>();
  lastValidCode = 0;
  if (fdo.isNull()) {
    //the received code does not exist
    if (!WLED_FS.exists("/ir.json")) errorFlag = ERR_FS_IRLOAD; //warn if IR file itself doesn't exist
    releaseJSONBufferLock();
    return;
  }

  cmdStr = fdo["cmd"].as<String>();
  jsonCmdObj = fdo["cmd"]; //object

  if (jsonCmdObj.isNull())  // we could also use: fdo["cmd"].is<String>()
  {
    if (cmdStr.startsWith("!")) {
      // call limited set of C functions
      if (cmdStr.startsWith(F("!incBri"))) {
        lastValidCode = code;
        incBrightness();
      } else if (cmdStr.startsWith(F("!decBri"))) {
        lastValidCode = code;
        decBrightness();
      } else if (cmdStr.startsWith(F("!presetF"))) { //!presetFallback
        uint8_t p1 = fdo["PL"] | 1;
        uint8_t p2 = fdo["FX"] | random8(MODE_COUNT -1);
        uint8_t p3 = fdo["FP"] | 0;
        presetFallback(p1, p2, p3);
      }
    } else {
      // HTTP API command
      String apireq = "win"; apireq += '&';                        // reduce flash string usage
      if (cmdStr.indexOf("~") || fdo["rpt"]) lastValidCode = code; // repeatable action
      if (!cmdStr.startsWith(apireq)) cmdStr = apireq + cmdStr;    // if no "win&" prefix
      if (!irApplyToAllSelected && cmdStr.indexOf(F("SS="))<0) {
        char tmp[10];
        sprintf_P(tmp, PSTR("&SS=%d"), strip.getMainSegmentId());
        cmdStr += tmp;
      }
      fdo.clear();                                                 // clear JSON buffer (it is no longer needed)
      handleSet(nullptr, cmdStr, false);                           // no stateUpdated() call here
    }
  } else {
    // command is JSON object (TODO: currently will not handle irApplyToAllSelected correctly)
    if (jsonCmdObj[F("psave")].isNull()) deserializeState(jsonCmdObj, CALL_MODE_BUTTON_PRESET);
    else {
      uint8_t psave = jsonCmdObj[F("psave")].as<int>();
      char pname[33];
      sprintf_P(pname, PSTR("IR Preset %d"), psave);
      fdo.clear();
      if (psave > 0 && psave < 251) savePreset(psave, pname, fdo);
    }
  }
  releaseJSONBufferLock();
}

void initIR()
{
  if (irEnabled > 0)
  {
    irrecv = new IRrecv(irPin);
    irrecv->enableIRIn();
  }
}

void handleIR()
{
  if (irEnabled > 0 && millis() - irCheckedTime > 120)
  {
    irCheckedTime = millis();
    if (irEnabled > 0)
    {
      if (irrecv == NULL)
      {
        initIR(); return;
      }

      if (irrecv->decode(&results))
      {
        if (results.value != 0) // only print results if anything is received ( != 0 )
        {
					if (!pinManager.isPinAllocated(1) || pinManager.getPinOwner(1) == PinOwner::DebugOut) //GPIO 1 - Serial TX pin
          	Serial.printf_P(PSTR("IR recv: 0x%lX\n"), (unsigned long)results.value);
        }
        decodeIR(results.value);
        irrecv->resume();
      }
    } else if (irrecv != NULL)
    {
      irrecv->disableIRIn();
      delete irrecv; irrecv = NULL;
    }
  }
}

#endif

=== ./ir_codes.h ===

//Infrared codes

//Add your custom codes here
#define IRCUSTOM_ONOFF  0xA55AEA15 //Pioneer RC-975R "+FAV" button (example)
#define IRCUSTOM_MACRO1 0xFFFFFFFF //placeholder, will never be checked for

// Default IR codes for 6-key learning remote https://www.aliexpress.com/item/4000307837886.html
// This cheap remote has the advantage of being more powerful (longer range) than cheap credit-card remotes
#define IR6_POWER        0xFF0FF0
#define IR6_CHANNEL_UP   0xFF8F70
#define IR6_CHANNEL_DOWN 0xFF4FB0
#define IR6_VOLUME_UP    0xFFCF30
#define IR6_VOLUME_DOWN  0xFF2FD0
#define IR6_MUTE         0xFFAF50

#define IR9_POWER       0xFF629D
#define IR9_A           0xFF22DD
#define IR9_B           0xFF02FD
#define IR9_C           0xFFC23D
#define IR9_LEFT        0xFF30CF
#define IR9_RIGHT       0xFF7A85
#define IR9_UP          0xFF9867
#define IR9_DOWN        0xFF38C7
#define IR9_SELECT      0xFF18E7

//Infrared codes for 24-key remote from http://woodsgood.ca/projects/2015/02/13/rgb-led-strip-controllers-ir-codes/
#define IR24_BRIGHTER  0xF700FF
#define IR24_DARKER    0xF7807F
#define IR24_OFF       0xF740BF
#define IR24_ON        0xF7C03F
#define IR24_RED       0xF720DF
#define IR24_REDDISH   0xF710EF
#define IR24_ORANGE    0xF730CF
#define IR24_YELLOWISH 0xF708F7
#define IR24_YELLOW    0xF728D7
#define IR24_GREEN     0xF7A05F
#define IR24_GREENISH  0xF7906F
#define IR24_TURQUOISE 0xF7B04F
#define IR24_CYAN      0xF78877
#define IR24_AQUA      0xF7A857
#define IR24_BLUE      0xF7609F
#define IR24_DEEPBLUE  0xF750AF
#define IR24_PURPLE    0xF7708F
#define IR24_MAGENTA   0xF748B7
#define IR24_PINK      0xF76897
#define IR24_WHITE     0xF7E01F
#define IR24_FLASH     0xF7D02F
#define IR24_STROBE    0xF7F00F 
#define IR24_FADE      0xF7C837 
#define IR24_SMOOTH    0xF7E817 

// 24-key defs for white remote control with CW / WW / CT+ and CT- keys (from ALDI LED pillar lamp)
#define IR24_CT_BRIGHTER   0xF700FF // BRI +
#define IR24_CT_DARKER     0xF7807F // BRI -
#define IR24_CT_OFF        0xF740BF // OFF
#define IR24_CT_ON         0xF7C03F // ON
#define IR24_CT_RED        0xF720DF // RED
#define IR24_CT_REDDISH    0xF710EF // REDDISH
#define IR24_CT_ORANGE     0xF730CF // ORANGE
#define IR24_CT_YELLOWISH  0xF708F7 // YELLOWISH
#define IR24_CT_YELLOW     0xF728D7 // YELLOW
#define IR24_CT_GREEN      0xF7A05F // GREEN
#define IR24_CT_GREENISH   0xF7906F // GREENISH
#define IR24_CT_TURQUOISE  0xF7B04F // TURQUOISE
#define IR24_CT_CYAN       0xF78877 // CYAN
#define IR24_CT_AQUA       0xF7A857 // AQUA
#define IR24_CT_BLUE       0xF7609F // BLUE
#define IR24_CT_DEEPBLUE   0xF750AF // DEEPBLUE
#define IR24_CT_PURPLE     0xF7708F // PURPLE
#define IR24_CT_MAGENTA    0xF748B7 // MAGENTA
#define IR24_CT_PINK       0xF76897 // PINK
#define IR24_CT_COLDWHITE  0xF7E01F // CW
#define IR24_CT_WARMWHITE  0xF7D02F // WW
#define IR24_CT_CTPLUS     0xF7F00F // CT+
#define IR24_CT_CTMINUS    0xF7C837 // CT-
#define IR24_CT_MEMORY     0xF7E817 // MEMORY

// 24-key defs for old remote control 
#define IR24_OLD_BRIGHTER  0xFF906F // Brightness Up
#define IR24_OLD_DARKER    0xFFB847 // Brightness Down
#define IR24_OLD_OFF       0xFFF807 // Power OFF
#define IR24_OLD_ON        0xFFB04F // Power On
#define IR24_OLD_RED       0xFF9867 // RED
#define IR24_OLD_REDDISH   0xFFE817 // Light RED
#define IR24_OLD_ORANGE    0xFF02FD // Orange
#define IR24_OLD_YELLOWISH 0xFF50AF // Light Orange
#define IR24_OLD_YELLOW    0xFF38C7 // YELLOW
#define IR24_OLD_GREEN     0xFFD827 // GREEN
#define IR24_OLD_GREENISH  0xFF48B7 // Light GREEN
#define IR24_OLD_TURQUOISE 0xFF32CD // TURQUOISE
#define IR24_OLD_CYAN      0xFF7887 // CYAN
#define IR24_OLD_AQUA      0xFF28D7 // AQUA
#define IR24_OLD_BLUE      0xFF8877 // BLUE
#define IR24_OLD_DEEPBLUE  0xFF6897 // Dark BLUE
#define IR24_OLD_PURPLE    0xFF20DF // PURPLE
#define IR24_OLD_MAGENTA   0xFF708F // MAGENTA
#define IR24_OLD_PINK      0xFFF00F // PINK
#define IR24_OLD_WHITE     0xFFA857 // WHITE
#define IR24_OLD_FLASH     0xFFB24D // FLASH Mode
#define IR24_OLD_STROBE    0xFF00FF // STROBE Mode
#define IR24_OLD_FADE      0xFF58A7 // FADE Mode
#define IR24_OLD_SMOOTH    0xFF30CF // SMOOTH Mode

// 40-key defs for blue remote control 
#define IR40_BPLUS         0xFF3AC5  // 
#define IR40_BMINUS        0xFFBA45  // 
#define IR40_OFF           0xFF827D  // 
#define IR40_ON            0xFF02FD  // 
#define IR40_RED           0xFF1AE5  // 
#define IR40_GREEN         0xFF9A65  // 
#define IR40_BLUE          0xFFA25D  // 
#define IR40_WHITE         0xFF22DD  // natural white
#define IR40_REDDISH       0xFF2AD5  // 
#define IR40_GREENISH      0xFFAA55  // 
#define IR40_DEEPBLUE      0xFF926D  // 
#define IR40_WARMWHITE2    0xFF12ED  // warmest white
#define IR40_ORANGE        0xFF0AF5  // 
#define IR40_TURQUOISE     0xFF8A75  // 
#define IR40_PURPLE        0xFFB24D  // 
#define IR40_WARMWHITE     0xFF32CD  // warm white
#define IR40_YELLOWISH     0xFF38C7  // 
#define IR40_CYAN          0xFFB847  // 
#define IR40_MAGENTA       0xFF7887  // 
#define IR40_COLDWHITE     0xFFF807  // cold white
#define IR40_YELLOW        0xFF18E7  // 
#define IR40_AQUA          0xFF9867  // 
#define IR40_PINK          0xFF58A7  // 
#define IR40_COLDWHITE2    0xFFD827  // coldest white
#define IR40_WPLUS         0xFF28D7  // white chanel bright plus
#define IR40_WMINUS        0xFFA857  // white chanel bright minus
#define IR40_WOFF          0xFF6897  // white chanel on
#define IR40_WON           0xFFE817  // white chanel off
#define IR40_W25           0xFF08F7  // white chanel 25%
#define IR40_W50           0xFF8877  // white chanel 50%
#define IR40_W75           0xFF48B7  // white chanel 75%
#define IR40_W100          0xFFC837  // white chanel 100%
#define IR40_JUMP3         0xFF30CF  // JUMP3
#define IR40_FADE3         0xFFB04F  // FADE3
#define IR40_JUMP7         0xFF708F  // JUMP7
#define IR40_QUICK         0xFFF00F  // QUICK
#define IR40_FADE7         0xFF10EF  // FADE7
#define IR40_FLASH         0xFF906F  // FLASH
#define IR40_AUTO          0xFF50AF  // AUTO
#define IR40_SLOW          0xFFD02F  // SLOW

// 44-key defs, to be done later
#define IR44_BPLUS         0xFF3AC5  // 
#define IR44_BMINUS        0xFFBA45  // 
#define IR44_OFF           0xFF827D  // 
#define IR44_ON            0xFF02FD  // 
#define IR44_RED           0xFF1AE5  // 
#define IR44_GREEN         0xFF9A65  // 
#define IR44_BLUE          0xFFA25D  // 
#define IR44_WHITE         0xFF22DD  // natural white
#define IR44_REDDISH       0xFF2AD5  // 
#define IR44_GREENISH      0xFFAA55  // 
#define IR44_DEEPBLUE      0xFF926D  // 
#define IR44_WARMWHITE2    0xFF12ED  // warmest white
#define IR44_ORANGE        0xFF0AF5  // 
#define IR44_TURQUOISE     0xFF8A75  // 
#define IR44_PURPLE        0xFFB24D  // 
#define IR44_WARMWHITE     0xFF32CD  // warm white
#define IR44_YELLOWISH     0xFF38C7  // 
#define IR44_CYAN          0xFFB847  // 
#define IR44_MAGENTA       0xFF7887  // 
#define IR44_COLDWHITE     0xFFF807  // cold white
#define IR44_YELLOW        0xFF18E7  // 
#define IR44_AQUA          0xFF9867  // 
#define IR44_PINK          0xFF58A7  // 
#define IR44_COLDWHITE2    0xFFD827  // coldest white
#define IR44_REDPLUS       0xFF28D7  // 
#define IR44_GREENPLUS     0xFFA857  // 
#define IR44_BLUEPLUS      0xFF6897  // 
#define IR44_QUICK         0xFFE817  // 
#define IR44_REDMINUS      0xFF08F7  // 
#define IR44_GREENMINUS    0xFF8877  // 
#define IR44_BLUEMINUS     0xFF48B7  // 
#define IR44_SLOW          0xFFC837  // 
#define IR44_DIY1          0xFF30CF  // 
#define IR44_DIY2          0xFFB04F  // 
#define IR44_DIY3          0xFF708F  // 
#define IR44_AUTO          0xFFF00F  // 
#define IR44_DIY4          0xFF10EF  // 
#define IR44_DIY5          0xFF906F  // 
#define IR44_DIY6          0xFF50AF  // 
#define IR44_FLASH         0xFFD02F  // 
#define IR44_JUMP3         0xFF20DF  // 
#define IR44_JUMP7         0xFFA05F  // 
#define IR44_FADE3         0xFF609F  // 
#define IR44_FADE7         0xFFE01F  // 

//Infrared codes for 21-key remote https://images-na.ssl-images-amazon.com/images/I/51NMA0XucnL.jpg
#define IR21_BRIGHTER      0xFFE01F
#define IR21_DARKER        0xFFA857
#define IR21_OFF           0xFF629D
#define IR21_ON            0xFFA25D
#define IR21_RED           0xFF6897
#define IR21_REDDISH       0xFF30CF
#define IR21_ORANGE        0xFF10EF
#define IR21_YELLOWISH     0xFF42BD
#define IR21_GREEN         0xFF9867
#define IR21_GREENISH      0xFF18E7
#define IR21_TURQUOISE     0xFF38C7
#define IR21_CYAN          0xFF4AB5
#define IR21_BLUE          0xFFB04F
#define IR21_DEEPBLUE      0xFF7A85
#define IR21_PURPLE        0xFF5AA5
#define IR21_PINK          0xFF52AD
#define IR21_WHITE         0xFF906F
#define IR21_FLASH         0xFFE21D
#define IR21_STROBE        0xFF22DD
#define IR21_FADE          0xFF02FD
#define IR21_SMOOTH        0xFFC23D

#define COLOR_RED            0xFF0000
#define COLOR_REDDISH        0xFF7800
#define COLOR_ORANGE         0xFFA000
#define COLOR_YELLOWISH      0xFFC800
#define COLOR_YELLOW         0xFFFF00
#define COLOR_GREEN          0x00FF00
#define COLOR_GREENISH       0x00FF78
#define COLOR_TURQUOISE      0x00FFA0
#define COLOR_CYAN           0x00FFDC
#define COLOR_AQUA           0x00C8FF
#define COLOR_BLUE           0x00A0FF
#define COLOR_DEEPBLUE       0x0000FF
#define COLOR_PURPLE         0xAA00FF
#define COLOR_MAGENTA        0xFF00DC
#define COLOR_PINK           0xFF00A0
#define COLOR_WHITE          0xFFFFFFFF
#define COLOR_WARMWHITE2     0xFFFFAA69
#define COLOR_WARMWHITE      0xFFFFBF8E
#define COLOR_NEUTRALWHITE   0xFFFFD4B4
#define COLOR_COLDWHITE      0xFFFFE9D9
#define COLOR_COLDWHITE2     0xFFFFFFFF

#define ACTION_NONE             0
#define ACTION_BRIGHT_UP        1
#define ACTION_BRIGHT_DOWN      2
#define ACTION_SPEED_UP         3
#define ACTION_SPEED_DOWN       4
#define ACTION_INTENSITY_UP     5
#define ACTION_INTENSITY_DOWN   6
#define ACTION_POWER            7

=== ./json.cpp ===

#include "wled.h"

#include "palettes.h"

#include <Esp.h>

/*
 * JSON API (De)serialization
 */

bool getVal(JsonVariant elem, byte* val, byte vmin=0, byte vmax=255) {
  if (elem.is<int>()) {
    if (elem < 0) return false; //ignore e.g. {"ps":-1}
    *val = elem;
    return true;
  } else if (elem.is<const char*>()) {
    const char* str = elem;
    size_t len = strnlen(str, 12);
    if (len == 0 || len > 10) return false;
    parseNumber(str, val, vmin, vmax);
    return true;
  }
  return false; //key does not exist
}

void deserializeSegment(JsonObject elem, byte it, byte presetId)
{
  byte id = elem["id"] | it;
  if (id >= strip.getMaxSegments()) return;

  WS2812FX::Segment& seg = strip.getSegment(id);
  WS2812FX::Segment prev = seg; //make a backup so we can tell if something changed

  uint16_t start = elem["start"] | seg.start;
  int stop = elem["stop"] | -1;
  if (stop < 0) {
    uint16_t len = elem["len"];
    stop = (len > 0) ? start + len : seg.stop;
  }

  //repeat, multiplies segment until all LEDs are used, or max segments reached
  bool repeat = elem["rpt"] | false;
  if (repeat && stop>0) {
    elem.remove("id");  // remove for recursive call
    elem.remove("rpt"); // remove for recursive call
    elem.remove("n");   // remove for recursive call
    uint16_t len = stop - start;
    for (byte i=id+1; i<strip.getMaxSegments(); i++) {
      start = start + len;
      if (start >= strip.getLengthTotal()) break;
      elem["start"] = start;
      elem["stop"]  = start + len;
      elem["rev"]   = !elem["rev"]; // alternate reverse on even/odd segments
      deserializeSegment(elem, i, presetId); // recursive call with new id
    }
    return;
  }

  if (elem["n"]) {
    // name field exists
    if (seg.name) { //clear old name
      delete[] seg.name;
      seg.name = nullptr;
    }

    const char * name = elem["n"].as<const char*>();
    size_t len = 0;
    if (name != nullptr) len = strlen(name);
    if (len > 0 && len < 33) {
      seg.name = new char[len+1];
      if (seg.name) strlcpy(seg.name, name, 33);
    } else {
      // but is empty (already deleted above)
      elem.remove("n");
    }
  } else if (start != seg.start || stop != seg.stop) {
    // clearing or setting segment without name field
    if (seg.name) {
      delete[] seg.name;
      seg.name = nullptr;
    }
  }

  uint16_t grp = elem["grp"] | seg.grouping;
  uint16_t spc = elem[F("spc")] | seg.spacing;
  uint16_t of = seg.offset;

  uint16_t len = 1;
  if (stop > start) len = stop - start;
  int offset = elem[F("of")] | INT32_MAX;
  if (offset != INT32_MAX) {
    int offsetAbs = abs(offset);
    if (offsetAbs > len - 1) offsetAbs %= len;
    if (offset < 0) offsetAbs = len - offsetAbs;
    of = offsetAbs;
  }
  if (stop > start && of > len -1) of = len -1;
  strip.setSegment(id, start, stop, grp, spc, of);

  byte segbri = seg.opacity;
  if (getVal(elem["bri"], &segbri)) {
    if (segbri > 0) seg.setOpacity(segbri, id);
    seg.setOption(SEG_OPTION_ON, segbri, id);
  }

  bool on = elem["on"] | seg.getOption(SEG_OPTION_ON);
  if (elem["on"].is<const char*>() && elem["on"].as<const char*>()[0] == 't') on = !on;
  seg.setOption(SEG_OPTION_ON, on, id);

  //WLEDSR ARTI-FX
  bool reset = elem["reset"];
  if (reset)
    strip.setReset(id);

  bool frz = elem["frz"] | seg.getOption(SEG_OPTION_FREEZE);
  if (elem["frz"].is<const char*>() && elem["frz"].as<const char*>()[0] == 't') frz = !seg.getOption(SEG_OPTION_FREEZE);
  seg.setOption(SEG_OPTION_FREEZE, frz, id);

  seg.setCCT(elem["cct"] | seg.cct, id);

  JsonArray colarr = elem["col"];
  if (!colarr.isNull())
  {
    for (uint8_t i = 0; i < 3; i++)
    {
      int rgbw[] = {0,0,0,0};
      bool colValid = false;
      JsonArray colX = colarr[i];
      if (colX.isNull()) {
        byte brgbw[] = {0,0,0,0};
        const char* hexCol = colarr[i];
        if (hexCol == nullptr) { //Kelvin color temperature (or invalid), e.g 2400
          int kelvin = colarr[i] | -1;
          if (kelvin <  0) continue;
          if (kelvin == 0) seg.setColor(i, 0, id);
          if (kelvin >  0) colorKtoRGB(kelvin, brgbw);
          colValid = true;
        } else { //HEX string, e.g. "FFAA00"
          colValid = colorFromHexString(brgbw, hexCol);
        }
        for (uint8_t c = 0; c < 4; c++) rgbw[c] = brgbw[c];
      } else { //Array of ints (RGB or RGBW color), e.g. [255,160,0]
        byte sz = colX.size();
        if (sz == 0) continue; //do nothing on empty array

        copyArray(colX, rgbw, 4);
        colValid = true;
      }

      if (!colValid) continue;

      seg.setColor(i, RGBW32(rgbw[0],rgbw[1],rgbw[2],rgbw[3]), id);
      if (seg.mode == FX_MODE_STATIC) strip.trigger(); //instant refresh
    }
  }

  // lx parser
  #ifdef WLED_ENABLE_LOXONE
  int lx = elem[F("lx")] | -1;
  if (lx > 0) {
    parseLxJson(lx, id, false);
  }
  int ly = elem[F("ly")] | -1;
  if (ly > 0) {
    parseLxJson(ly, id, true);
  }
  #endif

// CHANGED IN 7eb029d and 7b969bb and
/*  //if (pal != seg.palette && pal < strip.getPaletteCount()) strip.setPalette(pal);
  seg.setOption(SEG_OPTION_SELECTED  , elem[F("sel")]   | seg.getOption(SEG_OPTION_SELECTED  ));
  seg.setOption(SEG_OPTION_REVERSED  , elem["rev"]      | seg.getOption(SEG_OPTION_REVERSED  ));
  seg.setOption(SEG_OPTION_REVERSED2D, elem["rev2D"]    | seg.getOption(SEG_OPTION_REVERSED2D));
  seg.setOption(SEG_OPTION_MIRROR    , elem[F("mi")]    | seg.getOption(SEG_OPTION_MIRROR    ));
  seg.setOption(SEG_OPTION_ROTATED2D , elem[F("rot2D")] | seg.getOption(SEG_OPTION_ROTATED2D ));

  //temporary, strip object gets updated via colorUpdated()
  if (id == strip.getMainSegmentId()) {
		byte effectPrev = effectCurrent;
    if (getVal(elem["fx"], &effectCurrent, 1, strip.getModeCount())) { //load effect ('r' random, '~' inc/dec, 0-255 exact value)
      if (!presetId && effectCurrent != effectPrev) unloadPlaylist(); //stop playlist if active and FX changed manually
    }
    effectSpeed = elem[F("sx")] | effectSpeed;
    effectIntensity = elem[F("ix")] | effectIntensity;
    effectCustom1 = elem[F("c1x")] | effectCustom1;
    effectCustom2 = elem[F("c2x")] | effectCustom2;
    effectCustom3 = elem[F("c3x")] | effectCustom3;
    getVal(elem["pal"], &effectPalette, 1, strip.getPaletteCount());
  } else { //permanent
    byte fx = seg.mode;
		byte fxPrev = fx;
    if (getVal(elem["fx"], &fx, 1, strip.getModeCount())) { //load effect ('r' random, '~' inc/dec, 0-255 exact value)
      strip.setMode(id, fx);
      if (!presetId && seg.mode != fxPrev) unloadPlaylist(); //stop playlist if active and FX changed manually
    }
    seg.speed = elem[F("sx")] | seg.speed;
    seg.intensity = elem[F("ix")] | seg.intensity;
    seg.custom1 = elem[F("c1x")] | seg.custom1;
    seg.custom2 = elem[F("c2x")] | seg.custom2;
    seg.custom3 = elem[F("c3x")] | seg.custom3;
    getVal(elem["pal"], &seg.palette, 1, strip.getPaletteCount()); */

  seg.setOption(SEG_OPTION_SELECTED  , elem[F("sel")]   | seg.getOption(SEG_OPTION_SELECTED  ));
  seg.setOption(SEG_OPTION_REVERSED  , elem["rev"]      | seg.getOption(SEG_OPTION_REVERSED  ));
  seg.setOption(SEG_OPTION_REVERSED2D, elem["rev2D"]    | seg.getOption(SEG_OPTION_REVERSED2D)); // WLEDSR
  seg.setOption(SEG_OPTION_MIRROR    , elem[F("mi")]    | seg.getOption(SEG_OPTION_MIRROR    ));
  seg.setOption(SEG_OPTION_ROTATED2D , elem[F("rot2D")] | seg.getOption(SEG_OPTION_ROTATED2D )); // WLEDSR

  byte fx = seg.mode;
  if (getVal(elem["fx"], &fx, 1, strip.getModeCount())) { //load effect ('r' random, '~' inc/dec, 1-255 exact value)
    if (!presetId && currentPlaylist>=0) unloadPlaylist();
    strip.setMode(id, fx);
  }

  //getVal also supports inc/decrementing and random
  getVal(elem[F("sx")], &seg.speed, 0, 255);
  getVal(elem[F("ix")], &seg.intensity, 0, 255);
  getVal(elem[F("c1x")], &seg.custom1, 0, 255); // WLEDSR
  getVal(elem[F("c2x")], &seg.custom2, 0, 255); // WLEDSR
  getVal(elem[F("c3x")], &seg.custom3, 0, 255); // WLEDSR
  getVal(elem["pal"], &seg.palette, 1, strip.getPaletteCount());

  JsonArray iarr = elem[F("i")]; //set individual LEDs
  if (!iarr.isNull()) {
    uint8_t oldSegId = strip.setPixelSegment(id);

    // set brightness immediately and disable transition
    transitionDelayTemp = 0;
    jsonTransitionOnce = true;
    strip.setBrightness(scaledBri(bri), true);

    // freeze and init to black
    if (!seg.getOption(SEG_OPTION_FREEZE)) {
      seg.setOption(SEG_OPTION_FREEZE, true);
      strip.fill(0);
    }

    uint16_t start = 0, stop = 0;
    byte set = 0; //0 nothing set, 1 start set, 2 range set

    for (uint16_t i = 0; i < iarr.size(); i++) {
      if(iarr[i].is<JsonInteger>()) {
        if (!set) {
          start = iarr[i];
          set = 1;
        } else {
          stop = iarr[i];
          set = 2;
        }
      } else { //color
        int rgbw[] = {0,0,0,0};
        JsonArray icol = iarr[i];
        if (!icol.isNull()) { //array, e.g. [255,0,0]
          byte sz = icol.size();
          if (sz > 0 && sz < 5) copyArray(icol, rgbw);
        } else { //hex string, e.g. "FF0000"
          byte brgbw[] = {0,0,0,0};
          const char* hexCol = iarr[i];
          if (colorFromHexString(brgbw, hexCol)) {
            for (uint8_t c = 0; c < 4; c++) rgbw[c] = brgbw[c];
          }
        }

        if (set < 2) stop = start + 1;
        for (uint16_t i = start; i < stop; i++) {
          if (strip.gammaCorrectCol) {
            strip.setPixelColor(i, strip.gamma8(rgbw[0]), strip.gamma8(rgbw[1]), strip.gamma8(rgbw[2]), strip.gamma8(rgbw[3]));
          } else {
            strip.setPixelColor(i, rgbw[0], rgbw[1], rgbw[2], rgbw[3]);
          }
        }
        if (!set) start++;
        set = 0;
      }
    }
    strip.setPixelSegment(oldSegId);
    strip.trigger();
//  } else if (!elem["frz"] && iarr.isNull()) { //return to regular effect
//    seg.setOption(SEG_OPTION_FREEZE, false);
  }
  // send UDP if not in preset and something changed that is not just selection
  //if (!presetId && (seg.differs(prev) & 0x7F)) stateChanged = true;
  // send UDP if something changed that is not just selection
  if (seg.differs(prev) & 0x7F) stateChanged = true;
  return;
}

// deserializes WLED state (fileDoc points to doc object if called from web server)
bool deserializeState(JsonObject root, byte callMode, byte presetId)
{
  bool stateResponse = root[F("v")] | false;

  bool onBefore = bri;
  getVal(root["bri"], &bri);
  getVal(root["inputLevel"], &inputLevel); //WLEDSR

  bool on = root["on"] | (bri > 0);
  if (!on != !bri) toggleOnOff();

  if (root["on"].is<const char*>() && root["on"].as<const char*>()[0] == 't') toggleOnOff();

  if (bri && !onBefore) { // unfreeze all segments when turning on
    for (uint8_t s=0; s < strip.getMaxSegments(); s++) {
      strip.getSegment(s).setOption(SEG_OPTION_FREEZE, false, s);
    }
    if (realtimeMode && !realtimeOverride && useMainSegmentOnly) { // keep live segment frozen if live
      strip.getMainSegment().setOption(SEG_OPTION_FREEZE, true, strip.getMainSegmentId());
    }
  }

  int tr = -1;
  if (!presetId || currentPlaylist < 0) { //do not apply transition time from preset if playlist active, as it would override playlist transition times
    tr = root[F("transition")] | -1;
    if (tr >= 0)
    {
      transitionDelay = tr;
      transitionDelay *= 100;
      transitionDelayTemp = transitionDelay;
    }
  }

  tr = root[F("tt")] | -1;
  if (tr >= 0)
  {
    transitionDelayTemp = tr;
    transitionDelayTemp *= 100;
    jsonTransitionOnce = true;
  }
  strip.setTransition(transitionDelayTemp); // required here for color transitions to have correct duration

  tr = root[F("tb")] | -1;
  if (tr >= 0) strip.timebase = ((uint32_t)tr) - millis();

  JsonObject nl       = root["nl"];
  nightlightActive    = nl["on"]      | nightlightActive;
  nightlightDelayMins = nl["dur"]     | nightlightDelayMins;
  nightlightMode      = nl["mode"]    | nightlightMode;
  nightlightTargetBri = nl[F("tbri")] | nightlightTargetBri;

  JsonObject udpn      = root["udpn"];
  notifyDirect         = udpn["send"] | notifyDirect;
  receiveNotifications = udpn["recv"] | receiveNotifications;
  if ((bool)udpn[F("nn")]) callMode = CALL_MODE_NO_NOTIFY; //send no notification just for this request

  unsigned long timein = root[F("time")] | UINT32_MAX; //backup time source if NTP not synced
  if (timein != UINT32_MAX) {
    setTimeFromAPI(timein);
    if (presetsModifiedTime == 0) presetsModifiedTime = timein;
  }

  doReboot = root[F("rb")] | doReboot;

  strip.setMainSegmentId(root[F("mainseg")] | strip.getMainSegmentId()); // must be before realtimeLock() if "live"

  realtimeOverride = root[F("lor")] | realtimeOverride;
  if (realtimeOverride > 2) realtimeOverride = REALTIME_OVERRIDE_ALWAYS;
  if (realtimeMode && useMainSegmentOnly) {
    strip.getMainSegment().setOption(SEG_OPTION_FREEZE, !realtimeOverride, strip.getMainSegmentId());
  }

  // bool liveEnabled = false; (to suppress warning)
  if (root.containsKey("live")) {
    if (root["live"].as<bool>()) {
      transitionDelayTemp = 0;
      jsonTransitionOnce = true;
      realtimeLock(65000);
    } else {
      exitRealtime();
    }
  }

  int it = 0;
  JsonVariant segVar = root["seg"];
  if (segVar.is<JsonObject>())
  {
    int id = segVar["id"] | -1;
    //if "seg" is not an array and ID not specified, apply to all selected/checked segments
    if (id < 0) {
      //apply all selected segments
      bool didSet = false;
      for (byte s = 0; s < strip.getMaxSegments(); s++) {
        WS2812FX::Segment &sg = strip.getSegment(s);
        if (sg.isActive()) {
          if (sg.isSelected()) {
            deserializeSegment(segVar, s, presetId);
            didSet = true;
          }
        }
      }
      //if none selected, apply to the main segment
      if (!didSet) deserializeSegment(segVar, strip.getMainSegmentId(), presetId);
    } else {
      deserializeSegment(segVar, id, presetId); //apply only the segment with the specified ID
    }
  } else {
    JsonArray segs = segVar.as<JsonArray>();
    for (JsonObject elem : segs)
    {
      deserializeSegment(elem, it, presetId);
      it++;
    }
  }

  usermods.readFromJsonState(root);

  loadLedmap = root[F("ledmap")] | loadLedmap;

  byte ps = root[F("psave")];
  if (ps > 0) {
    savePreset(ps, nullptr, root);
  } else {
    ps = root[F("pdel")]; //deletion
    if (ps > 0) {
      deletePreset(ps);
    }

    ps = presetCycCurr;
    if (getVal(root["ps"], &ps, presetCycMin, presetCycMax)) { //load preset (clears state request!)
      if (!presetId) unloadPlaylist(); //stop playlist if preset changed manually
      if (ps >= presetCycMin && ps <= presetCycMax) presetCycCurr = ps;
      applyPreset(ps, callMode);
      return stateResponse;
    }

    //HTTP API commands
    const char* httpwin = root["win"];
    if (httpwin) {
      String apireq = "win&";
      apireq += httpwin;
      handleSet(nullptr, apireq, false);
    }
  }

  JsonObject playlist = root[F("playlist")];
  if (!playlist.isNull() && loadPlaylist(playlist, presetId)) {
    //do not notify here, because the first playlist entry will do
    if (root["on"].isNull()) callMode = CALL_MODE_NO_NOTIFY;
    else callMode = CALL_MODE_DIRECT_CHANGE;  // possible bugfix for playlist only containing HTTP API preset FX=~
  } else {
    interfaceUpdateCallMode = CALL_MODE_WS_SEND;
  }

  stateUpdated(callMode);

  return stateResponse;
}

void serializeSegment(JsonObject& root, WS2812FX::Segment& seg, byte id, bool forPreset, bool segmentBounds)
{
  root["id"] = id;
  if (segmentBounds) {
    root["start"] = seg.start;
    root["stop"] = seg.stop;
  }
  if (!forPreset) root["len"] = seg.stop - seg.start;
  root["grp"] = seg.grouping;
  root[F("spc")] = seg.spacing;
  root[F("of")] = seg.offset;
  root["on"] = seg.getOption(SEG_OPTION_ON);
  root["frz"] = seg.getOption(SEG_OPTION_FREEZE);
  byte segbri = seg.opacity;
  root["bri"] = (segbri) ? segbri : 255;
  root["cct"] = seg.cct;

  if (segmentBounds && seg.name != nullptr) root["n"] = reinterpret_cast<const char *>(seg.name); //not good practice, but decreases required JSON buffer

  // to conserve RAM we will serialize the col array manually
  // this will reduce RAM footprint from ~300 bytes to 84 bytes per segment
  char colstr[70]; colstr[0] = '['; colstr[1] = '\0';  //max len 68 (5 chan, all 255)
  const char *format = strip.hasWhiteChannel() ? PSTR("[%u,%u,%u,%u]") : PSTR("[%u,%u,%u]");
  for (uint8_t i = 0; i < 3; i++)
  {
    byte segcol[4]; byte* c = segcol;
    segcol[0] = R(seg.colors[i]);
    segcol[1] = G(seg.colors[i]);
    segcol[2] = B(seg.colors[i]);
    segcol[3] = W(seg.colors[i]);
    char tmpcol[22];
    sprintf_P(tmpcol, format, (unsigned)c[0], (unsigned)c[1], (unsigned)c[2], (unsigned)c[3]);
    strcat(colstr, i<2 ? strcat(tmpcol, ",") : tmpcol);
  }
  strcat(colstr, "]");
  root["col"] = serialized(colstr);

	root["fx"]     = seg.mode;
	root[F("sx")]  = seg.speed;
	root[F("ix")]  = seg.intensity;
  root[F("c1x")] = seg.custom1;
  root[F("c2x")] = seg.custom2;
  root[F("c3x")] = seg.custom3;
	root["pal"]    = seg.palette;
	root[F("sel")] = seg.isSelected();
	root["rev"]    = seg.getOption(SEG_OPTION_REVERSED);
	root["rev2D"]  = seg.getOption(SEG_OPTION_REVERSED2D);
  root[F("mi")]  = seg.getOption(SEG_OPTION_MIRROR);
  root[F("rot2D")]  = seg.getOption(SEG_OPTION_ROTATED2D);
}

void serializeState(JsonObject root, bool forPreset, bool includeBri, bool segmentBounds)
{
  if (includeBri) {
    root["on"] = (bri > 0);
    root["bri"] = briLast;
    root["inputLevel"] = inputLevel; //WLEDSR
    root[F("transition")] = transitionDelay/100; //in 100ms
  }

  if (!forPreset) {
    if (errorFlag) {root[F("error")] = errorFlag; errorFlag = ERR_NONE;} //prevent error message to persist on screen

    root["ps"] = (currentPreset > 0) ? currentPreset : -1;
    root[F("pl")] = currentPlaylist;

    usermods.addToJsonState(root);

    JsonObject nl = root.createNestedObject("nl");
    nl["on"] = nightlightActive;
    nl["dur"] = nightlightDelayMins;
    nl["mode"] = nightlightMode;
    nl[F("tbri")] = nightlightTargetBri;
    if (nightlightActive) {
      nl[F("rem")] = (nightlightDelayMs - (millis() - nightlightStartTime)) / 1000; // seconds remaining
    } else {
      nl[F("rem")] = -1;
    }

    JsonObject udpn = root.createNestedObject("udpn");
    udpn["send"] = notifyDirect;
    udpn["recv"] = receiveNotifications;

    root[F("lor")] = realtimeOverride;
  }

  root[F("mainseg")] = strip.getMainSegmentId();

  JsonArray seg = root.createNestedArray("seg");
  for (byte s = 0; s < strip.getMaxSegments(); s++) {
    WS2812FX::Segment &sg = strip.getSegment(s);
    if (sg.isActive()) {
      JsonObject seg0 = seg.createNestedObject();
      serializeSegment(seg0, sg, s, forPreset, segmentBounds);
    } else if (forPreset && segmentBounds) { //disable segments not part of preset
      JsonObject seg0 = seg.createNestedObject();
      seg0["stop"] = 0;
    }
  }
}

//by https://github.com/tzapu/WiFiManager/blob/master/WiFiManager.cpp
int getSignalQuality(int rssi)
{
    int quality = 0;

    if (rssi <= -100)
    {
        quality = 0;
    }
    else if (rssi >= -50)
    {
        quality = 100;
    }
    else
    {
        quality = 2 * (rssi + 100);
    }
    return quality;
}

extern char audioStatusInfo[7][24];   // WLEDSR
extern void usermod_updateInfo(void); // WLEDSR

void serializeInfo(JsonObject root)
{
  root[F("ver")] = versionString;
  root[F("rel")] = releaseString; //WLEDSR to add bin name
  root[F("vid")] = VERSION;
  //root[F("cn")] = WLED_CODENAME;

  JsonObject leds = root.createNestedObject("leds");
  leds[F("count")] = strip.getLengthTotal();

  leds[F("pwr")] = strip.currentMilliamps;
  leds["fps"] = strip.getFps();
  leds[F("maxpwr")] = (strip.currentMilliamps)? strip.ablMilliampsMax : 0;
  leds[F("maxseg")] = strip.getMaxSegments();
  //leds[F("seglock")] = false; //might be used in the future to prevent modifications to segment config

  uint8_t totalLC = 0;
  JsonArray lcarr = leds.createNestedArray(F("seglc"));
  uint8_t nSegs = strip.getLastActiveSegmentId();
  for (byte s = 0; s <= nSegs; s++) {
    uint8_t lc = strip.getSegment(s).getLightCapabilities();
    totalLC |= lc;
    lcarr.add(lc);
  }

  //WLEDSR
  leds[F("somp")] = strip.stripOrMatrixPanel;

  leds["lc"] = totalLC;

  leds[F("rgbw")] = strip.hasRGBWBus(); // deprecated, use info.leds.lc
  leds[F("wv")]   = totalLC & 0x02;     // deprecated, true if white slider should be displayed for any segment
  leds["cct"]     = totalLC & 0x04;     // deprecated, use info.leds.lc

  root[F("str")] = syncToggleReceive;

  root[F("name")] = serverDescription;
  root[F("udpport")] = udpPort;
  root["live"] = (bool)realtimeMode;
  root[F("liveseg")] = useMainSegmentOnly ? strip.getMainSegmentId() : -1;  // if using main segment only for live
  //root[F("mso")] = useMainSegmentOnly;  // using main segment only for live

  switch (realtimeMode) {
    case REALTIME_MODE_INACTIVE: root["lm"] = ""; break;
    case REALTIME_MODE_GENERIC:  root["lm"] = ""; break;
    case REALTIME_MODE_UDP:      root["lm"] = F("UDP"); break;
    case REALTIME_MODE_HYPERION: root["lm"] = F("Hyperion"); break;
    case REALTIME_MODE_E131:     root["lm"] = F("E1.31"); break;
    case REALTIME_MODE_ADALIGHT: root["lm"] = F("USB Adalight/TPM2"); break;
    case REALTIME_MODE_ARTNET:   root["lm"] = F("Art-Net"); break;
    case REALTIME_MODE_TPM2NET:  root["lm"] = F("tpm2.net"); break;
    case REALTIME_MODE_DDP:      root["lm"] = F("DDP"); break;
  }

  if (realtimeIP[0] == 0)
  {
    root[F("lip")] = "";
  } else {
    root[F("lip")] = realtimeIP.toString();
  }

  #ifdef WLED_ENABLE_WEBSOCKETS
  root[F("ws")] = ws.count();
  #else
  root[F("ws")] = -1;
  #endif

  root[F("fxcount")] = strip.getModeCount();
  root[F("palcount")] = strip.getPaletteCount();

  JsonObject wifi_info = root.createNestedObject("wifi");
  wifi_info[F("bssid")] = WiFi.BSSIDstr();
  int qrssi = WiFi.RSSI();
  wifi_info[F("rssi")] = qrssi;
  wifi_info[F("signal")] = getSignalQuality(qrssi);
  wifi_info[F("channel")] = WiFi.channel();

  JsonObject fs_info = root.createNestedObject("fs");
  fs_info["u"] = fsBytesUsed / 1000;
  fs_info["t"] = fsBytesTotal / 1000;
  fs_info[F("pmt")] = presetsModifiedTime;

  root[F("ndc")] = nodeListEnabled ? (int)Nodes.size() : -1;

  #ifdef ARDUINO_ARCH_ESP32
  #ifdef WLED_DEBUG
    wifi_info[F("txPower")] = (int) WiFi.getTxPower();
    wifi_info[F("sleep")] = (bool) WiFi.getSleep();
  #endif
  root[F("arch")] = "esp32";
  root[F("core")] = ESP.getSdkVersion();
  //root[F("maxalloc")] = ESP.getMaxAllocHeap();
  #ifdef WLED_DEBUG
    root[F("resetReason0")] = (int)rtc_get_reset_reason(0);
    root[F("resetReason1")] = (int)rtc_get_reset_reason(1);
  #endif
  root[F("lwip")] = 0; //deprecated
  #else
  root[F("arch")] = "esp8266";
  root[F("core")] = ESP.getCoreVersion();
  //root[F("maxalloc")] = ESP.getMaxFreeBlockSize();
  #ifdef WLED_DEBUG
    root[F("resetReason")] = (int)ESP.getResetInfoPtr()->reason;
  #endif
  root[F("lwip")] = LWIP_VERSION_MAJOR;
  #endif

  root[F("freeheap")] = ESP.getFreeHeap();
  
  // begin WLEDSR
  usermod_updateInfo();   // small hack -> request status from soundreactive. Result are on audioStatusInfo.
  if (strlen(audioStatusInfo[0]) >0 ) {
    root[F("audioType")]   = audioStatusInfo[0];
    root[F("audioStatus")] = audioStatusInfo[1];
    if (strlen(audioStatusInfo[2]) >0 ) root[F("audioGain")] = audioStatusInfo[2];
    root[F("ssyncMode")]   = audioStatusInfo[3];
    root[F("ssyncStatus")] = audioStatusInfo[4];
#ifdef WLED_DEBUG
    root[F("audioProcess")]= audioStatusInfo[5];
#endif
    if (strlen(audioStatusInfo[6]) >0 ) root[F("audioWarning")] = audioStatusInfo[6];
  }
  
  root[F("totalheap")] = ESP.getHeapSize(); //WLEDSR
  root[F("minfreeheap")] = ESP.getMinFreeHeap();
  #if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_PSRAM) && defined(BOARD_HAS_PSRAM)
  if (psramFound()) {
    root[F("psram")] = ESP.getFreePsram();
    root[F("tpram")] = ESP.getPsramSize(); //WLEDSR
    root[F("psusedram")] = ESP.getMinFreePsram();
  }  
  #endif
  #ifdef ARDUINO_ARCH_ESP32
  static char msgbuf[32];
  snprintf(msgbuf, sizeof(msgbuf)-1, "%s rev.%d", ESP.getChipModel(), ESP.getChipRevision());
  root[F("e32model")] = msgbuf;
  root[F("e32cores")] = ESP.getChipCores();
  root[F("e32speed")] = ESP.getCpuFreqMHz();
  root[F("e32flash")] = int((ESP.getFlashChipSize()/1024)/1024);
  root[F("e32flashspeed")] = int(ESP.getFlashChipSpeed()/1000000);
  root[F("e32flashmode")] = int(ESP.getFlashChipMode());
  switch (ESP.getFlashChipMode()) {
    // missing: Octal modes
    case FM_QIO:  root[F("e32flashtext")] = F(" (QIO)"); break;
    case FM_QOUT: root[F("e32flashtext")] = F(" (QOUT)");break;
    case FM_DIO:  root[F("e32flashtext")] = F(" (DIO?)"); break;         // due to bugs in arduino-esp32, this info is not always correct
    case FM_DOUT: root[F("e32flashtext")] = F(" (DOUT or other)");break; // due to bugs in arduino-esp32, this info is not reliable
    default: root[F("e32flashtext")] = F(" (other)"); break;
  }
  #endif

  // end WLEDSR

  root[F("uptime")] = millis()/1000 + rolloverMillis*4294967;

  //WLEDSR
  root[F("soundAgc")] = soundAgc;

  usermods.addToJsonInfo(root);

  byte os = 0;
  #ifdef WLED_DEBUG
  os  = 0x80;
  #endif
  #ifndef WLED_DISABLE_ALEXA
  os += 0x40;
  #endif
  #ifdef USERMOD_CRONIXIE
  os += 0x10;
  #endif
  #ifndef WLED_DISABLE_FILESYSTEM
  os += 0x08;
  #endif
  #ifndef WLED_DISABLE_HUESYNC
  os += 0x04;
  #endif
  #ifdef WLED_ENABLE_ADALIGHT
  os += 0x02;
  #endif
  #ifndef WLED_DISABLE_OTA
  os += 0x01;
  #endif
  root[F("opt")] = os;

  root[F("brand")] = "WLED";
  root[F("product")] = F("FOSS");
  root["mac"] = escapedMac;
  char s[16] = "";
  if (Network.isConnected())
  {
    IPAddress localIP = Network.localIP();
    sprintf(s, "%d.%d.%d.%d", localIP[0], localIP[1], localIP[2], localIP[3]);
  }
  root["ip"] = s;
}

void setPaletteColors(JsonArray json, CRGBPalette16 palette)
{
    for (int i = 0; i < 16; i++) {
      JsonArray colors =  json.createNestedArray();
      CRGB color = palette[i];
      colors.add(i<<4);
      colors.add(color.red);
      colors.add(color.green);
      colors.add(color.blue);
    }
}

void setPaletteColors(JsonArray json, byte* tcp)
{
    TRGBGradientPaletteEntryUnion* ent = (TRGBGradientPaletteEntryUnion*)(tcp);
    TRGBGradientPaletteEntryUnion u;

    // Count entries
    uint16_t count = 0;
    do {
        u = *(ent + count);
        count++;
    } while ( u.index != 255);

    u = *ent;
    int indexstart = 0;
    while( indexstart < 255) {
      indexstart = u.index;

      JsonArray colors =  json.createNestedArray();
      colors.add(u.index);
      colors.add(u.r);
      colors.add(u.g);
      colors.add(u.b);

      ent++;
      u = *ent;
    }
}

void serializePalettes(JsonObject root, AsyncWebServerRequest* request)
{
  #ifdef ESP8266
  int itemPerPage = 5;
  #else
  int itemPerPage = 8;
  #endif

  int page = 0;
  if (request->hasParam("page")) {
    page = request->getParam("page")->value().toInt();
  }

  int palettesCount = strip.getPaletteCount();

  int maxPage = (palettesCount -1) / itemPerPage;
  if (page > maxPage) page = maxPage;

  int start = itemPerPage * page;
  int end = start + itemPerPage;
  if (end >= palettesCount) end = palettesCount;

  root[F("m")] = maxPage;
  JsonObject palettes  = root.createNestedObject("p");

  for (int i = start; i < end; i++) {
    JsonArray curPalette = palettes.createNestedArray(String(i));
    switch (i) {
      case 0: //default palette
        setPaletteColors(curPalette, PartyColors_p);
        break;
      case 1: //random
          curPalette.add("r");
          curPalette.add("r");
          curPalette.add("r");
          curPalette.add("r");
        break;
      case 2: //primary color only
        curPalette.add("c1");
        break;
      case 3: //primary + secondary
        curPalette.add("c1");
        curPalette.add("c1");
        curPalette.add("c2");
        curPalette.add("c2");
        break;
      case 4: //primary + secondary + tertiary
        curPalette.add("c3");
        curPalette.add("c2");
        curPalette.add("c1");
        break;
      case 5: {//primary + secondary (+tert if not off), more distinct

        curPalette.add("c1");
        curPalette.add("c1");
        curPalette.add("c1");
        curPalette.add("c1");
        curPalette.add("c1");
        curPalette.add("c2");
        curPalette.add("c2");
        curPalette.add("c2");
        curPalette.add("c2");
        curPalette.add("c2");
        curPalette.add("c3");
        curPalette.add("c3");
        curPalette.add("c3");
        curPalette.add("c3");
        curPalette.add("c3");
        curPalette.add("c1");
        break;}
      case 6: //Party colors
        setPaletteColors(curPalette, PartyColors_p);
        break;
      case 7: //Cloud colors
        setPaletteColors(curPalette, CloudColors_p);
        break;
      case 8: //Lava colors
        setPaletteColors(curPalette, LavaColors_p);
        break;
      case 9: //Ocean colors
        setPaletteColors(curPalette, OceanColors_p);
        break;
      case 10: //Forest colors
        setPaletteColors(curPalette, ForestColors_p);
        break;
      case 11: //Rainbow colors
        setPaletteColors(curPalette, RainbowColors_p);
        break;
      case 12: //Rainbow stripe colors
        setPaletteColors(curPalette, RainbowStripeColors_p);
        break;

      default:
        if (i < 13) {
          break;
        }
        byte tcp[76] = { 255 };   // WLEDSR bugfix (ensure last entry is always a "stop" marker)
        // WLEDSR workaround for palettes index overflow at i=73 -> gGradientPalettes index=60 out of bounds.
        int palIndex = i-13;
        constexpr int palMax = sizeof(gGradientPalettes)/sizeof(gGradientPalettes[0]) -1;
        if ((palIndex < 0) || (palIndex > palMax)) { 
            DEBUG_PRINTF("WARNING gGradientPalettes[%d] is out of bounds! max=%d. (json.cpp)\n", palIndex, palMax);
            palIndex = palMax;  // use last valid array item
        } // WLEDSR end
        memcpy_P(tcp, (byte*)pgm_read_dword(&(gGradientPalettes[palIndex])), 72);
        setPaletteColors(curPalette, tcp);
        break;
    }
  }
}

void serializeNodes(JsonObject root)
{
  JsonArray nodes = root.createNestedArray("nodes");

  for (NodesMap::iterator it = Nodes.begin(); it != Nodes.end(); ++it)
  {
    if (it->second.ip[0] != 0)
    {
      JsonObject node = nodes.createNestedObject();
      node[F("name")] = it->second.nodeName;
      node["type"]    = it->second.nodeType;
      node["ip"]      = it->second.ip.toString();
      node[F("age")]  = it->second.age;
      node[F("vid")]  = it->second.build;
    }
  }
}

void serveJson(AsyncWebServerRequest* request)
{
  byte subJson = 0;
  const String& url = request->url();
  if      (url.indexOf("state") > 0) subJson = 1;
  else if (url.indexOf("info")  > 0) subJson = 2;
  else if (url.indexOf("si")    > 0) subJson = 3;
  else if (url.indexOf("nodes") > 0) subJson = 4;
  else if (url.indexOf("palx")  > 0) subJson = 5;
  #ifdef WLED_ENABLE_JSONLIVE
  else if (url.indexOf("live")  > 0) {
    serveLiveLeds(request);
    return;
  }
  #endif
  else if (url.indexOf(F("eff")) > 0) {
    request->send_P(200, "application/json", JSON_mode_names);
    return;
  }
  else if (url.indexOf("pal") > 0) {
    request->send_P(200, "application/json", JSON_palette_names);
    return;
  }
  else if (url.indexOf("cfg") > 0 && handleFileRead(request, "/cfg.json")) {
    return;
  }
  else if (url.length() > 6) { //not just /json
    request->send(  501, "application/json", F("{\"error\":\"Not implemented\"}"));
    return;
  }

  #ifdef WLED_USE_DYNAMIC_JSON
  AsyncJsonResponse* response = new AsyncJsonResponse(JSON_BUFFER_SIZE);
  #else
  if (!requestJSONBufferLock(17)) return;
  AsyncJsonResponse *response = new AsyncJsonResponse(&doc);
  #endif

  JsonObject lDoc = response->getRoot();

  switch (subJson)
  {
    case 1: //state
      serializeState(lDoc); break;
    case 2: //info
      serializeInfo(lDoc); break;
    case 4: //node list
      serializeNodes(lDoc); break;
    case 5: //palettes
      serializePalettes(lDoc, request); break;
    default: //all
      JsonObject state = lDoc.createNestedObject("state");
      serializeState(state);
      JsonObject info = lDoc.createNestedObject("info");
      serializeInfo(info);
      if (subJson != 3)
      {
        doc[F("effects")]  = serialized((const __FlashStringHelper*)JSON_mode_names);
        doc[F("palettes")] = serialized((const __FlashStringHelper*)JSON_palette_names);
      }
  }

  DEBUG_PRINT("JSON buffer size: ");
  DEBUG_PRINTLN(lDoc.memoryUsage());

  response->setLength();
  request->send(response);
  releaseJSONBufferLock();
}

#ifdef WLED_ENABLE_JSONLIVE
#define MAX_LIVE_LEDS 180

bool serveLiveLeds(AsyncWebServerRequest* request, uint32_t wsClient)
{
  #ifdef WLED_ENABLE_WEBSOCKETS
  AsyncWebSocketClient * wsc = nullptr;
  if (!request) { //not HTTP, use Websockets
    wsc = ws.client(wsClient);
    if (!wsc || wsc->queueLength() > 0) return false; //only send if queue free
  }
  #endif

  uint16_t used = strip.getLengthTotal();
  uint16_t n = (used -1) /MAX_LIVE_LEDS +1; //only serve every n'th LED if count over MAX_LIVE_LEDS
  char buffer[2000];
  strcpy_P(buffer, PSTR("{\"leds\":["));
  obuf = buffer;
  olen = 9;

  for (uint16_t i= 0; i < used; i += n)
  {
    uint32_t c = strip.getPixelColor(i);
    uint8_t r = qadd8(W(c), R(c)); //add white channel to RGB channels as a simple RGBW -> RGB map
    uint8_t g = qadd8(W(c), G(c));
    uint8_t b = qadd8(W(c), B(c));
    olen += sprintf(obuf + olen, "\"%06X\",", RGBW32(r,g,b,0));
  }
  olen -= 1;
  oappend((const char*)F("],\"n\":"));
  oappendi(n);
  oappend("}");
  if (request) {
    request->send(200, "application/json", buffer);
  }
  #ifdef WLED_ENABLE_WEBSOCKETS
  else {
    wsc->text(obuf, olen);
  }
  #endif
  return true;
}
#endif
=== ./led.cpp ===

#include "wled.h"

/*
 * LED methods
 */

void setValuesFromMainSeg()          { setValuesFromSegment(strip.getMainSegmentId()); }
void setValuesFromFirstSelectedSeg() { setValuesFromSegment(strip.getFirstSelectedSegId()); }
void setValuesFromSegment(uint8_t s)
{
  WS2812FX::Segment& seg = strip.getSegment(s);
  col[0] = R(seg.colors[0]);
  col[1] = G(seg.colors[0]);
  col[2] = B(seg.colors[0]);
  col[3] = W(seg.colors[0]);
  colSec[0] = R(seg.colors[1]);
  colSec[1] = G(seg.colors[1]);
  colSec[2] = B(seg.colors[1]);
  colSec[3] = W(seg.colors[1]);
  effectCurrent   = seg.mode;
  effectSpeed     = seg.speed;
  effectIntensity = seg.intensity;
  effectCustom1   = seg.custom1;
  effectCustom2   = seg.custom2;
  effectCustom3   = seg.custom3;
  effectPalette   = seg.palette;
}


// applies global legacy values (col, colSec, effectCurrent...)
// problem: if the first selected segment already has the value to be set, other selected segments are not updated
void applyValuesToSelectedSegs()
{
  // copy of first selected segment to tell if value was updated
  uint8_t firstSel = strip.getFirstSelectedSegId();
  WS2812FX::Segment selsegPrev = strip.getSegment(firstSel);
  for (uint8_t i = 0; i < strip.getMaxSegments(); i++) {
    WS2812FX::Segment& seg = strip.getSegment(i);
    if (i != firstSel && (!seg.isActive() || !seg.isSelected())) continue;

    if (effectSpeed     != selsegPrev.speed)     {seg.speed     = effectSpeed;     stateChanged = true;}
    if (effectIntensity != selsegPrev.intensity) {seg.intensity = effectIntensity; stateChanged = true;}
    if (effectCustom1   != selsegPrev.custom1)   {seg.custom1   = effectCustom1;   stateChanged = true;} // WLEDSR
    if (effectCustom2   != selsegPrev.custom2)   {seg.custom2   = effectCustom2;   stateChanged = true;} // WLEDSR
    if (effectCustom3   != selsegPrev.custom3)   {seg.custom3   = effectCustom3;   stateChanged = true;} // WLEDSR
    if (effectPalette   != selsegPrev.palette)   {seg.palette   = effectPalette;   stateChanged = true;}
    if (effectCurrent   != selsegPrev.mode)      {strip.setMode(i, effectCurrent); stateChanged = true;}
    uint32_t col0 = RGBW32(   col[0],    col[1],    col[2],    col[3]);
    uint32_t col1 = RGBW32(colSec[0], colSec[1], colSec[2], colSec[3]);
    if (col0 != selsegPrev.colors[0])            {seg.setColor(0, col0, i);        stateChanged = true;}
    if (col1 != selsegPrev.colors[1])            {seg.setColor(1, col1, i);        stateChanged = true;}
  }
}


void resetTimebase()
{
  strip.timebase = 0 - millis();
}


void toggleOnOff()
{
  if (bri == 0)
  {
    bri = briLast;
  } else
  {
    briLast = bri;
    bri = 0;
  }
}


//scales the brightness with the briMultiplier factor
byte scaledBri(byte in)
{
  uint16_t val = ((uint16_t)in*briMultiplier)/100;
  if (val > 255) val = 255;
  return (byte)val;
}


//applies global brightness
void applyBri() {
  if (!realtimeMode || !arlsForceMaxBri)
  {
    strip.setBrightness(scaledBri(briT));
  }
}


//applies global brightness and sets it as the "current" brightness (no transition)
void applyFinalBri() {
#ifdef USERMOD_AUTO_SAVE                  //WLEDSR - make autosave mod happy. A bit dangerous, as it may trigger unnecessary WS broadcasts (and other notificatios) 
  if (briOld != bri) stateChanged = true; //WLEDSR temporary fix, until solved in upstream
#endif
  briOld = bri;
  briT = bri;
  applyBri();
}


//called after every state changes, schedules interface updates, handles brightness transition and nightlight activation
//unlike colorUpdated(), does NOT apply any colors or FX to segments
void stateUpdated(byte callMode) {
  //call for notifier -> 0: init 1: direct change 2: button 3: notification 4: nightlight 5: other (No notification)
  //                     6: fx changed 7: hue 8: preset cycle 9: blynk 10: alexa 11: ws send only 12: button preset
  setValuesFromFirstSelectedSeg();

  if (bri != briOld || stateChanged) {
    if (stateChanged) currentPreset = 0; //something changed, so we are no longer in the preset

    if (callMode != CALL_MODE_NOTIFICATION && callMode != CALL_MODE_NO_NOTIFY) notify(callMode);

    //set flag to update blynk, ws and mqtt
    interfaceUpdateCallMode = callMode;
    stateChanged = false;
  } else {
    if (nightlightActive && !nightlightActiveOld && callMode != CALL_MODE_NOTIFICATION && callMode != CALL_MODE_NO_NOTIFY) {
      notify(CALL_MODE_NIGHTLIGHT);
      interfaceUpdateCallMode = CALL_MODE_NIGHTLIGHT;
    }
  }

  if (callMode != CALL_MODE_NO_NOTIFY && nightlightActive && (nightlightMode == NL_MODE_FADE || nightlightMode == NL_MODE_COLORFADE)) {
    briNlT = bri;
    nightlightDelayMs -= (millis() - nightlightStartTime);
    nightlightStartTime = millis();
  }
  if (briT == 0) {
    if (callMode != CALL_MODE_NOTIFICATION) resetTimebase(); //effect start from beginning
  }

  if (bri > 0) briLast = bri;

  //deactivate nightlight if target brightness is reached
  if (bri == nightlightTargetBri && callMode != CALL_MODE_NO_NOTIFY && nightlightMode != NL_MODE_SUN) nightlightActive = false;
  if (fadeTransition) {
    //set correct delay if not using notification delay
    if (callMode != CALL_MODE_NOTIFICATION && !jsonTransitionOnce) transitionDelayTemp = transitionDelay;
    jsonTransitionOnce = false;
    strip.setTransition(transitionDelayTemp);
    if (transitionDelayTemp == 0) {
      applyFinalBri();
      strip.trigger();
      return;
    }

    if (transitionActive) {
      briOld = briT;
      tperLast = 0;
    }
    strip.setTransitionMode(true);
    transitionActive = true;
    transitionStartTime = millis();
  } else {
    strip.setTransition(0);
    applyFinalBri();
    strip.trigger();
  }
}


void updateInterfaces(uint8_t callMode)
{
  sendDataWs();
  lastInterfaceUpdate = millis();
  if (callMode == CALL_MODE_WS_SEND) return;
  #ifndef WLED_DISABLE_ALEXA
  if (espalexaDevice != nullptr && callMode != CALL_MODE_ALEXA) {
    espalexaDevice->setValue(bri);
    espalexaDevice->setColor(col[0], col[1], col[2]);
  }
  #endif
  doPublishMqtt = true;
}


void handleTransitions()
{
  //handle still pending interface update
  if (interfaceUpdateCallMode && millis() - lastInterfaceUpdate > INTERFACE_UPDATE_COOLDOWN)
  {
    updateInterfaces(interfaceUpdateCallMode);
    interfaceUpdateCallMode = 0; //disable
  }
  if (doPublishMqtt) publishMqtt();

  if (transitionActive && transitionDelayTemp > 0)
  {
    float tper = (millis() - transitionStartTime)/(float)transitionDelayTemp;
    if (tper >= 1.0)
    {
      strip.setTransitionMode(false);
      transitionActive = false;
      tperLast = 0;
      applyFinalBri();
      return;
    }
    if (tper - tperLast < 0.004) return;
    tperLast = tper;
    briT    = briOld   +((bri    - briOld   )*tper);
    applyBri();
  }
}


//legacy method, applies values from col, effectCurrent, ... to selected segments
void colorUpdated(byte callMode){
  applyValuesToSelectedSegs();
  stateUpdated(callMode);
}


void handleNightlight()
{
/*
  static unsigned long lastNlUpdate;
  unsigned long now = millis();
  if (now < 100 && lastNlUpdate > 0) lastNlUpdate = 0; //take care of millis() rollover
  if (now - lastNlUpdate < 100) return; //allow only 10 NL updates per second
  lastNlUpdate = now;
*/
  if (nightlightActive)
  {
    if (!nightlightActiveOld) //init
    {
      nightlightStartTime = millis();
      nightlightDelayMs = (int)(nightlightDelayMins*60000);
      nightlightActiveOld = true;
      briNlT = bri;
      for (byte i=0; i<4; i++) colNlT[i] = col[i]; // remember starting color
      if (nightlightMode == NL_MODE_SUN)
      {
        //save current
        colNlT[0] = effectCurrent;
        colNlT[1] = effectSpeed;
        colNlT[2] = effectPalette;

        strip.setMode(strip.getFirstSelectedSegId(), FX_MODE_STATIC); // make sure seg runtime is reset if it was in sunrise mode
        effectCurrent = FX_MODE_SUNRISE;
        effectSpeed = nightlightDelayMins;
        effectPalette = 0;
        if (effectSpeed > 60) effectSpeed = 60; //currently limited to 60 minutes
        if (bri) effectSpeed += 60; //sunset if currently on
        briNlT = !bri; //true == sunrise, false == sunset
        if (!bri) bri = briLast;
        colorUpdated(CALL_MODE_NO_NOTIFY);
      }
    }
    float nper = (millis() - nightlightStartTime)/((float)nightlightDelayMs);
    if (nightlightMode == NL_MODE_FADE || nightlightMode == NL_MODE_COLORFADE)
    {
      bri = briNlT + ((nightlightTargetBri - briNlT)*nper);
      if (nightlightMode == NL_MODE_COLORFADE)                                         // color fading only is enabled with "NF=2"
      {
        for (byte i=0; i<4; i++) col[i] = colNlT[i]+ ((colSec[i] - colNlT[i])*nper);   // fading from actual color to secondary color
      }
      colorUpdated(CALL_MODE_NO_NOTIFY);
    }
    if (nper >= 1) //nightlight duration over
    {
      nightlightActive = false;
      if (nightlightMode == NL_MODE_SET)
      {
        bri = nightlightTargetBri;
        colorUpdated(CALL_MODE_NO_NOTIFY);
      }
      if (bri == 0) briLast = briNlT;
      if (nightlightMode == NL_MODE_SUN)
      {
        if (!briNlT) { //turn off if sunset
          effectCurrent = colNlT[0];
          effectSpeed = colNlT[1];
          effectPalette = colNlT[2];
          toggleOnOff();
          applyFinalBri();
        }
      }
      if (macroNl > 0)
        applyPreset(macroNl);
      nightlightActiveOld = false;
    }
  } else if (nightlightActiveOld) //early de-init
  {
    if (nightlightMode == NL_MODE_SUN) { //restore previous effect
      effectCurrent = colNlT[0];
      effectSpeed = colNlT[1];
      effectPalette = colNlT[2];
      colorUpdated(CALL_MODE_NO_NOTIFY);
    }
    nightlightActiveOld = false;
  }
}

//utility for FastLED to use our custom timer
uint32_t get_millisecond_timer()
{
  return strip.now;
}

=== ./lx_parser.cpp ===

#include "wled.h"

/*
 * Parser for Loxone formats
 */
bool parseLx(int lxValue, byte rgbw[4])
{
  #ifdef WLED_ENABLE_LOXONE
  DEBUG_PRINT(F("LX: Lox = "));
  DEBUG_PRINTLN(lxValue);

  bool ok = false;
  float lxRed = 0, lxGreen = 0, lxBlue = 0;

  if (lxValue < 200000000) { 
    // Loxone RGB
    ok = true;
    lxRed = round((lxValue % 1000) * 2.55);
    lxGreen = round(((lxValue / 1000) % 1000) * 2.55);
    lxBlue = round(((lxValue / 1000000) % 1000) * 2.55);
  } else if ((lxValue >= 200000000) && (lxValue <= 201006500)) { 
    // Loxone Lumitech
    ok = true;
    float tmpBri = floor((lxValue - 200000000) / 10000); ;
    uint16_t ct = (lxValue - 200000000) - (((uint8_t)tmpBri) * 10000);

    tmpBri *= 2.55;
    tmpBri = constrain(tmpBri, 0, 255);

    colorKtoRGB(ct, rgbw);
    lxRed = rgbw[0]; lxGreen = rgbw[1]; lxBlue = rgbw[2];

    lxRed *= (tmpBri/255);
    lxGreen *= (tmpBri/255);
    lxBlue *= (tmpBri/255);
  }

  if (ok) {
    rgbw[0] = (uint8_t) constrain(lxRed, 0, 255);
    rgbw[1] = (uint8_t) constrain(lxGreen, 0, 255);
    rgbw[2] = (uint8_t) constrain(lxBlue, 0, 255);
    rgbw[3] = 0;
    return true;
  }
  #endif
  return false;
}

void parseLxJson(int lxValue, byte segId, bool secondary)
{
  if (secondary) {
    DEBUG_PRINT(F("LY: Lox secondary = "));
  } else {
    DEBUG_PRINT(F("LX: Lox primary = "));
  }
  DEBUG_PRINTLN(lxValue);
  byte rgbw[] = {0,0,0,0};
  if (parseLx(lxValue, rgbw)) {
    if (bri == 0) {
      DEBUG_PRINTLN(F("LX: turn on"));
      toggleOnOff();
    }
    bri = 255;
    nightlightActive = false; //always disable nightlight when toggling
    if (segId == strip.getMainSegmentId()) {
      DEBUG_PRINTLN(F("LX: main segment"));
      if (secondary) for (byte i = 0; i < 4; i++) colSec[i] = rgbw[i];
      else           for (byte i = 0; i < 4; i++) col[i]    = rgbw[i];
    } else {
      DEBUG_PRINT(F("LX: segment "));
      DEBUG_PRINTLN(segId);
      strip.getSegment(segId).setColor(secondary, ((rgbw[3] << 24) | ((rgbw[0]&0xFF) << 16) | ((rgbw[1]&0xFF) << 8) | ((rgbw[2]&0xFF))), segId);
    }
  }
}


=== ./mqtt.cpp ===

#include "wled.h"

/*
 * MQTT communication protocol for home automation
 */

#ifdef WLED_ENABLE_MQTT
#warning MQTT enabled. MQTT is not officially supported in WLED-SR

#define MQTT_KEEP_ALIVE_TIME 60    // contact the MQTT broker every 60 seconds

void parseMQTTBriPayload(char* payload)
{
  if      (strstr(payload, "ON") || strstr(payload, "on") || strstr(payload, "true")) {bri = briLast; stateUpdated(1);}
  else if (strstr(payload, "T" ) || strstr(payload, "t" )) {toggleOnOff(); stateUpdated(1);}
  else {
    uint8_t in = strtoul(payload, NULL, 10);
    if (in == 0 && bri > 0) briLast = bri;
    bri = in;
    stateUpdated(CALL_MODE_DIRECT_CHANGE);
  }
}


void onMqttConnect(bool sessionPresent)
{
  //(re)subscribe to required topics
  char subuf[38];

  if (mqttDeviceTopic[0] != 0) {
    strlcpy(subuf, mqttDeviceTopic, 33);
    mqtt->subscribe(subuf, 0);
    strcat_P(subuf, PSTR("/col"));
    mqtt->subscribe(subuf, 0);
    strlcpy(subuf, mqttDeviceTopic, 33);
    strcat_P(subuf, PSTR("/api"));
    mqtt->subscribe(subuf, 0);
  }

  if (mqttGroupTopic[0] != 0) {
    strlcpy(subuf, mqttGroupTopic, 33);
    mqtt->subscribe(subuf, 0);
    strcat_P(subuf, PSTR("/col"));
    mqtt->subscribe(subuf, 0);
    strlcpy(subuf, mqttGroupTopic, 33);
    strcat_P(subuf, PSTR("/api"));
    mqtt->subscribe(subuf, 0);
  }

  usermods.onMqttConnect(sessionPresent);

  doPublishMqtt = true;
  DEBUG_PRINTLN(F("MQTT ready"));
}


void onMqttMessage(char* topic, char* payload, AsyncMqttClientMessageProperties properties, size_t len, size_t index, size_t total) {

  DEBUG_PRINT(F("MQTT msg: "));
  DEBUG_PRINTLN(topic);

  // paranoia check to avoid npe if no payload
  if (payload==nullptr) {
    DEBUG_PRINTLN(F("no payload -> leave"));
    return;
  }
  //make a copy of the payload to 0-terminate it
  char* payloadStr = new char[len+1];
  if (payloadStr == nullptr) return; //no mem
  strncpy(payloadStr, payload, len);
  payloadStr[len] = '\0';
  DEBUG_PRINTLN(payloadStr);

  size_t topicPrefixLen = strlen(mqttDeviceTopic);
  if (strncmp(topic, mqttDeviceTopic, topicPrefixLen) == 0) {
    topic += topicPrefixLen;
  } else {
    topicPrefixLen = strlen(mqttGroupTopic);
    if (strncmp(topic, mqttGroupTopic, topicPrefixLen) == 0) {
      topic += topicPrefixLen;
    } else {
      // Non-Wled Topic used here. Probably a usermod subscribed to this topic.
      usermods.onMqttMessage(topic, payloadStr);
      delete[] payloadStr;
      return;
    }
  }

  //Prefix is stripped from the topic at this point

  if (strcmp_P(topic, PSTR("/col")) == 0) {
    colorFromDecOrHexString(col, (char*)payloadStr);
    colorUpdated(CALL_MODE_DIRECT_CHANGE);
  } else if (strcmp_P(topic, PSTR("/api")) == 0) {
    if (payload[0] == '{') { //JSON API
      #ifdef WLED_USE_DYNAMIC_JSON
      DynamicJsonDocument doc(JSON_BUFFER_SIZE);
      #else
      if (!requestJSONBufferLock(15)) return;
      #endif
      deserializeJson(doc, payloadStr);
      deserializeState(doc.as<JsonObject>());
      releaseJSONBufferLock();
    } else { //HTTP API
      String apireq = "win&";
      apireq += (char*)payloadStr;
      handleSet(nullptr, apireq);
    }
  } else if (strlen(topic) != 0) {
    // non standard topic, check with usermods
    usermods.onMqttMessage(topic, payloadStr);
  } else {
    // topmost topic (just wled/MAC)
    parseMQTTBriPayload(payloadStr);
  }
  delete[] payloadStr;
}


void publishMqtt()
{
  doPublishMqtt = false;
  if (!WLED_MQTT_CONNECTED) return;
  DEBUG_PRINTLN(F("Publish MQTT"));

  char s[10];
  char subuf[38];

  sprintf_P(s, PSTR("%u"), bri);
  strlcpy(subuf, mqttDeviceTopic, 33);
  strcat_P(subuf, PSTR("/g"));
  mqtt->publish(subuf, 0, true, s);         // retain message

  sprintf_P(s, PSTR("#%06X"), (col[3] << 24) | (col[0] << 16) | (col[1] << 8) | (col[2]));
  strlcpy(subuf, mqttDeviceTopic, 33);
  strcat_P(subuf, PSTR("/c"));
  mqtt->publish(subuf, 0, true, s);         // retain message

  strlcpy(subuf, mqttDeviceTopic, 33);
  strcat_P(subuf, PSTR("/status"));
  mqtt->publish(subuf, 0, true, "online");  // retain message for a LWT

  char apires[1024];                        // allocating 1024 bytes from stack can be risky
  XML_response(nullptr, apires);
  strlcpy(subuf, mqttDeviceTopic, 33);
  strcat_P(subuf, PSTR("/v"));
  mqtt->publish(subuf, 0, false, apires);   // do not retain message
}


//HA autodiscovery was removed in favor of the native integration in HA v0.102.0

bool initMqtt()
{
  if (!mqttEnabled || mqttServer[0] == 0 || !WLED_CONNECTED) return false;

  if (mqtt == nullptr) {
    mqtt = new AsyncMqttClient();
    mqtt->onMessage(onMqttMessage);
    mqtt->onConnect(onMqttConnect);
  }
  if (mqtt->connected()) return true;

  DEBUG_PRINTLN(F("Reconnecting MQTT"));
  IPAddress mqttIP;
  if (mqttIP.fromString(mqttServer)) //see if server is IP or domain
  {
    mqtt->setServer(mqttIP, mqttPort);
  } else {
    mqtt->setServer(mqttServer, mqttPort);
  }
  mqtt->setClientId(mqttClientID);
  if (mqttUser[0] && mqttPass[0]) mqtt->setCredentials(mqttUser, mqttPass);

  strlcpy(mqttStatusTopic, mqttDeviceTopic, 33);
  strcat_P(mqttStatusTopic, PSTR("/status"));
  mqtt->setWill(mqttStatusTopic, 0, true, "offline"); // LWT message
  mqtt->setKeepAlive(MQTT_KEEP_ALIVE_TIME);
  mqtt->connect();
  return true;
}

#else
bool initMqtt(){return false;}
void publishMqtt(){}
#endif

=== ./my_config.h ===

#pragma once

/*
 * Welcome!
 * You can use the file "my_config.h" to make changes to the way WLED is compiled!
 * It is possible to enable and disable certain features as well as set defaults for some runtime changeable settings.
 *
 * How to use:
 * PlatformIO: Just compile the unmodified code once! The file "my_config.h" will be generated automatically and now you can make your changes.
 *
 * ArduinoIDE: Make a copy of this file and name it "my_config.h". Go to wled.h and uncomment "#define WLED_USE_MY_CONFIG" in the top of the file.
 *
 * DO NOT make changes to the "my_config_sample.h" file directly! Your changes will not be applied.
 */

// uncomment to force the compiler to show a warning to confirm that this file is included
//#warning **** my_config.h: Settings from this file are honored ****

/* Uncomment to use your WIFI settings as defaults
  //WARNING: this will hardcode these as the default even after a factory reset
#define CLIENT_SSID "Your_SSID"
#define CLIENT_PASS "Your_Password"
*/

//#define MAX_LEDS 1500       //Maximum total LEDs. More than 1500 might create a low memory situation on ESP8266.
=== ./my_config_sample.h ===

#pragma once

/*
 * Welcome!
 * You can use the file "my_config.h" to make changes to the way WLED is compiled!
 * It is possible to enable and disable certain features as well as set defaults for some runtime changeable settings.
 *
 * How to use:
 * PlatformIO: Just compile the unmodified code once! The file "my_config.h" will be generated automatically and now you can make your changes.
 *
 * ArduinoIDE: Make a copy of this file and name it "my_config.h". Go to wled.h and uncomment "#define WLED_USE_MY_CONFIG" in the top of the file.
 *
 * DO NOT make changes to the "my_config_sample.h" file directly! Your changes will not be applied.
 */

// uncomment to force the compiler to show a warning to confirm that this file is included
//#warning **** my_config.h: Settings from this file are honored ****

/* Uncomment to use your WIFI settings as defaults
  //WARNING: this will hardcode these as the default even after a factory reset
#define CLIENT_SSID "Your_SSID"
#define CLIENT_PASS "Your_Password"
*/

//#define MAX_LEDS 1500       //Maximum total LEDs. More than 1500 might create a low memory situation on ESP8266.
=== ./ntp.cpp ===

#include "src/dependencies/timezone/Timezone.h"
#include "wled.h"
#include "wled_math.h"

/*
 * Acquires time from NTP server
 */
//#define WLED_DEBUG_NTP
#define NTP_SYNC_INTERVAL 42000UL //Get fresh NTP time about twice per day

Timezone* tz;

#define TZ_UTC                  0
#define TZ_UK                   1
#define TZ_EUROPE_CENTRAL       2
#define TZ_EUROPE_EASTERN       3
#define TZ_US_EASTERN           4
#define TZ_US_CENTRAL           5
#define TZ_US_MOUNTAIN          6
#define TZ_US_ARIZONA           7
#define TZ_US_PACIFIC           8
#define TZ_CHINA                9
#define TZ_JAPAN               10
#define TZ_AUSTRALIA_EASTERN   11
#define TZ_NEW_ZEALAND         12
#define TZ_NORTH_KOREA         13
#define TZ_INDIA               14
#define TZ_SASKACHEWAN         15
#define TZ_AUSTRALIA_NORTHERN  16
#define TZ_AUSTRALIA_SOUTHERN  17
#define TZ_HAWAII              18
#define TZ_NOVOSIBIRSK         19
#define TZ_ANCHORAGE           20
#define TZ_MX_CENTRAL          21
#define TZ_PAKISTAN            22
#define TZ_INIT               255

byte tzCurrent = TZ_INIT; //uninitialized

void updateTimezone() {
  delete tz;
  TimeChangeRule tcrDaylight = {Last, Sun, Mar, 1, 0}; //UTC
  TimeChangeRule tcrStandard = tcrDaylight;            //UTC

  switch (currentTimezone) {
    case TZ_UK : {
      tcrDaylight = {Last, Sun, Mar, 1, 60};      //British Summer Time
      tcrStandard = {Last, Sun, Oct, 2, 0};       //Standard Time
      break;
    }
    case TZ_EUROPE_CENTRAL : {
      tcrDaylight = {Last, Sun, Mar, 2, 120};     //Central European Summer Time
      tcrStandard = {Last, Sun, Oct, 3, 60};      //Central European Standard Time
      break;
    }
    case TZ_EUROPE_EASTERN : {
      tcrDaylight = {Last, Sun, Mar, 3, 180};     //East European Summer Time
      tcrStandard = {Last, Sun, Oct, 4, 120};     //East European Standard Time
      break;
    }
    case TZ_US_EASTERN : {
      tcrDaylight = {Second, Sun, Mar, 2, -240};  //EDT = UTC - 4 hours
      tcrStandard = {First,  Sun, Nov, 2, -300};  //EST = UTC - 5 hours
      break;
    }
    case TZ_US_CENTRAL : {
      tcrDaylight = {Second, Sun, Mar, 2, -300};  //CDT = UTC - 5 hours
      tcrStandard = {First,  Sun, Nov, 2, -360};  //CST = UTC - 6 hours
      break;
    }
    case TZ_US_MOUNTAIN : {
      tcrDaylight = {Second, Sun, Mar, 2, -360};  //MDT = UTC - 6 hours
      tcrStandard = {First,  Sun, Nov, 2, -420};  //MST = UTC - 7 hours
      break;
    }
    case TZ_US_ARIZONA : {
      tcrDaylight = {First,  Sun, Nov, 2, -420};  //MST = UTC - 7 hours
      tcrStandard = {First,  Sun, Nov, 2, -420};  //MST = UTC - 7 hours
      break;
    }
    case TZ_US_PACIFIC : {
      tcrDaylight = {Second, Sun, Mar, 2, -420};  //PDT = UTC - 7 hours
      tcrStandard = {First,  Sun, Nov, 2, -480};  //PST = UTC - 8 hours
      break;
    }
    case TZ_CHINA : {
      tcrDaylight = {Last, Sun, Mar, 1, 480};     //CST = UTC + 8 hours
      tcrStandard = tcrDaylight;
      break;
    }
    case TZ_JAPAN : {
      tcrDaylight = {Last, Sun, Mar, 1, 540};     //JST = UTC + 9 hours
      tcrStandard = tcrDaylight;
      break;
    }
    case TZ_AUSTRALIA_EASTERN : {
      tcrDaylight = {First,  Sun, Oct, 2, 660};   //AEDT = UTC + 11 hours
      tcrStandard = {First,  Sun, Apr, 3, 600};   //AEST = UTC + 10 hours
      break;
    }
    case TZ_NEW_ZEALAND : {
      tcrDaylight = {Last,   Sun, Sep, 2, 780};   //NZDT = UTC + 13 hours
      tcrStandard = {First,  Sun, Apr, 3, 720};   //NZST = UTC + 12 hours
      break;
    }
    case TZ_NORTH_KOREA : {
      tcrDaylight = {Last, Sun, Mar, 1, 510};     //Pyongyang Time = UTC + 8.5 hours
      tcrStandard = tcrDaylight;
      break;
    }
    case TZ_INDIA : {
      tcrDaylight = {Last, Sun, Mar, 1, 330};     //India Standard Time = UTC + 5.5 hours
      tcrStandard = tcrDaylight;
      break;
    }
    case TZ_SASKACHEWAN : {
      tcrDaylight = {First,  Sun, Nov, 2, -360};  //CST = UTC - 6 hours
      tcrStandard = tcrDaylight;
      break;
    }
    case TZ_AUSTRALIA_NORTHERN : {
      tcrDaylight = {First, Sun, Apr, 3, 570};   //ACST = UTC + 9.5 hours
      tcrStandard = tcrDaylight;
      break;
    }
    case TZ_AUSTRALIA_SOUTHERN : {
      tcrDaylight = {First, Sun, Oct, 2, 630};   //ACDT = UTC + 10.5 hours
      tcrStandard = {First, Sun, Apr, 3, 570};   //ACST = UTC + 9.5 hours
      break;
    }
    case TZ_HAWAII : {
      tcrDaylight = {Last, Sun, Mar, 1, -600};   //HST =  UTC - 10 hours
      tcrStandard = tcrDaylight;
      break;
    }
    case TZ_NOVOSIBIRSK : {
      tcrDaylight = {Last, Sun, Mar, 1, 420};     //CST = UTC + 7 hours
      tcrStandard = tcrDaylight;
      break;
    }
    case TZ_ANCHORAGE : {
      tcrDaylight = {Second, Sun, Mar, 2, -480};  //AKDT = UTC - 8 hours
      tcrStandard = {First, Sun, Nov, 2, -540};   //AKST = UTC - 9 hours
      break;
    }
     case TZ_MX_CENTRAL : {
      tcrDaylight = {First, Sun, Apr, 2, -360};  //CST = UTC - 6 hours
      tcrStandard = tcrDaylight;
      break;
    }
     case TZ_PAKISTAN : {
      tcrDaylight = {Last, Sun, Mar, 1, 300};     //Pakistan Standard Time = UTC + 5 hours
      tcrStandard = tcrDaylight;
      break;
    }
  }

  tzCurrent = currentTimezone;

  tz = new Timezone(tcrDaylight, tcrStandard);
}

void handleTime() {
  handleNetworkTime();

  toki.millisecond();
  toki.setTick();

  if (toki.isTick()) //true only in the first loop after a new second started
  {
    #ifdef WLED_DEBUG_NTP
    Serial.print(F("TICK! "));
    toki.printTime(toki.getTime());
    #endif
    updateLocalTime();
    checkTimers();
    checkCountdown();
  }
}

void handleNetworkTime()
{
  if (ntpEnabled && ntpConnected && millis() - ntpLastSyncTime > (1000*NTP_SYNC_INTERVAL) && WLED_CONNECTED)
  {
    if (millis() - ntpPacketSentTime > 10000)
    {
      sendNTPPacket();
      ntpPacketSentTime = millis();
    }
    if (checkNTPResponse())
    {
      ntpLastSyncTime = millis();
    }
  }
}

void sendNTPPacket()
{
  if (!ntpServerIP.fromString(ntpServerName)) //see if server is IP or domain
  {
    #ifdef ESP8266
    WiFi.hostByName(ntpServerName, ntpServerIP, 750);
    #else
    WiFi.hostByName(ntpServerName, ntpServerIP);
    #endif
  }

  DEBUG_PRINTLN(F("send NTP"));
  byte pbuf[NTP_PACKET_SIZE];
  memset(pbuf, 0, NTP_PACKET_SIZE);

  pbuf[0] = 0b11100011;   // LI, Version, Mode
  pbuf[1] = 0;     // Stratum, or type of clock
  pbuf[2] = 6;     // Polling Interval
  pbuf[3] = 0xEC;  // Peer Clock Precision
  // 8 bytes of zero for Root Delay & Root Dispersion
  pbuf[12]  = 49;
  pbuf[13]  = 0x4E;
  pbuf[14]  = 49;
  pbuf[15]  = 52;

  ntpUdp.beginPacket(ntpServerIP, 123); //NTP requests are to port 123
  ntpUdp.write(pbuf, NTP_PACKET_SIZE);
  ntpUdp.endPacket();
}

bool checkNTPResponse()
{
  int cb = ntpUdp.parsePacket();
  if (!cb) return false;

  uint32_t ntpPacketReceivedTime = millis();
  DEBUG_PRINT(F("NTP recv, l="));
  DEBUG_PRINTLN(cb);
  byte pbuf[NTP_PACKET_SIZE];
  ntpUdp.read(pbuf, NTP_PACKET_SIZE); // read the packet into the buffer

  Toki::Time arrived  = toki.fromNTP(pbuf + 32);
  Toki::Time departed = toki.fromNTP(pbuf + 40);
  if (departed.sec == 0) return false;
  //basic half roundtrip estimation
  uint32_t serverDelay = toki.msDifference(arrived, departed);
  uint32_t offset = (ntpPacketReceivedTime - ntpPacketSentTime - serverDelay) >> 1;
  #ifdef WLED_DEBUG_NTP
  //the time the packet departed the NTP server
  toki.printTime(departed);
  #endif

  toki.adjust(departed, offset);
  toki.setTime(departed, TOKI_TS_NTP);

  #ifdef WLED_DEBUG_NTP
  Serial.print("Arrived: ");
  toki.printTime(arrived);
  Serial.print("Time: ");
  toki.printTime(departed);
  Serial.print("Roundtrip: ");
  Serial.println(ntpPacketReceivedTime - ntpPacketSentTime);
  Serial.print("Offset: ");
  Serial.println(offset);
  Serial.print("Serverdelay: ");
  Serial.println(serverDelay);
  #endif

  if (countdownTime - toki.second() > 0) countdownOverTriggered = false;
  // if time changed re-calculate sunrise/sunset
  updateLocalTime();
  calculateSunriseAndSunset();
  return true;
}

void updateLocalTime()
{
  if (currentTimezone != tzCurrent) updateTimezone();
  unsigned long tmc = toki.second()+ utcOffsetSecs;
  localTime = tz->toLocal(tmc);
}

void getTimeString(char* out)
{
  updateLocalTime();
  byte hr = hour(localTime);
  if (useAMPM)
  {
    if (hr > 11) hr -= 12;
    if (hr == 0) hr  = 12;
  }
  sprintf_P(out,PSTR("%i-%i-%i, %02d:%02d:%02d"),year(localTime), month(localTime), day(localTime), hr, minute(localTime), second(localTime));
  if (useAMPM)
  {
    strcat(out,(hour(localTime) > 11)? " PM":" AM");
  }
}

void setCountdown()
{
  if (currentTimezone != tzCurrent) updateTimezone();
  countdownTime = tz->toUTC(getUnixTime(countdownHour, countdownMin, countdownSec, countdownDay, countdownMonth, countdownYear));
  if (countdownTime - toki.second() > 0) countdownOverTriggered = false;
}

//returns true if countdown just over
bool checkCountdown()
{
  unsigned long n = toki.second();
  if (countdownMode) localTime = countdownTime - n + utcOffsetSecs;
  if (n > countdownTime) {
    if (countdownMode) localTime = n - countdownTime + utcOffsetSecs;
    if (!countdownOverTriggered)
    {
      if (macroCountdown != 0) applyPreset(macroCountdown);
      countdownOverTriggered = true;
      return true;
    }
  }
  return false;
}

byte weekdayMondayFirst()
{
  byte wd = weekday(localTime) -1;
  if (wd == 0) wd = 7;
  return wd;
}

bool isTodayInDateRange(byte monthStart, byte dayStart, byte monthEnd, byte dayEnd)
{
	if (monthStart == 0 || dayStart == 0) return true;
	if (monthEnd == 0) monthEnd = monthStart;
	if (dayEnd == 0) dayEnd = 31;
	byte d = day(localTime);
	byte m = month(localTime);

	if (monthStart < monthEnd) {
		if (m > monthStart && m < monthEnd) return true;
		if (m == monthStart) return (d >= dayStart);
		if (m == monthEnd) return (d <= dayEnd);
		return false;
	}
	if (monthEnd < monthStart) { //range spans change of year
		if (m > monthStart || m < monthEnd) return true;
		if (m == monthStart) return (d >= dayStart);
		if (m == monthEnd) return (d <= dayEnd);
		return false;
	}

	//start month and end month are the same
	if (dayEnd < dayStart) return (m != monthStart || (d <= dayEnd || d >= dayStart)); //all year, except the designated days in this month
	return (m == monthStart && d >= dayStart && d <= dayEnd); //just the designated days this month
}

void checkTimers()
{
  if (lastTimerMinute != minute(localTime)) //only check once a new minute begins
  {
    lastTimerMinute = minute(localTime);

    // re-calculate sunrise and sunset just after midnight
    if (!hour(localTime) && minute(localTime)==1) calculateSunriseAndSunset();

    DEBUG_PRINTF("Local time: %02d:%02d\n", hour(localTime), minute(localTime));
    for (uint8_t i = 0; i < 8; i++)
    {
      if (timerMacro[i] != 0
          && (timerWeekday[i] & 0x01) //timer is enabled
          && (timerHours[i] == hour(localTime) || timerHours[i] == 24) //if hour is set to 24, activate every hour
          && timerMinutes[i] == minute(localTime)
          && ((timerWeekday[i] >> weekdayMondayFirst()) & 0x01) //timer should activate at current day of week
          && isTodayInDateRange(((timerMonth[i] >> 4) & 0x0F), timerDay[i], timerMonth[i] & 0x0F, timerDayEnd[i])
         )
      {
        unloadPlaylist();
        applyPreset(timerMacro[i]);
      }
    }
    // sunrise macro
    if (sunrise) {
      time_t tmp = sunrise + timerMinutes[8]*60;  // NOTE: may not be ok
      DEBUG_PRINTF("Trigger time: %02d:%02d\n", hour(tmp), minute(tmp));
      if (timerMacro[8] != 0
          && hour(tmp) == hour(localTime)
          && minute(tmp) == minute(localTime)
          && (timerWeekday[8] & 0x01) //timer is enabled
          && ((timerWeekday[8] >> weekdayMondayFirst()) & 0x01)) //timer should activate at current day of week
      {
        unloadPlaylist();
        applyPreset(timerMacro[8]);
        DEBUG_PRINTF("Sunrise macro %d triggered.",timerMacro[8]);
      }
    }
    // sunset macro
    if (sunset) {
      time_t tmp = sunset + timerMinutes[9]*60;  // NOTE: may not be ok
      DEBUG_PRINTF("Trigger time: %02d:%02d\n", hour(tmp), minute(tmp));
      if (timerMacro[9] != 0
          && hour(tmp) == hour(localTime)
          && minute(tmp) == minute(localTime)
          && (timerWeekday[9] & 0x01) //timer is enabled
          && ((timerWeekday[9] >> weekdayMondayFirst()) & 0x01)) //timer should activate at current day of week
      {
        unloadPlaylist();
        applyPreset(timerMacro[9]);
        DEBUG_PRINTF("Sunset macro %d triggered.",timerMacro[9]);
      }
    }
  }
}

#define ZENITH -0.83
// get sunrise (or sunset) time (in minutes) for a given day at a given geo location
int getSunriseUTC(int year, int month, int day, float lat, float lon, bool sunset=false) {
  //1. first calculate the day of the year
  float N1 = 275 * month / 9;
  float N2 = (month + 9) / 12;
  float N3 = (1 + floor_t((year - 4 * floor_t(year / 4) + 2) / 3));
  float N = N1 - (N2 * N3) + day - 30;

  //2. convert the longitude to hour value and calculate an approximate time
  float lngHour = lon / 15.0f;
  float t = N + (((sunset ? 18 : 6) - lngHour) / 24);

  //3. calculate the Sun's mean anomaly
  float M = (0.9856f * t) - 3.289f;

  //4. calculate the Sun's true longitude
  float L = fmod_t(M + (1.916f * sin_t(DEG_TO_RAD*M)) + (0.02f * sin_t(2*DEG_TO_RAD*M)) + 282.634f, 360.0f);

  //5a. calculate the Sun's right ascension
  float RA = fmod_t(RAD_TO_DEG*atan_t(0.91764f * tan_t(DEG_TO_RAD*L)), 360.0f);

  //5b. right ascension value needs to be in the same quadrant as L
  float Lquadrant  = floor_t( L/90) * 90;
  float RAquadrant = floor_t(RA/90) * 90;
  RA = RA + (Lquadrant - RAquadrant);

  //5c. right ascension value needs to be converted into hours
  RA /= 15.0f;

  //6. calculate the Sun's declination
  float sinDec = 0.39782f * sin_t(DEG_TO_RAD*L);
  float cosDec = cos_t(asin_t(sinDec));

  //7a. calculate the Sun's local hour angle
  float cosH = (sin_t(DEG_TO_RAD*ZENITH) - (sinDec * sin_t(DEG_TO_RAD*lat))) / (cosDec * cos_t(DEG_TO_RAD*lat));
  if (cosH > 1 && !sunset) return 0;  // the sun never rises on this location (on the specified date)
  if (cosH < -1 && sunset) return 0;  // the sun never sets on this location (on the specified date)

  //7b. finish calculating H and convert into hours
  float H = sunset ? RAD_TO_DEG*acos_t(cosH) : 360 - RAD_TO_DEG*acos_t(cosH);
  H /= 15.0f;

  //8. calculate local mean time of rising/setting
  float T = H + RA - (0.06571f * t) - 6.622f;

  //9. adjust back to UTC
  float UT = fmod_t(T - lngHour, 24.0f);

  // return in minutes from midnight
	return UT*60;
}

// calculate sunrise and sunset (if longitude and latitude are set)
void calculateSunriseAndSunset() {
  if ((int)(longitude*10.) || (int)(latitude*10.)) {
    struct tm tim_0;
    tim_0.tm_year = year(localTime)-1900;
    tim_0.tm_mon = month(localTime)-1;
    tim_0.tm_mday = day(localTime);
    tim_0.tm_sec = 0;
    tim_0.tm_isdst = 0;

    int minUTC = getSunriseUTC(year(localTime), month(localTime), day(localTime), latitude, longitude);
    if (minUTC) {
      // there is a sunrise
      if (minUTC < 0) minUTC += 24*60; // add a day if negative
      tim_0.tm_hour = minUTC / 60;
      tim_0.tm_min = minUTC % 60;
      sunrise = tz->toLocal(mktime(&tim_0) + utcOffsetSecs);
      DEBUG_PRINTF("Sunrise: %02d:%02d\n", hour(sunrise), minute(sunrise));
    } else {
      sunrise = 0;
    }

    minUTC = getSunriseUTC(year(localTime), month(localTime), day(localTime), latitude, longitude, true);
    if (minUTC) {
      // there is a sunset
      if (minUTC < 0) minUTC += 24*60; // add a day if negative
      tim_0.tm_hour = minUTC / 60;
      tim_0.tm_min = minUTC % 60;
      sunset = tz->toLocal(mktime(&tim_0) + utcOffsetSecs);
      DEBUG_PRINTF("Sunset: %02d:%02d\n", hour(sunset), minute(sunset));
    } else {
      sunset = 0;
    }
  }
}

//time from JSON and HTTP API
void setTimeFromAPI(uint32_t timein) {
  if (timein == 0 || timein == UINT32_MAX) return;
  uint32_t prev = toki.second();
  //only apply if more accurate or there is a significant difference to the "more accurate" time source
  uint32_t diff = (timein > prev) ? timein - prev : prev - timein;
  if (toki.getTimeSource() > TOKI_TS_JSON && diff < 60U) return;

  toki.setTime(timein, TOKI_NO_MS_ACCURACY, TOKI_TS_JSON);
  if (diff >= 60U) {
    updateLocalTime();
    calculateSunriseAndSunset();
  }
  if (presetsModifiedTime == 0) presetsModifiedTime = timein;
}
=== ./overlay.cpp ===

#include "wled.h"

/*
 * Used to draw clock overlays over the strip
 */

uint16_t circlePixel(double angle) {
  uint16_t circleLength = min(strip.matrixWidth, strip.matrixHeight);
  uint16_t deltaWidth=0, deltaHeight=0;

  if (circleLength < strip.matrixHeight) //portrait
    deltaHeight = (strip.matrixHeight - circleLength) / 2;
  if (circleLength < strip.matrixWidth) //portrait
    deltaWidth = (strip.matrixWidth - circleLength) / 2;

  double halfLength = (circleLength-1)/2.0;

  //calculate circle positions, round to 5 digits and then round again to cater for radians inprecision (e.g. 3.49->3.5->4)
  int x = round(round((sin(radians(angle)) * halfLength + halfLength) * 10)/10) + deltaWidth;
  int y = round(round((halfLength - cos(radians(angle)) * halfLength) * 10)/10) + deltaHeight;
  return strip.XY(x,y);
}

void _overlayAnalogClock()
{
  return; //WLEDSR: disable temporarely as causes div/0 crash

  int overlaySize = overlayMax - overlayMin +1;
  if (countdownMode)
  {
    _overlayAnalogCountdown(); return;
  }
  double hourP = ((double)(hour(localTime)%12))/12;
  double minuteP = ((double)minute(localTime))/60;
  hourP = hourP + minuteP/12;
  double secondP = ((double)second(localTime))/60;
  int hourPixel = floor(analogClock12pixel + overlaySize*hourP);
  if (hourPixel > overlayMax) hourPixel = overlayMin -1 + hourPixel - overlayMax;
  int minutePixel = floor(analogClock12pixel + overlaySize*minuteP);
  if (minutePixel > overlayMax) minutePixel = overlayMin -1 + minutePixel - overlayMax;
  int secondPixel = floor(analogClock12pixel + overlaySize*secondP);
  if (secondPixel > overlayMax) secondPixel = overlayMin -1 + secondPixel - overlayMax;
  if (analogClockSecondsTrail)
  {
    if (secondPixel < analogClock12pixel)
    {
      strip.setRange(analogClock12pixel, overlayMax, 0xFF0000);
      strip.setRange(overlayMin, secondPixel, 0xFF0000);
    } else
    {
      strip.setRange(analogClock12pixel, secondPixel, 0xFF0000);
    }
  }
  if (analogClock5MinuteMarks)
  {
    for (byte i = 0; i <= 12; i++)
    {
      int pix = analogClock12pixel + round((overlaySize / 12.0) *i);
      if (pix > overlayMax) pix -= overlaySize;
      strip.setPixelColor(strip.matrixWidth > 0?circlePixel(i*30):pix, 0x00FFAA);
    }
  }
  if (!analogClockSecondsTrail) strip.setPixelColor(strip.matrixWidth > 0?circlePixel(secondP * 360):secondPixel, 0xFF0000);
  strip.setPixelColor(strip.matrixWidth > 0?circlePixel(minuteP * 360):minutePixel, 0x00FF00);
  strip.setPixelColor(strip.matrixWidth > 0?circlePixel(hourP * 360):hourPixel, 0x0000FF);
}


void _overlayAnalogCountdown()
{
  if ((unsigned long)toki.second() < countdownTime)
  {
    long diff = countdownTime - toki.second();
    double pval = 60;
    if (diff > 31557600L) //display in years if more than 365 days
    {
      pval = 315576000L; //10 years
    } else if (diff > 2592000L) //display in months if more than a month
    {
      pval = 31557600L; //1 year
    } else if (diff > 604800) //display in weeks if more than a week
    {
      pval = 2592000L; //1 month
    } else if (diff > 86400) //display in days if more than 24 hours
    {
      pval = 604800; //1 week
    } else if (diff > 3600) //display in hours if more than 60 minutes
    {
      pval = 86400; //1 day
    } else if (diff > 60) //display in minutes if more than 60 seconds
    {
      pval = 3600; //1 hour
    }
    int overlaySize = overlayMax - overlayMin +1;
    double perc = (pval-(double)diff)/pval;
    if (perc > 1.0) perc = 1.0;
    byte pixelCnt = perc*overlaySize;
    if (analogClock12pixel + pixelCnt > overlayMax)
    {
      strip.setRange(analogClock12pixel, overlayMax, ((uint32_t)colSec[3] << 24)| ((uint32_t)colSec[0] << 16) | ((uint32_t)colSec[1] << 8) | colSec[2]);
      strip.setRange(overlayMin, overlayMin +pixelCnt -(1+ overlayMax -analogClock12pixel), ((uint32_t)colSec[3] << 24)| ((uint32_t)colSec[0] << 16) | ((uint32_t)colSec[1] << 8) | colSec[2]);
    } else
    {
      strip.setRange(analogClock12pixel, analogClock12pixel + pixelCnt, ((uint32_t)colSec[3] << 24)| ((uint32_t)colSec[0] << 16) | ((uint32_t)colSec[1] << 8) | colSec[2]);
    }
  }
}

void handleOverlayDraw() {
  usermods.handleOverlayDraw();
  if (overlayCurrent == 1) _overlayAnalogClock();
}

/*
 * Support for the Cronixie clock has moved to a usermod, compile with "-D USERMOD_CRONIXIE" to enable
 */

=== ./palettes.h ===

/*
 * Color palettes for FastLED effects (65-73).
 */

// From ColorWavesWithPalettes by Mark Kriegsman: https://gist.github.com/kriegsman/8281905786e8b2632aeb
// Unfortunaltely, these are stored in RAM!

// Gradient palette "ib_jul01_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/ing/xmas/tn/ib_jul01.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 16 bytes of program space.

#ifndef PalettesWLED_h
#define PalettesWLED_h

#define GRADIENT_PALETTE_COUNT 60 //WLEDMM netmindz ar palette +2

const byte ib_jul01_gp[] PROGMEM = {
    0, 194,  1,  1,
   94,   1, 29, 18,
  132,  57,131, 28,
  255, 113,  1,  1};

// Gradient palette "es_vintage_57_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/es/vintage/tn/es_vintage_57.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 20 bytes of program space.

const byte es_vintage_57_gp[] PROGMEM = {
    0,   2,  1,  1,
   53,  18,  1,  0,
  104,  69, 29,  1,
  153, 167,135, 10,
  255,  46, 56,  4};


// Gradient palette "es_vintage_01_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/es/vintage/tn/es_vintage_01.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 32 bytes of program space.

const byte es_vintage_01_gp[] PROGMEM = {
    0,   4,  1,  1,
   51,  16,  0,  1,
   76,  97,104,  3,
  101, 255,131, 19,
  127,  67,  9,  4,
  153,  16,  0,  1,
  229,   4,  1,  1,
  255,   4,  1,  1};


// Gradient palette "es_rivendell_15_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/es/rivendell/tn/es_rivendell_15.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 20 bytes of program space.

const byte es_rivendell_15_gp[] PROGMEM = {
    0,   1, 14,  5,
  101,  16, 36, 14,
  165,  56, 68, 30,
  242, 150,156, 99,
  255, 150,156, 99};


// Gradient palette "rgi_15_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/ds/rgi/tn/rgi_15.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 36 bytes of program space.
// Edited to be brighter

const byte rgi_15_gp[] PROGMEM = {
    0,   4,  1, 70,
   31,  55,  1, 30,
   63, 255,  4,  7,
   95,  59,  2, 29,
  127,  11,  3, 50,
  159,  39,  8, 60,
  191, 112, 19, 40,
  223,  78, 11, 39,
  255,  29,  8, 59};


// Gradient palette "retro2_16_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/ma/retro2/tn/retro2_16.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 8 bytes of program space.

const byte retro2_16_gp[] PROGMEM = {
    0, 188,135,  1,
  255,  46,  7,  1};


// Gradient palette "Analogous_1_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/red/tn/Analogous_1.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 20 bytes of program space.

const byte Analogous_1_gp[] PROGMEM = {
    0,   3,  0,255,
   63,  23,  0,255,
  127,  67,  0,255,
  191, 142,  0, 45,
  255, 255,  0,  0};


// Gradient palette "es_pinksplash_08_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/es/pink_splash/tn/es_pinksplash_08.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 20 bytes of program space.

const byte es_pinksplash_08_gp[] PROGMEM = {
    0, 126, 11,255,
  127, 197,  1, 22,
  175, 210,157,172,
  221, 157,  3,112,
  255, 157,  3,112};


// Gradient palette "es_ocean_breeze_036_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/es/ocean_breeze/tn/es_ocean_breeze_036.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 16 bytes of program space.

const byte es_ocean_breeze_036_gp[] PROGMEM = {
    0,   1,  6,  7,
   89,   1, 99,111,
  153, 144,209,255,
  255,   0, 73, 82};


// Gradient palette "departure_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/mjf/tn/departure.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 88 bytes of program space.

const byte departure_gp[] PROGMEM = {
    0,   8,  3,  0,
   42,  23,  7,  0,
   63,  75, 38,  6,
   84, 169, 99, 38,
  106, 213,169,119,
  116, 255,255,255,
  138, 135,255,138,
  148,  22,255, 24,
  170,   0,255,  0,
  191,   0,136,  0,
  212,   0, 55,  0,
  255,   0, 55,  0};


// Gradient palette "es_landscape_64_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/es/landscape/tn/es_landscape_64.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 36 bytes of program space.

const byte es_landscape_64_gp[] PROGMEM = {
    0,   0,  0,  0,
   37,   2, 25,  1,
   76,  15,115,  5,
  127,  79,213,  1,
  128, 126,211, 47,
  130, 188,209,247,
  153, 144,182,205,
  204,  59,117,250,
  255,   1, 37,192};


// Gradient palette "es_landscape_33_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/es/landscape/tn/es_landscape_33.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 24 bytes of program space.

const byte es_landscape_33_gp[] PROGMEM = {
    0,   1,  5,  0,
   19,  32, 23,  1,
   38, 161, 55,  1,
   63, 229,144,  1,
   66,  39,142, 74,
  255,   1,  4,  1};


// Gradient palette "rainbowsherbet_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/ma/icecream/tn/rainbowsherbet.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 28 bytes of program space.

const byte rainbowsherbet_gp[] PROGMEM = {
    0, 255, 33,  4,
   43, 255, 68, 25,
   86, 255,  7, 25,
  127, 255, 82,103,
  170, 255,255,242,
  209,  42,255, 22,
  255,  87,255, 65};


// Gradient palette "gr65_hult_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/hult/tn/gr65_hult.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 24 bytes of program space.

const byte gr65_hult_gp[] PROGMEM = {
    0, 247,176,247,
   48, 255,136,255,
   89, 220, 29,226,
  160,   7, 82,178,
  216,   1,124,109,
  255,   1,124,109};


// Gradient palette "gr64_hult_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/hult/tn/gr64_hult.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 32 bytes of program space.

const byte gr64_hult_gp[] PROGMEM = {
    0,   1,124,109,
   66,   1, 93, 79,
  104,  52, 65,  1,
  130, 115,127,  1,
  150,  52, 65,  1,
  201,   1, 86, 72,
  239,   0, 55, 45,
  255,   0, 55, 45};


// Gradient palette "GMT_drywet_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/gmt/tn/GMT_drywet.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 28 bytes of program space.

const byte GMT_drywet_gp[] PROGMEM = {
    0,  47, 30,  2,
   42, 213,147, 24,
   84, 103,219, 52,
  127,   3,219,207,
  170,   1, 48,214,
  212,   1,  1,111,
  255,   1,  7, 33};


// Gradient palette "ib15_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/ing/general/tn/ib15.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 24 bytes of program space.

const byte ib15_gp[] PROGMEM = {
    0, 113, 91,147,
   72, 157, 88, 78,
   89, 208, 85, 33,
  107, 255, 29, 11,
  141, 137, 31, 39,
  255,  59, 33, 89};


// Gradient palette "Tertiary_01_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/vermillion/tn/Tertiary_01.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 20 bytes of program space.

const byte Tertiary_01_gp[] PROGMEM = {
    0,   0,  1,255,
   63,   3, 68, 45,
  127,  23,255,  0,
  191, 100, 68,  1,
  255, 255,  1,  4};


// Gradient palette "lava_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/neota/elem/tn/lava.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 52 bytes of program space.

const byte lava_gp[] PROGMEM = {
    0,   0,  0,  0,
   46,  18,  0,  0,
   96, 113,  0,  0,
  108, 142,  3,  1,
  119, 175, 17,  1,
  146, 213, 44,  2,
  174, 255, 82,  4,
  188, 255,115,  4,
  202, 255,156,  4,
  218, 255,203,  4,
  234, 255,255,  4,
  244, 255,255, 71,
  255, 255,255,255};


// Gradient palette "fierce_ice_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/neota/elem/tn/fierce-ice.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 28 bytes of program space.

const byte fierce_ice_gp[] PROGMEM = {
    0,   0,  0,  0,
   59,   0,  9, 45,
  119,   0, 38,255,
  149,   3,100,255,
  180,  23,199,255,
  217, 100,235,255,
  255, 255,255,255};


// Gradient palette "Colorfull_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/atmospheric/tn/Colorfull.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 44 bytes of program space.

const byte Colorfull_gp[] PROGMEM = {
    0,  10, 85,  5,
   25,  29,109, 18,
   60,  59,138, 42,
   93,  83, 99, 52,
  106, 110, 66, 64,
  109, 123, 49, 65,
  113, 139, 35, 66,
  116, 192,117, 98,
  124, 255,255,137,
  168, 100,180,155,
  255,  22,121,174};


// Gradient palette "Pink_Purple_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/atmospheric/tn/Pink_Purple.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 44 bytes of program space.

const byte Pink_Purple_gp[] PROGMEM = {
    0,  19,  2, 39,
   25,  26,  4, 45,
   51,  33,  6, 52,
   76,  68, 62,125,
  102, 118,187,240,
  109, 163,215,247,
  114, 217,244,255,
  122, 159,149,221,
  149, 113, 78,188,
  183, 128, 57,155,
  255, 146, 40,123};


// Gradient palette "Sunset_Real_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/atmospheric/tn/Sunset_Real.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 28 bytes of program space.

const byte Sunset_Real_gp[] PROGMEM = {
    0, 120,  0,  0,
   22, 179, 22,  0,
   51, 255,104,  0,
   85, 167, 22, 18,
  135, 100,  0,103,
  198,  16,  0,130,
  255,   0,  0,160};


// Gradient palette "Sunset_Yellow_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/atmospheric/tn/Sunset_Yellow.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 44 bytes of program space.

const byte Sunset_Yellow_gp[] PROGMEM = {
    0,  10, 62,123,
   36,  56,130,103,
   87, 153,225, 85,
  100, 199,217, 68,
  107, 255,207, 54,
  115, 247,152, 57,
  120, 239,107, 61,
  128, 247,152, 57,
  180, 255,207, 54,
  223, 255,227, 48,
  255, 255,248, 42};


// Gradient palette "Beech_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/atmospheric/tn/Beech.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 60 bytes of program space.

const byte Beech_gp[] PROGMEM = {
    0, 255,252,214,
   12, 255,252,214,
   22, 255,252,214,
   26, 190,191,115,
   28, 137,141, 52,
   28, 112,255,205,
   50,  51,246,214,
   71,  17,235,226,
   93,   2,193,199,
  120,   0,156,174,
  133,   1,101,115,
  136,   1, 59, 71,
  136,   7,131,170,
  208,   1, 90,151,
  255,   0, 56,133};


// Gradient palette "Another_Sunset_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/atmospheric/tn/Another_Sunset.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 32 bytes of program space.

const byte Another_Sunset_gp[] PROGMEM = {
    0, 110, 49, 11,
   29,  55, 34, 10,
   68,  22, 22,  9,
   68, 239,124,  8,
   97, 220,156, 27,
  124, 203,193, 61,
  178,  33, 53, 56,
  255,   0,  1, 52};





// Gradient palette "es_autumn_19_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/es/autumn/tn/es_autumn_19.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 52 bytes of program space.

const byte es_autumn_19_gp[] PROGMEM = {
    0,  26,  1,  1,
   51,  67,  4,  1,
   84, 118, 14,  1,
  104, 137,152, 52,
  112, 113, 65,  1,
  122, 133,149, 59,
  124, 137,152, 52,
  135, 113, 65,  1,
  142, 139,154, 46,
  163, 113, 13,  1,
  204,  55,  3,  1,
  249,  17,  1,  1,
  255,  17,  1,  1};


// Gradient palette "BlacK_Blue_Magenta_White_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/basic/tn/BlacK_Blue_Magenta_White.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 28 bytes of program space.

const byte BlacK_Blue_Magenta_White_gp[] PROGMEM = {
    0,   0,  0,  0,
   42,   0,  0, 45,
   84,   0,  0,255,
  127,  42,  0,255,
  170, 255,  0,255,
  212, 255, 55,255,
  255, 255,255,255};


// Gradient palette "BlacK_Magenta_Red_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/basic/tn/BlacK_Magenta_Red.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 20 bytes of program space.

const byte BlacK_Magenta_Red_gp[] PROGMEM = {
    0,   0,  0,  0,
   63,  42,  0, 45,
  127, 255,  0,255,
  191, 255,  0, 45,
  255, 255,  0,  0};


// Gradient palette "BlacK_Red_Magenta_Yellow_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/basic/tn/BlacK_Red_Magenta_Yellow.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 28 bytes of program space.

const byte BlacK_Red_Magenta_Yellow_gp[] PROGMEM = {
    0,   0,  0,  0,
   42,  42,  0,  0,
   84, 255,  0,  0,
  127, 255,  0, 45,
  170, 255,  0,255,
  212, 255, 55, 45,
  255, 255,255,  0};


// Gradient palette "Blue_Cyan_Yellow_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/basic/tn/Blue_Cyan_Yellow.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 20 bytes of program space.

const byte Blue_Cyan_Yellow_gp[] PROGMEM = {
    0,   0,  0,255,
   63,   0, 55,255,
  127,   0,255,255,
  191,  42,255, 45,
  255, 255,255,  0};


//Custom palette by Aircoookie

const byte Orange_Teal_gp[] PROGMEM = {
    0,   0,150, 92,
   55,   0,150, 92,
  200, 255, 72,  0,
  255, 255, 72,  0};

//Custom palette by Aircoookie

const byte Tiamat_gp[] PROGMEM = {
    0,   1,  2, 14, //gc
   33,   2,  5, 35, //gc from 47, 61,126
  100,  13,135, 92, //gc from 88,242,247
  120,  43,255,193, //gc from 135,255,253
  140, 247,  7,249, //gc from 252, 69,253
  160, 193, 17,208, //gc from 231, 96,237
  180,  39,255,154, //gc from 130, 77,213
  200,   4,213,236, //gc from 57,122,248
  220,  39,252,135, //gc from 177,254,255
  240, 193,213,253, //gc from 203,239,253
  255, 255,249,255};

//Custom palette by Aircoookie

const byte April_Night_gp[] PROGMEM = {
    0,   1,  5, 45, //deep blue
   10,   1,  5, 45,
   25,   5,169,175, //light blue
   40,   1,  5, 45,
   61,   1,  5, 45,
   76,  45,175, 31, //green
   91,   1,  5, 45,
  112,   1,  5, 45,
  127, 249,150,  5, //yellow
  143,   1,  5, 45,
  162,   1,  5, 45,
  178, 255, 92,  0, //pastel orange
  193,   1,  5, 45,
  214,   1,  5, 45,
  229, 223, 45, 72, //pink
  244,   1,  5, 45,
  255,   1,  5, 45};

const byte Orangery_gp[] PROGMEM = {
    0, 255, 95, 23,
   30, 255, 82,  0,
   60, 223, 13,  8,
   90, 144, 44,  2,
  120, 255,110, 17,
  150, 255, 69,  0,
  180, 158, 13, 11,
  210, 241, 82, 17,
  255, 213, 37,  4};

//inspired by Mark Kriegsman https://gist.github.com/kriegsman/756ea6dcae8e30845b5a
const byte C9_gp[] PROGMEM = {
    0, 184,  4,  0, //red
   60, 184,  4,  0,
   65, 144, 44,  2, //amber
  125, 144, 44,  2,
  130,   4, 96,  2, //green
  190,   4, 96,  2,
  195,   7,  7, 88, //blue
  255,   7,  7, 88};

const byte Sakura_gp[] PROGMEM = {
    0, 196, 19, 10,
   65, 255, 69, 45,
  130, 223, 45, 72,
  195, 255, 82,103,
  255, 223, 13, 17};

const byte Aurora_gp[] PROGMEM = {
    0,   1,  5, 45, //deep blue
   64,   0,200, 23,
  128,   0,255,  0, //green
  170,   0,243, 45,
  200,   0,135,  7,
  255,   1,  5, 45};//deep blue

const byte Atlantica_gp[] PROGMEM = {
    0,   0, 28,112, //#001C70
   50,  32, 96,255, //#2060FF
  100,   0,243, 45,
  150,  12, 95, 82, //#0C5F52
  200,  25,190, 95, //#19BE5F
  255,  40,170, 80};//#28AA50

  const byte C9_2_gp[] PROGMEM = {
    0,   6, 126,   2, //green
   45,   6, 126,   2,
   45,   4,  30, 114, //blue
   90,   4,  30, 114,
   90, 255,   5,   0, //red
  135, 255,   5,   0,
  135, 196,  57,   2, //amber
  180, 196,  57,   2,
  180, 137,  85,   2, //yellow
  255, 137,  85,   2};

  //C9, but brighter and with a less purple blue
  const byte C9_new_gp[] PROGMEM = {
    0, 255,   5,   0, //red
   60, 255,   5,   0,
   60, 196,  57,   2, //amber (start 61?)
  120, 196,  57,   2,
  120,   6, 126,   2, //green (start 126?)
  180,   6, 126,   2,
  180,   4,  30, 114, //blue (start 191?)
  255,   4,  30, 114};

// Gradient palette "temperature_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/arendal/tn/temperature.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 144 bytes of program space.

const byte temperature_gp[] PROGMEM = {
    0,   1, 27,105,
   14,   1, 40,127,
   28,   1, 70,168,
   42,   1, 92,197,
   56,   1,119,221,
   70,   3,130,151,
   84,  23,156,149,
   99,  67,182,112,
  113, 121,201, 52,
  127, 142,203, 11,
  141, 224,223,  1,
  155, 252,187,  2,
  170, 247,147,  1,
  184, 237, 87,  1,
  198, 229, 43,  1,
  226, 171,  2,  2,
  240,  80,  3,  3,
  255,  80,  3,  3};

  const byte Aurora2_gp[] PROGMEM = {
      0,  17, 177,  13,    //Greenish
     64, 121, 242,   5,    //Greenish
    128,  25, 173, 121,    //Turquoise
    192, 250,  77, 127,    //Pink
    255, 171, 101, 221     //Purple
  };

// Gradient palette "bhw1_01_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw1/tn/bhw1_01.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 12 bytes of program space.

const byte retro_clown_gp[] PROGMEM = {
    0, 227,101,  3,
  117, 194, 18, 19,
  255,  92,  8,192};

// Gradient palette "bhw1_04_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw1/tn/bhw1_04.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 20 bytes of program space.

const byte candy_gp[] PROGMEM = {
    0, 229,227,  1,
   15, 227,101,  3,
  142,  40,  1, 80,
  198,  17,  1, 79,
  255,   0,  0, 45};

// Gradient palette "bhw1_05_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw1/tn/bhw1_05.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 8 bytes of program space.

const byte toxy_reaf_gp[] PROGMEM = {
    0,   1,221, 53,
  255,  73,  3,178};

// Gradient palette "bhw1_06_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw1/tn/bhw1_06.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 16 bytes of program space.

const byte  fairy_reaf_gp[] PROGMEM = {
    0, 184,  1,128,
  160,   1,193,182,
  219, 153,227,190,
  255, 255,255,255};

// Gradient palette "bhw1_14_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw1/tn/bhw1_14.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 36 bytes of program space.

const byte semi_blue_gp[] PROGMEM = {
    0,   0,  0,  0,
   12,   1,  1,  3,
   53,   8,  1, 22,
   80,   4,  6, 89,
  119,   2, 25,216,
  145,   7, 10, 99,
  186,  15,  2, 31,
  233,   2,  1,  5,
  255,   0,  0,  0};

// Gradient palette "bhw1_three_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw1/tn/bhw1_three.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 32 bytes of program space.

const byte pink_candy_gp[] PROGMEM = {
    0, 255,255,255,
   45,   7, 12,255,
  112, 227,  1,127,
  112, 227,  1,127,
  140, 255,255,255,
  155, 227,  1,127,
  196,  45,  1, 99,
  255, 255,255,255};

// Gradient palette "bhw1_w00t_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw1/tn/bhw1_w00t.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 16 bytes of program space.

const byte red_reaf_gp[] PROGMEM = {
    0,   3, 13, 43,
  104,  78,141,240,
  188, 255,  0,  0,
  255,  28,  1,  1};


// Gradient palette "bhw2_23_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw2/tn/bhw2_23.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Red & Flash in SR
// Size: 28 bytes of program space.

const byte aqua_flash_gp[] PROGMEM = {
    0,   0,  0,  0,
   66,  57,227,233,
   96, 255,255,  8,
  124, 255,255,255,
  153, 255,255,  8,
  188,  57,227,233,
  255,   0,  0,  0};

// Gradient palette "bhw2_xc_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw2/tn/bhw2_xc.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// YBlue in SR
// Size: 28 bytes of program space.

const byte yelblu_hot_gp[] PROGMEM = {
    0,   4,  2,  9,
   58,  16,  0, 47,
  122,  24,  0, 16,
  158, 144,  9,  1,
  183, 179, 45,  1,
  219, 220,114,  2,
  255, 234,237,  1};

 // Gradient palette "bhw2_45_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw2/tn/bhw2_45.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 24 bytes of program space.

const byte lite_light_gp[] PROGMEM = {
    0,   0,  0,  0,
    9,   1,  1,  1,
   40,   5,  5,  6,
   66,   5,  5,  6,
  101,  10,  1, 12,
  255,   0,  0,  0};

// Gradient palette "bhw2_22_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw2/tn/bhw2_22.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Pink Plasma in SR
// Size: 20 bytes of program space.

const byte red_flash_gp[] PROGMEM = {
    0,   0,  0,  0,
   99, 227,  1,  1,
  130, 249,199, 95,
  155, 227,  1,  1,
  255,   0,  0,  0};

// Gradient palette "bhw3_40_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw3/tn/bhw3_40.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 32 bytes of program space.

const byte blink_red_gp[] PROGMEM = {
    0,   1,  1,  1,
   43,   4,  1, 11,
   76,  10,  1,  3,
  109, 161,  4, 29,
  127, 255, 86,123,
  165, 125, 16,160,
  204,  35, 13,223,
  255,  18,  2, 18};

// Gradient palette "bhw3_52_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw3/tn/bhw3_52.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Yellow2Blue in SR
// Size: 28 bytes of program space.

const byte red_shift_gp[] PROGMEM = {
    0,  31,  1, 27,
   45,  34,  1, 16,
   99, 137,  5,  9,
  132, 213,128, 10,
  175, 199, 22,  1,
  201, 199,  9,  6,
  255,   1,  0,  1};

// Gradient palette "bhw4_097_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw4/tn/bhw4_097.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Yellow2Red in SR
// Size: 44 bytes of program space.

const byte red_tide_gp[] PROGMEM = {
    0, 247,  5,  0,
   28, 255, 67,  1,
   43, 234, 88, 11,
   58, 234,176, 51,
   84, 229, 28,  1,
  114, 113, 12,  1,
  140, 255,225, 44,
  168, 113, 12,  1,
  196, 244,209, 88,
  216, 255, 28,  1,
  255,  53,  1,  1};

// Gradient palette "bhw4_017_gp", originally from
// http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw4/tn/bhw4_017.png.index.html
// converted for FastLED with gammas (2.6, 2.2, 2.5)
// Size: 40 bytes of program space.

const byte candy2_gp[] PROGMEM = {
    0,  39, 33, 34,
   25,   4,  6, 15,
   48,  49, 29, 22,
   73, 224,173,  1,
   89, 177, 35,  5,
  130,   4,  6, 15,
  163, 255,114,  6,
  186, 224,173,  1,
  211,  39, 33, 34,
  255,   1,  1,  1};

 //WLEDMM netmindz ar palette
// Start off as just RGB, but replace in runtime with colors relating to the music
const byte audio_responsive_gp[] PROGMEM = {
   0, 255, 0, 0,
   125, 0, 255, 0,
   255, 0, 0, 255
};

// Single array of defined cpt-city color palettes.
// This will let us programmatically choose one based on
// a number, rather than having to activate each explicitly
// by name every time.
const byte* const gGradientPalettes[] PROGMEM = {
  Sunset_Real_gp,               //13-00 Sunset
  es_rivendell_15_gp,           //14-01 Rivendell
  es_ocean_breeze_036_gp,       //15-02 Breeze
  rgi_15_gp,                    //16-03 Red & Blue
  retro2_16_gp,                 //17-04 Yellowout
  Analogous_1_gp,               //18-05 Analogous
  es_pinksplash_08_gp,          //19-06 Splash
  Sunset_Yellow_gp,             //20-07 Pastel
  Another_Sunset_gp,            //21-08 Sunset2
  Beech_gp,                     //22-09 Beech
  es_vintage_01_gp,             //23-10 Vintage
  departure_gp,                 //24-11 Departure
  es_landscape_64_gp,           //25-12 Landscape
  es_landscape_33_gp,           //26-13 Beach
  rainbowsherbet_gp,            //27-14 Sherbet
  gr65_hult_gp,                 //28-15 Hult
  gr64_hult_gp,                 //29-16 Hult64
  GMT_drywet_gp,                //30-17 Drywet
  ib_jul01_gp,                  //31-18 Jul
  es_vintage_57_gp,             //32-19 Grintage
  ib15_gp,                      //33-20 Rewhi
  Tertiary_01_gp,               //34-21 Tertiary
  lava_gp,                      //35-22 Fire
  fierce_ice_gp,                //36-23 Icefire
  Colorfull_gp,                 //37-24 Cyane
  Pink_Purple_gp,               //38-25 Light Pink
  es_autumn_19_gp,              //39-26 Autumn
  BlacK_Blue_Magenta_White_gp,  //40-27 Magenta
  BlacK_Magenta_Red_gp,         //41-28 Magred
  BlacK_Red_Magenta_Yellow_gp,  //42-29 Yelmag
  Blue_Cyan_Yellow_gp,          //43-30 Yelblu
  Orange_Teal_gp,               //44-31 Orange & Teal
  Tiamat_gp,                    //45-32 Tiamat
  April_Night_gp,               //46-33 April Night
  Orangery_gp,                  //47-34 Orangery
  C9_gp,                        //48-35 C9
  Sakura_gp,                    //49-36 Sakura
  Aurora_gp,                    //50-37 Aurora
  Atlantica_gp,                 //51-38 Atlantica
  C9_2_gp,                      //52-39 C9 2
  C9_new_gp,                    //53-40 C9 New
  temperature_gp,               //54-41 Temperature
  Aurora2_gp,                   //55-42 Aurora 2
  retro_clown_gp,               //56-43 Retro Clown
  candy_gp,                     //57-44 Candy
  toxy_reaf_gp,                 //58-45 Toxy Reaf
  fairy_reaf_gp,                //59-46 Fairy Reaf
  semi_blue_gp,                 //60-47 Semi Blue
  pink_candy_gp,                //61-48 Pink Candy
  red_reaf_gp,                  //62-49 Red Reaf
  aqua_flash_gp,                //63-50 Aqua Flash
  yelblu_hot_gp,                //64-51 Yelblu Hot
  lite_light_gp,                //65-52 Lite Light
  red_flash_gp,                 //66-53 Red Flash
  blink_red_gp,                 //67-54 Blink Red
  red_shift_gp,                 //68-55 Red Shift
  red_tide_gp,                  //69-56 Red Tide
  candy2_gp,                    //70-57 Candy2
  audio_responsive_gp,          //71-58 AudioResponsive  WLEDMM netmindz ar palette - placeholder1
  audio_responsive_gp,          //72-59 AudioResponsive  WLEDMM netmindz ar palette - placeholder2
};

#endif

=== ./pin_manager.cpp ===

#include "pin_manager.h"
#include "wled.h"

#ifdef WLED_DEBUG
static void DebugPrintOwnerTag(PinOwner tag)
{
  uint32_t q = static_cast<uint8_t>(tag);
  if (q) {
    DEBUG_PRINTF("0x%02x (%d)", q, q);
  } else {
    DEBUG_PRINT(F("(no owner)"));
  }
}
#endif

/// Actual allocation/deallocation routines
bool PinManagerClass::deallocatePin(byte gpio, PinOwner tag)
{
  if (gpio == 0xFF) return true;           // explicitly allow clients to free -1 as a no-op
  if (!isPinOk(gpio, false)) return false; // but return false for any other invalid pin

  // if a non-zero ownerTag, only allow de-allocation if the owner's tag is provided
  if ((ownerTag[gpio] != PinOwner::None) && (ownerTag[gpio] != tag)) {
    #ifdef WLED_DEBUG
    DEBUG_PRINT(F("PIN DEALLOC: IO "));
    DEBUG_PRINT(gpio);
    DEBUG_PRINT(F(" allocated by "));
    DebugPrintOwnerTag(ownerTag[gpio]);
    DEBUG_PRINT(F(", but attempted de-allocation by "));
    DebugPrintOwnerTag(tag);
    #endif
    return false;
  }
  
  byte by = gpio >> 3;
  byte bi = gpio - 8*by;
  bitWrite(pinAlloc[by], bi, false);
  ownerTag[gpio] = PinOwner::None;
  return true;
}

// support function for deallocating multiple pins
bool PinManagerClass::deallocateMultiplePins(const uint8_t *pinArray, byte arrayElementCount, PinOwner tag)
{
  bool shouldFail = false;
  DEBUG_PRINTLN(F("MULTIPIN DEALLOC"));
  // first verify the pins are OK and allocated by selected owner
  for (int i = 0; i < arrayElementCount; i++) {
    byte gpio = pinArray[i];
    if (gpio == 0xFF) {
      // explicit support for io -1 as a no-op (no allocation of pin),
      // as this can greatly simplify configuration arrays
      continue;
    }
    if (isPinAllocated(gpio, tag)) {
      // if the current pin is allocated by selected owner it is possible to release it
      continue;
    }
    #ifdef WLED_DEBUG
    DEBUG_PRINT(F("PIN DEALLOC: IO "));
    DEBUG_PRINT(gpio);
    DEBUG_PRINT(F(" allocated by "));
    DebugPrintOwnerTag(ownerTag[gpio]);
    DEBUG_PRINT(F(", but attempted de-allocation by "));
    DebugPrintOwnerTag(tag);
    #endif
    shouldFail = true;
  }
  if (shouldFail) {
    return false; // no pins deallocated
  }
  if (tag==PinOwner::HW_I2C) {
    if (i2cAllocCount && --i2cAllocCount>0) {
      // no deallocation done until last owner releases pins
      return true;
    }
  }
  for (int i = 0; i < arrayElementCount; i++) {
    deallocatePin(pinArray[i], tag);
  }
  return true;
}

bool PinManagerClass::allocateMultiplePins(const managed_pin_type * mptArray, byte arrayElementCount, PinOwner tag)
{
  bool shouldFail = false;
  // first verify the pins are OK and not already allocated
  for (int i = 0; i < arrayElementCount; i++) {
    byte gpio = mptArray[i].pin;
    if (gpio == 0xFF) {
      // explicit support for io -1 as a no-op (no allocation of pin),
      // as this can greatly simplify configuration arrays
      continue;
    }
    if (!isPinOk(gpio, mptArray[i].isOutput)) {
      #ifdef WLED_DEBUG
      DEBUG_PRINT(F("PIN ALLOC: Invalid pin attempted to be allocated: "));
      DEBUG_PRINT(gpio);
      DEBUG_PRINTLN(F(""));
      #endif
      shouldFail = true;
    }
    if (tag==PinOwner::HW_I2C && isPinAllocated(gpio, tag)) {
      // allow multiple "allocations" of HW I2C bus pins
      continue;
    } else if (isPinAllocated(gpio)) {
      #ifdef WLED_DEBUG
      DEBUG_PRINT(F("PIN ALLOC: FAIL: IO ")); 
      DEBUG_PRINT(gpio);
      DEBUG_PRINT(F(" already allocated by "));
      DebugPrintOwnerTag(ownerTag[gpio]);
      DEBUG_PRINTLN(F(""));
      #endif
      shouldFail = true;
    }
  }
  if (shouldFail) {
    return false;
  }

  if (tag==PinOwner::HW_I2C) i2cAllocCount++;

  // all pins are available .. track each one
  for (int i = 0; i < arrayElementCount; i++) {
    byte gpio = mptArray[i].pin;
    if (gpio == 0xFF) {
      // allow callers to include -1 value as non-requested pin
      // as this can greatly simplify configuration arrays
      continue;
    }
    byte by = gpio >> 3;
    byte bi = gpio - 8*by;
    bitWrite(pinAlloc[by], bi, true);
    ownerTag[gpio] = tag;
    #ifdef WLED_DEBUG
    DEBUG_PRINT(F("PIN ALLOC: Pin ")); 
    DEBUG_PRINT(gpio);
    DEBUG_PRINT(F(" allocated by "));
    DebugPrintOwnerTag(tag);
    DEBUG_PRINTLN(F(""));
    #endif
  }
  return true;
}

bool PinManagerClass::allocatePin(byte gpio, bool output, PinOwner tag)
{
  // HW I2C pins have to be allocated using allocateMultiplePins variant since there is always SCL/SDA pair
  if (!isPinOk(gpio, output) || tag==PinOwner::HW_I2C) return false;
  if (isPinAllocated(gpio)) {
    #ifdef WLED_DEBUG
    DEBUG_PRINT(F("PIN ALLOC: Pin ")); 
    DEBUG_PRINT(gpio);
    DEBUG_PRINT(F(" already allocated by "));
    DebugPrintOwnerTag(ownerTag[gpio]);
    DEBUG_PRINTLN(F(""));
    #endif
    return false;
  }

  byte by = gpio >> 3;
  byte bi = gpio - 8*by;
  bitWrite(pinAlloc[by], bi, true);
  ownerTag[gpio] = tag;
  #ifdef WLED_DEBUG
  DEBUG_PRINT(F("PIN ALLOC: Pin ")); 
  DEBUG_PRINT(gpio);
  DEBUG_PRINT(F(" allocated by "));
  DebugPrintOwnerTag(tag);
  DEBUG_PRINTLN(F(""));
  #endif  

  return true;
}

// if tag is set to PinOwner::None, checks for ANY owner of the pin.
// if tag is set to any other value, checks if that tag is the current owner of the pin.
bool PinManagerClass::isPinAllocated(byte gpio, PinOwner tag)
{
  if (!isPinOk(gpio, false)) return true;
  if ((tag != PinOwner::None) && (ownerTag[gpio] != tag)) return false;
  byte by = gpio >> 3;
  byte bi = gpio - (by<<3);
  return bitRead(pinAlloc[by], bi);
}

bool PinManagerClass::isPinOk(byte gpio, bool output)
{
  if (gpio <  6) return  true;
  if (gpio < 12) return false; //SPI flash pins
  
  #ifdef ESP8266
  if (gpio < 17) return true;
  #else //ESP32
  if (gpio < 34) return true;
  if (gpio < 40 && !output) return true; //34-39 input only
  #endif

  return false;
}

PinOwner PinManagerClass::getPinOwner(byte gpio) {
  if (!isPinOk(gpio, false)) return PinOwner::None;
  return ownerTag[gpio];
}

#ifdef ARDUINO_ARCH_ESP32
byte PinManagerClass::allocateLedc(byte channels)
{
  if (channels > 16 || channels == 0) return 255;
  byte ca = 0;
  for (byte i = 0; i < 16; i++) {
    byte by = i >> 3;
    byte bi = i - 8*by;
    if (bitRead(ledcAlloc[by], bi)) { //found occupied pin
      ca = 0;
    } else {
      ca++;
    }
    if (ca >= channels) { //enough free channels
      byte in = (i + 1) - ca;
      for (byte j = 0; j < ca; j++) {
        byte b = in + j;
        byte by = b >> 3;
        byte bi = b - 8*by;
        bitWrite(ledcAlloc[by], bi, true);
      }
      return in;
    }
  }
  return 255; //not enough consecutive free LEDC channels
}

void PinManagerClass::deallocateLedc(byte pos, byte channels)
{
  for (byte j = pos; j < pos + channels; j++) {
    if (j > 16) return;
    byte by = j >> 3;
    byte bi = j - 8*by;
    bitWrite(ledcAlloc[by], bi, false);
  }
}
#endif

PinManagerClass pinManager = PinManagerClass();

=== ./pin_manager.h ===

#ifndef WLED_PIN_MANAGER_H
#define WLED_PIN_MANAGER_H
/*
 * Registers pins so there is no attempt for two interfaces to use the same pin
 */
#include <Arduino.h>
#include "const.h" // for USERMOD_* values

typedef struct PinManagerPinType {
  int8_t pin;
  bool   isOutput;
} managed_pin_type;

/*
 * Allows PinManager to "lock" an allocation to a specific
 * owner, so someone else doesn't accidentally de-allocate
 * a pin it hasn't allocated.  Also enhances debugging.
 *
 * RAM Cost:
 *     17 bytes on ESP8266
 *     40 bytes on ESP32
 */
enum struct PinOwner : uint8_t {
  None          = 0,      // default == legacy == unspecified owner
  // High bit is set for all built-in pin owners
  Ethernet      = 0x81,
  BusDigital    = 0x82,
  BusDigital2   = 0x83,
  BusPwm        = 0x84,   // 'BusP' == PWM output using BusPwm
  Button        = 0x85,   // 'Butn' == button from configuration
  IR            = 0x86,   // 'IR'   == IR receiver pin from configuration
  Relay         = 0x87,   // 'Rly'  == Relay pin from configuration
  SPI_RAM       = 0x88,   // 'SpiR' == SPI RAM
  DebugOut      = 0x89,   // 'Dbg'  == debug output always IO1
  DMX           = 0x8A,   // 'DMX'  == hard-coded to IO2
  HW_I2C        = 0x8B,   // 'I2C'  == hardware I2C pins (4&5 on ESP8266, 21&22 on ESP32)
  AnalogMic     = 0x8C,   // WLEDSR
  DigitalMic    = 0x8D,   // WLEDSR
  // Use UserMod IDs from const.h here
  UM_Unspecified       = USERMOD_ID_UNSPECIFIED,        // 0x01
  UM_Example           = USERMOD_ID_EXAMPLE,            // 0x02 // Usermod "usermod_v2_example.h"
  UM_Temperature       = USERMOD_ID_TEMPERATURE,        // 0x03 // Usermod "usermod_temperature.h"
  // #define USERMOD_ID_FIXNETSERVICES                  // 0x04 // Usermod "usermod_Fix_unreachable_netservices.h" -- Does not allocate pins
  UM_PIR               = USERMOD_ID_PIRSWITCH,          // 0x05 // Usermod "usermod_PIR_sensor_switch.h"
  // #define USERMOD_ID_IMU                             // 0x06 // Usermod "usermod_mpu6050_imu.h" -- Uses "standard" HW_I2C pins
  UM_FourLineDisplay   = USERMOD_ID_FOUR_LINE_DISP,     // 0x07 // Usermod "usermod_v2_four_line_display.h -- May use "standard" HW_I2C pins
  UM_RotaryEncoderUI   = USERMOD_ID_ROTARY_ENC_UI,      // 0x08 // Usermod "usermod_v2_rotary_encoder_ui.h"
  // #define USERMOD_ID_AUTO_SAVE                       // 0x09 // Usermod "usermod_v2_auto_save.h" -- Does not allocate pins
  // #define USERMOD_ID_DHT                             // 0x0A // Usermod "usermod_dht.h" -- Statically allocates pins, not compatible with pinManager?
  // #define USERMOD_ID_MODE_SORT                       // 0x0B // Usermod "usermod_v2_mode_sort.h" -- Does not allocate pins
  // #define USERMOD_ID_VL53L0X                         // 0x0C // Usermod "usermod_vl53l0x_gestures.h" -- Uses "standard" HW_I2C pins
  UM_MultiRelay        = USERMOD_ID_MULTI_RELAY,        // 0x0D // Usermod "usermod_multi_relay.h"
  UM_AnimatedStaircase = USERMOD_ID_ANIMATED_STAIRCASE, // 0x0E // Usermod "Animated_Staircase.h"
  // #define USERMOD_ID_RTC                             // 0x0F // Usermod "usermod_rtc.h" -- Uses "standard" HW_I2C pins
  // #define USERMOD_ID_ELEKSTUBE_IPS                   // 0x10 // Usermod "usermod_elekstube_ips.h" -- Uses quite a few pins ... see Hardware.h and User_Setup.h
  // #define USERMOD_ID_SN_PHOTORESISTOR                // 0x11 // Usermod "usermod_sn_photoresistor.h" -- Uses hard-coded pin (PHOTORESISTOR_PIN == A0), but could be easily updated to use pinManager
  UM_RGBRotaryEncoder  = USERMOD_RGB_ROTARY_ENCODER,    // 0x16 // Usermod "rgb-rotary-encoder.h"
  UM_QuinLEDAnPenta    = USERMOD_ID_QUINLED_AN_PENTA,   // 0x17 // Usermod "quinled-an-penta.h"
  UM_BME280            = USERMOD_ID_BME280              // 0x18 // Usermod "usermod_bme280.h -- Uses "standard" HW_I2C pins
};
static_assert(0u == static_cast<uint8_t>(PinOwner::None), "PinOwner::None must be zero, so default array initialization works as expected");

class PinManagerClass {
  private:
  #ifdef ESP8266
  uint8_t pinAlloc[3] = {0x00, 0x00, 0x00}; //24bit, 1 bit per pin, we use first 17bits
  PinOwner ownerTag[17] = { PinOwner::None };
  #else
  uint8_t pinAlloc[5] = {0x00, 0x00, 0x00, 0x00, 0x00}; //40bit, 1 bit per pin, we use all bits
  uint8_t ledcAlloc[2] = {0x00, 0x00}; //16 LEDC channels
  PinOwner ownerTag[40] = { PinOwner::None };
  #endif
  uint8_t i2cAllocCount = 0; // allow multiple allocation of I2C bus pins but keep track of allocations

  public:
  // De-allocates a single pin
  bool deallocatePin(byte gpio, PinOwner tag);
  // De-allocates multiple pins but only if all can be deallocated (PinOwner has to be specified)
  bool deallocateMultiplePins(const uint8_t *pinArray, byte arrayElementCount, PinOwner tag);
  // Allocates a single pin, with an owner tag.
  // De-allocation requires the same owner tag (or override)
  bool allocatePin(byte gpio, bool output, PinOwner tag);
  // Allocates all the pins, or allocates none of the pins, with owner tag.
  // Provided to simplify error condition handling in clients
  // using more than one pin, such as I2C, SPI, rotary encoders,
  // ethernet, etc..
  bool allocateMultiplePins(const managed_pin_type * mptArray, byte arrayElementCount, PinOwner tag );

  #if !defined(ESP8266) // ESP8266 compiler doesn't understand deprecated attribute
  [[deprecated("Replaced by three-parameter allocatePin(gpio, output, ownerTag), for improved debugging")]]
  #endif
  inline bool allocatePin(byte gpio, bool output = true) { return allocatePin(gpio, output, PinOwner::None); }
  #if !defined(ESP8266) // ESP8266 compiler doesn't understand deprecated attribute
  [[deprecated("Replaced by two-parameter deallocatePin(gpio, ownerTag), for improved debugging")]]
  #endif
  inline void deallocatePin(byte gpio) { deallocatePin(gpio, PinOwner::None); }

  // will return true for reserved pins
  bool isPinAllocated(byte gpio, PinOwner tag = PinOwner::None);
  // will return false for reserved pins
  bool isPinOk(byte gpio, bool output = true);

  PinOwner getPinOwner(byte gpio);

  #ifdef ARDUINO_ARCH_ESP32
  byte allocateLedc(byte channels);
  void deallocateLedc(byte pos, byte channels);
  #endif
};

extern PinManagerClass pinManager;
#endif

=== ./playlist.cpp ===

#include "wled.h"

/*
 * Handles playlists, timed sequences of presets
 */

typedef struct PlaylistEntry {
  uint8_t preset; //ID of the preset to apply
  uint16_t dur;   //Duration of the entry (in tenths of seconds)
  uint16_t tr;    //Duration of the transition TO this entry (in tenths of seconds)
} ple;

byte           playlistRepeat = 1;        //how many times to repeat the playlist (0 = infinitely)
byte           playlistEndPreset = 0;     //what preset to apply after playlist end (0 = stay on last preset)
byte           playlistOptions = 0;       //bit 0: shuffle playlist after each iteration. bits 1-7 TBD

PlaylistEntry *playlistEntries = nullptr;
byte           playlistLen;               //number of playlist entries
int8_t         playlistIndex = -1;
uint16_t       playlistEntryDur = 0;      //duration of the current entry in tenths of seconds

//values we need to keep about the parent playlist while inside sub-playlist
//int8_t         parentPlaylistIndex = -1;
//byte           parentPlaylistRepeat = 0;
//byte           parentPlaylistPresetId = 0; //for re-loading


void shufflePlaylist() {
  int currentIndex = playlistLen;
  PlaylistEntry temporaryValue;

  // While there remain elements to shuffle...
  while (currentIndex--) {
    // Pick a random element...
    int randomIndex = random(0, currentIndex);
    // And swap it with the current element.
    temporaryValue = playlistEntries[currentIndex];
    playlistEntries[currentIndex] = playlistEntries[randomIndex];
    playlistEntries[randomIndex] = temporaryValue;
  }
  DEBUG_PRINTLN(F("Playlist shuffle."));
}


void unloadPlaylist() {
  if (playlistEntries != nullptr) {
    delete[] playlistEntries;
    playlistEntries = nullptr;
  }
  currentPlaylist = playlistIndex = -1;
  playlistLen = playlistEntryDur = playlistOptions = 0;
  DEBUG_PRINTLN(F("Playlist unloaded."));
}


int16_t loadPlaylist(JsonObject playlistObj, byte presetId) {
  unloadPlaylist();

  JsonArray presets = playlistObj["ps"];
  playlistLen = presets.size();
  if (playlistLen == 0) return -1;
  if (playlistLen > 100) playlistLen = 100;

  playlistEntries = new PlaylistEntry[playlistLen];
  if (playlistEntries == nullptr) return -1;

  byte it = 0;
  for (int ps : presets) {
    if (it >= playlistLen) break;
    playlistEntries[it].preset = ps;
    it++;
  }

  it = 0;
  JsonArray durations = playlistObj["dur"];
  if (durations.isNull()) {
    playlistEntries[0].dur = playlistObj["dur"] | 100; //10 seconds as fallback
    it = 1;
  } else {
    for (int dur : durations) {
      if (it >= playlistLen) break;
      playlistEntries[it].dur = (dur > 1) ? dur : 100;
      it++;
    }
  }
  for (int i = it; i < playlistLen; i++) playlistEntries[i].dur = playlistEntries[it -1].dur;

  it = 0;
  JsonArray tr = playlistObj[F("transition")];
  if (tr.isNull()) {
    playlistEntries[0].tr = playlistObj[F("transition")] | (transitionDelay / 100);
    it = 1;
  } else {
    for (int transition : tr) {
      if (it >= playlistLen) break;
      playlistEntries[it].tr = transition;
      it++;
    }
  }
  for (int i = it; i < playlistLen; i++) playlistEntries[i].tr = playlistEntries[it -1].tr;

  int rep = playlistObj[F("repeat")];
  bool shuffle = false;
  if (rep < 0) { //support negative values as infinite + shuffle
    rep = 0; shuffle = true;
  }

  playlistRepeat = rep;
  if (playlistRepeat > 0) playlistRepeat++; //add one extra repetition immediately since it will be deducted on first start
  playlistEndPreset = playlistObj["end"] | 0;
  shuffle = shuffle || playlistObj["r"];
  if (shuffle) playlistOptions += PL_OPTION_SHUFFLE;

  currentPlaylist = presetId;
  DEBUG_PRINTLN(F("Playlist loaded."));
  return currentPlaylist;
}


void handlePlaylist() {
  static unsigned long presetCycledTime = 0;
  // if fileDoc is not null JSON buffer is in use so just quit
  if (currentPlaylist < 0 || playlistEntries == nullptr || fileDoc != nullptr) return;

  if (millis() - presetCycledTime > (100*playlistEntryDur)) {
    presetCycledTime = millis();
    if (bri == 0 || nightlightActive) return;

    ++playlistIndex %= playlistLen; // -1 at 1st run (limit to playlistLen)

    // playlist roll-over
    if (!playlistIndex) {
      if (playlistRepeat == 1) { //stop if all repetitions are done
        unloadPlaylist();
        if (playlistEndPreset) applyPreset(playlistEndPreset);
        return;
      }
      if (playlistRepeat > 1) playlistRepeat--; // decrease repeat count on each index reset if not an endless playlist
      // playlistRepeat == 0: endless loop
      if (playlistOptions & PL_OPTION_SHUFFLE) shufflePlaylist(); // shuffle playlist and start over
    }

    jsonTransitionOnce = true;
    transitionDelayTemp = playlistEntries[playlistIndex].tr * 100;
    playlistEntryDur = playlistEntries[playlistIndex].dur;
    applyPreset(playlistEntries[playlistIndex].preset);
  }
}

=== ./presets.cpp ===

#include "wled.h"

/*
 * Methods to handle saving and loading presets to/from the filesystem
 */

bool applyPreset(byte index, byte callMode)
{
  if (index == 0) return false;

  const char *filename = index < 255 ? "/presets.json" : "/tmp.json";

	uint8_t core = 1;
	//crude way to determine if this was called by a network request
	#ifdef ARDUINO_ARCH_ESP32
	core = xPortGetCoreID();
	
	// begin WLEDSR specific
	//      loopTask (arduino main loop) sometimes runs on core #1
	//if ((core == 1) && (strncmp(pcTaskGetTaskName(NULL), "loopTask", 8) == 0)) {
	//	DEBUG_PRINTF("[applyPreset] called from loopTask on core %d; forcing core = 0\n", (int)core); 
	//	core = 0;
	//}
	//      async_tcp (network requests) sometimes runs on core #0
	if ((core == 0) && (strncmp(pcTaskGetTaskName(NULL), "async_tcp", 9) == 0)) {
		DEBUG_PRINTF("[applyPreset] called from async_tcp on core %d; forcing core = 1\n", (int)core); 
		core = 1;
	}
	// end WLEDSR specific
	#endif

	//only allow use of fileDoc from the core responsible for network requests
	//do not use active network request doc from preset called by main loop (playlist, schedule, ...)
  if (fileDoc && core) {
    errorFlag = readObjectFromFileUsingId(filename, index, fileDoc) ? ERR_NONE : ERR_FS_PLOAD;
    JsonObject fdo = fileDoc->as<JsonObject>();
    if (fdo["ps"] == index) fdo.remove("ps"); //remove load request for same presets to prevent recursive crash
    #ifdef WLED_DEBUG_FS
      serializeJson(*fileDoc, Serial);
    #endif
    deserializeState(fdo, callMode, index);
  } else {
    DEBUGFS_PRINTLN(F("Make read buf"));
    #ifdef WLED_USE_DYNAMIC_JSON
    DynamicJsonDocument doc(JSON_BUFFER_SIZE);
    #else
    if (!requestJSONBufferLock(9)) return false;
    #endif
    errorFlag = readObjectFromFileUsingId(filename, index, &doc) ? ERR_NONE : ERR_FS_PLOAD;
    JsonObject fdo = doc.as<JsonObject>();
    if (fdo["ps"] == index) fdo.remove("ps");
    #ifdef WLED_DEBUG_FS
      serializeJson(doc, Serial);
    #endif
    deserializeState(fdo, callMode, index);
    releaseJSONBufferLock();
  }

  if (!errorFlag) {
    if (index < 255) currentPreset = index;
    return true;
  }
  return false;
}

void savePreset(byte index, const char* pname, JsonObject saveobj)
{
  if (index == 0 || (index > 250 && index < 255)) return;
  char tmp[12];
  JsonObject sObj = saveobj;

  bool persist = (index != 255);
  const char *filename = persist ? "/presets.json" : "/tmp.json";

  if (!fileDoc) {
    DEBUGFS_PRINTLN(F("Allocating saving buffer"));
    #ifdef WLED_USE_DYNAMIC_JSON
    DynamicJsonDocument doc(JSON_BUFFER_SIZE);
    #else
    if (!requestJSONBufferLock(10)) return;
    #endif
    sObj = doc.to<JsonObject>();

    if (sObj["n"].isNull() && pname == nullptr) {
      sprintf_P(tmp, PSTR("Preset %d"), index);
      sObj["n"] = tmp;
    } else if (pname) sObj["n"] = pname;

    DEBUGFS_PRINTLN(F("Save current state"));
    serializeState(sObj, true);
    if (persist) currentPreset = index;

    writeObjectToFileUsingId(filename, index, &doc);

    releaseJSONBufferLock();
  } else { //from JSON API (fileDoc != nullptr)
    DEBUGFS_PRINTLN(F("Reuse recv buffer"));
    sObj.remove(F("psave"));
    sObj.remove(F("v"));

    if (!sObj["o"]) {
      DEBUGFS_PRINTLN(F("Save current state"));
      serializeState(sObj, true, sObj["ib"], sObj["sb"]);
      if (persist) currentPreset = index;
    }
    sObj.remove("o");
    sObj.remove("ib");
    sObj.remove("sb");
    sObj.remove(F("error"));
    sObj.remove(F("time"));

    writeObjectToFileUsingId(filename, index, fileDoc);
  }
  if (persist) presetsModifiedTime = toki.second(); //unix time
  updateFSInfo();
}

void deletePreset(byte index) {
  StaticJsonDocument<24> empty;
  writeObjectToFileUsingId("/presets.json", index, &empty);
  presetsModifiedTime = toki.second(); //unix time
  updateFSInfo();
}

=== ./set.cpp ===

#include "wled.h"

/*
 * Receives client input
 */
bool isAsterisksOnly(const char* str, byte maxLen)
{
  for (byte i = 0; i < maxLen; i++) {
    if (str[i] == 0) break;
    if (str[i] != '*') return false;
  }
  //at this point the password contains asterisks only
  return (str[0] != 0); //false on empty string
}


//called upon POST settings form submit
void handleSettingsSet(AsyncWebServerRequest *request, byte subPage)
{

  //0: menu 1: wifi 2: leds 3: ui 4: sync 5: time 6: sec 7: DMX 8: usermods 9: sound
  if (subPage <1 || subPage >10) return; //WLEDSR: 10 as update also added

  //WIFI SETTINGS
  if (subPage == 1)
  {
    strlcpy(clientSSID,request->arg(F("CS")).c_str(), 33);

    if (!isAsterisksOnly(request->arg(F("CP")).c_str(), 65)) strlcpy(clientPass, request->arg(F("CP")).c_str(), 65);

    strlcpy(cmDNS, request->arg(F("CM")).c_str(), 33);

    apBehavior = request->arg(F("AB")).toInt();
    strlcpy(apSSID, request->arg(F("AS")).c_str(), 33);
    apHide = request->hasArg(F("AH"));
    int passlen = request->arg(F("AP")).length();
    if (passlen == 0 || (passlen > 7 && !isAsterisksOnly(request->arg(F("AP")).c_str(), 65))) strlcpy(apPass, request->arg(F("AP")).c_str(), 65);
    int t = request->arg(F("AC")).toInt(); if (t > 0 && t < 14) apChannel = t;

    noWifiSleep = request->hasArg(F("WS"));

    #ifdef WLED_USE_ETHERNET
    ethernetType = request->arg(F("ETH")).toInt();
    WLED::instance().initEthernet();
    #endif

    char k[3]; k[2] = 0;
    for (int i = 0; i<4; i++)
    {
      k[1] = i+48;//ascii 0,1,2,3

      k[0] = 'I'; //static IP
      staticIP[i] = request->arg(k).toInt();

      k[0] = 'G'; //gateway
      staticGateway[i] = request->arg(k).toInt();

      k[0] = 'S'; //subnet
      staticSubnet[i] = request->arg(k).toInt();
    }
  }

  //LED SETTINGS
  if (subPage == 2)
  {
    int t = 0;

    if (rlyPin>=0 && pinManager.isPinAllocated(rlyPin, PinOwner::Relay)) {
       pinManager.deallocatePin(rlyPin, PinOwner::Relay);
    }
    if (irPin>=0 && pinManager.isPinAllocated(irPin, PinOwner::IR)) {
       pinManager.deallocatePin(irPin, PinOwner::IR);
    }
    for (uint8_t s=0; s<WLED_MAX_BUTTONS; s++) {
      if (btnPin[s]>=0 && pinManager.isPinAllocated(btnPin[s], PinOwner::Button)) {
        pinManager.deallocatePin(btnPin[s], PinOwner::Button);
      }
    }

    uint8_t colorOrder, type, skip;
    uint16_t length, start;
    uint8_t pins[5] = {255, 255, 255, 255, 255};

    autoSegments = request->hasArg(F("MS"));
    correctWB = request->hasArg(F("CCT"));
    cctFromRgb = request->hasArg(F("CR"));
    strip.cctBlending = request->arg(F("CB")).toInt();
    Bus::setCCTBlend(strip.cctBlending);
    strip.autoWhiteMode = (request->arg(F("AW")).toInt());
    Bus::setAutoWhiteMode(strip.autoWhiteMode);
    strip.setTargetFps(request->arg(F("FR")).toInt());

    bool busesChanged = false;
    for (uint8_t s = 0; s < WLED_MAX_BUSSES; s++) {
      char lp[4] = "L0"; lp[2] = 48+s; lp[3] = 0; //ascii 0-9 //strip data pin
      char lc[4] = "LC"; lc[2] = 48+s; lc[3] = 0; //strip length
      char co[4] = "CO"; co[2] = 48+s; co[3] = 0; //strip color order
      char lt[4] = "LT"; lt[2] = 48+s; lt[3] = 0; //strip type
      char ls[4] = "LS"; ls[2] = 48+s; ls[3] = 0; //strip start LED
      char cv[4] = "CV"; cv[2] = 48+s; cv[3] = 0; //strip reverse
      char sl[4] = "SL"; sl[2] = 48+s; sl[3] = 0; //skip first N LEDs
      char rf[4] = "RF"; rf[2] = 48+s; rf[3] = 0; //refresh required
      if (!request->hasArg(lp)) {
        DEBUG_PRINTLN(F("No data.")); break;
      }
      for (uint8_t i = 0; i < 5; i++) {
        lp[1] = 48+i;
        if (!request->hasArg(lp)) break;
        pins[i] = (request->arg(lp).length() > 0) ? request->arg(lp).toInt() : 255;
      }
      type = request->arg(lt).toInt();
      type |= request->hasArg(rf) << 7; // off refresh override
      skip = request->arg(sl).toInt();
      colorOrder = request->arg(co).toInt();
      start = (request->hasArg(ls)) ? request->arg(ls).toInt() : t;
      if (request->hasArg(lc) && request->arg(lc).toInt() > 0) {
        t += length = request->arg(lc).toInt();
      } else {
        break;  // no parameter
      }

      // actual finalization is done in WLED::loop() (removing old busses and adding new)
      if (busConfigs[s] != nullptr) delete busConfigs[s];
      busConfigs[s] = new BusConfig(type, pins, start, length, colorOrder, request->hasArg(cv), skip);
      busesChanged = true;
    }
    //doInitBusses = busesChanged; // we will do that below to ensure all input data is processed

    ColorOrderMap com = {};
    for (uint8_t s = 0; s < WLED_MAX_COLOR_ORDER_MAPPINGS; s++) {
      char xs[4] = "XS"; xs[2] = 48+s; xs[3] = 0; //start LED
      char xc[4] = "XC"; xc[2] = 48+s; xc[3] = 0; //strip length
      char xo[4] = "XO"; xo[2] = 48+s; xo[3] = 0; //color order
      if (request->hasArg(xs)) {
        start = request->arg(xs).toInt();
        length = request->arg(xc).toInt();
        colorOrder = request->arg(xo).toInt();
        com.add(start, length, colorOrder);
      }
    }
    busses.updateColorOrderMap(com);

    // upate other pins
    int hw_ir_pin = request->arg(F("IR")).toInt();
    if (pinManager.allocatePin(hw_ir_pin,false, PinOwner::IR)) {
      irPin = hw_ir_pin;
    } else {
      irPin = -1;
    }
    irEnabled = request->arg(F("IT")).toInt();
    irApplyToAllSelected = !request->hasArg(F("MSO"));

    int hw_rly_pin = request->arg(F("RL")).toInt();
    if (pinManager.allocatePin(hw_rly_pin,true, PinOwner::Relay)) {
      rlyPin = hw_rly_pin;
    } else {
      rlyPin = -1;
    }
    rlyMde = (bool)request->hasArg(F("RM"));

    for (uint8_t i=0; i<WLED_MAX_BUTTONS; i++) {
      char bt[4] = "BT"; bt[2] = (i<10?48:55)+i; bt[3] = 0; // button pin (use A,B,C,... if WLED_MAX_BUTTONS>10)
      char be[4] = "BE"; be[2] = (i<10?48:55)+i; be[3] = 0; // button type (use A,B,C,... if WLED_MAX_BUTTONS>10)
      int hw_btn_pin = request->arg(bt).toInt();
      if (pinManager.allocatePin(hw_btn_pin,false,PinOwner::Button)) {
        btnPin[i] = hw_btn_pin;
        pinMode(btnPin[i], INPUT_PULLUP);
        buttonType[i] = request->arg(be).toInt();
      } else {
        btnPin[i] = -1;
        buttonType[i] = BTN_TYPE_NONE;
      }
    }
    touchThreshold = request->arg(F("TT")).toInt();

    strip.ablMilliampsMax = request->arg(F("MA")).toInt();
    strip.milliampsPerLed = request->arg(F("LA")).toInt();
    briS = request->arg(F("CA")).toInt();

    turnOnAtBoot = request->hasArg(F("BO"));
    t = request->arg(F("BP")).toInt();
    if (t <= 250) bootPreset = t;
    strip.gammaCorrectBri = request->hasArg(F("GB"));
    strip.gammaCorrectCol = request->hasArg(F("GC"));

    fadeTransition = request->hasArg(F("TF"));
    t = request->arg(F("TD")).toInt();
    if (t >= 0) transitionDelay = t;
    transitionDelayDefault = t;
    strip.paletteFade = request->hasArg(F("PF"));

    nightlightTargetBri = request->arg(F("TB")).toInt();
    t = request->arg(F("TL")).toInt();
    if (t > 0) nightlightDelayMinsDefault = t;
    nightlightDelayMins = nightlightDelayMinsDefault;
    nightlightMode = request->arg(F("TW")).toInt();

    t = request->arg(F("PB")).toInt();
    if (t >= 0 && t < 4) strip.paletteBlend = t;
    t = request->arg(F("BF")).toInt();
    if (t > 0) briMultiplier = t;

    // 2D Matrix Settings - BROKEN BY MULTI-PIN
    strip.stripOrMatrixPanel = request->arg(F("SOMP")).toInt();
    strip.matrixWidth = request->arg(F("MXW")).toInt();
    strip.matrixHeight = request->arg(F("MXH")).toInt();

    strip.setStripOrPanelWidthAndHeight();

    strip.matrixPanels = request->hasArg(F("MXP"));
    strip.matrixHorizontalPanels = request->arg(F("MPH")).toInt();
    strip.matrixVerticalPanels = request->arg(F("MPV")).toInt();

    strip.panelFirstLedTopBottom = request->arg(F("PFLTB")).toInt();
    strip.panelFirstLedLeftRight = request->arg(F("PFLLR")).toInt();
    strip.panelOrientationHorVert = request->arg(F("POHV")).toInt();
    strip.panelSerpentine = request->hasArg(F("PNLS"));
    strip.panelTranspose = request->hasArg(F("PNLT"));
    doInitBusses = busesChanged;
  }

  //UI
  if (subPage == 3)
  {
    strlcpy(serverDescription, request->arg(F("DS")).c_str(), 33);
    syncToggleReceive = request->hasArg(F("ST"));
  }

  //SYNC
  if (subPage == 4)
  {
    int t = request->arg(F("UP")).toInt();
    if (t > 0) udpPort = t;
    t = request->arg(F("U2")).toInt();
    if (t > 0) udpPort2 = t;

    syncGroups = request->arg(F("GS")).toInt();
    receiveGroups = request->arg(F("GR")).toInt();

    receiveNotificationBrightness = request->hasArg(F("RB"));
    receiveNotificationColor = request->hasArg(F("RC"));
    receiveNotificationEffects = request->hasArg(F("RX"));
    receiveSegmentOptions = request->hasArg(F("SO"));
    receiveSegmentBounds = request->hasArg(F("SG"));
    receiveNotifications = (receiveNotificationBrightness || receiveNotificationColor || receiveNotificationEffects || receiveSegmentOptions);
    notifyDirectDefault = request->hasArg(F("SD"));
    notifyDirect = notifyDirectDefault;
    notifyButton = request->hasArg(F("SB"));
    notifyAlexa = request->hasArg(F("SA"));
    notifyHue = request->hasArg(F("SH"));
    notifyMacro = request->hasArg(F("SM"));
    notifyTwice = request->hasArg(F("S2"));

    nodeListEnabled = request->hasArg(F("NL"));
    if (!nodeListEnabled) Nodes.clear();
    nodeBroadcastEnabled = request->hasArg(F("NB"));

    receiveDirect = request->hasArg(F("RD"));
    useMainSegmentOnly = request->hasArg(F("MO"));
    e131SkipOutOfSequence = request->hasArg(F("ES"));
    e131Multicast = request->hasArg(F("EM"));
    t = request->arg(F("EP")).toInt();
    if (t > 0) e131Port = t;
    t = request->arg(F("EU")).toInt();
    if (t >= 0  && t <= 63999) e131Universe = t;
    t = request->arg(F("DA")).toInt();
    if (t >= 0  && t <= 510) DMXAddress = t;
    t = request->arg(F("DM")).toInt();
    if (t >= DMX_MODE_DISABLED && t <= DMX_MODE_MULTIPLE_RGBW) DMXMode = t;
    t = request->arg(F("ET")).toInt();
    if (t > 99  && t <= 65000) realtimeTimeoutMs = t;
    arlsForceMaxBri = request->hasArg(F("FB"));
    arlsDisableGammaCorrection = request->hasArg(F("RG"));
    t = request->arg(F("WO")).toInt();
    if (t >= -255  && t <= 255) arlsOffset = t;

    alexaEnabled = request->hasArg(F("AL"));
    strlcpy(alexaInvocationName, request->arg(F("AI")).c_str(), 33);

    t = request->arg(F("ASE")).toInt();
    if (t == 0) {
      // 0 == udp audio sync off
      Serial.print("Setting audio sync settings");
      audioSyncEnabled &= ~(1 << 0);
      audioSyncEnabled &= ~(1 << 1);
    }
    else if (t == 1) {
      // 1 == transmit only
      Serial.print("Setting audio sync settings");
      audioSyncEnabled |= 1 << 0;
      audioSyncEnabled &= ~(1 << 1);
    }
    else if (t == 2) {
      // 2 == receive only
      Serial.print("Setting audio sync settings");
      audioSyncEnabled &= ~(1 << 0);
      audioSyncEnabled |= 1 << 1;
    }
    Serial.print(audioSyncEnabled);
    t = request->arg(F("ASP")).toInt();
    audioSyncPort = t;

    #ifdef WLED_ENABLE_MQTT
    mqttEnabled = request->hasArg(F("MQ"));
    strlcpy(mqttServer, request->arg(F("MS")).c_str(), 33);
    t = request->arg(F("MQPORT")).toInt();
    if (t > 0) mqttPort = t;
    strlcpy(mqttUser, request->arg(F("MQUSER")).c_str(), 41);
    if (!isAsterisksOnly(request->arg(F("MQPASS")).c_str(), 41)) strlcpy(mqttPass, request->arg(F("MQPASS")).c_str(), 65);
    strlcpy(mqttClientID, request->arg(F("MQCID")).c_str(), 41);
    strlcpy(mqttDeviceTopic, request->arg(F("MD")).c_str(), 33);
    strlcpy(mqttGroupTopic, request->arg(F("MG")).c_str(), 33);
    buttonPublishMqtt = request->hasArg(F("BM"));
    #endif

    #ifndef WLED_DISABLE_HUESYNC
    for (int i=0;i<4;i++){
      String a = "H"+String(i);
      hueIP[i] = request->arg(a).toInt();
    }

    t = request->arg(F("HL")).toInt();
    if (t > 0) huePollLightId = t;

    t = request->arg(F("HI")).toInt();
    if (t > 50) huePollIntervalMs = t;

    hueApplyOnOff = request->hasArg(F("HO"));
    hueApplyBri = request->hasArg(F("HB"));
    hueApplyColor = request->hasArg(F("HC"));
    huePollingEnabled = request->hasArg(F("HP"));
    hueStoreAllowed = true;
    reconnectHue();
    #endif

    t = request->arg(F("BD")).toInt();
    if (t >= 96 && t <= 15000) serialBaud = t;
    updateBaudRate(serialBaud *100);
  }

  //TIME
  if (subPage == 5)
  {
    ntpEnabled = request->hasArg(F("NT"));
    strlcpy(ntpServerName, request->arg(F("NS")).c_str(), 33);
    useAMPM = !request->hasArg(F("CF"));
    currentTimezone = request->arg(F("TZ")).toInt();
    utcOffsetSecs = request->arg(F("UO")).toInt();

    //start ntp if not already connected
    if (ntpEnabled && WLED_CONNECTED && !ntpConnected) ntpConnected = ntpUdp.begin(ntpLocalPort);
    ntpLastSyncTime = 0; // force new NTP query

    longitude = request->arg(F("LN")).toFloat();
    latitude = request->arg(F("LT")).toFloat();
    // force a sunrise/sunset re-calculation
    calculateSunriseAndSunset();

    overlayCurrent = request->hasArg(F("OL")) ? 1 : 0;

    overlayMin = request->arg(F("O1")).toInt();
    overlayMax = request->arg(F("O2")).toInt();
    analogClock12pixel = request->arg(F("OM")).toInt();
    analogClock5MinuteMarks = request->hasArg(F("O5"));
    analogClockSecondsTrail = request->hasArg(F("OS"));

    countdownMode = request->hasArg(F("CE"));
    countdownYear = request->arg(F("CY")).toInt();
    countdownMonth = request->arg(F("CI")).toInt();
    countdownDay = request->arg(F("CD")).toInt();
    countdownHour = request->arg(F("CH")).toInt();
    countdownMin = request->arg(F("CM")).toInt();
    countdownSec = request->arg(F("CS")).toInt();
    setCountdown();

    macroAlexaOn = request->arg(F("A0")).toInt();
    macroAlexaOff = request->arg(F("A1")).toInt();
    macroCountdown = request->arg(F("MC")).toInt();
    macroNl = request->arg(F("MN")).toInt();
    for (uint8_t i=0; i<WLED_MAX_BUTTONS; i++) {
      char mp[4] = "MP"; mp[2] = (i<10?48:55)+i; mp[3] = 0; // short
      char ml[4] = "ML"; ml[2] = (i<10?48:55)+i; ml[3] = 0; // long
      char md[4] = "MD"; md[2] = (i<10?48:55)+i; md[3] = 0; // double
      //if (!request->hasArg(mp)) break;
      macroButton[i] = request->arg(mp).toInt();      // these will default to 0 if not present
      macroLongPress[i] = request->arg(ml).toInt();
      macroDoublePress[i] = request->arg(md).toInt();
    }

    char k[3]; k[2] = 0;
    for (int i = 0; i<10; i++) {
      k[1] = i+48;//ascii 0,1,2,3,...
      k[0] = 'H'; //timer hours
      timerHours[i] = request->arg(k).toInt();
      k[0] = 'N'; //minutes
      timerMinutes[i] = request->arg(k).toInt();
      k[0] = 'T'; //macros
      timerMacro[i] = request->arg(k).toInt();
      k[0] = 'W'; //weekdays
      timerWeekday[i] = request->arg(k).toInt();
      if (i<8) {
				k[0] = 'M'; //start month
				timerMonth[i] = request->arg(k).toInt() & 0x0F;
				timerMonth[i] <<= 4;
				k[0] = 'P'; //end month
				timerMonth[i] += (request->arg(k).toInt() & 0x0F);
				k[0] = 'D'; //start day
				timerDay[i] = request->arg(k).toInt();
				k[0] = 'E'; //end day
				timerDayEnd[i] = request->arg(k).toInt();
      }
    }
  }

  //SECURITY
  if (subPage == 6)
  {
    if (request->hasArg(F("RS"))) //complete factory reset
    {
      WLED_FS.format();
      clearEEPROM();
      serveMessage(request, 200, F("All Settings erased."), F("Connect to WLED-AP to setup again"),255);
      doReboot = true;
    }

    bool pwdCorrect = !otaLock; //always allow access if ota not locked
    if (request->hasArg(F("OP")))
    {
      if (otaLock && strcmp(otaPass,request->arg(F("OP")).c_str()) == 0)
      {
        pwdCorrect = true;
      }
      if (!otaLock && request->arg(F("OP")).length() > 0)
      {
        strlcpy(otaPass,request->arg(F("OP")).c_str(), 33);
      }
    }

    if (pwdCorrect) //allow changes if correct pwd or no ota active
    {
      otaLock = request->hasArg(F("NO"));
      wifiLock = request->hasArg(F("OW"));
      aOtaEnabled = request->hasArg(F("AO"));
    }
  }
  #ifdef WLED_ENABLE_DMX // include only if DMX is enabled
  if (subPage == 7)
  {
    int t = request->arg(F("PU")).toInt();
    if (t >= 0  && t <= 63999) e131ProxyUniverse = t;

    t = request->arg(F("CN")).toInt();
    if (t>0 && t<16) {
      DMXChannels = t;
    }
    t = request->arg(F("CS")).toInt();
    if (t>0 && t<513) {
      DMXStart = t;
    }
    t = request->arg(F("CG")).toInt();
    if (t>0 && t<513) {
      DMXGap = t;
    }
    t = request->arg(F("SL")).toInt();
    if (t>=0 && t < MAX_LEDS) {
      DMXStartLED = t;
    }
    for (int i=0; i<15; i++) {
      String argname = "CH" + String((i+1));
      t = request->arg(argname).toInt();
      DMXFixtureMap[i] = t;
    }
  }
  #endif

  //USERMODS
  if (subPage == 8)
  {
    #ifdef WLED_USE_DYNAMIC_JSON
    DynamicJsonDocument doc(JSON_BUFFER_SIZE);
    #else
    if (!requestJSONBufferLock(5)) return;
    #endif

    JsonObject um = doc.createNestedObject("um");

    size_t args = request->args();
    uint16_t j=0;
    for (size_t i=0; i<args; i++) {
      String name = request->argName(i);
      String value = request->arg(i);

      // POST request parameters are combined as <usermodname>_<usermodparameter>
      int umNameEnd = name.indexOf(":");
      if (umNameEnd<1) break;  // parameter does not contain ":" or on 1st place -> wrong

      JsonObject mod = um[name.substring(0,umNameEnd)]; // get a usermod JSON object
      if (mod.isNull()) {
        mod = um.createNestedObject(name.substring(0,umNameEnd)); // if it does not exist create it
      }
      DEBUG_PRINT(name.substring(0,umNameEnd));
      DEBUG_PRINT(":");
      name = name.substring(umNameEnd+1); // remove mod name from string

      // if the resulting name still contains ":" this means nested object
      JsonObject subObj;
      int umSubObj = name.indexOf(":");
      DEBUG_PRINTF("(%d):",umSubObj);
      if (umSubObj>0) {
        subObj = mod[name.substring(0,umSubObj)];
        if (subObj.isNull())
          subObj = mod.createNestedObject(name.substring(0,umSubObj));
        name = name.substring(umSubObj+1); // remove nested object name from string
      } else {
        subObj = mod;
      }
      DEBUG_PRINT(name);

      // check if parameters represent array
      if (name.endsWith("[]")) {
        name.replace("[]","");
        value.replace(",",".");      // just in case conversion
        if (!subObj[name].is<JsonArray>()) {
          JsonArray ar = subObj.createNestedArray(name);
          if (value.indexOf(".") >= 0) ar.add(value.toFloat());  // we do have a float
          else                         ar.add(value.toInt());    // we may have an int
          j=0;
        } else {
          if (value.indexOf(".") >= 0) subObj[name].add(value.toFloat());  // we do have a float
          else                         subObj[name].add(value.toInt());    // we may have an int
          j++;
        }
        DEBUG_PRINT("[");
        DEBUG_PRINT(j);
        DEBUG_PRINT("] = ");
        DEBUG_PRINTLN(value);
      } else {
        // we are using a hidden field with the same name as our parameter (!before the actual parameter!)
        // to describe the type of parameter (text,float,int), for boolean patameters the first field contains "off"
        // so checkboxes have one or two fields (first is always "false", existence of second depends on checkmark and may be "true")
        if (subObj[name].isNull()) {
          // the first occurence of the field describes the parameter type (used in next loop)
          if (value == "false") subObj[name] = false; // checkboxes may have only one field
          else                  subObj[name] = value;
        } else {
          String type = subObj[name].as<String>();  // get previously stored value as a type
          if (subObj[name].is<bool>())   subObj[name] = true;   // checkbox/boolean
          else if (type == "number") {
            value.replace(",",".");      // just in case conversion
            if (value.indexOf(".") >= 0) subObj[name] = value.toFloat();  // we do have a float
            else                         subObj[name] = value.toInt();    // we may have an int
          } else if (type == "int")      subObj[name] = value.toInt();
          else                           subObj[name] = value;  // text fields
        }
        DEBUG_PRINT(" = ");
        DEBUG_PRINTLN(value);
      }
    }
    usermods.readFromConfig(um);  // force change of usermod parameters

    releaseJSONBufferLock();
  }

  //SOUND SETTINGS
  if (subPage == 9)
  {

    if (audioPin>=0 && pinManager.isPinAllocated(audioPin, PinOwner::AnalogMic)) pinManager.deallocatePin(audioPin, PinOwner::AnalogMic);
    if (i2ssdPin>=0 && pinManager.isPinAllocated(i2ssdPin, PinOwner::DigitalMic)) pinManager.deallocatePin(i2ssdPin, PinOwner::DigitalMic);
    if (i2swsPin>=0 && pinManager.isPinAllocated(i2swsPin, PinOwner::DigitalMic)) pinManager.deallocatePin(i2swsPin, PinOwner::DigitalMic);
    if (i2sckPin>=0 && pinManager.isPinAllocated(i2sckPin, PinOwner::DigitalMic)) pinManager.deallocatePin(i2sckPin, PinOwner::DigitalMic);
    if (mclkPin>=0 && pinManager.isPinAllocated(mclkPin, PinOwner::DigitalMic)) pinManager.deallocatePin(mclkPin, PinOwner::DigitalMic);

    int t = 0;
    t = request->arg(F("SQ")).toInt();
    if (t >= 0) soundSquelch = t;

    t = request->arg(F("GN")).toInt();
    if (t >= 0) sampleGain = t;

    t = request->arg(F("AGC")).toInt();
    if (t >=0) soundAgc = t;


    t = request->arg(F("SI")).toInt();
    if (t >= 0 && t <=39) audioPin = t;

    // Digital Mic I2S SD pin
    t = request->arg(F("DI")).toInt();
    if (t >= 0 && t <=39) i2ssdPin = t;

    // Digital Mic I2S WS pin
    t = request->arg(F("LR")).toInt();
    if (t >= 0 && t <=39) i2swsPin = t;

    // Digital Mic I2S SCK pin
    t = request->arg(F("CK")).toInt();
    if (t >= -1 && t <=39) i2sckPin = t;

    // Digital Mic I2S MCLK pin
    t = request->arg(F("MCLK")).toInt();
    if (t >= -1 && t <=3 && t!=2) mclkPin = t;

    // Digital mic mode
    uint8_t newDmType = request->arg(F("DMM")).toInt();
    // If the mic type was changed, tell the user to reset the board!
    if (dmType != newDmType) {
      serveMessage(request, 200,F("Settings saved..."),F("Please reset the board for changes to take effect!"), 10);
      dmType = newDmType;
    }
  }

  if (subPage != 2 && (subPage != 6 || !doReboot)) serializeConfig(); //do not save if factory reset or LED settings (which are saved after LED re-init)
  if (subPage == 4) alexaInit();
}



//helper to get int value at a position in string
int getNumVal(const String* req, uint16_t pos)
{
  return req->substring(pos+3).toInt();
}


//helper to get int value with in/decrementing support via ~ syntax
void parseNumber(const char* str, byte* val, byte minv, byte maxv)
{
  if (str == nullptr || str[0] == '\0') return;
  if (str[0] == 'r') {*val = random8(minv,maxv); return;}
  bool wrap = false;
  if (str[0] == 'w' && strlen(str) > 1) {str++; wrap = true;}
  if (str[0] == '~') {
    int out = atoi(str +1);
    if (out == 0)
    {
      if (str[1] == '0') return;
      if (str[1] == '-')
      {
        *val = (int)(*val -1) < (int)minv ? maxv : min((int)maxv,(*val -1)); //-1, wrap around
      } else {
        *val = (int)(*val +1) > (int)maxv ? minv : max((int)minv,(*val +1)); //+1, wrap around
      }
    } else {
      if (wrap && *val == maxv && out > 0) out = minv;
      else if (wrap && *val == minv && out < 0) out = maxv;
      else {
        out += *val;
        if (out > maxv) out = maxv;
        if (out < minv) out = minv;
      }
      *val = out;
    }
  } else
  {
    byte p1 = atoi(str);
    const char* str2 = strchr(str,'~'); //min/max range (for preset cycle, e.g. "1~5~")
    if (str2) {
      byte p2 = atoi(str2+1);
      presetCycMin = p1; presetCycMax = p2;
      while (isdigit((str2+1)[0])) str2++;
      parseNumber(str2+1, val, p1, p2);
    } else {
      *val = p1;
    }
  }
}


bool updateVal(const String* req, const char* key, byte* val, byte minv, byte maxv)
{
  int pos = req->indexOf(key);
  if (pos < 1) return false;
  if (req->length() < (unsigned int)(pos + 4)) return false;
  parseNumber(req->c_str() + pos +3, val, minv, maxv);
  return true;
}


//HTTP API request parser
bool handleSet(AsyncWebServerRequest *request, const String& req, bool apply)
{
  if (!(req.indexOf("win") >= 0)) return false;

  int pos = 0;
  DEBUG_PRINT(F("API req: "));
  DEBUG_PRINTLN(req);

  //segment select (sets main segment)
  pos = req.indexOf(F("SM="));
  if (pos > 0) {
    strip.setMainSegmentId(getNumVal(&req, pos));
  }

  byte selectedSeg = strip.getFirstSelectedSegId();

  bool singleSegment = false;

  pos = req.indexOf(F("SS="));
  if (pos > 0) {
    byte t = getNumVal(&req, pos);
    if (t < strip.getMaxSegments()) {
      selectedSeg = t;
      singleSegment = true;
    }
  }

  WS2812FX::Segment& selseg = strip.getSegment(selectedSeg);
  pos = req.indexOf(F("SV=")); //segment selected
  if (pos > 0) {
    byte t = getNumVal(&req, pos);
    if (t == 2) for (uint8_t i = 0; i < strip.getMaxSegments(); i++) strip.getSegment(i).setOption(SEG_OPTION_SELECTED, 0); // unselect other segments
    selseg.setOption(SEG_OPTION_SELECTED, t);
  }

  // temporary values, write directly to segments, globals are updated by setValuesFromFirstSelectedSeg()
  uint32_t col0 = selseg.colors[0];
  uint32_t col1 = selseg.colors[1];
  byte colIn[4]    = {R(col0), G(col0), B(col0), W(col0)};
  byte colInSec[4] = {R(col1), G(col1), B(col1), W(col1)};
  byte effectIn    = selseg.mode;
  byte speedIn     = selseg.speed;
  byte intensityIn = selseg.intensity;
  byte custom1In   = selseg.custom1; //WLEDSR
  byte custom2In   = selseg.custom2; //WLEDSR
  byte custom3In   = selseg.custom3; //WLEDSR
  byte paletteIn   = selseg.palette;

  uint16_t startI = selseg.start;
  uint16_t stopI  = selseg.stop;
  uint8_t  grpI   = selseg.grouping;
  uint16_t spcI   = selseg.spacing;
  pos = req.indexOf(F("&S=")); //segment start
  if (pos > 0) {
    startI = getNumVal(&req, pos);
  }
  pos = req.indexOf(F("S2=")); //segment stop
  if (pos > 0) {
    stopI = getNumVal(&req, pos);
  }
  pos = req.indexOf(F("GP=")); //segment grouping
  if (pos > 0) {
    grpI = getNumVal(&req, pos);
    if (grpI == 0) grpI = 1;
  }
  pos = req.indexOf(F("SP=")); //segment spacing
  if (pos > 0) {
    spcI = getNumVal(&req, pos);
  }
  strip.setSegment(selectedSeg, startI, stopI, grpI, spcI);

  pos = req.indexOf(F("RV=")); //Segment reverse
  if (pos > 0) selseg.setOption(SEG_OPTION_REVERSED, req.charAt(pos+3) != '0');

  pos = req.indexOf(F("MI=")); //Segment mirror
  if (pos > 0) selseg.setOption(SEG_OPTION_MIRROR, req.charAt(pos+3) != '0');

  pos = req.indexOf(F("SB=")); //Segment brightness/opacity
  if (pos > 0) {
    byte segbri = getNumVal(&req, pos);
    selseg.setOption(SEG_OPTION_ON, segbri, selectedSeg);
    if (segbri) {
      selseg.setOpacity(segbri, selectedSeg);
    }
  }

  pos = req.indexOf(F("SW=")); //segment power
  if (pos > 0) {
    switch (getNumVal(&req, pos)) {
      case 0: selseg.setOption(SEG_OPTION_ON, false); break;
      case 1: selseg.setOption(SEG_OPTION_ON, true); break;
      default: selseg.setOption(SEG_OPTION_ON, !selseg.getOption(SEG_OPTION_ON)); break;
    }
  }

  pos = req.indexOf(F("PS=")); //saves current in preset
  if (pos > 0) savePreset(getNumVal(&req, pos));

  pos = req.indexOf(F("P1=")); //sets first preset for cycle
  if (pos > 0) presetCycMin = getNumVal(&req, pos);

  pos = req.indexOf(F("P2=")); //sets last preset for cycle
  if (pos > 0) presetCycMax = getNumVal(&req, pos);

  //apply preset
  if (updateVal(&req, "PL=", &presetCycCurr, presetCycMin, presetCycMax)) {
		unloadPlaylist();
    applyPreset(presetCycCurr);
  }

  //set brightness
  updateVal(&req, "&A=", &bri);

  bool col0Changed = false, col1Changed = false;
  //set colors
  col0Changed |= updateVal(&req, "&R=", &colIn[0]);
  col0Changed |= updateVal(&req, "&G=", &colIn[1]);
  col0Changed |= updateVal(&req, "&B=", &colIn[2]);
  col0Changed |= updateVal(&req, "&W=", &colIn[3]);

  col1Changed |= updateVal(&req, "R2=", &colInSec[0]);
  col1Changed |= updateVal(&req, "G2=", &colInSec[1]);
  col1Changed |= updateVal(&req, "B2=", &colInSec[2]);
  col1Changed |= updateVal(&req, "W2=", &colInSec[3]);

  #ifdef WLED_ENABLE_LOXONE
  //lox parser
  pos = req.indexOf(F("LX=")); // Lox primary color
  if (pos > 0) {
    int lxValue = getNumVal(&req, pos);
    if (parseLx(lxValue, colIn)) {
      bri = 255;
      nightlightActive = false; //always disable nightlight when toggling
      col0Changed = true;
    }
  }
  pos = req.indexOf(F("LY=")); // Lox secondary color
  if (pos > 0) {
    int lxValue = getNumVal(&req, pos);
    if(parseLx(lxValue, colInSec)) {
      bri = 255;
      nightlightActive = false; //always disable nightlight when toggling
      col1Changed = true;
    }
  }
  #endif

  //set hue
  pos = req.indexOf(F("HU="));
  if (pos > 0) {
    uint16_t temphue = getNumVal(&req, pos);
    byte tempsat = 255;
    pos = req.indexOf(F("SA="));
    if (pos > 0) {
      tempsat = getNumVal(&req, pos);
    }
    byte sec = req.indexOf(F("H2"));
    colorHStoRGB(temphue, tempsat, (sec>0) ? colInSec : colIn);
    col0Changed |= (!sec); col1Changed |= sec;
  }

  //set white spectrum (kelvin)
  pos = req.indexOf(F("&K="));
  if (pos > 0) {
    byte sec = req.indexOf(F("K2"));
    colorKtoRGB(getNumVal(&req, pos), (sec>0) ? colInSec : colIn);
    col0Changed |= (!sec); col1Changed |= sec;
  }

  //set color from HEX or 32bit DEC
  byte tmpCol[4];
  pos = req.indexOf(F("CL="));
  if (pos > 0) {
    colorFromDecOrHexString(colIn, (char*)req.substring(pos + 3).c_str());
    col0Changed = true;
  }
  pos = req.indexOf(F("C2="));
  if (pos > 0) {
    colorFromDecOrHexString(colInSec, (char*)req.substring(pos + 3).c_str());
    col1Changed = true;
  }
  pos = req.indexOf(F("C3="));
  if (pos > 0) {
    colorFromDecOrHexString(tmpCol, (char*)req.substring(pos + 3).c_str());
    uint32_t col2 = RGBW32(tmpCol[0], tmpCol[1], tmpCol[2], tmpCol[3]);
    selseg.setColor(2, col2, selectedSeg); // defined above (SS= or main)
    stateChanged = true;
    if (!singleSegment) strip.setColor(2, col2);
  }

  //set to random hue SR=0->1st SR=1->2nd
  pos = req.indexOf(F("SR"));
  if (pos > 0) {
    byte sec = getNumVal(&req, pos);
    setRandomColor(sec? colInSec : colIn);
    col0Changed |= (!sec); col1Changed |= sec;
  }

  //swap 2nd & 1st
  pos = req.indexOf(F("SC"));
  if (pos > 0) {
    byte temp;
    for (uint8_t i=0; i<4; i++) {
      temp        = colIn[i];
      colIn[i]    = colInSec[i];
      colInSec[i] = temp;
    }
    col0Changed = col1Changed = true;
  }

  // apply colors to selected segment, and all selected segments if applicable
  if (col0Changed) {
    stateChanged = true;
    uint32_t colIn0 = RGBW32(colIn[0], colIn[1], colIn[2], colIn[3]);
    selseg.setColor(0, colIn0, selectedSeg);
    if (!singleSegment) strip.setColor(0, colIn0);
  }

  if (col1Changed) {
    stateChanged = true;
    uint32_t colIn1 = RGBW32(colInSec[0], colInSec[1], colInSec[2], colInSec[3]);
    selseg.setColor(1, colIn1, selectedSeg);
    if (!singleSegment) strip.setColor(1, colIn1);
  }

  bool fxModeChanged = false, speedChanged = false, intensityChanged = false, paletteChanged = false;
  bool custom1Changed = false, custom2Changed = false, custom3Changed = false;  // WLEDSR
  // set effect parameters
  if (updateVal(&req, "FX=", &effectIn, 0, strip.getModeCount()-1)) {
    if (request != nullptr) unloadPlaylist(); // unload playlist if changing FX using web request
    fxModeChanged = true;
  }
  speedChanged     = updateVal(&req, "SX=", &speedIn);
  intensityChanged = updateVal(&req, "IX=", &intensityIn);
  custom1Changed   = updateVal(&req, "C1=", &custom1In);  // WLEDSR
  custom2Changed   = updateVal(&req, "C2=", &custom2In);  // WLEDSR
  custom3Changed   = updateVal(&req, "C3=", &custom3In);  // WLEDSR
  paletteChanged   = updateVal(&req, "FP=", &paletteIn, 0, strip.getPaletteCount()-1);

  stateChanged |= (fxModeChanged || speedChanged || intensityChanged || custom1Changed || custom2Changed || custom3Changed || paletteChanged); // WLEDSR

  // apply to main and all selected segments to prevent #1618.
  for (uint8_t i = 0; i < strip.getMaxSegments(); i++) {
    WS2812FX::Segment& seg = strip.getSegment(i);
    if (i != selectedSeg && (singleSegment || !seg.isActive() || !seg.isSelected())) continue; // skip non main segments if not applying to all
    if (fxModeChanged)    strip.setMode(i, effectIn);
    if (speedChanged)     seg.speed     = speedIn;
    if (intensityChanged) seg.intensity = intensityIn;
    if (custom1Changed)   seg.custom1   = custom1In;  // WLEDSR
    if (custom2Changed)   seg.custom2   = custom2In;  // WLEDSR
    if (custom3Changed)   seg.custom3   = custom3In;  // WLEDSR
    if (paletteChanged)   seg.palette   = paletteIn;
  }

  //set advanced overlay
  pos = req.indexOf(F("OL="));
  if (pos > 0) {
    overlayCurrent = getNumVal(&req, pos);
  }

  //apply macro (deprecated, added for compatibility with pre-0.11 automations)
  pos = req.indexOf(F("&M="));
  if (pos > 0) {
    applyPreset(getNumVal(&req, pos) + 16);
  }

  //toggle send UDP direct notifications
  pos = req.indexOf(F("SN="));
  if (pos > 0) notifyDirect = (req.charAt(pos+3) != '0');

  //toggle receive UDP direct notifications
  pos = req.indexOf(F("RN="));
  if (pos > 0) receiveNotifications = (req.charAt(pos+3) != '0');

  //receive live data via UDP/Hyperion
  pos = req.indexOf(F("RD="));
  if (pos > 0) receiveDirect = (req.charAt(pos+3) != '0');

  //main toggle on/off (parse before nightlight, #1214)
  pos = req.indexOf(F("&T="));
  if (pos > 0) {
    nightlightActive = false; //always disable nightlight when toggling
    switch (getNumVal(&req, pos))
    {
      case 0: if (bri != 0){briLast = bri; bri = 0;} break; //off, only if it was previously on
      case 1: if (bri == 0) bri = briLast; break; //on, only if it was previously off
      default: toggleOnOff(); //toggle
    }
  }

  //toggle nightlight mode
  bool aNlDef = false;
  if (req.indexOf(F("&ND")) > 0) aNlDef = true;
  pos = req.indexOf(F("NL="));
  if (pos > 0)
  {
    if (req.charAt(pos+3) == '0')
    {
      nightlightActive = false;
    } else {
      nightlightActive = true;
      if (!aNlDef) nightlightDelayMins = getNumVal(&req, pos);
      nightlightStartTime = millis();
    }
  } else if (aNlDef)
  {
    nightlightActive = true;
    nightlightStartTime = millis();
  }

  //set nightlight target brightness
  pos = req.indexOf(F("NT="));
  if (pos > 0) {
    nightlightTargetBri = getNumVal(&req, pos);
    nightlightActiveOld = false; //re-init
  }

  //toggle nightlight fade
  pos = req.indexOf(F("NF="));
  if (pos > 0)
  {
    nightlightMode = getNumVal(&req, pos);

    nightlightActiveOld = false; //re-init
  }
  if (nightlightMode > NL_MODE_SUN) nightlightMode = NL_MODE_SUN;

  pos = req.indexOf(F("TT="));
  if (pos > 0) transitionDelay = getNumVal(&req, pos);

  //Segment reverse
  pos = req.indexOf(F("RV="));
  if (pos > 0) strip.getSegment(selectedSeg).setOption(SEG_OPTION_REVERSED, req.charAt(pos+3) != '0');

  pos = req.indexOf(F("RY="));
  if (pos > 0) strip.getSegment(selectedSeg).setOption(SEG_OPTION_REVERSED2D, req.charAt(pos+3) != '0');

  //Segment mirror
  pos = req.indexOf(F("MI="));
  if (pos > 0) strip.getSegment(selectedSeg).setOption(SEG_OPTION_MIRROR, req.charAt(pos+3) != '0');

  //Segment rotation
  pos = req.indexOf(F("ROT="));
  if (pos > 0) strip.getSegment(selectedSeg).setOption(SEG_OPTION_ROTATED2D, req.charAt(pos+3) != '0');

  //Segment brightness/opacity
  pos = req.indexOf(F("SB="));
  if (pos > 0) {
    byte segbri = getNumVal(&req, pos);
    strip.getSegment(selectedSeg).setOption(SEG_OPTION_ON, segbri, selectedSeg);
    if (segbri) {
      strip.getSegment(selectedSeg).setOpacity(segbri, selectedSeg);
    }
  }

  //set time (unix timestamp)
  pos = req.indexOf(F("ST="));
  if (pos > 0) {
    setTimeFromAPI(getNumVal(&req, pos));
  }

  //set countdown goal (unix timestamp)
  pos = req.indexOf(F("CT="));
  if (pos > 0) {
    countdownTime = getNumVal(&req, pos);
    if (countdownTime - toki.second() > 0) countdownOverTriggered = false;
  }

  pos = req.indexOf(F("LO="));
  if (pos > 0) {
    realtimeOverride = getNumVal(&req, pos);
    if (realtimeOverride > 2) realtimeOverride = REALTIME_OVERRIDE_ALWAYS;
    if (realtimeMode && useMainSegmentOnly) {
      strip.getMainSegment().setOption(SEG_OPTION_FREEZE, !realtimeOverride, strip.getMainSegmentId());
    }
  }

  pos = req.indexOf(F("RB"));
  if (pos > 0) doReboot = true;

  // clock mode, 0: normal, 1: countdown
  pos = req.indexOf(F("NM="));
  if (pos > 0) countdownMode = (req.charAt(pos+3) != '0');

  pos = req.indexOf(F("U0=")); //user var 0
  if (pos > 0) {
    userVar0 = getNumVal(&req, pos);
  }

  pos = req.indexOf(F("U1=")); //user var 1
  if (pos > 0) {
    userVar1 = getNumVal(&req, pos);
  }
  // you can add more if you need

  // global col[], effectCurrent, ... are updated in stateChanged()
  if (!apply) return true; // when called by JSON API, do not call colorUpdated() here

  pos = req.indexOf(F("&NN")); //do not send UDP notifications this time
  stateUpdated((pos > 0) ? CALL_MODE_NO_NOTIFY : CALL_MODE_DIRECT_CHANGE);

  // internal call, does not send XML response
  pos = req.indexOf(F("IN"));
  if (pos < 1) XML_response(request);

  return true;
}

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient.cpp ===

#include "AsyncMqttClient.hpp"

AsyncMqttClient::AsyncMqttClient()
: _connected(false)
, _connectPacketNotEnoughSpace(false)
, _disconnectFlagged(false)
, _tlsBadFingerprint(false)
, _lastClientActivity(0)
, _lastServerActivity(0)
, _lastPingRequestTime(0)
, _host(nullptr)
, _useIp(false)
#if ASYNC_TCP_SSL_ENABLED
, _secure(false)
#endif
, _port(0)
, _keepAlive(15)
, _cleanSession(true)
, _clientId(nullptr)
, _username(nullptr)
, _password(nullptr)
, _willTopic(nullptr)
, _willPayload(nullptr)
, _willPayloadLength(0)
, _willQos(0)
, _willRetain(false)
, _parsingInformation { .bufferState = AsyncMqttClientInternals::BufferState::NONE }
, _currentParsedPacket(nullptr)
, _remainingLengthBufferPosition(0)
, _nextPacketId(1) {
  _client.onConnect([](void* obj, AsyncClient* c) { (static_cast<AsyncMqttClient*>(obj))->_onConnect(c); }, this);
  _client.onDisconnect([](void* obj, AsyncClient* c) { (static_cast<AsyncMqttClient*>(obj))->_onDisconnect(c); }, this);
  _client.onError([](void* obj, AsyncClient* c, int8_t error) { (static_cast<AsyncMqttClient*>(obj))->_onError(c, error); }, this);
  _client.onTimeout([](void* obj, AsyncClient* c, uint32_t time) { (static_cast<AsyncMqttClient*>(obj))->_onTimeout(c, time); }, this);
  _client.onAck([](void* obj, AsyncClient* c, size_t len, uint32_t time) { (static_cast<AsyncMqttClient*>(obj))->_onAck(c, len, time); }, this);
  _client.onData([](void* obj, AsyncClient* c, void* data, size_t len) { (static_cast<AsyncMqttClient*>(obj))->_onData(c, static_cast<char*>(data), len); }, this);
  _client.onPoll([](void* obj, AsyncClient* c) { (static_cast<AsyncMqttClient*>(obj))->_onPoll(c); }, this);

#ifdef ESP32
  sprintf(_generatedClientId, "esp32%06x", (uint32_t)ESP.getEfuseMac());
  _xSemaphore = xSemaphoreCreateMutex();
#elif defined(ESP8266)
  sprintf(_generatedClientId, "esp8266%06x", (uint32_t)ESP.getChipId());
#endif
  _clientId = _generatedClientId;

  setMaxTopicLength(128);
}

AsyncMqttClient::~AsyncMqttClient() {
  delete _currentParsedPacket;
  delete[] _parsingInformation.topicBuffer;
#ifdef ESP32
  vSemaphoreDelete(_xSemaphore);
#endif
}

AsyncMqttClient& AsyncMqttClient::setKeepAlive(uint16_t keepAlive) {
  _keepAlive = keepAlive;
  return *this;
}

AsyncMqttClient& AsyncMqttClient::setClientId(const char* clientId) {
  _clientId = clientId;
  return *this;
}

AsyncMqttClient& AsyncMqttClient::setCleanSession(bool cleanSession) {
  _cleanSession = cleanSession;
  return *this;
}

AsyncMqttClient& AsyncMqttClient::setMaxTopicLength(uint16_t maxTopicLength) {
  _parsingInformation.maxTopicLength = maxTopicLength;
  delete[] _parsingInformation.topicBuffer;
  _parsingInformation.topicBuffer = new char[maxTopicLength + 1];
  return *this;
}

AsyncMqttClient& AsyncMqttClient::setCredentials(const char* username, const char* password) {
  _username = username;
  _password = password;
  return *this;
}

AsyncMqttClient& AsyncMqttClient::setWill(const char* topic, uint8_t qos, bool retain, const char* payload, size_t length) {
  _willTopic = topic;
  _willQos = qos;
  _willRetain = retain;
  _willPayload = payload;
  _willPayloadLength = length;
  return *this;
}

AsyncMqttClient& AsyncMqttClient::setServer(IPAddress ip, uint16_t port) {
  _useIp = true;
  _ip = ip;
  _port = port;
  return *this;
}

AsyncMqttClient& AsyncMqttClient::setServer(const char* host, uint16_t port) {
  _useIp = false;
  _host = host;
  _port = port;
  return *this;
}

#if ASYNC_TCP_SSL_ENABLED
AsyncMqttClient& AsyncMqttClient::setSecure(bool secure) {
  _secure = secure;
  return *this;
}

AsyncMqttClient& AsyncMqttClient::addServerFingerprint(const uint8_t* fingerprint) {
  std::array<uint8_t, SHA1_SIZE> newFingerprint;
  memcpy(newFingerprint.data(), fingerprint, SHA1_SIZE);
  _secureServerFingerprints.push_back(newFingerprint);
  return *this;
}
#endif

AsyncMqttClient& AsyncMqttClient::onConnect(AsyncMqttClientInternals::OnConnectUserCallback callback) {
  _onConnectUserCallbacks.push_back(callback);
  return *this;
}

AsyncMqttClient& AsyncMqttClient::onDisconnect(AsyncMqttClientInternals::OnDisconnectUserCallback callback) {
  _onDisconnectUserCallbacks.push_back(callback);
  return *this;
}

AsyncMqttClient& AsyncMqttClient::onSubscribe(AsyncMqttClientInternals::OnSubscribeUserCallback callback) {
  _onSubscribeUserCallbacks.push_back(callback);
  return *this;
}

AsyncMqttClient& AsyncMqttClient::onUnsubscribe(AsyncMqttClientInternals::OnUnsubscribeUserCallback callback) {
  _onUnsubscribeUserCallbacks.push_back(callback);
  return *this;
}

AsyncMqttClient& AsyncMqttClient::onMessage(AsyncMqttClientInternals::OnMessageUserCallback callback) {
  _onMessageUserCallbacks.push_back(callback);
  return *this;
}

AsyncMqttClient& AsyncMqttClient::onPublish(AsyncMqttClientInternals::OnPublishUserCallback callback) {
  _onPublishUserCallbacks.push_back(callback);
  return *this;
}

void AsyncMqttClient::_freeCurrentParsedPacket() {
  delete _currentParsedPacket;
  _currentParsedPacket = nullptr;
}

void AsyncMqttClient::_clear() {
  _lastPingRequestTime = 0;
  _connected = false;
  _disconnectFlagged = false;
  _connectPacketNotEnoughSpace = false;
  _tlsBadFingerprint = false;
  _freeCurrentParsedPacket();

  _pendingPubRels.clear();
  _pendingPubRels.shrink_to_fit();

  _toSendAcks.clear();
  _toSendAcks.shrink_to_fit();

  _nextPacketId = 1;
  _parsingInformation.bufferState = AsyncMqttClientInternals::BufferState::NONE;
}

/* TCP */
void AsyncMqttClient::_onConnect(AsyncClient* client) {
  (void)client;

#if ASYNC_TCP_SSL_ENABLED
  if (_secure && _secureServerFingerprints.size() > 0) {
    SSL* clientSsl = _client.getSSL();

    bool sslFoundFingerprint = false;
    for (std::array<uint8_t, SHA1_SIZE> fingerprint : _secureServerFingerprints) {
      if (ssl_match_fingerprint(clientSsl, fingerprint.data()) == SSL_OK) {
        sslFoundFingerprint = true;
        break;
      }
    }

    if (!sslFoundFingerprint) {
      _tlsBadFingerprint = true;
      _client.close(true);
      return;
    }
  }
#endif

  char fixedHeader[5];
  fixedHeader[0] = AsyncMqttClientInternals::PacketType.CONNECT;
  fixedHeader[0] = fixedHeader[0] << 4;
  fixedHeader[0] = fixedHeader[0] | AsyncMqttClientInternals::HeaderFlag.CONNECT_RESERVED;

  uint16_t protocolNameLength = 4;
  char protocolNameLengthBytes[2];
  protocolNameLengthBytes[0] = protocolNameLength >> 8;
  protocolNameLengthBytes[1] = protocolNameLength & 0xFF;

  char protocolLevel[1];
  protocolLevel[0] = 0x04;

  char connectFlags[1];
  connectFlags[0] = 0;
  if (_cleanSession) connectFlags[0] |= AsyncMqttClientInternals::ConnectFlag.CLEAN_SESSION;
  if (_username != nullptr) connectFlags[0] |= AsyncMqttClientInternals::ConnectFlag.USERNAME;
  if (_password != nullptr) connectFlags[0] |= AsyncMqttClientInternals::ConnectFlag.PASSWORD;
  if (_willTopic != nullptr) {
    connectFlags[0] |= AsyncMqttClientInternals::ConnectFlag.WILL;
    if (_willRetain) connectFlags[0] |= AsyncMqttClientInternals::ConnectFlag.WILL_RETAIN;
    switch (_willQos) {
      case 0:
        connectFlags[0] |= AsyncMqttClientInternals::ConnectFlag.WILL_QOS0;
        break;
      case 1:
        connectFlags[0] |= AsyncMqttClientInternals::ConnectFlag.WILL_QOS1;
        break;
      case 2:
        connectFlags[0] |= AsyncMqttClientInternals::ConnectFlag.WILL_QOS2;
        break;
    }
  }

  char keepAliveBytes[2];
  keepAliveBytes[0] = _keepAlive >> 8;
  keepAliveBytes[1] = _keepAlive & 0xFF;

  uint16_t clientIdLength = strlen(_clientId);
  char clientIdLengthBytes[2];
  clientIdLengthBytes[0] = clientIdLength >> 8;
  clientIdLengthBytes[1] = clientIdLength & 0xFF;

  // Optional fields
  uint16_t willTopicLength = 0;
  char willTopicLengthBytes[2];
  uint16_t willPayloadLength = _willPayloadLength;
  char willPayloadLengthBytes[2];
  if (_willTopic != nullptr) {
    willTopicLength = strlen(_willTopic);
    willTopicLengthBytes[0] = willTopicLength >> 8;
    willTopicLengthBytes[1] = willTopicLength & 0xFF;

    if (_willPayload != nullptr && willPayloadLength == 0) willPayloadLength = strlen(_willPayload);

    willPayloadLengthBytes[0] = willPayloadLength >> 8;
    willPayloadLengthBytes[1] = willPayloadLength & 0xFF;
  }

  uint16_t usernameLength = 0;
  char usernameLengthBytes[2];
  if (_username != nullptr) {
    usernameLength = strlen(_username);
    usernameLengthBytes[0] = usernameLength >> 8;
    usernameLengthBytes[1] = usernameLength & 0xFF;
  }

  uint16_t passwordLength = 0;
  char passwordLengthBytes[2];
  if (_password != nullptr) {
    passwordLength = strlen(_password);
    passwordLengthBytes[0] = passwordLength >> 8;
    passwordLengthBytes[1] = passwordLength & 0xFF;
  }

  uint32_t remainingLength = 2 + protocolNameLength + 1 + 1 + 2 + 2 + clientIdLength;  // always present
  if (_willTopic != nullptr) remainingLength += 2 + willTopicLength + 2 + willPayloadLength;
  if (_username != nullptr) remainingLength += 2 + usernameLength;
  if (_password != nullptr) remainingLength += 2 + passwordLength;
  uint8_t remainingLengthLength = AsyncMqttClientInternals::Helpers::encodeRemainingLength(remainingLength, fixedHeader + 1);

  uint32_t neededSpace = 1 + remainingLengthLength;
  neededSpace += 2;
  neededSpace += protocolNameLength;
  neededSpace += 1;
  neededSpace += 1;
  neededSpace += 2;
  neededSpace += 2;
  neededSpace += clientIdLength;
  if (_willTopic != nullptr) {
    neededSpace += 2;
    neededSpace += willTopicLength;

    neededSpace += 2;
    if (_willPayload != nullptr) neededSpace += willPayloadLength;
  }
  if (_username != nullptr) {
    neededSpace += 2;
    neededSpace += usernameLength;
  }
  if (_password != nullptr) {
    neededSpace += 2;
    neededSpace += passwordLength;
  }

  SEMAPHORE_TAKE();
  if (_client.space() < neededSpace) {
    _connectPacketNotEnoughSpace = true;
    _client.close(true);
    SEMAPHORE_GIVE();
    return;
  }

  _client.add(fixedHeader, 1 + remainingLengthLength);
  _client.add(protocolNameLengthBytes, 2);
  _client.add("MQTT", protocolNameLength);
  _client.add(protocolLevel, 1);
  _client.add(connectFlags, 1);
  _client.add(keepAliveBytes, 2);
  _client.add(clientIdLengthBytes, 2);
  _client.add(_clientId, clientIdLength);
  if (_willTopic != nullptr) {
    _client.add(willTopicLengthBytes, 2);
    _client.add(_willTopic, willTopicLength);

    _client.add(willPayloadLengthBytes, 2);
    if (_willPayload != nullptr) _client.add(_willPayload, willPayloadLength);
  }
  if (_username != nullptr) {
    _client.add(usernameLengthBytes, 2);
    _client.add(_username, usernameLength);
  }
  if (_password != nullptr) {
    _client.add(passwordLengthBytes, 2);
    _client.add(_password, passwordLength);
  }
  _client.send();
  _lastClientActivity = millis();
  SEMAPHORE_GIVE();
}

void AsyncMqttClient::_onDisconnect(AsyncClient* client) {
  (void)client;
  if (!_disconnectFlagged) {
    AsyncMqttClientDisconnectReason reason;

    if (_connectPacketNotEnoughSpace) {
      reason = AsyncMqttClientDisconnectReason::ESP8266_NOT_ENOUGH_SPACE;
    } else if (_tlsBadFingerprint) {
      reason = AsyncMqttClientDisconnectReason::TLS_BAD_FINGERPRINT;
    } else {
      reason = AsyncMqttClientDisconnectReason::TCP_DISCONNECTED;
    }
    for (auto callback : _onDisconnectUserCallbacks) callback(reason);
  }
  _clear();
}

void AsyncMqttClient::_onError(AsyncClient* client, int8_t error) {
  (void)client;
  (void)error;
  // _onDisconnect called anyway
}

void AsyncMqttClient::_onTimeout(AsyncClient* client, uint32_t time) {
  (void)client;
  (void)time;
  // disconnection will be handled by ping/pong management
}

void AsyncMqttClient::_onAck(AsyncClient* client, size_t len, uint32_t time) {
  (void)client;
  (void)len;
  (void)time;
}

void AsyncMqttClient::_onData(AsyncClient* client, char* data, size_t len) {
  (void)client;
  size_t currentBytePosition = 0;
  char currentByte;
  do {
    switch (_parsingInformation.bufferState) {
      case AsyncMqttClientInternals::BufferState::NONE:
        currentByte = data[currentBytePosition++];
        _parsingInformation.packetType = currentByte >> 4;
        _parsingInformation.packetFlags = (currentByte << 4) >> 4;
        _parsingInformation.bufferState = AsyncMqttClientInternals::BufferState::REMAINING_LENGTH;
        _lastServerActivity = millis();
        switch (_parsingInformation.packetType) {
          case AsyncMqttClientInternals::PacketType.CONNACK:
            _currentParsedPacket = new AsyncMqttClientInternals::ConnAckPacket(&_parsingInformation, std::bind(&AsyncMqttClient::_onConnAck, this, std::placeholders::_1, std::placeholders::_2));
            break;
          case AsyncMqttClientInternals::PacketType.PINGRESP:
            _currentParsedPacket = new AsyncMqttClientInternals::PingRespPacket(&_parsingInformation, std::bind(&AsyncMqttClient::_onPingResp, this));
            break;
          case AsyncMqttClientInternals::PacketType.SUBACK:
            _currentParsedPacket = new AsyncMqttClientInternals::SubAckPacket(&_parsingInformation, std::bind(&AsyncMqttClient::_onSubAck, this, std::placeholders::_1, std::placeholders::_2));
            break;
          case AsyncMqttClientInternals::PacketType.UNSUBACK:
            _currentParsedPacket = new AsyncMqttClientInternals::UnsubAckPacket(&_parsingInformation, std::bind(&AsyncMqttClient::_onUnsubAck, this, std::placeholders::_1));
            break;
          case AsyncMqttClientInternals::PacketType.PUBLISH:
            _currentParsedPacket = new AsyncMqttClientInternals::PublishPacket(&_parsingInformation, std::bind(&AsyncMqttClient::_onMessage, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5, std::placeholders::_6, std::placeholders::_7, std::placeholders::_8, std::placeholders::_9), std::bind(&AsyncMqttClient::_onPublish, this, std::placeholders::_1, std::placeholders::_2));
            break;
          case AsyncMqttClientInternals::PacketType.PUBREL:
            _currentParsedPacket = new AsyncMqttClientInternals::PubRelPacket(&_parsingInformation, std::bind(&AsyncMqttClient::_onPubRel, this, std::placeholders::_1));
            break;
          case AsyncMqttClientInternals::PacketType.PUBACK:
            _currentParsedPacket = new AsyncMqttClientInternals::PubAckPacket(&_parsingInformation, std::bind(&AsyncMqttClient::_onPubAck, this, std::placeholders::_1));
            break;
          case AsyncMqttClientInternals::PacketType.PUBREC:
            _currentParsedPacket = new AsyncMqttClientInternals::PubRecPacket(&_parsingInformation, std::bind(&AsyncMqttClient::_onPubRec, this, std::placeholders::_1));
            break;
          case AsyncMqttClientInternals::PacketType.PUBCOMP:
            _currentParsedPacket = new AsyncMqttClientInternals::PubCompPacket(&_parsingInformation, std::bind(&AsyncMqttClient::_onPubComp, this, std::placeholders::_1));
            break;
          default:
            break;
        }
        break;
      case AsyncMqttClientInternals::BufferState::REMAINING_LENGTH:
        currentByte = data[currentBytePosition++];
        _remainingLengthBuffer[_remainingLengthBufferPosition++] = currentByte;
        if (currentByte >> 7 == 0) {
          _parsingInformation.remainingLength = AsyncMqttClientInternals::Helpers::decodeRemainingLength(_remainingLengthBuffer);
          _remainingLengthBufferPosition = 0;
          if (_parsingInformation.remainingLength > 0) {
            _parsingInformation.bufferState = AsyncMqttClientInternals::BufferState::VARIABLE_HEADER;
          } else {
            // PINGRESP is a special case where it has no variable header, so the packet ends right here
            _parsingInformation.bufferState = AsyncMqttClientInternals::BufferState::NONE;
            _onPingResp();
          }
        }
        break;
      case AsyncMqttClientInternals::BufferState::VARIABLE_HEADER:
        _currentParsedPacket->parseVariableHeader(data, len, &currentBytePosition);
        break;
      case AsyncMqttClientInternals::BufferState::PAYLOAD:
        _currentParsedPacket->parsePayload(data, len, &currentBytePosition);
        break;
      default:
        currentBytePosition = len;
    }
  } while (currentBytePosition != len);
}

void AsyncMqttClient::_onPoll(AsyncClient* client) {
  if (!_connected) return;

  // if there is too much time the client has sent a ping request without a response, disconnect client to avoid half open connections
  if (_lastPingRequestTime != 0 && (millis() - _lastPingRequestTime) >= (_keepAlive * 1000 * 2)) {
    disconnect();
    return;
  // send ping to ensure the server will receive at least one message inside keepalive window
  } else if (_lastPingRequestTime == 0 && (millis() - _lastClientActivity) >= (_keepAlive * 1000 * 0.7)) {
    _sendPing();

  // send ping to verify if the server is still there (ensure this is not a half connection)
  } else if (_connected && _lastPingRequestTime == 0 && (millis() - _lastServerActivity) >= (_keepAlive * 1000 * 0.7)) {
    _sendPing();
  }

  // handle to send ack packets

  _sendAcks();

  // handle disconnect

  if (_disconnectFlagged) {
    _sendDisconnect();
  }
}

/* MQTT */
void AsyncMqttClient::_onPingResp() {
  _freeCurrentParsedPacket();
  _lastPingRequestTime = 0;
}

void AsyncMqttClient::_onConnAck(bool sessionPresent, uint8_t connectReturnCode) {
  (void)sessionPresent;
  _freeCurrentParsedPacket();

  if (connectReturnCode == 0) {
    _connected = true;
    for (auto callback : _onConnectUserCallbacks) callback(sessionPresent);
  } else {
    for (auto callback : _onDisconnectUserCallbacks) callback(static_cast<AsyncMqttClientDisconnectReason>(connectReturnCode));
    _disconnectFlagged = true;
  }
}

void AsyncMqttClient::_onSubAck(uint16_t packetId, char status) {
  _freeCurrentParsedPacket();

  for (auto callback : _onSubscribeUserCallbacks) callback(packetId, status);
}

void AsyncMqttClient::_onUnsubAck(uint16_t packetId) {
  _freeCurrentParsedPacket();

  for (auto callback : _onUnsubscribeUserCallbacks) callback(packetId);
}

void AsyncMqttClient::_onMessage(char* topic, char* payload, uint8_t qos, bool dup, bool retain, size_t len, size_t index, size_t total, uint16_t packetId) {
  bool notifyPublish = true;

  if (qos == 2) {
    for (AsyncMqttClientInternals::PendingPubRel pendingPubRel : _pendingPubRels) {
      if (pendingPubRel.packetId == packetId) {
        notifyPublish = false;
        break;
      }
    }
  }

  if (notifyPublish) {
    AsyncMqttClientMessageProperties properties;
    properties.qos = qos;
    properties.dup = dup;
    properties.retain = retain;

    for (auto callback : _onMessageUserCallbacks) callback(topic, payload, properties, len, index, total);
  }
}

void AsyncMqttClient::_onPublish(uint16_t packetId, uint8_t qos) {
  AsyncMqttClientInternals::PendingAck pendingAck;

  if (qos == 1) {
    pendingAck.packetType = AsyncMqttClientInternals::PacketType.PUBACK;
    pendingAck.headerFlag = AsyncMqttClientInternals::HeaderFlag.PUBACK_RESERVED;
    pendingAck.packetId = packetId;
    _toSendAcks.push_back(pendingAck);
  } else if (qos == 2) {
    pendingAck.packetType = AsyncMqttClientInternals::PacketType.PUBREC;
    pendingAck.headerFlag = AsyncMqttClientInternals::HeaderFlag.PUBREC_RESERVED;
    pendingAck.packetId = packetId;
    _toSendAcks.push_back(pendingAck);

    bool pubRelAwaiting = false;
    for (AsyncMqttClientInternals::PendingPubRel pendingPubRel : _pendingPubRels) {
      if (pendingPubRel.packetId == packetId) {
        pubRelAwaiting = true;
        break;
      }
    }

    if (!pubRelAwaiting) {
      AsyncMqttClientInternals::PendingPubRel pendingPubRel;
      pendingPubRel.packetId = packetId;
      _pendingPubRels.push_back(pendingPubRel);
    }

    _sendAcks();
  }

  _freeCurrentParsedPacket();
}

void AsyncMqttClient::_onPubRel(uint16_t packetId) {
  _freeCurrentParsedPacket();

  AsyncMqttClientInternals::PendingAck pendingAck;
  pendingAck.packetType = AsyncMqttClientInternals::PacketType.PUBCOMP;
  pendingAck.headerFlag = AsyncMqttClientInternals::HeaderFlag.PUBCOMP_RESERVED;
  pendingAck.packetId = packetId;
  _toSendAcks.push_back(pendingAck);

  for (size_t i = 0; i < _pendingPubRels.size(); i++) {
    if (_pendingPubRels[i].packetId == packetId) {
      _pendingPubRels.erase(_pendingPubRels.begin() + i);
      _pendingPubRels.shrink_to_fit();
    }
  }

  _sendAcks();
}

void AsyncMqttClient::_onPubAck(uint16_t packetId) {
  _freeCurrentParsedPacket();

  for (auto callback : _onPublishUserCallbacks) callback(packetId);
}

void AsyncMqttClient::_onPubRec(uint16_t packetId) {
  _freeCurrentParsedPacket();

  AsyncMqttClientInternals::PendingAck pendingAck;
  pendingAck.packetType = AsyncMqttClientInternals::PacketType.PUBREL;
  pendingAck.headerFlag = AsyncMqttClientInternals::HeaderFlag.PUBREL_RESERVED;
  pendingAck.packetId = packetId;
  _toSendAcks.push_back(pendingAck);

  _sendAcks();
}

void AsyncMqttClient::_onPubComp(uint16_t packetId) {
  _freeCurrentParsedPacket();

  for (auto callback : _onPublishUserCallbacks) callback(packetId);
}

bool AsyncMqttClient::_sendPing() {
  char fixedHeader[2];
  fixedHeader[0] = AsyncMqttClientInternals::PacketType.PINGREQ;
  fixedHeader[0] = fixedHeader[0] << 4;
  fixedHeader[0] = fixedHeader[0] | AsyncMqttClientInternals::HeaderFlag.PINGREQ_RESERVED;
  fixedHeader[1] = 0;

  size_t neededSpace = 2;

  SEMAPHORE_TAKE(false);
  if (_client.space() < neededSpace) { SEMAPHORE_GIVE(); return false; }

  _client.add(fixedHeader, 2);
  _client.send();
  _lastClientActivity = millis();
  _lastPingRequestTime = millis();

  SEMAPHORE_GIVE();
  return true;
}

void AsyncMqttClient::_sendAcks() {
  uint8_t neededAckSpace = 2 + 2;

  SEMAPHORE_TAKE();
  for (size_t i = 0; i < _toSendAcks.size(); i++) {
    if (_client.space() < neededAckSpace) break;

    AsyncMqttClientInternals::PendingAck pendingAck = _toSendAcks[i];

    char fixedHeader[2];
    fixedHeader[0] = pendingAck.packetType;
    fixedHeader[0] = fixedHeader[0] << 4;
    fixedHeader[0] = fixedHeader[0] | pendingAck.headerFlag;
    fixedHeader[1] = 2;

    char packetIdBytes[2];
    packetIdBytes[0] = pendingAck.packetId >> 8;
    packetIdBytes[1] = pendingAck.packetId & 0xFF;

    _client.add(fixedHeader, 2);
    _client.add(packetIdBytes, 2);
    _client.send();

    _toSendAcks.erase(_toSendAcks.begin() + i);
    _toSendAcks.shrink_to_fit();

    _lastClientActivity = millis();
  }
  SEMAPHORE_GIVE();
}

bool AsyncMqttClient::_sendDisconnect() {
  if (!_connected) return true;

  const uint8_t neededSpace = 2;

  SEMAPHORE_TAKE(false);

  if (_client.space() < neededSpace) { SEMAPHORE_GIVE(); return false; }

  char fixedHeader[2];
  fixedHeader[0] = AsyncMqttClientInternals::PacketType.DISCONNECT;
  fixedHeader[0] = fixedHeader[0] << 4;
  fixedHeader[0] = fixedHeader[0] | AsyncMqttClientInternals::HeaderFlag.DISCONNECT_RESERVED;
  fixedHeader[1] = 0;

  _client.add(fixedHeader, 2);
  _client.send();
  _client.close(true);

  _disconnectFlagged = false;

  SEMAPHORE_GIVE();
  return true;
}

uint16_t AsyncMqttClient::_getNextPacketId() {
  uint16_t nextPacketId = _nextPacketId;

  if (_nextPacketId == 65535) _nextPacketId = 0;  // 0 is forbidden
  _nextPacketId++;

  return nextPacketId;
}

bool AsyncMqttClient::connected() const {
  return _connected;
}

void AsyncMqttClient::connect() {
  if (_connected) return;

#if ASYNC_TCP_SSL_ENABLED
  if (_useIp) {
    _client.connect(_ip, _port, _secure);
  } else {
    _client.connect(_host, _port, _secure);
  }
#else
  if (_useIp) {
    _client.connect(_ip, _port);
  } else {
    _client.connect(_host, _port);
  }
#endif
}

void AsyncMqttClient::disconnect(bool force) {
  if (!_connected) return;

  if (force) {
    _client.close(true);
  } else {
    _disconnectFlagged = true;
    _sendDisconnect();
  }
}

uint16_t AsyncMqttClient::subscribe(const char* topic, uint8_t qos) {
  if (!_connected) return 0;

  char fixedHeader[5];
  fixedHeader[0] = AsyncMqttClientInternals::PacketType.SUBSCRIBE;
  fixedHeader[0] = fixedHeader[0] << 4;
  fixedHeader[0] = fixedHeader[0] | AsyncMqttClientInternals::HeaderFlag.SUBSCRIBE_RESERVED;

  uint16_t topicLength = strlen(topic);
  char topicLengthBytes[2];
  topicLengthBytes[0] = topicLength >> 8;
  topicLengthBytes[1] = topicLength & 0xFF;

  char qosByte[1];
  qosByte[0] = qos;

  uint8_t remainingLengthLength = AsyncMqttClientInternals::Helpers::encodeRemainingLength(2 + 2 + topicLength + 1, fixedHeader + 1);

  size_t neededSpace = 0;
  neededSpace += 1 + remainingLengthLength;
  neededSpace += 2;
  neededSpace += 2;
  neededSpace += topicLength;
  neededSpace += 1;

  SEMAPHORE_TAKE(0);
  if (_client.space() < neededSpace) { SEMAPHORE_GIVE(); return 0; }

  uint16_t packetId = _getNextPacketId();
  char packetIdBytes[2];
  packetIdBytes[0] = packetId >> 8;
  packetIdBytes[1] = packetId & 0xFF;

  _client.add(fixedHeader, 1 + remainingLengthLength);
  _client.add(packetIdBytes, 2);
  _client.add(topicLengthBytes, 2);
  _client.add(topic, topicLength);
  _client.add(qosByte, 1);
  _client.send();
  _lastClientActivity = millis();

  SEMAPHORE_GIVE();
  return packetId;
}

uint16_t AsyncMqttClient::unsubscribe(const char* topic) {
  if (!_connected) return 0;

  char fixedHeader[5];
  fixedHeader[0] = AsyncMqttClientInternals::PacketType.UNSUBSCRIBE;
  fixedHeader[0] = fixedHeader[0] << 4;
  fixedHeader[0] = fixedHeader[0] | AsyncMqttClientInternals::HeaderFlag.UNSUBSCRIBE_RESERVED;

  uint16_t topicLength = strlen(topic);
  char topicLengthBytes[2];
  topicLengthBytes[0] = topicLength >> 8;
  topicLengthBytes[1] = topicLength & 0xFF;

  uint8_t remainingLengthLength = AsyncMqttClientInternals::Helpers::encodeRemainingLength(2 + 2 + topicLength, fixedHeader + 1);

  size_t neededSpace = 0;
  neededSpace += 1 + remainingLengthLength;
  neededSpace += 2;
  neededSpace += 2;
  neededSpace += topicLength;

  SEMAPHORE_TAKE(0);
  if (_client.space() < neededSpace) { SEMAPHORE_GIVE(); return 0; }

  uint16_t packetId = _getNextPacketId();
  char packetIdBytes[2];
  packetIdBytes[0] = packetId >> 8;
  packetIdBytes[1] = packetId & 0xFF;

  _client.add(fixedHeader, 1 + remainingLengthLength);
  _client.add(packetIdBytes, 2);
  _client.add(topicLengthBytes, 2);
  _client.add(topic, topicLength);
  _client.send();
  _lastClientActivity = millis();

  SEMAPHORE_GIVE();
  return packetId;
}

uint16_t AsyncMqttClient::publish(const char* topic, uint8_t qos, bool retain, const char* payload, size_t length, bool dup, uint16_t message_id) {
  if (!_connected) return 0;

  char fixedHeader[5];
  fixedHeader[0] = AsyncMqttClientInternals::PacketType.PUBLISH;
  fixedHeader[0] = fixedHeader[0] << 4;
  if (dup) fixedHeader[0] |= AsyncMqttClientInternals::HeaderFlag.PUBLISH_DUP;
  if (retain) fixedHeader[0] |= AsyncMqttClientInternals::HeaderFlag.PUBLISH_RETAIN;
  switch (qos) {
    case 0:
      fixedHeader[0] |= AsyncMqttClientInternals::HeaderFlag.PUBLISH_QOS0;
      break;
    case 1:
      fixedHeader[0] |= AsyncMqttClientInternals::HeaderFlag.PUBLISH_QOS1;
      break;
    case 2:
      fixedHeader[0] |= AsyncMqttClientInternals::HeaderFlag.PUBLISH_QOS2;
      break;
  }

  uint16_t topicLength = strlen(topic);
  char topicLengthBytes[2];
  topicLengthBytes[0] = topicLength >> 8;
  topicLengthBytes[1] = topicLength & 0xFF;

  uint32_t payloadLength = length;
  if (payload != nullptr && payloadLength == 0) payloadLength = strlen(payload);

  uint32_t remainingLength = 2 + topicLength + payloadLength;
  if (qos != 0) remainingLength += 2;
  uint8_t remainingLengthLength = AsyncMqttClientInternals::Helpers::encodeRemainingLength(remainingLength, fixedHeader + 1);

  size_t neededSpace = 0;
  neededSpace += 1 + remainingLengthLength;
  neededSpace += 2;
  neededSpace += topicLength;
  if (qos != 0) neededSpace += 2;
  if (payload != nullptr) neededSpace += payloadLength;

  SEMAPHORE_TAKE(0);
  if (_client.space() < neededSpace) { SEMAPHORE_GIVE(); return 0; }

  uint16_t packetId = 0;
  char packetIdBytes[2];
  if (qos != 0) {
    if (dup && message_id > 0) {
      packetId = message_id;
    } else {
      packetId = _getNextPacketId();
    }

    packetIdBytes[0] = packetId >> 8;
    packetIdBytes[1] = packetId & 0xFF;
  }

  _client.add(fixedHeader, 1 + remainingLengthLength);
  _client.add(topicLengthBytes, 2);
  _client.add(topic, topicLength);
  if (qos != 0) _client.add(packetIdBytes, 2);
  if (payload != nullptr) _client.add(payload, payloadLength);
  _client.send();
  _lastClientActivity = millis();

  SEMAPHORE_GIVE();
  if (qos != 0) {
    return packetId;
  } else {
    return 1;
  }
}

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient.h ===

#ifndef SRC_ASYNCMQTTCLIENT_H_
#define SRC_ASYNCMQTTCLIENT_H_

#include "AsyncMqttClient.hpp"

#endif  // SRC_ASYNCMQTTCLIENT_H_

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/ConnAckPacket.cpp ===

#include "ConnAckPacket.hpp"

using AsyncMqttClientInternals::ConnAckPacket;

ConnAckPacket::ConnAckPacket(ParsingInformation* parsingInformation, OnConnAckInternalCallback callback)
: _parsingInformation(parsingInformation)
, _callback(callback)
, _bytePosition(0)
, _sessionPresent(false)
, _connectReturnCode(0) {
}

ConnAckPacket::~ConnAckPacket() {
}

void ConnAckPacket::parseVariableHeader(char* data, size_t len, size_t* currentBytePosition) {
  char currentByte = data[(*currentBytePosition)++];
  if (_bytePosition++ == 0) {
    _sessionPresent = (currentByte << 7) >> 7;
  } else {
    _connectReturnCode = currentByte;
    _parsingInformation->bufferState = BufferState::NONE;
    _callback(_sessionPresent, _connectReturnCode);
  }
}

void ConnAckPacket::parsePayload(char* data, size_t len, size_t* currentBytePosition) {
  (void)data;
  (void)currentBytePosition;
}

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PingRespPacket.cpp ===

#include "PingRespPacket.hpp"

using AsyncMqttClientInternals::PingRespPacket;

PingRespPacket::PingRespPacket(ParsingInformation* parsingInformation, OnPingRespInternalCallback callback)
: _parsingInformation(parsingInformation)
, _callback(callback) {
}

PingRespPacket::~PingRespPacket() {
}

void PingRespPacket::parseVariableHeader(char* data, size_t len, size_t* currentBytePosition) {
  (void)data;
  (void)currentBytePosition;
}

void PingRespPacket::parsePayload(char* data, size_t len, size_t* currentBytePosition) {
  (void)data;
  (void)currentBytePosition;
}

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PubAckPacket.cpp ===

#include "PubAckPacket.hpp"

using AsyncMqttClientInternals::PubAckPacket;

PubAckPacket::PubAckPacket(ParsingInformation* parsingInformation, OnPubAckInternalCallback callback)
: _parsingInformation(parsingInformation)
, _callback(callback)
, _bytePosition(0)
, _packetIdMsb(0)
, _packetId(0) {
}

PubAckPacket::~PubAckPacket() {
}

void PubAckPacket::parseVariableHeader(char* data, size_t len, size_t* currentBytePosition) {
  char currentByte = data[(*currentBytePosition)++];
  if (_bytePosition++ == 0) {
    _packetIdMsb = currentByte;
  } else {
    _packetId = currentByte | _packetIdMsb << 8;
    _parsingInformation->bufferState = BufferState::NONE;
    _callback(_packetId);
  }
}

void PubAckPacket::parsePayload(char* data, size_t len, size_t* currentBytePosition) {
  (void)data;
  (void)currentBytePosition;
}

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PubCompPacket.cpp ===

#include "PubCompPacket.hpp"

using AsyncMqttClientInternals::PubCompPacket;

PubCompPacket::PubCompPacket(ParsingInformation* parsingInformation, OnPubCompInternalCallback callback)
: _parsingInformation(parsingInformation)
, _callback(callback)
, _bytePosition(0)
, _packetIdMsb(0)
, _packetId(0) {
}

PubCompPacket::~PubCompPacket() {
}

void PubCompPacket::parseVariableHeader(char* data, size_t len, size_t* currentBytePosition) {
  char currentByte = data[(*currentBytePosition)++];
  if (_bytePosition++ == 0) {
    _packetIdMsb = currentByte;
  } else {
    _packetId = currentByte | _packetIdMsb << 8;
    _parsingInformation->bufferState = BufferState::NONE;
    _callback(_packetId);
  }
}

void PubCompPacket::parsePayload(char* data, size_t len, size_t* currentBytePosition) {
  (void)data;
  (void)currentBytePosition;
}

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PubRecPacket.cpp ===

#include "PubRecPacket.hpp"

using AsyncMqttClientInternals::PubRecPacket;

PubRecPacket::PubRecPacket(ParsingInformation* parsingInformation, OnPubRecInternalCallback callback)
: _parsingInformation(parsingInformation)
, _callback(callback)
, _bytePosition(0)
, _packetIdMsb(0)
, _packetId(0) {
}

PubRecPacket::~PubRecPacket() {
}

void PubRecPacket::parseVariableHeader(char* data, size_t len, size_t* currentBytePosition) {
  char currentByte = data[(*currentBytePosition)++];
  if (_bytePosition++ == 0) {
    _packetIdMsb = currentByte;
  } else {
    _packetId = currentByte | _packetIdMsb << 8;
    _parsingInformation->bufferState = BufferState::NONE;
    _callback(_packetId);
  }
}

void PubRecPacket::parsePayload(char* data, size_t len, size_t* currentBytePosition) {
  (void)data;
  (void)currentBytePosition;
}

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PubRelPacket.cpp ===

#include "PubRelPacket.hpp"

using AsyncMqttClientInternals::PubRelPacket;

PubRelPacket::PubRelPacket(ParsingInformation* parsingInformation, OnPubRelInternalCallback callback)
: _parsingInformation(parsingInformation)
, _callback(callback)
, _bytePosition(0)
, _packetIdMsb(0)
, _packetId(0) {
}

PubRelPacket::~PubRelPacket() {
}

void PubRelPacket::parseVariableHeader(char* data, size_t len, size_t* currentBytePosition) {
  char currentByte = data[(*currentBytePosition)++];
  if (_bytePosition++ == 0) {
    _packetIdMsb = currentByte;
  } else {
    _packetId = currentByte | _packetIdMsb << 8;
    _parsingInformation->bufferState = BufferState::NONE;
    _callback(_packetId);
  }
}

void PubRelPacket::parsePayload(char* data, size_t len, size_t* currentBytePosition) {
  (void)data;
  (void)currentBytePosition;
}

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/PublishPacket.cpp ===

#include "PublishPacket.hpp"

using AsyncMqttClientInternals::PublishPacket;

PublishPacket::PublishPacket(ParsingInformation* parsingInformation, OnMessageInternalCallback dataCallback, OnPublishInternalCallback completeCallback)
: _parsingInformation(parsingInformation)
, _dataCallback(dataCallback)
, _completeCallback(completeCallback)
, _dup(false)
, _qos(0)
, _retain(0)
, _bytePosition(0)
, _topicLengthMsb(0)
, _topicLength(0)
, _ignore(false)
, _packetIdMsb(0)
, _packetId(0)
, _payloadLength(0)
, _payloadBytesRead(0) {
    _dup = _parsingInformation->packetFlags & HeaderFlag.PUBLISH_DUP;
    _retain = _parsingInformation->packetFlags & HeaderFlag.PUBLISH_RETAIN;
    char qosMasked = _parsingInformation->packetFlags & 0x06;
    switch (qosMasked) {
      case HeaderFlag.PUBLISH_QOS0:
        _qos = 0;
        break;
      case HeaderFlag.PUBLISH_QOS1:
        _qos = 1;
        break;
      case HeaderFlag.PUBLISH_QOS2:
        _qos = 2;
        break;
    }
}

PublishPacket::~PublishPacket() {
}

void PublishPacket::parseVariableHeader(char* data, size_t len, size_t* currentBytePosition) {
  char currentByte = data[(*currentBytePosition)++];
  if (_bytePosition == 0) {
    _topicLengthMsb = currentByte;
  } else if (_bytePosition == 1) {
    _topicLength = currentByte | _topicLengthMsb << 8;
    if (_topicLength > _parsingInformation->maxTopicLength) {
      _ignore = true;
    } else {
      _parsingInformation->topicBuffer[_topicLength] = '\0';
    }
  } else if (_bytePosition >= 2 && _bytePosition < 2 + _topicLength) {
    // Starting from here, _ignore might be true
    if (!_ignore) _parsingInformation->topicBuffer[_bytePosition - 2] = currentByte;
    if (_bytePosition == 2 + _topicLength - 1 && _qos == 0) {
      _preparePayloadHandling(_parsingInformation->remainingLength - (_bytePosition + 1));
      return;
    }
  } else if (_bytePosition == 2 + _topicLength) {
    _packetIdMsb = currentByte;
  } else {
    _packetId = currentByte | _packetIdMsb << 8;
    _preparePayloadHandling(_parsingInformation->remainingLength - (_bytePosition + 1));
  }
  _bytePosition++;
}

void PublishPacket::_preparePayloadHandling(uint32_t payloadLength) {
  _payloadLength = payloadLength;
  if (payloadLength == 0) {
    _parsingInformation->bufferState = BufferState::NONE;
    if (!_ignore) {
      _dataCallback(_parsingInformation->topicBuffer, nullptr, _qos, _dup, _retain, 0, 0, 0, _packetId);
      _completeCallback(_packetId, _qos);
    }
  } else {
    _parsingInformation->bufferState = BufferState::PAYLOAD;
  }
}

void PublishPacket::parsePayload(char* data, size_t len, size_t* currentBytePosition) {
  size_t remainToRead = len - (*currentBytePosition);
  if (_payloadBytesRead + remainToRead > _payloadLength) remainToRead = _payloadLength - _payloadBytesRead;

  if (!_ignore) _dataCallback(_parsingInformation->topicBuffer, data + (*currentBytePosition), _qos, _dup, _retain, remainToRead, _payloadBytesRead, _payloadLength, _packetId);
  _payloadBytesRead += remainToRead;
  (*currentBytePosition) += remainToRead;

  if (_payloadBytesRead == _payloadLength) {
    _parsingInformation->bufferState = BufferState::NONE;
    if (!_ignore) _completeCallback(_packetId, _qos);
  }
}

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/SubAckPacket.cpp ===

#include "SubAckPacket.hpp"

using AsyncMqttClientInternals::SubAckPacket;

SubAckPacket::SubAckPacket(ParsingInformation* parsingInformation, OnSubAckInternalCallback callback)
: _parsingInformation(parsingInformation)
, _callback(callback)
, _bytePosition(0)
, _packetIdMsb(0)
, _packetId(0) {
}

SubAckPacket::~SubAckPacket() {
}

void SubAckPacket::parseVariableHeader(char* data, size_t len, size_t* currentBytePosition) {
  char currentByte = data[(*currentBytePosition)++];
  if (_bytePosition++ == 0) {
    _packetIdMsb = currentByte;
  } else {
    _packetId = currentByte | _packetIdMsb << 8;
    _parsingInformation->bufferState = BufferState::PAYLOAD;
  }
}

void SubAckPacket::parsePayload(char* data, size_t len, size_t* currentBytePosition) {
  char status = data[(*currentBytePosition)++];

  /* switch (status) {
    case 0:
      Serial.println("Success QoS 0");
      break;
    case 1:
      Serial.println("Success QoS 1");
      break;
    case 2:
      Serial.println("Success QoS 2");
      break;
    case 0x80:
      Serial.println("Failure");
      break;
  } */

  _parsingInformation->bufferState = BufferState::NONE;
  _callback(_packetId, status);
}

=== ./src/dependencies/async-mqtt-client/AsyncMqttClient/Packets/UnsubAckPacket.cpp ===

#include "UnsubAckPacket.hpp"

using AsyncMqttClientInternals::UnsubAckPacket;

UnsubAckPacket::UnsubAckPacket(ParsingInformation* parsingInformation, OnUnsubAckInternalCallback callback)
: _parsingInformation(parsingInformation)
, _callback(callback)
, _bytePosition(0)
, _packetIdMsb(0)
, _packetId(0) {
}

UnsubAckPacket::~UnsubAckPacket() {
}

void UnsubAckPacket::parseVariableHeader(char* data, size_t len, size_t* currentBytePosition) {
  char currentByte = data[(*currentBytePosition)++];
  if (_bytePosition++ == 0) {
    _packetIdMsb = currentByte;
  } else {
    _packetId = currentByte | _packetIdMsb << 8;
    _parsingInformation->bufferState = BufferState::NONE;
    _callback(_packetId);
  }
}

void UnsubAckPacket::parsePayload(char* data, size_t len, size_t* currentBytePosition) {
  (void)data;
  (void)currentBytePosition;
}

=== ./src/dependencies/dmx/ESPDMX.cpp ===

// - - - - -
// ESPDMX - A Arduino library for sending and receiving DMX using the builtin serial hardware port.
// ESPDMX.cpp: Library implementation file
//
// Copyright (C) 2015  Rick <ricardogg95@gmail.com>
// This work is licensed under a GNU style license.
//
// Last change: Marcel Seerig <https://github.com/mseerig>
//
// Documentation and samples are available at https://github.com/Rickgg/ESP-Dmx
// - - - - -

/* ----- LIBRARIES ----- */
#ifdef ESP8266

#include <Arduino.h>

#include "ESPDMX.h"



#define dmxMaxChannel  512
#define defaultMax 32

#define DMXSPEED       250000
#define DMXFORMAT      SERIAL_8N2
#define BREAKSPEED     83333
#define BREAKFORMAT    SERIAL_8N1

bool dmxStarted = false;
int sendPin = 2;		//dafault on ESP8266

//DMX value array and size. Entry 0 will hold startbyte
uint8_t dmxDataStore[dmxMaxChannel] = {};
int channelSize;


void DMXESPSerial::init() {
  channelSize = defaultMax;

  Serial1.begin(DMXSPEED);
  pinMode(sendPin, OUTPUT);
  dmxStarted = true;
}

// Set up the DMX-Protocol
void DMXESPSerial::init(int chanQuant) {

  if (chanQuant > dmxMaxChannel || chanQuant <= 0) {
    chanQuant = defaultMax;
  }

  channelSize = chanQuant;

  Serial1.begin(DMXSPEED);
  pinMode(sendPin, OUTPUT);
  dmxStarted = true;
}

// Function to read DMX data
uint8_t DMXESPSerial::read(int Channel) {
  if (dmxStarted == false) init();

  if (Channel < 1) Channel = 1;
  if (Channel > dmxMaxChannel) Channel = dmxMaxChannel;
  return(dmxDataStore[Channel]);
}

// Function to send DMX data
void DMXESPSerial::write(int Channel, uint8_t value) {
  if (dmxStarted == false) init();

  if (Channel < 1) Channel = 1;
  if (Channel > channelSize) Channel = channelSize;
  if (value < 0) value = 0;
  if (value > 255) value = 255;

  dmxDataStore[Channel] = value;
}

void DMXESPSerial::end() {
  channelSize = 0;
  Serial1.end();
  dmxStarted = false;
}

void DMXESPSerial::update() {
  if (dmxStarted == false) init();

  //Send break
  digitalWrite(sendPin, HIGH);
  Serial1.begin(BREAKSPEED, BREAKFORMAT);
  Serial1.write(0);
  Serial1.flush();
  delay(1);
  Serial1.end();

  //send data
  Serial1.begin(DMXSPEED, DMXFORMAT);
  digitalWrite(sendPin, LOW);
  Serial1.write(dmxDataStore, channelSize);
  Serial1.flush();
  delay(1);
  Serial1.end();
}

// Function to update the DMX bus

#endif
=== ./src/dependencies/dmx/ESPDMX.h ===

// - - - - -
// ESPDMX - A Arduino library for sending and receiving DMX using the builtin serial hardware port.
// ESPDMX.cpp: Library implementation file
//
// Copyright (C) 2015  Rick <ricardogg95@gmail.com>
// This work is licensed under a GNU style license.
//
// Last change: Marcel Seerig <https://github.com/mseerig>
//
// Documentation and samples are available at https://github.com/Rickgg/ESP-Dmx
// - - - - -

#include <inttypes.h>


#ifndef ESPDMX_h
#define ESPDMX_h

// ---- Methods ----

class DMXESPSerial {
public:
  void init();
  void init(int MaxChan);
  uint8_t read(int Channel);
  void write(int channel, uint8_t value);
  void update();
  void end();
};

#endif

=== ./src/dependencies/dmx/SparkFunDMX.cpp ===

/******************************************************************************
SparkFunDMX.h
Arduino Library for the SparkFun ESP32 LED to DMX Shield
Andy England @ SparkFun Electronics
7/22/2019

Development environment specifics:
Arduino IDE 1.6.4

This code is released under the [MIT License](http://opensource.org/licenses/MIT).
Please review the LICENSE.md file included with this example. If you have any questions 
or concerns with licensing, please contact techsupport@sparkfun.com.
Distributed as-is; no warranty is given.
******************************************************************************/

/* ----- LIBRARIES ----- */
#if defined(ARDUINO_ARCH_ESP32)

#include <Arduino.h>
#if !defined(CONFIG_IDF_TARGET_ESP32C3)  && !defined(CONFIG_IDF_TARGET_ESP32S2)

#include "SparkFunDMX.h"
#include <HardwareSerial.h>

#define dmxMaxChannel  512
#define defaultMax 32

#define DMXSPEED       250000
#define DMXFORMAT      SERIAL_8N2
#define BREAKSPEED     83333
#define BREAKFORMAT    SERIAL_8N1

static const int enablePin = -1;		// disable the enable pin because it is not needed
static const int rxPin = -1;       // disable the receiving pin because it is not needed - softhack007: Pin=-1 means "use default" not "disable"
static const int txPin = 2;        // transmit DMX data over this pin (default is pin 2)

//DMX value array and size. Entry 0 will hold startbyte
static uint8_t dmxData[dmxMaxChannel] = { 0 };
static int chanSize = 0;
#if !defined(DMX_SEND_ONLY)
static int currentChannel = 0;
#endif

// Some new MCUs (-S2, -C3) don't have HardwareSerial(2)
#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0)
  #if SOC_UART_NUM < 3
  #error DMX output is not possible on your MCU, as it does not have HardwareSerial(2)
  #endif
#endif

static HardwareSerial DMXSerial(2);

/* Interrupt Timer for DMX Receive */
#if !defined(DMX_SEND_ONLY)
static hw_timer_t * timer = NULL;
static portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;
#endif

static volatile int _interruptCounter = 0;
static volatile bool _startCodeDetected = false;


#if !defined(DMX_SEND_ONLY)
/* Start Code is detected by 21 low interrupts */
void IRAM_ATTR onTimer() {
	if ((rxPin >= 0) && (digitalRead(rxPin) == 1))
	{
		_interruptCounter = 0; //If the RX Pin is high, we are not in an interrupt
	}
	else
	{
		_interruptCounter++;
	}
	if (_interruptCounter > 9)
	{	
		portENTER_CRITICAL_ISR(&timerMux);
		_startCodeDetected = true;
		DMXSerial.begin(DMXSPEED, DMXFORMAT, rxPin, txPin);
		portEXIT_CRITICAL_ISR(&timerMux);
		_interruptCounter = 0;
	}
}

void SparkFunDMX::initRead(int chanQuant) {
	
  timer = timerBegin(0, 1, true);
  timerAttachInterrupt(timer, &onTimer, true);
  timerAlarmWrite(timer, 320, true);
  timerAlarmEnable(timer);
  _READWRITE = _READ;
  if (chanQuant > dmxMaxChannel || chanQuant <= 0) 
  {
    chanQuant = defaultMax;
  }
  chanSize = chanQuant;
  if (enablePin >= 0) {
    pinMode(enablePin, OUTPUT);
    digitalWrite(enablePin, LOW);
  }
  if (rxPin >= 0) pinMode(rxPin, INPUT);
}
#endif

// Set up the DMX-Protocol
void SparkFunDMX::initWrite (int chanQuant) {

  _READWRITE = _WRITE;
  if (chanQuant > dmxMaxChannel || chanQuant <= 0) {
    chanQuant = defaultMax;
  }

  chanSize = chanQuant + 1; //Add 1 for start code

  DMXSerial.begin(DMXSPEED, DMXFORMAT, rxPin, txPin);
  if (enablePin >= 0) {
    pinMode(enablePin, OUTPUT);
    digitalWrite(enablePin, HIGH);
  }
}

#if !defined(DMX_SEND_ONLY)
// Function to read DMX data
uint8_t SparkFunDMX::read(int Channel) {
  if (Channel > chanSize) Channel = chanSize;
  return(dmxData[Channel - 1]); //subtract one to account for start byte
}
#endif

// Function to send DMX data
void SparkFunDMX::write(int Channel, uint8_t value) {
  if (Channel < 0) Channel = 0;
  if (Channel > chanSize) chanSize = Channel;
  dmxData[0] = 0;
  dmxData[Channel] = value; //add one to account for start byte
}



void SparkFunDMX::update() {
  if (_READWRITE == _WRITE)
  {
    //Send DMX break
    digitalWrite(txPin, HIGH);
    DMXSerial.begin(BREAKSPEED, BREAKFORMAT, rxPin, txPin);//Begin the Serial port
    DMXSerial.write(0);
    DMXSerial.flush();
    delay(1);
    DMXSerial.end();
    
    //Send DMX data
    DMXSerial.begin(DMXSPEED, DMXFORMAT, rxPin, txPin);//Begin the Serial port
    DMXSerial.write(dmxData, chanSize);
    DMXSerial.flush();
    DMXSerial.end();//clear our DMX array, end the Hardware Serial port
  }
#if !defined(DMX_SEND_ONLY)
  else if (_READWRITE == _READ)//In a perfect world, this function ends serial communication upon packet completion and attaches RX to a CHANGE interrupt so the start code can be read again
  { 
	if (_startCodeDetected == true)
	{
		while (DMXSerial.available())
		{
			dmxData[currentChannel++] = DMXSerial.read();
		}
	if (currentChannel > chanSize) //Set the channel counter back to 0 if we reach the known end size of our packet
	{
		
      portENTER_CRITICAL(&timerMux);
	  _startCodeDetected = false;
	  DMXSerial.flush();
	  DMXSerial.end();
      portEXIT_CRITICAL(&timerMux);
	  currentChannel = 0;
	}
	}
  }
#endif
}

// Function to update the DMX bus
#endif
#endif
=== ./src/dependencies/dmx/SparkFunDMX.h ===

/******************************************************************************
SparkFunDMX.h
Arduino Library for the SparkFun ESP32 LED to DMX Shield
Andy England @ SparkFun Electronics
7/22/2019

Development environment specifics:
Arduino IDE 1.6.4

This code is released under the [MIT License](http://opensource.org/licenses/MIT).
Please review the LICENSE.md file included with this example. If you have any questions 
or concerns with licensing, please contact techsupport@sparkfun.com.
Distributed as-is; no warranty is given.
******************************************************************************/

#include <inttypes.h>


#ifndef SparkFunDMX_h
#define SparkFunDMX_h

#define DMX_SEND_ONLY // this disables DMX sending features, and saves us two GPIO pins

// ---- Methods ----

class SparkFunDMX {
public:
  void initWrite(int maxChan);
#if !defined(DMX_SEND_ONLY)
  void initRead(int maxChan);
  uint8_t read(int Channel);
#endif
  void write(int channel, uint8_t value);
  void update();
private:
  const uint8_t _startCodeValue = 0xFF;
  const bool _READ = true;
  const bool _WRITE = false;
  bool _READWRITE;
};

#endif
=== ./src/dependencies/e131/ESPAsyncE131.cpp ===

/*
* ESPAsyncE131.cpp
*
* Project: ESPAsyncE131 - Asynchronous E.131 (sACN) library for Arduino ESP8266 and ESP32
* Copyright (c) 2019 Shelby Merrick
* http://www.forkineye.com
*
*  This program is provided free for you to use in any way that you wish,
*  subject to the laws and regulations where you are using it.  Due diligence
*  is strongly suggested before using this code.  Please give credit where due.
*
*  The Author makes no warranty of any kind, express or implied, with regard
*  to this program or the documentation contained in this document.  The
*  Author shall not be liable in any event for incidental or consequential
*  damages in connection with, or arising out of, the furnishing, performance
*  or use of these programs.
*
*/

#include "ESPAsyncE131.h"
#include "../network/Network.h"
#include <string.h>

// E1.17 ACN Packet Identifier
const byte ESPAsyncE131::ACN_ID[12] = { 0x41, 0x53, 0x43, 0x2d, 0x45, 0x31, 0x2e, 0x31, 0x37, 0x00, 0x00, 0x00 };

// Art-Net Packet Identifier
const byte ESPAsyncE131::ART_ID[8]  = { 0x41, 0x72, 0x74, 0x2d, 0x4e, 0x65, 0x74, 0x00 };

// Constructor
ESPAsyncE131::ESPAsyncE131(e131_packet_callback_function callback) {
  _callback = callback;
}

/////////////////////////////////////////////////////////
//
// Public begin() members
//
/////////////////////////////////////////////////////////

bool ESPAsyncE131::begin(bool multicast, uint16_t port, uint16_t universe, uint8_t n) {
  bool success = false;

  if (multicast) {
		success = initMulticast(port, universe, n);
	} else {
    success = initUnicast(port);
	}

  return success;
}

/////////////////////////////////////////////////////////
//
// Private init() members
//
/////////////////////////////////////////////////////////

bool ESPAsyncE131::initUnicast(uint16_t port) {
  bool success = false;

  if (udp.listen(port)) {
    udp.onPacket(std::bind(&ESPAsyncE131::parsePacket, this, std::placeholders::_1));
    success = true;
  }
  return success;
}

bool ESPAsyncE131::initMulticast(uint16_t port, uint16_t universe, uint8_t n) {
  bool success = false;

  IPAddress address = IPAddress(239, 255, ((universe >> 8) & 0xff),
    ((universe >> 0) & 0xff));

  if (udp.listenMulticast(address, port)) {
    ip4_addr_t ifaddr;
    ip4_addr_t multicast_addr;

    ifaddr.addr = static_cast<uint32_t>(Network.localIP());
    for (uint8_t i = 1; i < n; i++) {
        multicast_addr.addr = static_cast<uint32_t>(IPAddress(239, 255,
          (((universe + i) >> 8) & 0xff), (((universe + i) >> 0)
          & 0xff)));
      igmp_joingroup(&ifaddr, &multicast_addr);
    }

    udp.onPacket(std::bind(&ESPAsyncE131::parsePacket, this, std::placeholders::_1));

    success = true;
  }
  return success;
}

/////////////////////////////////////////////////////////
//
// Packet parsing - Private
//
/////////////////////////////////////////////////////////

void ESPAsyncE131::parsePacket(AsyncUDPPacket _packet) {
  bool error = false;
  uint8_t protocol = P_E131;

  e131_packet_t *sbuff = reinterpret_cast<e131_packet_t *>(_packet.data());
	
	//E1.31 packet identifier ("ACS-E1.17")
  if (memcmp(sbuff->acn_id, ESPAsyncE131::ACN_ID, sizeof(sbuff->acn_id)))
    protocol = P_ARTNET;
	
	if (protocol == P_ARTNET) {
		if (memcmp(sbuff->art_id, ESPAsyncE131::ART_ID, sizeof(sbuff->art_id)))
			error = true; //not "Art-Net"
		if (sbuff->art_opcode != ARTNET_OPCODE_OPDMX)
			error = true; //not a DMX packet
	} else { //E1.31 error handling
		if (htonl(sbuff->root_vector) != ESPAsyncE131::VECTOR_ROOT)
			error = true;
		if (htonl(sbuff->frame_vector) != ESPAsyncE131::VECTOR_FRAME)
			error = true;
		if (sbuff->dmp_vector != ESPAsyncE131::VECTOR_DMP)
			error = true;
		if (sbuff->property_values[0] != 0)
			error = true;
	} 
  
  if (error && _packet.localPort() == DDP_DEFAULT_PORT) { //DDP packet
    error = false;
    protocol = P_DDP;
  }

  if (!error) {
    _callback(sbuff, _packet.remoteIP(), protocol);
  }
}
=== ./src/dependencies/e131/ESPAsyncE131.h ===

/*
* ESPAsyncE131.h
*
* Project: ESPAsyncE131 - Asynchronous E.131 (sACN) library for Arduino ESP8266 and ESP32
* Copyright (c) 2019 Shelby Merrick
* http://www.forkineye.com
*
*  Project: ESPAsyncDDP - Asynchronous DDP library for Arduino ESP8266 and ESP32
* Copyright (c) 2019 Daniel Kulp
*
*  This program is provided free for you to use in any way that you wish,
*  subject to the laws and regulations where you are using it.  Due diligence
*  is strongly suggested before using this code.  Please give credit where due.
*
*  The Author makes no warranty of any kind, express or implied, with regard
*  to this program or the documentation contained in this document.  The
*  Author shall not be liable in any event for incidental or consequential
*  damages in connection with, or arising out of, the furnishing, performance
*  or use of these programs.
*/

/*
 * Inspired by https://github.com/hideakitai/ArtNet for ArtNet support
 */

#ifndef ESPASYNCE131_H_
#define ESPASYNCE131_H_

#ifdef ESP32
#include <WiFi.h>
#include <AsyncUDP.h>
#elif defined (ESP8266)
#include <ESPAsyncUDP.h>
#include <ESP8266WiFi.h>
#include <ESP8266WiFiMulti.h>
#else
#error Platform not supported
#endif

#include <lwip/ip_addr.h>
#include <lwip/igmp.h>
#include <Arduino.h>

#if LWIP_VERSION_MAJOR == 1
typedef struct ip_addr ip4_addr_t;
#endif

// Defaults
#define E131_DEFAULT_PORT   5568
#define ARTNET_DEFAULT_PORT 6454
#define DDP_DEFAULT_PORT    4048

#define DDP_PUSH_FLAG 0x01
#define DDP_TIMECODE_FLAG 0x10

#define ARTNET_OPCODE_OPDMX 0x5000

#define P_E131   0
#define P_ARTNET 1
#define P_DDP    2

// E1.31 Packet Offsets
#define E131_ROOT_PREAMBLE_SIZE 0
#define E131_ROOT_POSTAMBLE_SIZE 2
#define E131_ROOT_ID 4
#define E131_ROOT_FLENGTH 16
#define E131_ROOT_VECTOR 18
#define E131_ROOT_CID 22

#define E131_FRAME_FLENGTH 38
#define E131_FRAME_VECTOR 40
#define E131_FRAME_SOURCE 44
#define E131_FRAME_PRIORITY 108
#define E131_FRAME_RESERVED 109
#define E131_FRAME_SEQ 111
#define E131_FRAME_OPT 112
#define E131_FRAME_UNIVERSE 113

#define E131_DMP_FLENGTH 115
#define E131_DMP_VECTOR 117
#define E131_DMP_TYPE 118
#define E131_DMP_ADDR_FIRST 119
#define E131_DMP_ADDR_INC 121
#define E131_DMP_COUNT 123
#define E131_DMP_DATA 125

// E1.31 Packet Structure
typedef union {
    struct { //E1.31 packet
      // Root Layer
      uint16_t preamble_size;
      uint16_t postamble_size;
      uint8_t  acn_id[12];
      uint16_t root_flength;
      uint32_t root_vector;
      uint8_t  cid[16];

      // Frame Layer
      uint16_t frame_flength;
      uint32_t frame_vector;
      uint8_t  source_name[64];
      uint8_t  priority;
      uint16_t reserved;
      uint8_t  sequence_number;
      uint8_t  options;
      uint16_t universe;

      // DMP Layer
      uint16_t dmp_flength;
      uint8_t  dmp_vector;
      uint8_t  type;
      uint16_t first_address;
      uint16_t address_increment;
      uint16_t property_value_count;
      uint8_t  property_values[513];
    } __attribute__((packed));
	
	struct { //Art-Net packet
    uint8_t  art_id[8];
    uint16_t art_opcode;
    uint16_t art_protocol_ver;
    uint8_t  art_sequence_number;
    uint8_t  art_physical;
    uint16_t art_universe;
    uint16_t art_length;

    uint8_t  art_data[512];
  } __attribute__((packed));

  struct { //DDP Header
    uint8_t flags;
    uint8_t sequenceNum;
    uint8_t dataType;
    uint8_t destination;
    uint32_t channelOffset;
    uint16_t dataLen;
    uint8_t data[1];
  } __attribute__((packed));

  /*struct { //DDP Time code Header (unsupported)
    uint8_t flags;
    uint8_t sequenceNum;
    uint8_t dataType;
    uint8_t destination;
    uint32_t channelOffset;
    uint16_t dataLen;
    uint32_t timeCode;
    uint8_t data[1];
  } __attribute__((packed));*/

  uint8_t raw[1458];
} e131_packet_t;

// new packet callback
typedef void (*e131_packet_callback_function) (e131_packet_t* p, IPAddress clientIP, byte protocol);

class ESPAsyncE131 {
 private:
    // Constants for packet validation
    static const uint8_t ACN_ID[];
	  static const uint8_t ART_ID[];
    static const uint32_t VECTOR_ROOT = 4;
    static const uint32_t VECTOR_FRAME = 2;
    static const uint8_t VECTOR_DMP = 2;

    AsyncUDP        udp;        // AsyncUDP

    // Internal Initializers
    bool initUnicast(uint16_t port);
    bool initMulticast(uint16_t port, uint16_t universe, uint8_t n = 1);

    // Packet parser callback
    void parsePacket(AsyncUDPPacket _packet);
    
    e131_packet_callback_function _callback = nullptr;

 public:
    ESPAsyncE131(e131_packet_callback_function callback);

    // Generic UDP listener, no physical or IP configuration
    bool begin(bool multicast, uint16_t port = E131_DEFAULT_PORT, uint16_t universe = 1, uint8_t n = 1);
};

#endif  // ESPASYNCE131_H_
=== ./src/dependencies/espalexa/Espalexa.h ===

#ifndef Espalexa_h
#define Espalexa_h

/*
 * Alexa Voice On/Off/Brightness/Color Control. Emulates a Philips Hue bridge to Alexa.
 * 
 * This was put together from these two excellent projects:
 * https://github.com/kakopappa/arduino-esp8266-alexa-wemo-switch
 * https://github.com/probonopd/ESP8266HueEmulator
 */
/*
 * @title Espalexa library
 * @version 2.7.0
 * @author Christian Schwinne
 * @license MIT
 * @contributors d-999
 */

#include "Arduino.h"

//you can use these defines for library config in your sketch. Just use them before #include <Espalexa.h>
//#define ESPALEXA_ASYNC

//in case this is unwanted in your application (will disable the /espalexa value page)
//#define ESPALEXA_NO_SUBPAGE

#ifndef ESPALEXA_MAXDEVICES
 #define ESPALEXA_MAXDEVICES 10 //this limit only has memory reasons, set it higher should you need to, max 128
#endif

//#define ESPALEXA_DEBUG

#ifdef ESPALEXA_ASYNC
 #ifdef ARDUINO_ARCH_ESP32
  #include <AsyncTCP.h>
 #else
  #include <ESPAsyncTCP.h>
 #endif
 #include <ESPAsyncWebServer.h>
#else
 #ifdef ARDUINO_ARCH_ESP32
  #include <WiFi.h>
  #include <WebServer.h> //if you get an error here please update to ESP32 arduino core 1.0.0
 #else
  #include <ESP8266WebServer.h>
  #include <ESP8266WiFi.h>
 #endif
#endif
#include <WiFiUdp.h>
#include "../network/Network.h"

#ifdef ESPALEXA_DEBUG
 #pragma message "Espalexa 2.7.0 debug mode"
 #define EA_DEBUG(x)  Serial.print (x)
 #define EA_DEBUGLN(x) Serial.println (x)
#else
 #define EA_DEBUG(x)
 #define EA_DEBUGLN(x)
#endif

#include "EspalexaDevice.h"

#define DEVICE_UNIQUE_ID_LENGTH 12

class Espalexa {
private:
  //private member vars
  #ifdef ESPALEXA_ASYNC
  AsyncWebServer* serverAsync;
  AsyncWebServerRequest* server; //this saves many #defines
  String body = "";
  #elif defined ARDUINO_ARCH_ESP32
  WebServer* server;
  #else
  ESP8266WebServer* server;
  #endif
  uint8_t currentDeviceCount = 0;
  bool discoverable = true;
  bool udpConnected = false;

  EspalexaDevice* devices[ESPALEXA_MAXDEVICES] = {};
  //Keep in mind that Device IDs go from 1 to DEVICES, cpp arrays from 0 to DEVICES-1!!
  
  WiFiUDP espalexaUdp;
  IPAddress ipMulti;
  uint32_t mac24; //bottom 24 bits of mac
  String escapedMac=""; //lowercase mac address
  
  //private member functions
  const char* modeString(EspalexaColorMode m)
  {
    if (m == EspalexaColorMode::xy) return "xy";
    if (m == EspalexaColorMode::hs) return "hs";
    return "ct";
  }
  
  const char* typeString(EspalexaDeviceType t)
  {
    switch (t)
    {
      case EspalexaDeviceType::dimmable:      return PSTR("Dimmable light");
      case EspalexaDeviceType::whitespectrum: return PSTR("Color temperature light");
      case EspalexaDeviceType::color:         return PSTR("Color light");
      case EspalexaDeviceType::extendedcolor: return PSTR("Extended color light");
      default: return "";
    }
  }
  
  const char* modelidString(EspalexaDeviceType t)
  {
    switch (t)
    {
      case EspalexaDeviceType::dimmable:      return "LWB010";
      case EspalexaDeviceType::whitespectrum: return "LWT010";
      case EspalexaDeviceType::color:         return "LST001";
      case EspalexaDeviceType::extendedcolor: return "LCT015";
      default: return "";
    }
  }
  
  void encodeLightId(uint8_t idx, char* out)
  {
    uint8_t mac[6];
    WiFi.macAddress(mac);

    sprintf_P(out, PSTR("%02X:%02X:%02X:%02X:%02X:%02X:00:11-%02X"), mac[0],mac[1],mac[2],mac[3],mac[4],mac[5], idx);
  }

  // construct 'globally unique' Json dict key fitting into signed int
  inline int encodeLightKey(uint8_t idx)
  {
    //return idx +1;
    static_assert(ESPALEXA_MAXDEVICES <= 128, "");
    return (mac24<<7) | idx;
  }

  // get device index from Json key
  uint8_t decodeLightKey(int key)
  {
    //return key -1;
    return (((uint32_t)key>>7) == mac24) ? (key & 127U) : 255U;
  }

  //device JSON string: color+temperature device emulates LCT015, dimmable device LWB010, (TODO: on/off Plug 01, color temperature device LWT010, color device LST001)
  void deviceJsonString(EspalexaDevice* dev, char* buf)
  {
    char buf_lightid[27];
    encodeLightId(dev->getId() + 1, buf_lightid);
    
    char buf_col[80] = "";
    //color support
    if (static_cast<uint8_t>(dev->getType()) > 2)
      //TODO: %f is not working for some reason on ESP8266 in v0.11.0 (was fine in 0.10.2). Need to investigate
      //sprintf_P(buf_col,PSTR(",\"hue\":%u,\"sat\":%u,\"effect\":\"none\",\"xy\":[%f,%f]")
      //  ,dev->getHue(), dev->getSat(), dev->getX(), dev->getY());
      sprintf_P(buf_col,PSTR(",\"hue\":%u,\"sat\":%u,\"effect\":\"none\",\"xy\":[%s,%s]"),dev->getHue(), dev->getSat(),
        ((String)dev->getX()).c_str(), ((String)dev->getY()).c_str());
      
    char buf_ct[16] = "";
    //white spectrum support
    if (static_cast<uint8_t>(dev->getType()) > 1 && dev->getType() != EspalexaDeviceType::color)
      sprintf(buf_ct, ",\"ct\":%u", dev->getCt());
    
    char buf_cm[20] = "";
    if (static_cast<uint8_t>(dev->getType()) > 1)
      sprintf(buf_cm,PSTR("\",\"colormode\":\"%s"), modeString(dev->getColorMode()));
    
    sprintf_P(buf, PSTR("{\"state\":{\"on\":%s,\"bri\":%u%s%s,\"alert\":\"none%s\",\"mode\":\"homeautomation\",\"reachable\":true},"
                   "\"type\":\"%s\",\"name\":\"%s\",\"modelid\":\"%s\",\"manufacturername\":\"Philips\",\"productname\":\"E%u"
                   "\",\"uniqueid\":\"%s\",\"swversion\":\"espalexa-2.7.0\"}")
                   
    , (dev->getValue())?"true":"false", dev->getLastValue()-1, buf_col, buf_ct, buf_cm, typeString(dev->getType()),
    dev->getName().c_str(), modelidString(dev->getType()), static_cast<uint8_t>(dev->getType()), buf_lightid);
  }
  
  //Espalexa status page /espalexa
  #ifndef ESPALEXA_NO_SUBPAGE
  void servePage()
  {
    EA_DEBUGLN("HTTP Req espalexa ...\n");
    String res = "Hello from Espalexa!\r\n\r\n";
    for (int i=0; i<currentDeviceCount; i++)
    {
      EspalexaDevice* dev = devices[i];
      res += "Value of device " + String(i+1) + " (" + dev->getName() + "): " + String(dev->getValue()) + " (" + typeString(dev->getType());
      if (static_cast<uint8_t>(dev->getType()) > 1) //color support
      {
        res += ", colormode=" + String(modeString(dev->getColorMode())) + ", r=" + String(dev->getR()) + ", g=" + String(dev->getG()) + ", b=" + String(dev->getB());
        res +=", ct=" + String(dev->getCt()) + ", hue=" + String(dev->getHue()) + ", sat=" + String(dev->getSat()) + ", x=" + String(dev->getX()) + ", y=" + String(dev->getY());
      }
      res += ")\r\n";
    }
    res += "\r\nFree Heap: " + (String)ESP.getFreeHeap();
    res += "\r\nUptime: " + (String)millis();
    res += "\r\n\r\nEspalexa library v2.7.0 by Christian Schwinne 2021";
    server->send(200, "text/plain", res);
  }
  #endif

  //not found URI (only if internal webserver is used)
  void serveNotFound()
  {
    EA_DEBUGLN("Not-Found HTTP call:");
    #ifndef ESPALEXA_ASYNC
    EA_DEBUGLN("URI: " + server->uri());
    EA_DEBUGLN("Body: " + server->arg(0));
    if(!handleAlexaApiCall(server->uri(), server->arg(0)))
    #else
    EA_DEBUGLN("URI: " + server->url());
    EA_DEBUGLN("Body: " + body);
    if(!handleAlexaApiCall(server))
    #endif
      server->send(404, "text/plain", "Not Found (espalexa)");
  }

  //send description.xml device property page
  void serveDescription()
  {
    EA_DEBUGLN("# Responding to description.xml ... #\n");
    IPAddress localIP = Network.localIP();
    char s[16];
    sprintf(s, "%d.%d.%d.%d", localIP[0], localIP[1], localIP[2], localIP[3]);
    char buf[1024];
    
    sprintf_P(buf,PSTR("<?xml version=\"1.0\" ?>"
        "<root xmlns=\"urn:schemas-upnp-org:device-1-0\">"
        "<specVersion><major>1</major><minor>0</minor></specVersion>"
        "<URLBase>http://%s:80/</URLBase>"
        "<device>"
          "<deviceType>urn:schemas-upnp-org:device:Basic:1</deviceType>"
          "<friendlyName>Espalexa (%s:80)</friendlyName>"
          "<manufacturer>Royal Philips Electronics</manufacturer>"
          "<manufacturerURL>http://www.philips.com</manufacturerURL>"
          "<modelDescription>Philips hue Personal Wireless Lighting</modelDescription>"
          "<modelName>Philips hue bridge 2012</modelName>"
          "<modelNumber>929000226503</modelNumber>"
          "<modelURL>http://www.meethue.com</modelURL>"
          "<serialNumber>%s</serialNumber>"
          "<UDN>uuid:2f402f80-da50-11e1-9b23-%s</UDN>"
          "<presentationURL>index.html</presentationURL>"
        "</device>"
        "</root>"),s,s,escapedMac.c_str(),escapedMac.c_str());
          
    server->send(200, "text/xml", buf);
    
    EA_DEBUGLN("Send setup.xml");
    EA_DEBUGLN(buf);
  }
  
  //init the server
  void startHttpServer()
  {
    #ifdef ESPALEXA_ASYNC
    if (serverAsync == nullptr) {
      serverAsync = new AsyncWebServer(80);
      serverAsync->onNotFound([=](AsyncWebServerRequest *request){server = request; serveNotFound();});
    }
    
    serverAsync->onRequestBody([=](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total){
      char b[len +1];
      b[len] = 0;
      memcpy(b, data, len);
      body = b; //save the body so we can use it for the API call
      EA_DEBUG("Received body: ");
      EA_DEBUGLN(body);
    });
    #ifndef ESPALEXA_NO_SUBPAGE
    serverAsync->on("/espalexa", HTTP_GET, [=](AsyncWebServerRequest *request){server = request; servePage();});
    #endif
    serverAsync->on("/description.xml", HTTP_GET, [=](AsyncWebServerRequest *request){server = request; serveDescription();});
    serverAsync->begin();
    
    #else
    if (server == nullptr) {
      #ifdef ARDUINO_ARCH_ESP32
      server = new WebServer(80);
      #else
      server = new ESP8266WebServer(80);  
      #endif
      server->onNotFound([=](){serveNotFound();});
    }

    #ifndef ESPALEXA_NO_SUBPAGE
    server->on("/espalexa", HTTP_GET, [=](){servePage();});
    #endif
    server->on("/description.xml", HTTP_GET, [=](){serveDescription();});
    server->begin();
    #endif
  }

  //respond to UDP SSDP M-SEARCH
  void respondToSearch()
  {
    IPAddress localIP = Network.localIP();
    char s[16];
    sprintf(s, "%d.%d.%d.%d", localIP[0], localIP[1], localIP[2], localIP[3]);

    char buf[1024];

    sprintf_P(buf,PSTR("HTTP/1.1 200 OK\r\n"
      "EXT:\r\n"
      "CACHE-CONTROL: max-age=100\r\n" // SSDP_INTERVAL
      "LOCATION: http://%s:80/description.xml\r\n"
      "SERVER: FreeRTOS/6.0.5, UPnP/1.0, IpBridge/1.17.0\r\n" // _modelName, _modelNumber
      "hue-bridgeid: %s\r\n"
      "ST: urn:schemas-upnp-org:device:basic:1\r\n"  // _deviceType
      "USN: uuid:2f402f80-da50-11e1-9b23-%s::upnp:rootdevice\r\n" // _uuid::_deviceType
      "\r\n"),s,escapedMac.c_str(),escapedMac.c_str());

    espalexaUdp.beginPacket(espalexaUdp.remoteIP(), espalexaUdp.remotePort());
    #ifdef ARDUINO_ARCH_ESP32
    espalexaUdp.write((uint8_t*)buf, strlen(buf));
    #else
    espalexaUdp.write(buf);
    #endif
    espalexaUdp.endPacket();                    
  }

public:
  Espalexa(){}

  //initialize interfaces
  #ifdef ESPALEXA_ASYNC
  bool begin(AsyncWebServer* externalServer = nullptr)
  #elif defined ARDUINO_ARCH_ESP32
  bool begin(WebServer* externalServer = nullptr)
  #else
  bool begin(ESP8266WebServer* externalServer = nullptr)
  #endif
  {
    EA_DEBUGLN("Espalexa Begin...");
    EA_DEBUG("MAXDEVICES ");
    EA_DEBUGLN(ESPALEXA_MAXDEVICES);
    escapedMac = WiFi.macAddress();
    escapedMac.replace(":", "");
    escapedMac.toLowerCase();

    String macSubStr = escapedMac.substring(6, 12);
    mac24 = strtol(macSubStr.c_str(), 0, 16);

    #ifdef ESPALEXA_ASYNC
    serverAsync = externalServer;
    #else
    server = externalServer;
    #endif
    #ifdef ARDUINO_ARCH_ESP32
    udpConnected = espalexaUdp.beginMulticast(IPAddress(239, 255, 255, 250), 1900);
    #else
    udpConnected = espalexaUdp.beginMulticast(Network.localIP(), IPAddress(239, 255, 255, 250), 1900);
    #endif

    if (udpConnected){
      
      startHttpServer();
      EA_DEBUGLN("Done");
      return true;
    }
    EA_DEBUGLN("Failed");
    return false;
  }

  //service loop
  void loop() {
    #ifndef ESPALEXA_ASYNC
    if (server == nullptr) return; //only if begin() was not called
    server->handleClient();
    #endif
    
    if (!udpConnected) return;   
    int packetSize = espalexaUdp.parsePacket();    
    if (packetSize < 1) return; //no new udp packet
    
    EA_DEBUGLN("Got UDP!");

    unsigned char packetBuffer[packetSize+1]; //buffer to hold incoming udp packet
    espalexaUdp.read(packetBuffer, packetSize);
    packetBuffer[packetSize] = 0;
  
    espalexaUdp.flush();
    if (!discoverable) return; //do not reply to M-SEARCH if not discoverable
  
    const char* request = (const char *) packetBuffer;
    if (strstr(request, "M-SEARCH") == nullptr) return;

    EA_DEBUGLN(request);
    if (strstr(request, "ssdp:disc")  != nullptr &&  //short for "ssdp:discover"
        (strstr(request, "upnp:rootd") != nullptr || //short for "upnp:rootdevice"
         strstr(request, "ssdp:all")   != nullptr ||
         strstr(request, "asic:1")     != nullptr )) //short for "device:basic:1"
    {
      EA_DEBUGLN("Responding search req...");
      respondToSearch();
    }
  }

  // returns device index or 0 on failure
  uint8_t addDevice(EspalexaDevice* d)
  {
    EA_DEBUG("Adding device ");
    EA_DEBUGLN((currentDeviceCount+1));
    if (currentDeviceCount >= ESPALEXA_MAXDEVICES) return 0;
    if (d == nullptr) return 0;
    d->setId(currentDeviceCount);
    devices[currentDeviceCount] = d;
    return ++currentDeviceCount;
  }
  
  //brightness-only callback
  uint8_t addDevice(String deviceName, BrightnessCallbackFunction callback, uint8_t initialValue = 0)
  {
    EA_DEBUG("Constructing device ");
    EA_DEBUGLN((currentDeviceCount+1));
    if (currentDeviceCount >= ESPALEXA_MAXDEVICES) return 0;
    EspalexaDevice* d = new EspalexaDevice(deviceName, callback, initialValue);
    return addDevice(d);
  }
  
  //brightness-only callback
  uint8_t addDevice(String deviceName, ColorCallbackFunction callback, uint8_t initialValue = 0)
  {
    EA_DEBUG("Constructing device ");
    EA_DEBUGLN((currentDeviceCount+1));
    if (currentDeviceCount >= ESPALEXA_MAXDEVICES) return 0;
    EspalexaDevice* d = new EspalexaDevice(deviceName, callback, initialValue);
    return addDevice(d);
  }


  uint8_t addDevice(String deviceName, DeviceCallbackFunction callback, EspalexaDeviceType t = EspalexaDeviceType::dimmable, uint8_t initialValue = 0)
  {
    EA_DEBUG("Constructing device ");
    EA_DEBUGLN((currentDeviceCount+1));
    if (currentDeviceCount >= ESPALEXA_MAXDEVICES) return 0;
    EspalexaDevice* d = new EspalexaDevice(deviceName, callback, t, initialValue);
    return addDevice(d);
  }

  void renameDevice(uint8_t id, const String& deviceName)
  {
    unsigned int index = id - 1;
    if (index < currentDeviceCount)
      devices[index]->setName(deviceName);
  }

  //basic implementation of Philips hue api functions needed for basic Alexa control
  #ifdef ESPALEXA_ASYNC
  bool handleAlexaApiCall(AsyncWebServerRequest* request)
  {
    server = request; //copy request reference
    String req = request->url(); //body from global variable
    EA_DEBUGLN(request->contentType());
    if (request->hasParam("body", true)) // This is necessary, otherwise ESP crashes if there is no body
    {
      EA_DEBUG("BodyMethod2");
      body = request->getParam("body", true)->value();
    }
    EA_DEBUG("FinalBody: ");
    EA_DEBUGLN(body);
  #else
  bool handleAlexaApiCall(String req, String body)
  {  
  #endif
    EA_DEBUG("URL: ");
    EA_DEBUGLN(req);
    EA_DEBUGLN("AlexaApiCall");
    if (req.indexOf("api") <0) return false; //return if not an API call
    EA_DEBUGLN("ok");

    if (body.indexOf("devicetype") > 0) //client wants a hue api username, we don't care and give static
    {
      EA_DEBUGLN("devType");
      body = "";
      server->send(200, "application/json", F("[{\"success\":{\"username\":\"2BLEDHardQrI3WHYTHoMcXHgEspsM8ZZRpSKtBGr\"}}]"));
      return true;
    }

    if ((req.indexOf("state") > 0) && (body.length() > 0)) //client wants to control light
    {
      uint32_t devId = req.substring(req.indexOf("lights")+7).toInt();
      EA_DEBUG("ls"); EA_DEBUGLN(devId);
      unsigned idx = decodeLightKey(devId);
      EA_DEBUGLN(idx);
      char buf[50];
      sprintf_P(buf,PSTR("[{\"success\":{\"/lights/%u/state/\": true}}]"),devId);
      server->send(200, "application/json", buf);
      if (idx >= currentDeviceCount) return true; //return if invalid ID
      EspalexaDevice* dev = devices[idx];
      
      dev->setPropertyChanged(EspalexaDeviceProperty::none);
      
      if (body.indexOf("false")>0) //OFF command
      {
        dev->setValue(0);
        dev->setPropertyChanged(EspalexaDeviceProperty::off);
        dev->doCallback();
        return true;
      }
      
      if (body.indexOf("true") >0) //ON command
      {
        dev->setValue(dev->getLastValue());
        dev->setPropertyChanged(EspalexaDeviceProperty::on);
      }
      
      if (body.indexOf("bri")  >0) //BRIGHTNESS command
      {
        uint8_t briL = body.substring(body.indexOf("bri") +5).toInt();
        if (briL == 255)
        {
         dev->setValue(255);
        } else {
         dev->setValue(briL+1); 
        }
        dev->setPropertyChanged(EspalexaDeviceProperty::bri);
      }
      
      if (body.indexOf("xy")   >0) //COLOR command (XY mode)
      {
        dev->setColorXY(body.substring(body.indexOf("[") +1).toFloat(), body.substring(body.indexOf(",0") +1).toFloat());
        dev->setPropertyChanged(EspalexaDeviceProperty::xy);
      }
      
      if (body.indexOf("hue")  >0) //COLOR command (HS mode)
      {
        dev->setColor(body.substring(body.indexOf("hue") +5).toInt(), body.substring(body.indexOf("sat") +5).toInt());
        dev->setPropertyChanged(EspalexaDeviceProperty::hs);
      }
      
      if (body.indexOf("ct")   >0) //COLOR TEMP command (white spectrum)
      {
        dev->setColor(body.substring(body.indexOf("ct") +4).toInt());
        dev->setPropertyChanged(EspalexaDeviceProperty::ct);
      }
      
      dev->doCallback();
      
      #ifdef ESPALEXA_DEBUG
      if (dev->getLastChangedProperty() == EspalexaDeviceProperty::none)
        EA_DEBUGLN("STATE REQ WITHOUT BODY (likely Content-Type issue #6)");
      #endif
      return true;
    }
    
    int pos = req.indexOf("lights");
    if (pos > 0) //client wants light info
    {
      int devId = req.substring(pos+7).toInt();
      EA_DEBUG("l"); EA_DEBUGLN(devId);

      if (devId == 0) //client wants all lights
      {
        EA_DEBUGLN("lAll");
        String jsonTemp = "{";
        for (int i = 0; i<currentDeviceCount; i++)
        {
          jsonTemp += '"';
          jsonTemp += encodeLightKey(i);
          jsonTemp += '"';
          jsonTemp += ':';

          char buf[512];
          deviceJsonString(devices[i], buf);
          jsonTemp += buf;
          if (i < currentDeviceCount-1) jsonTemp += ',';
        }
        jsonTemp += '}';
        server->send(200, "application/json", jsonTemp);
      } else //client wants one light (devId)
      {
        EA_DEBUGLN(devId);
        unsigned int idx = decodeLightKey(devId);

        if (idx >= currentDeviceCount) idx = 0; //send first device if invalid
        if (currentDeviceCount == 0) {
          server->send(200, "application/json", "{}");
          return true;
        }
        char buf[512];
        deviceJsonString(devices[idx], buf);
        server->send(200, "application/json", buf);
      }
      
      return true;
    }

    //we don't care about other api commands at this time and send empty JSON
    server->send(200, "application/json", "{}");
    return true;
  }
  
  //set whether Alexa can discover any devices
  void setDiscoverable(bool d)
  {
    discoverable = d;
  }
  
  //get EspalexaDevice at specific index
  EspalexaDevice* getDevice(uint8_t index)
  {
    if (index >= currentDeviceCount) return nullptr;
    return devices[index];
  }
  
  //is an unique device ID
  String getEscapedMac()
  {
    return escapedMac;
  }
  
  //convert brightness (0-255) to percentage
  uint8_t toPercent(uint8_t bri)
  {
    uint16_t perc = bri * 100;
    return perc / 255;
  }
  
  ~Espalexa(){} //note: Espalexa is NOT meant to be destructed
};

#endif

=== ./src/dependencies/espalexa/EspalexaDevice.cpp ===

//EspalexaDevice Class

#include "EspalexaDevice.h"

EspalexaDevice::EspalexaDevice(){}

EspalexaDevice::EspalexaDevice(String deviceName, BrightnessCallbackFunction gnCallback, uint8_t initialValue) { //constructor for dimmable device
  
  _deviceName = deviceName;
  _callback = gnCallback;
  _val = initialValue;
  _val_last = _val;
  _type = EspalexaDeviceType::dimmable;
}

EspalexaDevice::EspalexaDevice(String deviceName, ColorCallbackFunction gnCallback, uint8_t initialValue) { //constructor for color device
  
  _deviceName = deviceName;
  _callbackCol = gnCallback;
  _val = initialValue;
  _val_last = _val;
  _type = EspalexaDeviceType::extendedcolor;
}

EspalexaDevice::EspalexaDevice(String deviceName, DeviceCallbackFunction gnCallback, EspalexaDeviceType t, uint8_t initialValue) { //constructor for general device
  
  _deviceName = deviceName;
  _callbackDev = gnCallback;
  _type = t;
  if (t == EspalexaDeviceType::onoff) _type = EspalexaDeviceType::dimmable; //on/off is broken, so make dimmable device instead
  if (t == EspalexaDeviceType::whitespectrum) _mode = EspalexaColorMode::ct;
  _val = initialValue;
  _val_last = _val;
}

EspalexaDevice::~EspalexaDevice(){/*nothing to destruct*/}

uint8_t EspalexaDevice::getId()
{
  return _id;
}

EspalexaColorMode EspalexaDevice::getColorMode()
{
  return _mode;
}

EspalexaDeviceType EspalexaDevice::getType()
{
  return _type;
}

String EspalexaDevice::getName()
{
  return _deviceName;
}

EspalexaDeviceProperty EspalexaDevice::getLastChangedProperty()
{
  return _changed;
}

uint8_t EspalexaDevice::getValue()
{
  return _val;
}

bool EspalexaDevice::getState()
{
  return _val;
}

uint8_t EspalexaDevice::getPercent()
{
  uint16_t perc = _val * 100;
  return perc / 255;
}

uint8_t EspalexaDevice::getDegrees()
{
  return getPercent();
}

uint16_t EspalexaDevice::getHue()
{
  return _hue;
}

uint8_t EspalexaDevice::getSat()
{
  return _sat;
}

float EspalexaDevice::getX()
{
  return _x;
}

float EspalexaDevice::getY()
{
  return _y;
}

uint16_t EspalexaDevice::getCt()
{
  if (_ct == 0) return 500;
  return _ct;
}

uint32_t EspalexaDevice::getKelvin()
{
  if (_ct == 0) return 2000;
  return 1000000/_ct;
}

uint32_t EspalexaDevice::getRGB()
{
  if (_rgb != 0) return _rgb; //color has not changed
  byte rgb[4]{0, 0, 0, 0};
  
  if (_mode == EspalexaColorMode::none) return 0;

  if (_mode == EspalexaColorMode::ct)
  {
    //TODO tweak a bit to match hue lamp characteristics
    //based on https://gist.github.com/paulkaplan/5184275
    float temp = 10000/ _ct; //kelvins = 1,000,000/mired (and that /100)
    float r, g, b;

    if (temp <= 66) { 
      r = 255; 
      g = temp;
      g = 99.470802 * log(g) - 161.119568;
      if (temp <= 19) {
          b = 0;
      } else {
          b = temp-10;
          b = 138.517731 * log(b) - 305.044793;
      }
    } else {
      r = temp - 60;
      r = 329.698727 * pow(r, -0.13320476);
      g = temp - 60;
      g = 288.12217 * pow(g, -0.07551485 );
      b = 255;
    }
    
    rgb[0] = (byte)constrain(r,0.1,255.1);
    rgb[1] = (byte)constrain(g,0.1,255.1);
    rgb[2] = (byte)constrain(b,0.1,255.1);
    
  } else if (_mode == EspalexaColorMode::hs)
  {
    float h = ((float)_hue)/65535.0;
    float s = ((float)_sat)/255.0;
    byte i = floor(h*6);
    float f = h * 6-i;
    float p = 255 * (1-s);
    float q = 255 * (1-f*s);
    float t = 255 * (1-(1-f)*s);
    switch (i%6) {
      case 0: rgb[0]=255,rgb[1]=t,rgb[2]=p;break;
      case 1: rgb[0]=q,rgb[1]=255,rgb[2]=p;break;
      case 2: rgb[0]=p,rgb[1]=255,rgb[2]=t;break;
      case 3: rgb[0]=p,rgb[1]=q,rgb[2]=255;break;
      case 4: rgb[0]=t,rgb[1]=p,rgb[2]=255;break;
      case 5: rgb[0]=255,rgb[1]=p,rgb[2]=q;
    }
  } else if (_mode == EspalexaColorMode::xy)
  {
    //Source: https://www.developers.meethue.com/documentation/color-conversions-rgb-xy
    float z = 1.0f - _x - _y;
    float X = (1.0f / _y) * _x;
    float Z = (1.0f / _y) * z;
    float r = (int)255*(X * 1.656492f - 0.354851f - Z * 0.255038f);
    float g = (int)255*(-X * 0.707196f + 1.655397f + Z * 0.036152f);
    float b = (int)255*(X * 0.051713f - 0.121364f + Z * 1.011530f);
    if (r > b && r > g && r > 1.0f) {
      // red is too big
      g = g / r;
      b = b / r;
      r = 1.0f;
    } else if (g > b && g > r && g > 1.0f) {
      // green is too big
      r = r / g;
      b = b / g;
      g = 1.0f;
    } else if (b > r && b > g && b > 1.0f) {
      // blue is too big
      r = r / b;
      g = g / b;
      b = 1.0f;
    }
    // Apply gamma correction
    r = r <= 0.0031308f ? 12.92f * r : (1.0f + 0.055f) * pow(r, (1.0f / 2.4f)) - 0.055f;
    g = g <= 0.0031308f ? 12.92f * g : (1.0f + 0.055f) * pow(g, (1.0f / 2.4f)) - 0.055f;
    b = b <= 0.0031308f ? 12.92f * b : (1.0f + 0.055f) * pow(b, (1.0f / 2.4f)) - 0.055f;

    if (r > b && r > g) {
      // red is biggest
      if (r > 1.0f) {
        g = g / r;
        b = b / r;
        r = 1.0f;
      }
    } else if (g > b && g > r) {
      // green is biggest
      if (g > 1.0f) {
        r = r / g;
        b = b / g;
        g = 1.0f;
      }
    } else if (b > r && b > g) {
      // blue is biggest
      if (b > 1.0f) {
        r = r / b;
        g = g / b;
        b = 1.0f;
      }
    }
    rgb[0] = 255.0*r;
    rgb[1] = 255.0*g;
    rgb[2] = 255.0*b;
  }
  _rgb = ((rgb[0] << 16) | (rgb[1] << 8) | (rgb[2]));
  return _rgb;
}

//white channel for RGBW lights. Always 0 unless colormode is ct
uint8_t EspalexaDevice::getW()
{
  return (getRGB() >> 24) & 0xFF;
}

uint8_t EspalexaDevice::getR()
{
  return (getRGB() >> 16) & 0xFF;
}

uint8_t EspalexaDevice::getG()
{
  return (getRGB() >> 8) & 0xFF;
}

uint8_t EspalexaDevice::getB()
{
  return getRGB() & 0xFF;
}

uint8_t EspalexaDevice::getLastValue()
{
  if (_val_last == 0) return 255;
  return _val_last;
}

void EspalexaDevice::setPropertyChanged(EspalexaDeviceProperty p)
{
  _changed = p;
}

void EspalexaDevice::setId(uint8_t id)
{
  _id = id;
}

//you need to re-discover the device for the Alexa name to change
void EspalexaDevice::setName(String name)
{
  _deviceName = name;
}

void EspalexaDevice::setValue(uint8_t val)
{
  if (_val != 0)
  {
    _val_last = _val;
  }
  if (val != 0)
  {
    _val_last = val;
  }
  _val = val;
}

void EspalexaDevice::setState(bool onoff)
{
  if (onoff) 
  {
    setValue(_val_last);
  } else {
    setValue(0);
  }
}

void EspalexaDevice::setPercent(uint8_t perc)
{
  uint16_t val = perc * 255;
  val /= 100;
  if (val > 255) val = 255;
  setValue(val);
}

void EspalexaDevice::setColorXY(float x, float y)
{
  _x = x;
  _y = y;
  _rgb = 0;
  _mode = EspalexaColorMode::xy;
}

void EspalexaDevice::setColor(uint16_t hue, uint8_t sat)
{
  _hue = hue;
  _sat = sat;
  _rgb = 0;
  _mode = EspalexaColorMode::hs;
}

void EspalexaDevice::setColor(uint16_t ct)
{
  _ct = ct;
  _rgb = 0;
  _mode =EspalexaColorMode::ct;
}

void EspalexaDevice::setColor(uint8_t r, uint8_t g, uint8_t b)
{
  float X = r * 0.664511f + g * 0.154324f + b * 0.162028f;
  float Y = r * 0.283881f + g * 0.668433f + b * 0.047685f;
  float Z = r * 0.000088f + g * 0.072310f + b * 0.986039f;
  _x = X / (X + Y + Z);
  _y = Y / (X + Y + Z);
  _rgb = ((r << 16) | (g << 8) | b);
  _mode = EspalexaColorMode::xy;
}

void EspalexaDevice::doCallback()
{
  if (_callback != nullptr) {_callback(_val); return;}
  if (_callbackDev != nullptr) {_callbackDev(this); return;}
  if (_callbackCol != nullptr) _callbackCol(_val, getRGB());
}
=== ./src/dependencies/espalexa/EspalexaDevice.h ===

#ifndef EspalexaDevice_h
#define EspalexaDevice_h

#include "Arduino.h"
#include <functional>

class EspalexaDevice;

typedef std::function<void(uint8_t b)> BrightnessCallbackFunction;
typedef std::function<void(EspalexaDevice* d)> DeviceCallbackFunction;
typedef std::function<void(uint8_t br, uint32_t col)> ColorCallbackFunction;

enum class EspalexaColorMode : uint8_t { none = 0, ct = 1, hs = 2, xy = 3 };
enum class EspalexaDeviceType : uint8_t { onoff = 0, dimmable = 1, whitespectrum = 2, color = 3, extendedcolor = 4 };
enum class EspalexaDeviceProperty : uint8_t { none = 0, on = 1, off = 2, bri = 3, hs = 4, ct = 5, xy = 6 };

class EspalexaDevice {
private:
  String _deviceName;
  BrightnessCallbackFunction _callback = nullptr;
  DeviceCallbackFunction _callbackDev = nullptr;
  ColorCallbackFunction _callbackCol = nullptr;
  uint8_t _val, _val_last, _sat = 0;
  uint16_t _hue = 0, _ct = 0;
  float _x = 0.5f, _y = 0.5f;
  uint32_t _rgb = 0;
  uint8_t _id = 0;
  EspalexaDeviceType _type;
  EspalexaDeviceProperty _changed = EspalexaDeviceProperty::none;
  EspalexaColorMode _mode = EspalexaColorMode::xy;
  
public:
  EspalexaDevice();
  ~EspalexaDevice();
  EspalexaDevice(String deviceName, BrightnessCallbackFunction bcb, uint8_t initialValue =0);
  EspalexaDevice(String deviceName, DeviceCallbackFunction dcb, EspalexaDeviceType t =EspalexaDeviceType::dimmable, uint8_t initialValue =0);
  EspalexaDevice(String deviceName, ColorCallbackFunction ccb, uint8_t initialValue =0);
  
  String getName();
  uint8_t getId();
  EspalexaDeviceProperty getLastChangedProperty();
  uint8_t getValue();
  uint8_t getLastValue(); //last value that was not off (1-255)
  bool    getState();
  uint8_t getPercent();
  uint8_t getDegrees();
  uint16_t getHue();
  uint8_t getSat();
  uint16_t getCt();
  uint32_t getKelvin();
  float getX();
  float getY();
  uint32_t getRGB();
  uint8_t getR();
  uint8_t getG();
  uint8_t getB();
  uint8_t getW();
  EspalexaColorMode getColorMode();
  EspalexaDeviceType getType();
  
  void setId(uint8_t id);
  void setPropertyChanged(EspalexaDeviceProperty p);
  void setValue(uint8_t bri);
  void setState(bool onoff);
  void setPercent(uint8_t perc);
  void setName(String name);
  void setColor(uint16_t ct);
  void setColor(uint16_t hue, uint8_t sat);
  void setColorXY(float x, float y);
  void setColor(uint8_t r, uint8_t g, uint8_t b);
  
  void doCallback();
};

#endif
=== ./src/dependencies/json/ArduinoJson-v6.h ===

// ArduinoJson - https://arduinojson.org
// Copyright Benoit Blanchon 2014-2021
// MIT License

#pragma once

#ifdef __cplusplus

#if __cplusplus >= 201103L
#  define ARDUINOJSON_HAS_LONG_LONG 1
#  define ARDUINOJSON_HAS_RVALUE_REFERENCES 1
#else
#  define ARDUINOJSON_HAS_LONG_LONG 0
#  define ARDUINOJSON_HAS_RVALUE_REFERENCES 0
#endif
#ifndef ARDUINOJSON_HAS_NULLPTR
#  if __cplusplus >= 201103L
#    define ARDUINOJSON_HAS_NULLPTR 1
#  else
#    define ARDUINOJSON_HAS_NULLPTR 0
#  endif
#endif
#if defined(_MSC_VER) && !ARDUINOJSON_HAS_LONG_LONG
#  define ARDUINOJSON_HAS_INT64 1
#else
#  define ARDUINOJSON_HAS_INT64 0
#endif
#ifndef ARDUINOJSON_EMBEDDED_MODE
#  if defined(ARDUINO)                /* Arduino*/                 \
      || defined(__IAR_SYSTEMS_ICC__) /* IAR Embedded Workbench */ \
      || defined(__XC)                /* MPLAB XC compiler */      \
      || defined(__ARMCC_VERSION)     /* Keil ARM Compiler */      \
      || defined(__AVR)               /* Atmel AVR8/GNU C Compiler */
#    define ARDUINOJSON_EMBEDDED_MODE 1
#  else
#    define ARDUINOJSON_EMBEDDED_MODE 0
#  endif
#endif
#if !defined(ARDUINOJSON_ENABLE_STD_STREAM) && defined(__has_include)
#  if __has_include(<istream>) && \
    __has_include(<ostream>) && \
    !defined(min) && \
    !defined(max)
#    define ARDUINOJSON_ENABLE_STD_STREAM 1
#  else
#    define ARDUINOJSON_ENABLE_STD_STREAM 0
#  endif
#endif
#if !defined(ARDUINOJSON_ENABLE_STD_STRING) && defined(__has_include)
#  if __has_include(<string>) && !defined(min) && !defined(max)
#    define ARDUINOJSON_ENABLE_STD_STRING 1
#  else
#    define ARDUINOJSON_ENABLE_STD_STRING 0
#  endif
#endif
#ifndef ARDUINOJSON_ENABLE_STRING_VIEW
#  ifdef __has_include
#    if __has_include(<string_view>) && __cplusplus >= 201703L
#      define ARDUINOJSON_ENABLE_STRING_VIEW 1
#    endif
#  endif
#endif
#ifndef ARDUINOJSON_ENABLE_STRING_VIEW
#  define ARDUINOJSON_ENABLE_STRING_VIEW 0
#endif
#if ARDUINOJSON_EMBEDDED_MODE
#  ifndef ARDUINOJSON_USE_DOUBLE
#    define ARDUINOJSON_USE_DOUBLE 0
#  endif
#  ifndef ARDUINOJSON_USE_LONG_LONG
#    define ARDUINOJSON_USE_LONG_LONG 0
#  endif
#  ifndef ARDUINOJSON_ENABLE_STD_STRING
#    define ARDUINOJSON_ENABLE_STD_STRING 0
#  endif
#  ifndef ARDUINOJSON_ENABLE_STD_STREAM
#    define ARDUINOJSON_ENABLE_STD_STREAM 0
#  endif
#  ifndef ARDUINOJSON_DEFAULT_NESTING_LIMIT
#    define ARDUINOJSON_DEFAULT_NESTING_LIMIT 10
#  endif
#  ifndef ARDUINOJSON_SLOT_OFFSET_SIZE
#    if defined(__SIZEOF_POINTER__) && __SIZEOF_POINTER__ == 2
#      define ARDUINOJSON_SLOT_OFFSET_SIZE 1
#    else
#      define ARDUINOJSON_SLOT_OFFSET_SIZE 2
#    endif
#  endif
#else  // ARDUINOJSON_EMBEDDED_MODE
#  ifndef ARDUINOJSON_USE_DOUBLE
#    define ARDUINOJSON_USE_DOUBLE 1
#  endif
#  ifndef ARDUINOJSON_USE_LONG_LONG
#    if ARDUINOJSON_HAS_LONG_LONG || ARDUINOJSON_HAS_INT64
#      define ARDUINOJSON_USE_LONG_LONG 1
#    else
#      define ARDUINOJSON_USE_LONG_LONG 0
#    endif
#  endif
#  ifndef ARDUINOJSON_ENABLE_STD_STRING
#    define ARDUINOJSON_ENABLE_STD_STRING 1
#  endif
#  ifndef ARDUINOJSON_ENABLE_STD_STREAM
#    define ARDUINOJSON_ENABLE_STD_STREAM 1
#  endif
#  ifndef ARDUINOJSON_DEFAULT_NESTING_LIMIT
#    define ARDUINOJSON_DEFAULT_NESTING_LIMIT 50
#  endif
#  ifndef ARDUINOJSON_SLOT_OFFSET_SIZE
#    define ARDUINOJSON_SLOT_OFFSET_SIZE 4
#  endif
#endif  // ARDUINOJSON_EMBEDDED_MODE
#ifdef ARDUINO
#include <Arduino.h>
#  ifndef ARDUINOJSON_ENABLE_ARDUINO_STRING
#    define ARDUINOJSON_ENABLE_ARDUINO_STRING 1
#  endif
#  ifndef ARDUINOJSON_ENABLE_ARDUINO_STREAM
#    define ARDUINOJSON_ENABLE_ARDUINO_STREAM 1
#  endif
#  ifndef ARDUINOJSON_ENABLE_ARDUINO_PRINT
#    define ARDUINOJSON_ENABLE_ARDUINO_PRINT 1
#  endif
#else  // ARDUINO
#  ifndef ARDUINOJSON_ENABLE_ARDUINO_STRING
#    define ARDUINOJSON_ENABLE_ARDUINO_STRING 0
#  endif
#  ifndef ARDUINOJSON_ENABLE_ARDUINO_STREAM
#    define ARDUINOJSON_ENABLE_ARDUINO_STREAM 0
#  endif
#  ifndef ARDUINOJSON_ENABLE_ARDUINO_PRINT
#    define ARDUINOJSON_ENABLE_ARDUINO_PRINT 0
#  endif
#endif  // ARDUINO
#ifndef ARDUINOJSON_ENABLE_PROGMEM
#  if defined(PROGMEM) && defined(pgm_read_byte) && defined(pgm_read_dword) && \
      defined(pgm_read_ptr) && defined(pgm_read_float)
#    define ARDUINOJSON_ENABLE_PROGMEM 1
#  else
#    define ARDUINOJSON_ENABLE_PROGMEM 0
#  endif
#endif
#ifndef ARDUINOJSON_DECODE_UNICODE
#  define ARDUINOJSON_DECODE_UNICODE 1
#endif
#ifndef ARDUINOJSON_ENABLE_COMMENTS
#  define ARDUINOJSON_ENABLE_COMMENTS 0
#endif
#ifndef ARDUINOJSON_ENABLE_NAN
#  define ARDUINOJSON_ENABLE_NAN 0
#endif
#ifndef ARDUINOJSON_ENABLE_INFINITY
#  define ARDUINOJSON_ENABLE_INFINITY 0
#endif
#ifndef ARDUINOJSON_POSITIVE_EXPONENTIATION_THRESHOLD
#  define ARDUINOJSON_POSITIVE_EXPONENTIATION_THRESHOLD 1e7
#endif
#ifndef ARDUINOJSON_NEGATIVE_EXPONENTIATION_THRESHOLD
#  define ARDUINOJSON_NEGATIVE_EXPONENTIATION_THRESHOLD 1e-5
#endif
#ifndef ARDUINOJSON_LITTLE_ENDIAN
#  if defined(_MSC_VER) ||                           \
      (defined(__BYTE_ORDER__) &&                    \
       __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || \
      defined(__LITTLE_ENDIAN__) || defined(__i386) || defined(__x86_64)
#    define ARDUINOJSON_LITTLE_ENDIAN 1
#  else
#    define ARDUINOJSON_LITTLE_ENDIAN 0
#  endif
#endif
#ifndef ARDUINOJSON_ENABLE_ALIGNMENT
#  if defined(__AVR)
#    define ARDUINOJSON_ENABLE_ALIGNMENT 0
#  else
#    define ARDUINOJSON_ENABLE_ALIGNMENT 1
#  endif
#endif
#ifndef ARDUINOJSON_TAB
#  define ARDUINOJSON_TAB "  "
#endif
#ifndef ARDUINOJSON_ENABLE_STRING_DEDUPLICATION
#  define ARDUINOJSON_ENABLE_STRING_DEDUPLICATION 1
#endif
#ifndef ARDUINOJSON_STRING_BUFFER_SIZE
#  define ARDUINOJSON_STRING_BUFFER_SIZE 32
#endif
#ifndef ARDUINOJSON_DEBUG
#  ifdef __PLATFORMIO_BUILD_DEBUG__
#    define ARDUINOJSON_DEBUG 1
#  else
#    define ARDUINOJSON_DEBUG 0
#  endif
#endif
#if ARDUINOJSON_HAS_NULLPTR && defined(nullptr)
#  error nullptr is defined as a macro. Remove the faulty #define or #undef nullptr
#endif
#if !ARDUINOJSON_DEBUG
#  ifdef __clang__
#    pragma clang system_header
#  elif defined __GNUC__
#    pragma GCC system_header
#  endif
#endif
#define ARDUINOJSON_EXPAND6(a, b, c, d, e, f) a, b, c, d, e, f
#define ARDUINOJSON_EXPAND9(a, b, c, d, e, f, g, h, i) a, b, c, d, e, f, g, h, i
#define ARDUINOJSON_EXPAND18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, \
                             q, r)                                           \
  a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r
#define ARDUINOJSON_CONCAT_(A, B) A##B
#define ARDUINOJSON_CONCAT2(A, B) ARDUINOJSON_CONCAT_(A, B)
#define ARDUINOJSON_CONCAT4(A, B, C, D) \
  ARDUINOJSON_CONCAT2(ARDUINOJSON_CONCAT2(A, B), ARDUINOJSON_CONCAT2(C, D))
#define ARDUINOJSON_HEX_DIGIT_0000() 0
#define ARDUINOJSON_HEX_DIGIT_0001() 1
#define ARDUINOJSON_HEX_DIGIT_0010() 2
#define ARDUINOJSON_HEX_DIGIT_0011() 3
#define ARDUINOJSON_HEX_DIGIT_0100() 4
#define ARDUINOJSON_HEX_DIGIT_0101() 5
#define ARDUINOJSON_HEX_DIGIT_0110() 6
#define ARDUINOJSON_HEX_DIGIT_0111() 7
#define ARDUINOJSON_HEX_DIGIT_1000() 8
#define ARDUINOJSON_HEX_DIGIT_1001() 9
#define ARDUINOJSON_HEX_DIGIT_1010() A
#define ARDUINOJSON_HEX_DIGIT_1011() B
#define ARDUINOJSON_HEX_DIGIT_1100() C
#define ARDUINOJSON_HEX_DIGIT_1101() D
#define ARDUINOJSON_HEX_DIGIT_1110() E
#define ARDUINOJSON_HEX_DIGIT_1111() F
#define ARDUINOJSON_HEX_DIGIT_(A, B, C, D) ARDUINOJSON_HEX_DIGIT_##A##B##C##D()
#define ARDUINOJSON_HEX_DIGIT(A, B, C, D) ARDUINOJSON_HEX_DIGIT_(A, B, C, D)
#define ARDUINOJSON_VERSION "6.18.1"
#define ARDUINOJSON_VERSION_MAJOR 6
#define ARDUINOJSON_VERSION_MINOR 18
#define ARDUINOJSON_VERSION_REVISION 1
#ifndef ARDUINOJSON_NAMESPACE
#  define ARDUINOJSON_NAMESPACE                                               \
    ARDUINOJSON_CONCAT4(                                                      \
        ARDUINOJSON_CONCAT4(ArduinoJson, ARDUINOJSON_VERSION_MAJOR,           \
                            ARDUINOJSON_VERSION_MINOR,                        \
                            ARDUINOJSON_VERSION_REVISION),                    \
        _,                                                                    \
        ARDUINOJSON_HEX_DIGIT(                                                \
            ARDUINOJSON_ENABLE_PROGMEM, ARDUINOJSON_USE_LONG_LONG,            \
            ARDUINOJSON_USE_DOUBLE, ARDUINOJSON_ENABLE_STRING_DEDUPLICATION), \
        ARDUINOJSON_HEX_DIGIT(                                                \
            ARDUINOJSON_ENABLE_NAN, ARDUINOJSON_ENABLE_INFINITY,              \
            ARDUINOJSON_ENABLE_COMMENTS, ARDUINOJSON_DECODE_UNICODE))
#endif
#if ARDUINOJSON_DEBUG
#include <assert.h>
#  define ARDUINOJSON_ASSERT(X) assert(X)
#else
#  define ARDUINOJSON_ASSERT(X) ((void)0)
#endif
#include <stddef.h>
namespace ARDUINOJSON_NAMESPACE {
class MemoryPool;
class VariantData;
class VariantSlot;
class CollectionData {
  VariantSlot *_head;
  VariantSlot *_tail;
 public:
  VariantData *addElement(MemoryPool *pool);
  VariantData *getElement(size_t index) const;
  VariantData *getOrAddElement(size_t index, MemoryPool *pool);
  void removeElement(size_t index);
  bool equalsArray(const CollectionData &other) const;
  template <typename TAdaptedString>
  VariantData *addMember(TAdaptedString key, MemoryPool *pool);
  template <typename TAdaptedString>
  VariantData *getMember(TAdaptedString key) const;
  template <typename TAdaptedString>
  VariantData *getOrAddMember(TAdaptedString key, MemoryPool *pool);
  template <typename TAdaptedString>
  void removeMember(TAdaptedString key) {
    removeSlot(getSlot(key));
  }
  template <typename TAdaptedString>
  bool containsKey(const TAdaptedString &key) const;
  bool equalsObject(const CollectionData &other) const;
  void clear();
  size_t memoryUsage() const;
  size_t nesting() const;
  size_t size() const;
  VariantSlot *addSlot(MemoryPool *);
  void removeSlot(VariantSlot *slot);
  bool copyFrom(const CollectionData &src, MemoryPool *pool);
  VariantSlot *head() const {
    return _head;
  }
  void movePointers(ptrdiff_t stringDistance, ptrdiff_t variantDistance);
 private:
  VariantSlot *getSlot(size_t index) const;
  template <typename TAdaptedString>
  VariantSlot *getSlot(TAdaptedString key) const;
  VariantSlot *getPreviousSlot(VariantSlot *) const;
};
inline VariantData *arrayAdd(CollectionData *arr, MemoryPool *pool) {
  return arr ? arr->addElement(pool) : 0;
}
template <typename TVisitor>
inline typename TVisitor::result_type arrayAccept(const CollectionData *arr,
                                                  TVisitor &visitor) {
  if (arr)
    return visitor.visitArray(*arr);
  else
    return visitor.visitNull();
}
inline bool arrayEquals(const CollectionData *lhs, const CollectionData *rhs) {
  if (lhs == rhs)
    return true;
  if (!lhs || !rhs)
    return false;
  return lhs->equalsArray(*rhs);
}
#if ARDUINOJSON_ENABLE_ALIGNMENT
inline bool isAligned(size_t value) {
  const size_t mask = sizeof(void *) - 1;
  size_t addr = value;
  return (addr & mask) == 0;
}
inline size_t addPadding(size_t bytes) {
  const size_t mask = sizeof(void *) - 1;
  return (bytes + mask) & ~mask;
}
template <size_t bytes>
struct AddPadding {
  static const size_t mask = sizeof(void *) - 1;
  static const size_t value = (bytes + mask) & ~mask;
};
#else
inline bool isAligned(size_t) {
  return true;
}
inline size_t addPadding(size_t bytes) {
  return bytes;
}
template <size_t bytes>
struct AddPadding {
  static const size_t value = bytes;
};
#endif
template <typename T>
inline bool isAligned(T *ptr) {
  return isAligned(reinterpret_cast<size_t>(ptr));
}
template <typename T>
inline T *addPadding(T *p) {
  size_t address = addPadding(reinterpret_cast<size_t>(p));
  return reinterpret_cast<T *>(address);
}
template <size_t X, size_t Y, bool MaxIsX = (X > Y)>
struct Max {};
template <size_t X, size_t Y>
struct Max<X, Y, true> {
  static const size_t value = X;
};
template <size_t X, size_t Y>
struct Max<X, Y, false> {
  static const size_t value = Y;
};
}  // namespace ARDUINOJSON_NAMESPACE
#include <string.h>
#include <stdint.h>
namespace ARDUINOJSON_NAMESPACE {
inline int safe_strcmp(const char* a, const char* b) {
  if (a == b)
    return 0;
  if (!a)
    return -1;
  if (!b)
    return 1;
  return strcmp(a, b);
}
inline int safe_strncmp(const char* a, const char* b, size_t n) {
  if (a == b)
    return 0;
  if (!a)
    return -1;
  if (!b)
    return 1;
  return strncmp(a, b, n);
}
template <bool Condition, class TrueType, class FalseType>
struct conditional {
  typedef TrueType type;
};
template <class TrueType, class FalseType>
struct conditional<false, TrueType, FalseType> {
  typedef FalseType type;
};
template <bool Condition, typename T = void>
struct enable_if {};
template <typename T>
struct enable_if<true, T> {
  typedef T type;
};
template <typename T, T v>
struct integral_constant {
  static const T value = v;
};
typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;
template <typename T>
struct is_array : false_type {};
template <typename T>
struct is_array<T[]> : true_type {};
template <typename T, size_t N>
struct is_array<T[N]> : true_type {};
template <typename TBase, typename TDerived>
class is_base_of {
 protected:  // <- to avoid GCC's "all member functions in class are private"
  typedef char Yes[1];
  typedef char No[2];
  static Yes &probe(const TBase *);
  static No &probe(...);
 public:
  static const bool value =
      sizeof(probe(reinterpret_cast<TDerived *>(0))) == sizeof(Yes);
};
template <typename T>
T declval();
template <typename T>
struct is_class {
 protected:  // <- to avoid GCC's "all member functions in class are private"
  typedef char Yes[1];
  typedef char No[2];
  template <typename U>
  static Yes &probe(void (U::*)(void));
  template <typename>
  static No &probe(...);
 public:
  static const bool value = sizeof(probe<T>(0)) == sizeof(Yes);
};
template <typename T>
struct is_const : false_type {};
template <typename T>
struct is_const<const T> : true_type {};
}  // namespace ARDUINOJSON_NAMESPACE
#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable : 4244)
#endif
#ifdef __ICCARM__
#pragma diag_suppress=Pa093
#endif
namespace ARDUINOJSON_NAMESPACE {
template <typename From, typename To>
struct is_convertible {
 protected:  // <- to avoid GCC's "all member functions in class are private"
  typedef char Yes[1];
  typedef char No[2];
  static Yes &probe(To);
  static No &probe(...);
 public:
  static const bool value = sizeof(probe(declval<From>())) == sizeof(Yes);
};
}  // namespace ARDUINOJSON_NAMESPACE
#ifdef _MSC_VER
#  pragma warning(pop)
#endif
#ifdef __ICCARM__
#pragma diag_default=Pa093
#endif
namespace ARDUINOJSON_NAMESPACE {
template <typename T, typename U>
struct is_same : false_type {};
template <typename T>
struct is_same<T, T> : true_type {};
template <typename T>
struct remove_cv {
  typedef T type;
};
template <typename T>
struct remove_cv<const T> {
  typedef T type;
};
template <typename T>
struct remove_cv<volatile T> {
  typedef T type;
};
template <typename T>
struct remove_cv<const volatile T> {
  typedef T type;
};
template <class T>
struct is_floating_point
    : integral_constant<
          bool,  //
          is_same<float, typename remove_cv<T>::type>::value ||
              is_same<double, typename remove_cv<T>::type>::value> {};
template <typename T>
struct is_integral : integral_constant<bool,
    is_same<typename remove_cv<T>::type, signed char>::value ||
    is_same<typename remove_cv<T>::type, unsigned char>::value ||
    is_same<typename remove_cv<T>::type, signed short>::value ||
    is_same<typename remove_cv<T>::type, unsigned short>::value ||
    is_same<typename remove_cv<T>::type, signed int>::value ||
    is_same<typename remove_cv<T>::type, unsigned int>::value ||
    is_same<typename remove_cv<T>::type, signed long>::value ||
    is_same<typename remove_cv<T>::type, unsigned long>::value ||
#if ARDUINOJSON_HAS_LONG_LONG
    is_same<typename remove_cv<T>::type, signed long long>::value ||
    is_same<typename remove_cv<T>::type, unsigned long long>::value ||
#endif
#if ARDUINOJSON_HAS_INT64
    is_same<typename remove_cv<T>::type, signed __int64>::value ||
    is_same<typename remove_cv<T>::type, unsigned __int64>::value ||
#endif
    is_same<typename remove_cv<T>::type, char>::value ||
    is_same<typename remove_cv<T>::type, bool>::value> {};
template <typename T>
struct is_enum {
  static const bool value = is_convertible<T, int>::value &&
                            !is_class<T>::value && !is_integral<T>::value &&
                            !is_floating_point<T>::value;
};
template <typename T>
struct is_pointer : false_type {};
template <typename T>
struct is_pointer<T*> : true_type {};
template <typename T>
struct is_signed : integral_constant<bool, 
    is_same<typename remove_cv<T>::type, char>::value ||
    is_same<typename remove_cv<T>::type, signed char>::value ||
    is_same<typename remove_cv<T>::type, signed short>::value ||
    is_same<typename remove_cv<T>::type, signed int>::value ||
    is_same<typename remove_cv<T>::type, signed long>::value ||
#if ARDUINOJSON_HAS_LONG_LONG
    is_same<typename remove_cv<T>::type, signed long long>::value ||
#endif
#if ARDUINOJSON_HAS_INT64
    is_same<typename remove_cv<T>::type, signed __int64>::value ||
#endif
    is_same<typename remove_cv<T>::type, float>::value ||
    is_same<typename remove_cv<T>::type, double>::value> {};
template <typename T>
struct is_unsigned : integral_constant<bool,
    is_same<typename remove_cv<T>::type, unsigned char>::value ||
    is_same<typename remove_cv<T>::type, unsigned short>::value ||
    is_same<typename remove_cv<T>::type, unsigned int>::value ||
    is_same<typename remove_cv<T>::type, unsigned long>::value ||
#if ARDUINOJSON_HAS_INT64
    is_same<typename remove_cv<T>::type, unsigned __int64>::value ||
#endif
#if ARDUINOJSON_HAS_LONG_LONG
    is_same<typename remove_cv<T>::type, unsigned long long>::value ||
#endif
    is_same<typename remove_cv<T>::type, bool>::value> {};
template <typename T>
struct type_identity {
  typedef T type;
};
template <typename T>
struct make_unsigned;
template <>
struct make_unsigned<char> : type_identity<unsigned char> {};
template <>
struct make_unsigned<signed char> : type_identity<unsigned char> {};
template <>
struct make_unsigned<unsigned char> : type_identity<unsigned char> {};
template <>
struct make_unsigned<signed short> : type_identity<unsigned short> {};
template <>
struct make_unsigned<unsigned short> : type_identity<unsigned short> {};
template <>
struct make_unsigned<signed int> : type_identity<unsigned int> {};
template <>
struct make_unsigned<unsigned int> : type_identity<unsigned int> {};
template <>
struct make_unsigned<signed long> : type_identity<unsigned long> {};
template <>
struct make_unsigned<unsigned long> : type_identity<unsigned long> {};
#if ARDUINOJSON_HAS_LONG_LONG
template <>
struct make_unsigned<signed long long> : type_identity<unsigned long long> {};
template <>
struct make_unsigned<unsigned long long> : type_identity<unsigned long long> {};
#endif
#if ARDUINOJSON_HAS_INT64
template <>
struct make_unsigned<signed __int64> : type_identity<unsigned __int64> {};
template <>
struct make_unsigned<unsigned __int64> : type_identity<unsigned __int64> {};
#endif
template <typename T>
struct remove_const {
  typedef T type;
};
template <typename T>
struct remove_const<const T> {
  typedef T type;
};
template <typename T>
struct remove_reference {
  typedef T type;
};
template <typename T>
struct remove_reference<T&> {
  typedef T type;
};
template <typename>
struct IsString : false_type {};
template <typename T>
struct IsString<const T> : IsString<T> {};
template <typename T>
struct IsString<T&> : IsString<T> {};
namespace storage_policies {
struct store_by_address {};
struct store_by_copy {};
struct decide_at_runtime {};
}  // namespace storage_policies
class ConstRamStringAdapter {
 public:
  ConstRamStringAdapter(const char* str = 0) : _str(str) {}
  int compare(const char* other) const {
    return safe_strcmp(_str, other);
  }
  bool equals(const char* expected) const {
    return compare(expected) == 0;
  }
  bool isNull() const {
    return !_str;
  }
  size_t size() const {
    if (!_str)
      return 0;
    return strlen(_str);
  }
  const char* data() const {
    return _str;
  }
  typedef storage_policies::store_by_address storage_policy;
 protected:
  const char* _str;
};
template <>
struct IsString<const char*> : true_type {};
template <int N>
struct IsString<const char[N]> : true_type {};
inline ConstRamStringAdapter adaptString(const char* str) {
  return ConstRamStringAdapter(str);
}
class RamStringAdapter : public ConstRamStringAdapter {
 public:
  RamStringAdapter(const char* str) : ConstRamStringAdapter(str) {}
  void copyTo(char* p, size_t n) const {
    memcpy(p, _str, n);
  }
  typedef ARDUINOJSON_NAMESPACE::storage_policies::store_by_copy storage_policy;
};
template <typename TChar>
inline RamStringAdapter adaptString(const TChar* str) {
  return RamStringAdapter(reinterpret_cast<const char*>(str));
}
inline RamStringAdapter adaptString(char* str) {
  return RamStringAdapter(str);
}
template <typename TChar>
struct IsString<TChar*> {
  static const bool value = sizeof(TChar) == 1;
};
template <>
struct IsString<void*> {
  static const bool value = false;
};
class SizedRamStringAdapter {
 public:
  SizedRamStringAdapter(const char* str, size_t n) : _str(str), _size(n) {}
  int compare(const char* other) const {
    return safe_strncmp(_str, other, _size);
  }
  bool equals(const char* expected) const {
    return compare(expected) == 0;
  }
  bool isNull() const {
    return !_str;
  }
  void copyTo(char* p, size_t n) const {
    memcpy(p, _str, n);
  }
  size_t size() const {
    return _size;
  }
  typedef storage_policies::store_by_copy storage_policy;
 private:
  const char* _str;
  size_t _size;
};
template <typename TChar>
inline SizedRamStringAdapter adaptString(const TChar* str, size_t size) {
  return SizedRamStringAdapter(reinterpret_cast<const char*>(str), size);
}
}  // namespace ARDUINOJSON_NAMESPACE
#if ARDUINOJSON_ENABLE_STD_STRING
#include <string>
namespace ARDUINOJSON_NAMESPACE {
template <typename TString>
class StdStringAdapter {
 public:
  StdStringAdapter(const TString& str) : _str(&str) {}
  void copyTo(char* p, size_t n) const {
    memcpy(p, _str->c_str(), n);
  }
  bool isNull() const {
    return false;
  }
  int compare(const char* other) const {
    if (!other)
      return 1;
    return _str->compare(other);
  }
  bool equals(const char* expected) const {
    if (!expected)
      return false;
    return *_str == expected;
  }
  size_t size() const {
    return _str->size();
  }
  typedef storage_policies::store_by_copy storage_policy;
 private:
  const TString* _str;
};
template <typename TCharTraits, typename TAllocator>
struct IsString<std::basic_string<char, TCharTraits, TAllocator> > : true_type {
};
template <typename TCharTraits, typename TAllocator>
inline StdStringAdapter<std::basic_string<char, TCharTraits, TAllocator> >
adaptString(const std::basic_string<char, TCharTraits, TAllocator>& str) {
  return StdStringAdapter<std::basic_string<char, TCharTraits, TAllocator> >(
      str);
}
}  // namespace ARDUINOJSON_NAMESPACE
#endif
#if ARDUINOJSON_ENABLE_STRING_VIEW
#include <string_view>
namespace ARDUINOJSON_NAMESPACE {
class StringViewAdapter {
 public:
  StringViewAdapter(std::string_view str) : _str(str) {}
  void copyTo(char* p, size_t n) const {
    memcpy(p, _str.data(), n);
  }
  bool isNull() const {
    return false;
  }
  int compare(const char* other) const {
    if (!other)
      return 1;
    return _str.compare(other);
  }
  bool equals(const char* expected) const {
    if (!expected)
      return false;
    return _str == expected;
  }
  size_t size() const {
    return _str.size();
  }
  typedef storage_policies::store_by_copy storage_policy;
 private:
  std::string_view _str;
};
template <>
struct IsString<std::string_view> : true_type {};
inline StringViewAdapter adaptString(const std::string_view& str) {
  return StringViewAdapter(str);
}
}  // namespace ARDUINOJSON_NAMESPACE
#endif
#if ARDUINOJSON_ENABLE_ARDUINO_STRING
namespace ARDUINOJSON_NAMESPACE {
class ArduinoStringAdapter {
 public:
  ArduinoStringAdapter(const ::String& str) : _str(&str) {}
  void copyTo(char* p, size_t n) const {
    memcpy(p, _str->c_str(), n);
  }
  bool isNull() const {
    return !_str->c_str();
  }
  int compare(const char* other) const {
    const char* me = _str->c_str();
    return safe_strcmp(me, other);
  }
  bool equals(const char* expected) const {
    return compare(expected) == 0;
  }
  size_t size() const {
    return _str->length();
  }
  typedef storage_policies::store_by_copy storage_policy;
 private:
  const ::String* _str;
};
template <>
struct IsString< ::String> : true_type {};
template <>
struct IsString< ::StringSumHelper> : true_type {};
inline ArduinoStringAdapter adaptString(const ::String& str) {
  return ArduinoStringAdapter(str);
}
}  // namespace ARDUINOJSON_NAMESPACE
#endif
#if ARDUINOJSON_ENABLE_PROGMEM
namespace ARDUINOJSON_NAMESPACE {
struct pgm_p {
  pgm_p(const char* p) : address(p) {}
  const char* address;
};
}  // namespace ARDUINOJSON_NAMESPACE
#ifndef strlen_P
inline size_t strlen_P(ARDUINOJSON_NAMESPACE::pgm_p s) {
  const char* p = s.address;
  ARDUINOJSON_ASSERT(p != NULL);
  while (pgm_read_byte(p)) p++;
  return size_t(p - s.address);
}
#endif
#ifndef strncmp_P
inline int strncmp_P(const char* a, ARDUINOJSON_NAMESPACE::pgm_p b, size_t n) {
  const char* s1 = a;
  const char* s2 = b.address;
  ARDUINOJSON_ASSERT(s1 != NULL);
  ARDUINOJSON_ASSERT(s2 != NULL);
  while (n-- > 0) {
    char c1 = *s1++;
    char c2 = static_cast<char>(pgm_read_byte(s2++));
    if (c1 < c2)
      return -1;
    if (c1 > c2)
      return 1;
    if (c1 == 0 /* and c2 as well */)
      return 0;
  }
  return 0;
}
#endif
#ifndef strcmp_P
inline int strcmp_P(const char* a, ARDUINOJSON_NAMESPACE::pgm_p b) {
  const char* s1 = a;
  const char* s2 = b.address;
  ARDUINOJSON_ASSERT(s1 != NULL);
  ARDUINOJSON_ASSERT(s2 != NULL);
  for (;;) {
    char c1 = *s1++;
    char c2 = static_cast<char>(pgm_read_byte(s2++));
    if (c1 < c2)
      return -1;
    if (c1 > c2)
      return 1;
    if (c1 == 0 /* and c2 as well */)
      return 0;
  }
}
#endif
#ifndef memcpy_P
inline void* memcpy_P(void* dst, ARDUINOJSON_NAMESPACE::pgm_p src, size_t n) {
  uint8_t* d = reinterpret_cast<uint8_t*>(dst);
  const char* s = src.address;
  ARDUINOJSON_ASSERT(d != NULL);
  ARDUINOJSON_ASSERT(s != NULL);
  while (n-- > 0) {
    *d++ = pgm_read_byte(s++);
  }
  return dst;
}
#endif
namespace ARDUINOJSON_NAMESPACE {
class FlashStringAdapter {
 public:
  FlashStringAdapter(const __FlashStringHelper* str) : _str(str) {}
  int compare(const char* other) const {
    if (!other && !_str)
      return 0;
    if (!_str)
      return -1;
    if (!other)
      return 1;
    return -strcmp_P(other, reinterpret_cast<const char*>(_str));
  }
  bool equals(const char* expected) const {
    return compare(expected) == 0;
  }
  bool isNull() const {
    return !_str;
  }
  void copyTo(char* p, size_t n) const {
    memcpy_P(p, reinterpret_cast<const char*>(_str), n);
  }
  size_t size() const {
    if (!_str)
      return 0;
    return strlen_P(reinterpret_cast<const char*>(_str));
  }
  typedef storage_policies::store_by_copy storage_policy;
 private:
  const __FlashStringHelper* _str;
};
inline FlashStringAdapter adaptString(const __FlashStringHelper* str) {
  return FlashStringAdapter(str);
}
template <>
struct IsString<const __FlashStringHelper*> : true_type {};
class SizedFlashStringAdapter {
 public:
  SizedFlashStringAdapter(const __FlashStringHelper* str, size_t sz)
      : _str(str), _size(sz) {}
  int compare(const char* other) const {
    if (!other && !_str)
      return 0;
    if (!_str)
      return -1;
    if (!other)
      return 1;
    return -strncmp_P(other, reinterpret_cast<const char*>(_str), _size);
  }
  bool equals(const char* expected) const {
    return compare(expected) == 0;
  }
  bool isNull() const {
    return !_str;
  }
  void copyTo(char* p, size_t n) const {
    memcpy_P(p, reinterpret_cast<const char*>(_str), n);
  }
  size_t size() const {
    return _size;
  }
  typedef storage_policies::store_by_copy storage_policy;
 private:
  const __FlashStringHelper* _str;
  size_t _size;
};
inline SizedFlashStringAdapter adaptString(const __FlashStringHelper* str,
                                           size_t sz) {
  return SizedFlashStringAdapter(str, sz);
}
}  // namespace ARDUINOJSON_NAMESPACE
#endif
namespace ARDUINOJSON_NAMESPACE {
template <int Bits>
struct int_t;
template <>
struct int_t<8> {
  typedef int8_t type;
};
template <>
struct int_t<16> {
  typedef int16_t type;
};
template <>
struct int_t<32> {
  typedef int32_t type;
};
}  // namespace ARDUINOJSON_NAMESPACE
#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable : 4310)
#endif
namespace ARDUINOJSON_NAMESPACE {
template <typename T, typename Enable = void>
struct numeric_limits;
template <typename T>
struct numeric_limits<T, typename enable_if<is_unsigned<T>::value>::type> {
  static T lowest() {
    return 0;
  }
  static T highest() {
    return T(-1);
  }
};
template <typename T>
struct numeric_limits<
    T, typename enable_if<is_integral<T>::value && is_signed<T>::value>::type> {
  static T lowest() {
    return T(T(1) << (sizeof(T) * 8 - 1));
  }
  static T highest() {
    return T(~lowest());
  }
};
}  // namespace ARDUINOJSON_NAMESPACE
#ifdef _MSC_VER
#  pragma warning(pop)
#endif
namespace ARDUINOJSON_NAMESPACE {
#if ARDUINOJSON_USE_DOUBLE
typedef double Float;
#else
typedef float Float;
#endif
#if ARDUINOJSON_USE_LONG_LONG
typedef int64_t Integer;
typedef uint64_t UInt;
#else
typedef long Integer;
typedef unsigned long UInt;
#endif
}  // namespace ARDUINOJSON_NAMESPACE
#if ARDUINOJSON_HAS_LONG_LONG && !ARDUINOJSON_USE_LONG_LONG
#  define ARDUINOJSON_ASSERT_INTEGER_TYPE_IS_SUPPORTED(T)                  \
    static_assert(sizeof(T) <= sizeof(ARDUINOJSON_NAMESPACE::Integer),     \
                  "To use 64-bit integers with ArduinoJson, you must set " \
                  "ARDUINOJSON_USE_LONG_LONG to 1. See "                   \
                  "https://arduinojson.org/v6/api/config/use_long_long/");
#else
#  define ARDUINOJSON_ASSERT_INTEGER_TYPE_IS_SUPPORTED(T)
#endif
namespace ARDUINOJSON_NAMESPACE {
enum {
  VALUE_MASK = 0x7F,
  OWNED_VALUE_BIT = 0x01,
  VALUE_IS_NULL = 0,
  VALUE_IS_LINKED_RAW = 0x02,
  VALUE_IS_OWNED_RAW = 0x03,
  VALUE_IS_LINKED_STRING = 0x04,
  VALUE_IS_OWNED_STRING = 0x05,
  VALUE_IS_BOOLEAN = 0x06,
  NUMBER_BIT = 0x08,
  VALUE_IS_UNSIGNED_INTEGER = 0x08,
  VALUE_IS_SIGNED_INTEGER = 0x0A,
  VALUE_IS_FLOAT = 0x0C,
  COLLECTION_MASK = 0x60,
  VALUE_IS_OBJECT = 0x20,
  VALUE_IS_ARRAY = 0x40,
  OWNED_KEY_BIT = 0x80
};
struct RawData {
  const char *data;
  size_t size;
};
union VariantContent {
  Float asFloat;
  bool asBoolean;
  UInt asUnsignedInteger;
  Integer asSignedInteger;
  CollectionData asCollection;
  const char *asString;
  struct {
    const char *data;
    size_t size;
  } asRaw;
};
typedef int_t<ARDUINOJSON_SLOT_OFFSET_SIZE * 8>::type VariantSlotDiff;
class VariantSlot {
  VariantContent _content;
  uint8_t _flags;
  VariantSlotDiff _next;
  const char* _key;
 public:
  VariantData* data() {
    return reinterpret_cast<VariantData*>(&_content);
  }
  const VariantData* data() const {
    return reinterpret_cast<const VariantData*>(&_content);
  }
  VariantSlot* next() {
    return _next ? this + _next : 0;
  }
  const VariantSlot* next() const {
    return const_cast<VariantSlot*>(this)->next();
  }
  VariantSlot* next(size_t distance) {
    VariantSlot* slot = this;
    while (distance--) {
      if (!slot->_next)
        return 0;
      slot += slot->_next;
    }
    return slot;
  }
  const VariantSlot* next(size_t distance) const {
    return const_cast<VariantSlot*>(this)->next(distance);
  }
  void setNext(VariantSlot* slot) {
    ARDUINOJSON_ASSERT(!slot || slot - this >=
                                    numeric_limits<VariantSlotDiff>::lowest());
    ARDUINOJSON_ASSERT(!slot || slot - this <=
                                    numeric_limits<VariantSlotDiff>::highest());
    _next = VariantSlotDiff(slot ? slot - this : 0);
  }
  void setNextNotNull(VariantSlot* slot) {
    ARDUINOJSON_ASSERT(slot != 0);
    ARDUINOJSON_ASSERT(slot - this >=
                       numeric_limits<VariantSlotDiff>::lowest());
    ARDUINOJSON_ASSERT(slot - this <=
                       numeric_limits<VariantSlotDiff>::highest());
    _next = VariantSlotDiff(slot - this);
  }
  void setKey(const char* k, storage_policies::store_by_copy) {
    ARDUINOJSON_ASSERT(k != NULL);
    _flags |= OWNED_KEY_BIT;
    _key = k;
  }
  void setKey(const char* k, storage_policies::store_by_address) {
    ARDUINOJSON_ASSERT(k != NULL);
    _flags &= VALUE_MASK;
    _key = k;
  }
  const char* key() const {
    return _key;
  }
  bool ownsKey() const {
    return (_flags & OWNED_KEY_BIT) != 0;
  }
  void clear() {
    _next = 0;
    _flags = 0;
    _key = 0;
  }
  void movePointers(ptrdiff_t stringDistance, ptrdiff_t variantDistance) {
    if (_flags & OWNED_KEY_BIT)
      _key += stringDistance;
    if (_flags & OWNED_VALUE_BIT)
      _content.asString += stringDistance;
    if (_flags & COLLECTION_MASK)
      _content.asCollection.movePointers(stringDistance, variantDistance);
  }
};
}  // namespace ARDUINOJSON_NAMESPACE
#define JSON_STRING_SIZE(SIZE) (SIZE + 1)
namespace ARDUINOJSON_NAMESPACE {
class MemoryPool {
 public:
  MemoryPool(char* buf, size_t capa)
      : _begin(buf),
        _left(buf),
        _right(buf ? buf + capa : 0),
        _end(buf ? buf + capa : 0),
        _overflowed(false) {
    ARDUINOJSON_ASSERT(isAligned(_begin));
    ARDUINOJSON_ASSERT(isAligned(_right));
    ARDUINOJSON_ASSERT(isAligned(_end));
  }
  void* buffer() {
    return _begin;  // NOLINT(clang-analyzer-unix.Malloc)
  }
  size_t capacity() const {
    return size_t(_end - _begin);
  }
  size_t size() const {
    return size_t(_left - _begin + _end - _right);
  }
  bool overflowed() const {
    return _overflowed;
  }
  VariantSlot* allocVariant() {
    return allocRight<VariantSlot>();
  }
  template <typename TAdaptedString>
  const char* saveString(const TAdaptedString& str) {
    if (str.isNull())
      return 0;
#if ARDUINOJSON_ENABLE_STRING_DEDUPLICATION
    const char* existingCopy = findString(str);
    if (existingCopy)
      return existingCopy;
#endif
    size_t n = str.size();
    char* newCopy = allocString(n + 1);
    if (newCopy) {
      str.copyTo(newCopy, n);
      newCopy[n] = 0;  // force null-terminator
    }
    return newCopy;
  }
  void getFreeZone(char** zoneStart, size_t* zoneSize) const {
    *zoneStart = _left;
    *zoneSize = size_t(_right - _left);
  }
  const char* saveStringFromFreeZone(size_t len) {
#if ARDUINOJSON_ENABLE_STRING_DEDUPLICATION
    const char* dup = findString(adaptString(_left));
    if (dup)
      return dup;
#endif
    const char* str = _left;
    _left += len;
    checkInvariants();
    return str;
  }
  void markAsOverflowed() {
    _overflowed = true;
  }
  void clear() {
    _left = _begin;
    _right = _end;
    _overflowed = false;
  }
  bool canAlloc(size_t bytes) const {
    return _left + bytes <= _right;
  }
  bool owns(void* p) const {
    return _begin <= p && p < _end;
  }
  void* operator new(size_t, void* p) {
    return p;
  }
  ptrdiff_t squash() {
    char* new_right = addPadding(_left);
    if (new_right >= _right)
      return 0;
    size_t right_size = static_cast<size_t>(_end - _right);
    memmove(new_right, _right, right_size);
    ptrdiff_t bytes_reclaimed = _right - new_right;
    _right = new_right;
    _end = new_right + right_size;
    return bytes_reclaimed;
  }
  void movePointers(ptrdiff_t offset) {
    _begin += offset;
    _left += offset;
    _right += offset;
    _end += offset;
  }
 private:
  void checkInvariants() {
    ARDUINOJSON_ASSERT(_begin <= _left);
    ARDUINOJSON_ASSERT(_left <= _right);
    ARDUINOJSON_ASSERT(_right <= _end);
    ARDUINOJSON_ASSERT(isAligned(_right));
  }
#if ARDUINOJSON_ENABLE_STRING_DEDUPLICATION
  template <typename TAdaptedString>
  const char* findString(const TAdaptedString& str) {
    for (char* next = _begin; next < _left; ++next) {
      if (str.equals(next))
        return next;
      while (*next) ++next;
    }
    return 0;
  }
#endif
  char* allocString(size_t n) {
    if (!canAlloc(n)) {
      _overflowed = true;
      return 0;
    }
    char* s = _left;
    _left += n;
    checkInvariants();
    return s;
  }
  template <typename T>
  T* allocRight() {
    return reinterpret_cast<T*>(allocRight(sizeof(T)));
  }
  void* allocRight(size_t bytes) {
    if (!canAlloc(bytes)) {
      _overflowed = true;
      return 0;
    }
    _right -= bytes;
    return _right;
  }
  char *_begin, *_left, *_right, *_end;
  bool _overflowed;
};
template <typename T>
class SerializedValue {
 public:
  explicit SerializedValue(T str) : _str(str) {}
  operator T() const {
    return _str;
  }
  const char* data() const {
    return _str.c_str();
  }
  size_t size() const {
    return _str.length();
  }
 private:
  T _str;
};
template <typename TChar>
class SerializedValue<TChar*> {
 public:
  explicit SerializedValue(TChar* p, size_t n) : _data(p), _size(n) {}
  operator TChar*() const {
    return _data;
  }
  TChar* data() const {
    return _data;
  }
  size_t size() const {
    return _size;
  }
 private:
  TChar* _data;
  size_t _size;
};
template <typename T>
inline SerializedValue<T> serialized(T str) {
  return SerializedValue<T>(str);
}
template <typename TChar>
inline SerializedValue<TChar*> serialized(TChar* p) {
  return SerializedValue<TChar*>(p, adaptString(p).size());
}
template <typename TChar>
inline SerializedValue<TChar*> serialized(TChar* p, size_t n) {
  return SerializedValue<TChar*>(p, n);
}
}  // namespace ARDUINOJSON_NAMESPACE
#if defined(__clang__)
#  pragma clang diagnostic push
#  pragma clang diagnostic ignored "-Wconversion"
#elif defined(__GNUC__)
#  if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
#    pragma GCC diagnostic push
#  endif
#  pragma GCC diagnostic ignored "-Wconversion"
#endif
namespace ARDUINOJSON_NAMESPACE {
template <typename TOut, typename TIn>
typename enable_if<is_integral<TIn>::value && is_unsigned<TIn>::value &&
                       is_integral<TOut>::value && sizeof(TOut) <= sizeof(TIn),
                   bool>::type
canConvertNumber(TIn value) {
  return value <= TIn(numeric_limits<TOut>::highest());
}
template <typename TOut, typename TIn>
typename enable_if<is_integral<TIn>::value && is_unsigned<TIn>::value &&
                       is_integral<TOut>::value && sizeof(TIn) < sizeof(TOut),
                   bool>::type
canConvertNumber(TIn) {
  return true;
}
template <typename TOut, typename TIn>
typename enable_if<is_integral<TIn>::value && is_floating_point<TOut>::value,
                   bool>::type
canConvertNumber(TIn) {
  return true;
}
template <typename TOut, typename TIn>
typename enable_if<is_integral<TIn>::value && is_signed<TIn>::value &&
                       is_integral<TOut>::value && is_signed<TOut>::value &&
                       sizeof(TOut) < sizeof(TIn),
                   bool>::type
canConvertNumber(TIn value) {
  return value >= TIn(numeric_limits<TOut>::lowest()) &&
         value <= TIn(numeric_limits<TOut>::highest());
}
template <typename TOut, typename TIn>
typename enable_if<is_integral<TIn>::value && is_signed<TIn>::value &&
                       is_integral<TOut>::value && is_signed<TOut>::value &&
                       sizeof(TIn) <= sizeof(TOut),
                   bool>::type
canConvertNumber(TIn) {
  return true;
}
template <typename TOut, typename TIn>
typename enable_if<is_integral<TIn>::value && is_signed<TIn>::value &&
                       is_integral<TOut>::value && is_unsigned<TOut>::value &&
                       sizeof(TOut) >= sizeof(TIn),
                   bool>::type
canConvertNumber(TIn value) {
  if (value < 0)
    return false;
  return TOut(value) <= numeric_limits<TOut>::highest();
}
template <typename TOut, typename TIn>
typename enable_if<is_integral<TIn>::value && is_signed<TIn>::value &&
                       is_integral<TOut>::value && is_unsigned<TOut>::value &&
                       sizeof(TOut) < sizeof(TIn),
                   bool>::type
canConvertNumber(TIn value) {
  if (value < 0)
    return false;
  return value <= TIn(numeric_limits<TOut>::highest());
}
template <typename TOut, typename TIn>
typename enable_if<is_floating_point<TIn>::value &&
                       !is_floating_point<TOut>::value,
                   bool>::type
canConvertNumber(TIn value) {
  return value >= numeric_limits<TOut>::lowest() &&
         value <= numeric_limits<TOut>::highest();
}
template <typename TOut, typename TIn>
TOut convertNumber(TIn value) {
  return canConvertNumber<TOut>(value) ? TOut(value) : 0;
}
}  // namespace ARDUINOJSON_NAMESPACE
#if defined(__clang__)
#  pragma clang diagnostic pop
#elif defined(__GNUC__)
#  if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
#    pragma GCC diagnostic pop
#  endif
#endif
#if defined(__GNUC__)
#  if __GNUC__ >= 7
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
#    pragma GCC diagnostic ignored "-Wuninitialized"
#  endif
#endif
namespace ARDUINOJSON_NAMESPACE {
class VariantData {
  VariantContent _content;  // must be first to allow cast from array to variant
  uint8_t _flags;
 public:
  void init() {
    _flags = VALUE_IS_NULL;
  }
  template <typename TVisitor>
  typename TVisitor::result_type accept(TVisitor &visitor) const {
    switch (type()) {
      case VALUE_IS_FLOAT:
        return visitor.visitFloat(_content.asFloat);
      case VALUE_IS_ARRAY:
        return visitor.visitArray(_content.asCollection);
      case VALUE_IS_OBJECT:
        return visitor.visitObject(_content.asCollection);
      case VALUE_IS_LINKED_STRING:
      case VALUE_IS_OWNED_STRING:
        return visitor.visitString(_content.asString);
      case VALUE_IS_OWNED_RAW:
      case VALUE_IS_LINKED_RAW:
        return visitor.visitRawJson(_content.asRaw.data, _content.asRaw.size);
      case VALUE_IS_SIGNED_INTEGER:
        return visitor.visitSignedInteger(_content.asSignedInteger);
      case VALUE_IS_UNSIGNED_INTEGER:
        return visitor.visitUnsignedInteger(_content.asUnsignedInteger);
      case VALUE_IS_BOOLEAN:
        return visitor.visitBoolean(_content.asBoolean != 0);
      default:
        return visitor.visitNull();
    }
  }
  template <typename T>
  T asIntegral() const;
  template <typename T>
  T asFloat() const;
  const char *asString() const;
  bool asBoolean() const;
  CollectionData *asArray() {
    return isArray() ? &_content.asCollection : 0;
  }
  const CollectionData *asArray() const {
    return const_cast<VariantData *>(this)->asArray();
  }
  CollectionData *asObject() {
    return isObject() ? &_content.asCollection : 0;
  }
  const CollectionData *asObject() const {
    return const_cast<VariantData *>(this)->asObject();
  }
  bool copyFrom(const VariantData &src, MemoryPool *pool) {
    switch (src.type()) {
      case VALUE_IS_ARRAY:
        return toArray().copyFrom(src._content.asCollection, pool);
      case VALUE_IS_OBJECT:
        return toObject().copyFrom(src._content.asCollection, pool);
      case VALUE_IS_OWNED_STRING:
        return setString(RamStringAdapter(src._content.asString), pool);
      case VALUE_IS_OWNED_RAW:
        return setOwnedRaw(
            serialized(src._content.asRaw.data, src._content.asRaw.size), pool);
      default:
        setType(src.type());
        _content = src._content;
        return true;
    }
  }
  bool isArray() const {
    return (_flags & VALUE_IS_ARRAY) != 0;
  }
  bool isBoolean() const {
    return type() == VALUE_IS_BOOLEAN;
  }
  bool isCollection() const {
    return (_flags & COLLECTION_MASK) != 0;
  }
  template <typename T>
  bool isInteger() const {
    switch (type()) {
      case VALUE_IS_UNSIGNED_INTEGER:
        return canConvertNumber<T>(_content.asUnsignedInteger);
      case VALUE_IS_SIGNED_INTEGER:
        return canConvertNumber<T>(_content.asSignedInteger);
      default:
        return false;
    }
  }
  bool isFloat() const {
    return (_flags & NUMBER_BIT) != 0;
  }
  bool isString() const {
    return type() == VALUE_IS_LINKED_STRING || type() == VALUE_IS_OWNED_STRING;
  }
  bool isObject() const {
    return (_flags & VALUE_IS_OBJECT) != 0;
  }
  bool isNull() const {
    return type() == VALUE_IS_NULL;
  }
  bool isEnclosed() const {
    return !isFloat();
  }
  void remove(size_t index) {
    if (isArray())
      _content.asCollection.removeElement(index);
  }
  template <typename TAdaptedString>
  void remove(TAdaptedString key) {
    if (isObject())
      _content.asCollection.removeMember(key);
  }
  void setBoolean(bool value) {
    setType(VALUE_IS_BOOLEAN);
    _content.asBoolean = value;
  }
  void setFloat(Float value) {
    setType(VALUE_IS_FLOAT);
    _content.asFloat = value;
  }
  void setLinkedRaw(SerializedValue<const char *> value) {
    if (value.data()) {
      setType(VALUE_IS_LINKED_RAW);
      _content.asRaw.data = value.data();
      _content.asRaw.size = value.size();
    } else {
      setType(VALUE_IS_NULL);
    }
  }
  template <typename T>
  bool setOwnedRaw(SerializedValue<T> value, MemoryPool *pool) {
    const char *dup = pool->saveString(adaptString(value.data(), value.size()));
    if (dup) {
      setType(VALUE_IS_OWNED_RAW);
      _content.asRaw.data = dup;
      _content.asRaw.size = value.size();
      return true;
    } else {
      setType(VALUE_IS_NULL);
      return false;
    }
  }
  template <typename T>
  typename enable_if<is_unsigned<T>::value>::type setInteger(T value) {
    setType(VALUE_IS_UNSIGNED_INTEGER);
    _content.asUnsignedInteger = static_cast<UInt>(value);
  }
  template <typename T>
  typename enable_if<is_signed<T>::value>::type setInteger(T value) {
    setType(VALUE_IS_SIGNED_INTEGER);
    _content.asSignedInteger = value;
  }
  void setNull() {
    setType(VALUE_IS_NULL);
  }
  void setStringPointer(const char *s, storage_policies::store_by_copy) {
    ARDUINOJSON_ASSERT(s != 0);
    setType(VALUE_IS_OWNED_STRING);
    _content.asString = s;
  }
  void setStringPointer(const char *s, storage_policies::store_by_address) {
    ARDUINOJSON_ASSERT(s != 0);
    setType(VALUE_IS_LINKED_STRING);
    _content.asString = s;
  }
  template <typename TAdaptedString>
  bool setString(TAdaptedString value, MemoryPool *pool) {
    return storeString(value, pool, typename TAdaptedString::storage_policy());
  }
  CollectionData &toArray() {
    setType(VALUE_IS_ARRAY);
    _content.asCollection.clear();
    return _content.asCollection;
  }
  CollectionData &toObject() {
    setType(VALUE_IS_OBJECT);
    _content.asCollection.clear();
    return _content.asCollection;
  }
  size_t memoryUsage() const {
    switch (type()) {
      case VALUE_IS_OWNED_STRING:
        return strlen(_content.asString) + 1;
      case VALUE_IS_OWNED_RAW:
        return _content.asRaw.size;
      case VALUE_IS_OBJECT:
      case VALUE_IS_ARRAY:
        return _content.asCollection.memoryUsage();
      default:
        return 0;
    }
  }
  size_t nesting() const {
    return isCollection() ? _content.asCollection.nesting() : 0;
  }
  size_t size() const {
    return isCollection() ? _content.asCollection.size() : 0;
  }
  VariantData *addElement(MemoryPool *pool) {
    if (isNull())
      toArray();
    if (!isArray())
      return 0;
    return _content.asCollection.addElement(pool);
  }
  VariantData *getElement(size_t index) const {
    return isArray() ? _content.asCollection.getElement(index) : 0;
  }
  VariantData *getOrAddElement(size_t index, MemoryPool *pool) {
    if (isNull())
      toArray();
    if (!isArray())
      return 0;
    return _content.asCollection.getOrAddElement(index, pool);
  }
  template <typename TAdaptedString>
  VariantData *getMember(TAdaptedString key) const {
    return isObject() ? _content.asCollection.getMember(key) : 0;
  }
  template <typename TAdaptedString>
  VariantData *getOrAddMember(TAdaptedString key, MemoryPool *pool) {
    if (isNull())
      toObject();
    if (!isObject())
      return 0;
    return _content.asCollection.getOrAddMember(key, pool);
  }
  void movePointers(ptrdiff_t stringDistance, ptrdiff_t variantDistance) {
    if (_flags & OWNED_VALUE_BIT)
      _content.asString += stringDistance;
    if (_flags & COLLECTION_MASK)
      _content.asCollection.movePointers(stringDistance, variantDistance);
  }
  uint8_t type() const {
    return _flags & VALUE_MASK;
  }
 private:
  void setType(uint8_t t) {
    _flags &= OWNED_KEY_BIT;
    _flags |= t;
  }
  template <typename TAdaptedString>
  inline bool storeString(TAdaptedString value, MemoryPool *pool,
                          storage_policies::decide_at_runtime) {
    if (value.isStatic())
      return storeString(value, pool, storage_policies::store_by_address());
    else
      return storeString(value, pool, storage_policies::store_by_copy());
  }
  template <typename TAdaptedString>
  inline bool storeString(TAdaptedString value, MemoryPool *,
                          storage_policies::store_by_address) {
    if (value.isNull())
      setNull();
    else
      setStringPointer(value.data(), storage_policies::store_by_address());
    return true;
  }
  template <typename TAdaptedString>
  inline bool storeString(TAdaptedString value, MemoryPool *pool,
                          storage_policies::store_by_copy) {
    if (value.isNull()) {
      setNull();
      return true;
    }
    const char *copy = pool->saveString(value);
    if (!copy) {
      setNull();
      return false;
    }
    setStringPointer(copy, storage_policies::store_by_copy());
    return true;
  }
};
}  // namespace ARDUINOJSON_NAMESPACE
#if defined(__GNUC__)
#  if __GNUC__ >= 8
#    pragma GCC diagnostic pop
#  endif
#endif
namespace ARDUINOJSON_NAMESPACE {
template <typename TAdaptedString>
inline bool slotSetKey(VariantSlot* var, TAdaptedString key, MemoryPool* pool) {
  if (!var)
    return false;
  return slotSetKey(var, key, pool, typename TAdaptedString::storage_policy());
}
template <typename TAdaptedString>
inline bool slotSetKey(VariantSlot* var, TAdaptedString key, MemoryPool* pool,
                       storage_policies::decide_at_runtime) {
  if (key.isStatic()) {
    return slotSetKey(var, key, pool, storage_policies::store_by_address());
  } else {
    return slotSetKey(var, key, pool, storage_policies::store_by_copy());
  }
}
template <typename TAdaptedString>
inline bool slotSetKey(VariantSlot* var, TAdaptedString key, MemoryPool*,
                       storage_policies::store_by_address) {
  ARDUINOJSON_ASSERT(var);
  var->setKey(key.data(), storage_policies::store_by_address());
  return true;
}
template <typename TAdaptedString>
inline bool slotSetKey(VariantSlot* var, TAdaptedString key, MemoryPool* pool,
                       storage_policies::store_by_copy) {
  const char* dup = pool->saveString(key);
  if (!dup)
    return false;
  ARDUINOJSON_ASSERT(var);
  var->setKey(dup, storage_policies::store_by_copy());
  return true;
}
inline size_t slotSize(const VariantSlot* var) {
  size_t n = 0;
  while (var) {
    n++;
    var = var->next();
  }
  return n;
}
inline VariantData* slotData(VariantSlot* slot) {
  return reinterpret_cast<VariantData*>(slot);
}
struct Visitable {
};
template <typename T>
struct IsVisitable : is_base_of<Visitable, T> {};
template <typename T>
struct IsVisitable<T &> : IsVisitable<T> {};
template <typename T, typename Enable = void>
struct Converter;
template <typename T1, typename T2>
class InvalidConversion;  // Error here? See https://arduinojson.org/v6/invalid-conversion/
}  // namespace ARDUINOJSON_NAMESPACE
#ifdef _MSC_VER  // Visual Studio
#  define FORCE_INLINE  // __forceinline causes C4714 when returning std::string
#  define NO_INLINE __declspec(noinline)
#  ifndef ARDUINOJSON_DEPRECATED
#    define ARDUINOJSON_DEPRECATED(msg) __declspec(deprecated(msg))
#  endif
#elif defined(__GNUC__)  // GCC or Clang
#  define FORCE_INLINE __attribute__((always_inline))
#  define NO_INLINE __attribute__((noinline))
#  ifndef ARDUINOJSON_DEPRECATED
#    if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
#      define ARDUINOJSON_DEPRECATED(msg) __attribute__((deprecated(msg)))
#    else
#      define ARDUINOJSON_DEPRECATED(msg) __attribute__((deprecated))
#    endif
#  endif
#else  // Other compilers
#  define FORCE_INLINE
#  define NO_INLINE
#  ifndef ARDUINOJSON_DEPRECATED
#    define ARDUINOJSON_DEPRECATED(msg)
#  endif
#endif
#if __cplusplus >= 201103L
#  define NOEXCEPT noexcept
#else
#  define NOEXCEPT throw()
#endif
#if defined(__has_attribute)
#  if __has_attribute(no_sanitize)
#    define ARDUINOJSON_NO_SANITIZE(check) __attribute__((no_sanitize(check)))
#  else
#    define ARDUINOJSON_NO_SANITIZE(check)
#  endif
#else
#  define ARDUINOJSON_NO_SANITIZE(check)
#endif
namespace ARDUINOJSON_NAMESPACE {
template <typename TVisitor>
inline typename TVisitor::result_type variantAccept(const VariantData *var,
                                                    TVisitor &visitor) {
  if (var != 0)
    return var->accept(visitor);
  else
    return visitor.visitNull();
}
inline const CollectionData *variantAsArray(const VariantData *var) {
  return var != 0 ? var->asArray() : 0;
}
inline const CollectionData *variantAsObject(const VariantData *var) {
  return var != 0 ? var->asObject() : 0;
}
inline CollectionData *variantAsObject(VariantData *var) {
  return var != 0 ? var->asObject() : 0;
}
inline bool variantCopyFrom(VariantData *dst, const VariantData *src,
                            MemoryPool *pool) {
  if (!dst)
    return false;
  if (!src) {
    dst->setNull();
    return true;
  }
  return dst->copyFrom(*src, pool);
}
inline int variantCompare(const VariantData *a, const VariantData *b);
inline void variantSetNull(VariantData *var) {
  if (!var)
    return;
  var->setNull();
}
template <typename TAdaptedString>
inline bool variantSetString(VariantData *var, TAdaptedString value,
                             MemoryPool *pool) {
  if (!var)
    return false;
  return var->setString(value, pool);
}
inline size_t variantSize(const VariantData *var) {
  return var != 0 ? var->size() : 0;
}
inline CollectionData *variantToArray(VariantData *var) {
  if (!var)
    return 0;
  return &var->toArray();
}
inline CollectionData *variantToObject(VariantData *var) {
  if (!var)
    return 0;
  return &var->toObject();
}
inline NO_INLINE VariantData *variantAddElement(VariantData *var,
                                                MemoryPool *pool) {
  return var != 0 ? var->addElement(pool) : 0;
}
inline NO_INLINE VariantData *variantGetOrAddElement(VariantData *var,
                                                     size_t index,
                                                     MemoryPool *pool) {
  return var != 0 ? var->getOrAddElement(index, pool) : 0;
}
template <typename TChar>
NO_INLINE VariantData *variantGetOrAddMember(VariantData *var, TChar *key,
                                             MemoryPool *pool) {
  return var != 0 ? var->getOrAddMember(adaptString(key), pool) : 0;
}
template <typename TString>
NO_INLINE VariantData *variantGetOrAddMember(VariantData *var,
                                             const TString &key,
                                             MemoryPool *pool) {
  return var != 0 ? var->getOrAddMember(adaptString(key), pool) : 0;
}
inline bool variantIsNull(const VariantData *var) {
  return var == 0 || var->isNull();
}
enum CompareResult {
  COMPARE_RESULT_DIFFER = 0,
  COMPARE_RESULT_EQUAL = 1,
  COMPARE_RESULT_GREATER = 2,
  COMPARE_RESULT_LESS = 4,
  COMPARE_RESULT_GREATER_OR_EQUAL = 3,
  COMPARE_RESULT_LESS_OR_EQUAL = 5
};
template <typename T>
CompareResult arithmeticCompare(const T &lhs, const T &rhs) {
  if (lhs < rhs)
    return COMPARE_RESULT_LESS;
  else if (lhs > rhs)
    return COMPARE_RESULT_GREATER;
  else
    return COMPARE_RESULT_EQUAL;
}
template <typename T1, typename T2>
CompareResult arithmeticCompare(
    const T1 &lhs, const T2 &rhs,
    typename enable_if<is_integral<T1>::value && is_integral<T2>::value &&
                           sizeof(T1) < sizeof(T2),
                       int  // Using int instead of void to avoid C2572 on
                       >::type * = 0) {
  return arithmeticCompare<T2>(static_cast<T2>(lhs), rhs);
}
template <typename T1, typename T2>
CompareResult arithmeticCompare(
    const T1 &lhs, const T2 &rhs,
    typename enable_if<is_integral<T1>::value && is_integral<T2>::value &&
                       sizeof(T2) < sizeof(T1)>::type * = 0) {
  return arithmeticCompare<T1>(lhs, static_cast<T1>(rhs));
}
template <typename T1, typename T2>
CompareResult arithmeticCompare(
    const T1 &lhs, const T2 &rhs,
    typename enable_if<is_integral<T1>::value && is_integral<T2>::value &&
                       is_signed<T1>::value == is_signed<T2>::value &&
                       sizeof(T2) == sizeof(T1)>::type * = 0) {
  return arithmeticCompare<T1>(lhs, static_cast<T1>(rhs));
}
template <typename T1, typename T2>
CompareResult arithmeticCompare(
    const T1 &lhs, const T2 &rhs,
    typename enable_if<is_integral<T1>::value && is_integral<T2>::value &&
                       is_unsigned<T1>::value && is_signed<T2>::value &&
                       sizeof(T2) == sizeof(T1)>::type * = 0) {
  if (rhs < 0)
    return COMPARE_RESULT_GREATER;
  return arithmeticCompare<T1>(lhs, static_cast<T1>(rhs));
}
template <typename T1, typename T2>
CompareResult arithmeticCompare(
    const T1 &lhs, const T2 &rhs,
    typename enable_if<is_integral<T1>::value && is_integral<T2>::value &&
                       is_signed<T1>::value && is_unsigned<T2>::value &&
                       sizeof(T2) == sizeof(T1)>::type * = 0) {
  if (lhs < 0)
    return COMPARE_RESULT_LESS;
  return arithmeticCompare<T2>(static_cast<T2>(lhs), rhs);
}
template <typename T1, typename T2>
CompareResult arithmeticCompare(
    const T1 &lhs, const T2 &rhs,
    typename enable_if<is_floating_point<T1>::value ||
                       is_floating_point<T2>::value>::type * = 0) {
  return arithmeticCompare<double>(static_cast<double>(lhs),
                                   static_cast<double>(rhs));
}
template <typename T2>
CompareResult arithmeticCompareNegateLeft(
    UInt, const T2 &, typename enable_if<is_unsigned<T2>::value>::type * = 0) {
  return COMPARE_RESULT_LESS;
}
template <typename T2>
CompareResult arithmeticCompareNegateLeft(
    UInt lhs, const T2 &rhs,
    typename enable_if<is_signed<T2>::value>::type * = 0) {
  if (rhs > 0)
    return COMPARE_RESULT_LESS;
  return arithmeticCompare(-rhs, static_cast<T2>(lhs));
}
template <typename T1>
CompareResult arithmeticCompareNegateRight(
    const T1 &, UInt, typename enable_if<is_unsigned<T1>::value>::type * = 0) {
  return COMPARE_RESULT_GREATER;
}
template <typename T1>
CompareResult arithmeticCompareNegateRight(
    const T1 &lhs, UInt rhs,
    typename enable_if<is_signed<T1>::value>::type * = 0) {
  if (lhs > 0)
    return COMPARE_RESULT_GREATER;
  return arithmeticCompare(static_cast<T1>(rhs), -lhs);
}
struct VariantTag {};
template <typename T>
struct IsVariant : is_base_of<VariantTag, T> {};
template <typename T1, typename T2>
CompareResult compare(const T1 &lhs, const T2 &rhs);  // VariantCompare.cpp
template <typename TVariant>
struct VariantOperators {
  template <typename T>
  friend
      typename enable_if<!IsVariant<T>::value && !is_array<T>::value, T>::type
      operator|(const TVariant &variant, const T &defaultValue) {
    if (variant.template is<T>())
      return variant.template as<T>();
    else
      return defaultValue;
  }
  friend const char *operator|(const TVariant &variant,
                               const char *defaultValue) {
    if (variant.template is<const char *>())
      return variant.template as<const char *>();
    else
      return defaultValue;
  }
  template <typename T>
  friend typename enable_if<IsVariant<T>::value, typename T::variant_type>::type
  operator|(const TVariant &variant, T defaultValue) {
    if (variant)
      return variant;
    else
      return defaultValue;
  }
  template <typename T>
  friend bool operator==(T *lhs, TVariant rhs) {
    return compare(rhs, lhs) == COMPARE_RESULT_EQUAL;
  }
  template <typename T>
  friend bool operator==(const T &lhs, TVariant rhs) {
    return compare(rhs, lhs) == COMPARE_RESULT_EQUAL;
  }
  template <typename T>
  friend bool operator==(TVariant lhs, T *rhs) {
    return compare(lhs, rhs) == COMPARE_RESULT_EQUAL;
  }
  template <typename T>
  friend typename enable_if<!IsVisitable<T>::value, bool>::type operator==(
      TVariant lhs, const T &rhs) {
    return compare(lhs, rhs) == COMPARE_RESULT_EQUAL;
  }
  template <typename T>
  friend bool operator!=(T *lhs, TVariant rhs) {
    return compare(rhs, lhs) != COMPARE_RESULT_EQUAL;
  }
  template <typename T>
  friend bool operator!=(const T &lhs, TVariant rhs) {
    return compare(rhs, lhs) != COMPARE_RESULT_EQUAL;
  }
  template <typename T>
  friend bool operator!=(TVariant lhs, T *rhs) {
    return compare(lhs, rhs) != COMPARE_RESULT_EQUAL;
  }
  template <typename T>
  friend typename enable_if<!IsVisitable<T>::value, bool>::type operator!=(
      TVariant lhs, const T &rhs) {
    return compare(lhs, rhs) != COMPARE_RESULT_EQUAL;
  }
  template <typename T>
  friend bool operator<(T *lhs, TVariant rhs) {
    return compare(rhs, lhs) == COMPARE_RESULT_GREATER;
  }
  template <typename T>
  friend bool operator<(const T &lhs, TVariant rhs) {
    return compare(rhs, lhs) == COMPARE_RESULT_GREATER;
  }
  template <typename T>
  friend bool operator<(TVariant lhs, T *rhs) {
    return compare(lhs, rhs) == COMPARE_RESULT_LESS;
  }
  template <typename T>
  friend typename enable_if<!IsVisitable<T>::value, bool>::type operator<(
      TVariant lhs, const T &rhs) {
    return compare(lhs, rhs) == COMPARE_RESULT_LESS;
  }
  template <typename T>
  friend bool operator<=(T *lhs, TVariant rhs) {
    return (compare(rhs, lhs) & COMPARE_RESULT_GREATER_OR_EQUAL) != 0;
  }
  template <typename T>
  friend bool operator<=(const T &lhs, TVariant rhs) {
    return (compare(rhs, lhs) & COMPARE_RESULT_GREATER_OR_EQUAL) != 0;
  }
  template <typename T>
  friend bool operator<=(TVariant lhs, T *rhs) {
    return (compare(lhs, rhs) & COMPARE_RESULT_LESS_OR_EQUAL) != 0;
  }
  template <typename T>
  friend typename enable_if<!IsVisitable<T>::value, bool>::type operator<=(
      TVariant lhs, const T &rhs) {
    return (compare(lhs, rhs) & COMPARE_RESULT_LESS_OR_EQUAL) != 0;
  }
  template <typename T>
  friend bool operator>(T *lhs, TVariant rhs) {
    return compare(rhs, lhs) == COMPARE_RESULT_LESS;
  }
  template <typename T>
  friend bool operator>(const T &lhs, TVariant rhs) {
    return compare(rhs, lhs) == COMPARE_RESULT_LESS;
  }
  template <typename T>
  friend bool operator>(TVariant lhs, T *rhs) {
    return compare(lhs, rhs) == COMPARE_RESULT_GREATER;
  }
  template <typename T>
  friend typename enable_if<!IsVisitable<T>::value, bool>::type operator>(
      TVariant lhs, const T &rhs) {
    return compare(lhs, rhs) == COMPARE_RESULT_GREATER;
  }
  template <typename T>
  friend bool operator>=(T *lhs, TVariant rhs) {
    return (compare(rhs, lhs) & COMPARE_RESULT_LESS_OR_EQUAL) != 0;
  }
  template <typename T>
  friend bool operator>=(const T &lhs, TVariant rhs) {
    return (compare(rhs, lhs) & COMPARE_RESULT_LESS_OR_EQUAL) != 0;
  }
  template <typename T>
  friend bool operator>=(TVariant lhs, T *rhs) {
    return (compare(lhs, rhs) & COMPARE_RESULT_GREATER_OR_EQUAL) != 0;
  }
  template <typename T>
  friend typename enable_if<!IsVisitable<T>::value, bool>::type operator>=(
      TVariant lhs, const T &rhs) {
    return (compare(lhs, rhs) & COMPARE_RESULT_GREATER_OR_EQUAL) != 0;
  }
};
class ArrayRef;
class ObjectRef;
template <typename>
class ElementProxy;
template <typename TArray>
class ArrayShortcuts {
 public:
  FORCE_INLINE ElementProxy<TArray> operator[](size_t index) const;
  FORCE_INLINE ObjectRef createNestedObject() const;
  FORCE_INLINE ArrayRef createNestedArray() const;
  template <typename T>
  FORCE_INLINE bool add(const T &value) const {
    return impl()->addElement().set(value);
  }
  template <typename T>
  FORCE_INLINE bool add(T *value) const {
    return impl()->addElement().set(value);
  }
 private:
  const TArray *impl() const {
    return static_cast<const TArray *>(this);
  }
};
template <typename TParent, typename TStringRef>
class MemberProxy;
template <typename TObject>
class ObjectShortcuts {
 public:
  template <typename TString>
  FORCE_INLINE typename enable_if<IsString<TString>::value, bool>::type
  containsKey(const TString &key) const;
  template <typename TChar>
  FORCE_INLINE typename enable_if<IsString<TChar *>::value, bool>::type
  containsKey(TChar *key) const;
  template <typename TString>
  FORCE_INLINE typename enable_if<IsString<TString>::value,
                                  MemberProxy<TObject, TString> >::type
  operator[](const TString &key) const;
  template <typename TChar>
  FORCE_INLINE typename enable_if<IsString<TChar *>::value,
                                  MemberProxy<TObject, TChar *> >::type
  operator[](TChar *key) const;
  template <typename TString>
  FORCE_INLINE ArrayRef createNestedArray(const TString &key) const;
  template <typename TChar>
  FORCE_INLINE ArrayRef createNestedArray(TChar *key) const;
  template <typename TString>
  ObjectRef createNestedObject(const TString &key) const;
  template <typename TChar>
  ObjectRef createNestedObject(TChar *key) const;
 private:
  const TObject *impl() const {
    return static_cast<const TObject *>(this);
  }
};
template <typename TVariant>
class VariantShortcuts : public ObjectShortcuts<TVariant>,
                         public ArrayShortcuts<TVariant> {
 public:
  using ArrayShortcuts<TVariant>::createNestedArray;
  using ArrayShortcuts<TVariant>::createNestedObject;
  using ArrayShortcuts<TVariant>::operator[];
  using ObjectShortcuts<TVariant>::createNestedArray;
  using ObjectShortcuts<TVariant>::createNestedObject;
  using ObjectShortcuts<TVariant>::operator[];
};
class ArrayRef;
class ObjectRef;
template <typename TData>
class VariantRefBase : public VariantTag {
 public:
  FORCE_INLINE bool isNull() const {
    return variantIsNull(_data);
  }
  FORCE_INLINE bool isUndefined() const {
    return !_data;
  }
  FORCE_INLINE size_t memoryUsage() const {
    return _data ? _data->memoryUsage() : 0;
  }
  FORCE_INLINE size_t nesting() const {
    return _data ? _data->nesting() : 0;
  }
  size_t size() const {
    return variantSize(_data);
  }
 protected:
  VariantRefBase(TData *data) : _data(data) {}
  TData *_data;
  friend TData *getData(const VariantRefBase &variant) {
    return variant._data;
  }
};
class VariantRef : public VariantRefBase<VariantData>,
                   public VariantOperators<VariantRef>,
                   public VariantShortcuts<VariantRef>,
                   public Visitable {
  typedef VariantRefBase<VariantData> base_type;
  friend class VariantConstRef;
 public:
  FORCE_INLINE VariantRef(MemoryPool *pool, VariantData *data)
      : base_type(data), _pool(pool) {}
  FORCE_INLINE VariantRef() : base_type(0), _pool(0) {}
  FORCE_INLINE void clear() const {
    return variantSetNull(_data);
  }
  template <typename T>
  FORCE_INLINE bool set(const T &value) const {
    return Converter<T>::toJson(value, *this);
  }
  bool ARDUINOJSON_DEPRECATED(
      "Support for char is deprecated, use int8_t or uint8_t instead")
      set(char value) const;
  template <typename T>
  FORCE_INLINE bool set(T *value) const {
    return Converter<T *>::toJson(value, *this);
  }
  template <typename T>
  FORCE_INLINE
      typename enable_if<!is_same<T, char *>::value && !is_same<T, char>::value,
                         T>::type
      as() const {
    return Converter<T>::fromJson(*this);
  }
  template <typename T>
  FORCE_INLINE typename enable_if<is_same<T, char *>::value, const char *>::type
  ARDUINOJSON_DEPRECATED("Replace as<char*>() with as<const char*>()")
      as() const {
    return as<const char *>();
  }
  template <typename T>
  FORCE_INLINE typename enable_if<is_same<T, char>::value, char>::type
  ARDUINOJSON_DEPRECATED(
      "Support for char is deprecated, use int8_t or uint8_t instead")
      as() const {
    return as<signed char>();
  }
  template <typename T>
  FORCE_INLINE
      typename enable_if<!is_same<T, char *>::value && !is_same<T, char>::value,
                         bool>::type
      is() const {
    return Converter<T>::checkJson(*this);
  }
  template <typename T>
  FORCE_INLINE typename enable_if<is_same<T, char *>::value, bool>::type
  ARDUINOJSON_DEPRECATED("Replace is<char*>() with is<const char*>()")
      is() const {
    return is<const char *>();
  }
  template <typename T>
  FORCE_INLINE typename enable_if<is_same<T, char>::value, bool>::type
  ARDUINOJSON_DEPRECATED(
      "Support for char is deprecated, use int8_t or uint8_t instead")
      is() const {
    return is<signed char>();
  }
  template <typename T>
  FORCE_INLINE operator T() const {
    return as<T>();
  }
  template <typename TVisitor>
  typename TVisitor::result_type accept(TVisitor &visitor) const {
    return variantAccept(_data, visitor);
  }
  template <typename T>
  typename enable_if<is_same<T, ArrayRef>::value, ArrayRef>::type to() const;
  template <typename T>
  typename enable_if<is_same<T, ObjectRef>::value, ObjectRef>::type to() const;
  template <typename T>
  typename enable_if<is_same<T, VariantRef>::value, VariantRef>::type to()
      const;
  VariantRef addElement() const;
  FORCE_INLINE VariantRef getElement(size_t) const;
  FORCE_INLINE VariantRef getOrAddElement(size_t) const;
  template <typename TChar>
  FORCE_INLINE VariantRef getMember(TChar *) const;
  template <typename TString>
  FORCE_INLINE typename enable_if<IsString<TString>::value, VariantRef>::type
  getMember(const TString &) const;
  template <typename TChar>
  FORCE_INLINE VariantRef getOrAddMember(TChar *) const;
  template <typename TString>
  FORCE_INLINE VariantRef getOrAddMember(const TString &) const;
  FORCE_INLINE void remove(size_t index) const {
    if (_data)
      _data->remove(index);
  }
  template <typename TChar>
  FORCE_INLINE typename enable_if<IsString<TChar *>::value>::type remove(
      TChar *key) const {
    if (_data)
      _data->remove(adaptString(key));
  }
  template <typename TString>
  FORCE_INLINE typename enable_if<IsString<TString>::value>::type remove(
      const TString &key) const {
    if (_data)
      _data->remove(adaptString(key));
  }
 private:
  MemoryPool *_pool;
  friend MemoryPool *getPool(const VariantRef &variant) {
    return variant._pool;
  }
};
class VariantConstRef : public VariantRefBase<const VariantData>,
                        public VariantOperators<VariantConstRef>,
                        public VariantShortcuts<VariantConstRef>,
                        public Visitable {
  typedef VariantRefBase<const VariantData> base_type;
  friend class VariantRef;
 public:
  VariantConstRef() : base_type(0) {}
  VariantConstRef(const VariantData *data) : base_type(data) {}
  VariantConstRef(VariantRef var) : base_type(var._data) {}
  template <typename TVisitor>
  typename TVisitor::result_type accept(TVisitor &visitor) const {
    return variantAccept(_data, visitor);
  }
  template <typename T>
  FORCE_INLINE
      typename enable_if<!is_same<T, char *>::value && !is_same<T, char>::value,
                         T>::type
      as() const {
    return Converter<T>::fromJson(*this);
  }
  template <typename T>
  FORCE_INLINE typename enable_if<is_same<T, char *>::value, const char *>::type
  ARDUINOJSON_DEPRECATED("Replace as<char*>() with as<const char*>()")
      as() const {
    return as<const char *>();
  }
  template <typename T>
  FORCE_INLINE typename enable_if<is_same<T, char>::value, char>::type
  ARDUINOJSON_DEPRECATED(
      "Support for char is deprecated, use int8_t or uint8_t instead")
      as() const {
    return as<signed char>();
  }
  template <typename T>
  FORCE_INLINE
      typename enable_if<!is_same<T, char *>::value && !is_same<T, char>::value,
                         bool>::type
      is() const {
    return Converter<T>::checkJson(*this);
  }
  template <typename T>
  FORCE_INLINE typename enable_if<is_same<T, char *>::value, bool>::type
  ARDUINOJSON_DEPRECATED("Replace is<char*>() with is<const char*>()")
      is() const {
    return is<const char *>();
  }
  template <typename T>
  FORCE_INLINE typename enable_if<is_same<T, char>::value, bool>::type
  ARDUINOJSON_DEPRECATED(
      "Support for char is deprecated, use int8_t or uint8_t instead")
      is() const {
    return is<signed char>();
  }
  template <typename T>
  FORCE_INLINE operator T() const {
    return as<T>();
  }
  FORCE_INLINE VariantConstRef getElement(size_t) const;
  FORCE_INLINE VariantConstRef operator[](size_t index) const {
    return getElement(index);
  }
  template <typename TString>
  FORCE_INLINE VariantConstRef getMember(const TString &key) const {
    return VariantConstRef(
        objectGetMember(variantAsObject(_data), adaptString(key)));
  }
  template <typename TChar>
  FORCE_INLINE VariantConstRef getMember(TChar *key) const {
    const CollectionData *obj = variantAsObject(_data);
    return VariantConstRef(obj ? obj->getMember(adaptString(key)) : 0);
  }
  template <typename TString>
  FORCE_INLINE
      typename enable_if<IsString<TString>::value, VariantConstRef>::type
      operator[](const TString &key) const {
    return getMember(key);
  }
  template <typename TChar>
  FORCE_INLINE
      typename enable_if<IsString<TChar *>::value, VariantConstRef>::type
      operator[](TChar *key) const {
    return getMember(key);
  }
};
template <>
struct Converter<VariantRef> {
  static bool toJson(VariantRef src, VariantRef dst) {
    return variantCopyFrom(getData(dst), getData(src), getPool(dst));
  }
  static VariantRef fromJson(VariantRef src) {
    return src;
  }
  static InvalidConversion<VariantConstRef, VariantRef> fromJson(
      VariantConstRef);
  static bool checkJson(VariantRef src) {
    VariantData *data = getData(src);
    return !!data;
  }
  static bool checkJson(VariantConstRef) {
    return false;
  }
};
template <>
struct Converter<VariantConstRef> {
  static bool toJson(VariantConstRef src, VariantRef dst) {
    return variantCopyFrom(getData(dst), getData(src), getPool(dst));
  }
  static VariantConstRef fromJson(VariantConstRef src) {
    return VariantConstRef(getData(src));
  }
  static bool checkJson(VariantConstRef src) {
    const VariantData *data = getData(src);
    return !!data;
  }
};
class VariantPtr {
 public:
  VariantPtr(MemoryPool *pool, VariantData *data) : _variant(pool, data) {}
  VariantRef *operator->() {
    return &_variant;
  }
  VariantRef &operator*() {
    return _variant;
  }
 private:
  VariantRef _variant;
};
class ArrayIterator {
 public:
  ArrayIterator() : _slot(0) {}
  explicit ArrayIterator(MemoryPool *pool, VariantSlot *slot)
      : _pool(pool), _slot(slot) {}
  VariantRef operator*() const {
    return VariantRef(_pool, _slot->data());
  }
  VariantPtr operator->() {
    return VariantPtr(_pool, _slot->data());
  }
  bool operator==(const ArrayIterator &other) const {
    return _slot == other._slot;
  }
  bool operator!=(const ArrayIterator &other) const {
    return _slot != other._slot;
  }
  ArrayIterator &operator++() {
    _slot = _slot->next();
    return *this;
  }
  ArrayIterator &operator+=(size_t distance) {
    _slot = _slot->next(distance);
    return *this;
  }
  VariantSlot *internal() {
    return _slot;
  }
 private:
  MemoryPool *_pool;
  VariantSlot *_slot;
};
class VariantConstPtr {
 public:
  VariantConstPtr(const VariantData *data) : _variant(data) {}
  VariantConstRef *operator->() {
    return &_variant;
  }
  VariantConstRef &operator*() {
    return _variant;
  }
 private:
  VariantConstRef _variant;
};
class ArrayConstRefIterator {
 public:
  ArrayConstRefIterator() : _slot(0) {}
  explicit ArrayConstRefIterator(const VariantSlot *slot) : _slot(slot) {}
  VariantConstRef operator*() const {
    return VariantConstRef(_slot->data());
  }
  VariantConstPtr operator->() {
    return VariantConstPtr(_slot->data());
  }
  bool operator==(const ArrayConstRefIterator &other) const {
    return _slot == other._slot;
  }
  bool operator!=(const ArrayConstRefIterator &other) const {
    return _slot != other._slot;
  }
  ArrayConstRefIterator &operator++() {
    _slot = _slot->next();
    return *this;
  }
  ArrayConstRefIterator &operator+=(size_t distance) {
    _slot = _slot->next(distance);
    return *this;
  }
  const VariantSlot *internal() {
    return _slot;
  }
 private:
  const VariantSlot *_slot;
};
}  // namespace ARDUINOJSON_NAMESPACE
#define JSON_ARRAY_SIZE(NUMBER_OF_ELEMENTS) \
  ((NUMBER_OF_ELEMENTS) * sizeof(ARDUINOJSON_NAMESPACE::VariantSlot))
namespace ARDUINOJSON_NAMESPACE {
class ObjectRef;
template <typename>
class ElementProxy;
template <typename TData>
class ArrayRefBase {
 public:
  operator VariantConstRef() const {
    const void* data = _data;  // prevent warning cast-align
    return VariantConstRef(reinterpret_cast<const VariantData*>(data));
  }
  template <typename TVisitor>
  FORCE_INLINE typename TVisitor::result_type accept(TVisitor& visitor) const {
    return arrayAccept(_data, visitor);
  }
  FORCE_INLINE bool isNull() const {
    return _data == 0;
  }
  FORCE_INLINE operator bool() const {
    return _data != 0;
  }
  FORCE_INLINE size_t memoryUsage() const {
    return _data ? _data->memoryUsage() : 0;
  }
  FORCE_INLINE size_t nesting() const {
    return _data ? _data->nesting() : 0;
  }
  FORCE_INLINE size_t size() const {
    return _data ? _data->size() : 0;
  }
 protected:
  ArrayRefBase(TData* data) : _data(data) {}
  TData* _data;
};
class ArrayConstRef : public ArrayRefBase<const CollectionData>,
                      public Visitable {
  friend class ArrayRef;
  typedef ArrayRefBase<const CollectionData> base_type;
 public:
  typedef ArrayConstRefIterator iterator;
  FORCE_INLINE iterator begin() const {
    if (!_data)
      return iterator();
    return iterator(_data->head());
  }
  FORCE_INLINE iterator end() const {
    return iterator();
  }
  FORCE_INLINE ArrayConstRef() : base_type(0) {}
  FORCE_INLINE ArrayConstRef(const CollectionData* data) : base_type(data) {}
  FORCE_INLINE bool operator==(ArrayConstRef rhs) const {
    return arrayEquals(_data, rhs._data);
  }
  FORCE_INLINE VariantConstRef operator[](size_t index) const {
    return getElement(index);
  }
  FORCE_INLINE VariantConstRef getElement(size_t index) const {
    return VariantConstRef(_data ? _data->getElement(index) : 0);
  }
};
class ArrayRef : public ArrayRefBase<CollectionData>,
                 public ArrayShortcuts<ArrayRef>,
                 public Visitable {
  typedef ArrayRefBase<CollectionData> base_type;
 public:
  typedef ArrayIterator iterator;
  FORCE_INLINE ArrayRef() : base_type(0), _pool(0) {}
  FORCE_INLINE ArrayRef(MemoryPool* pool, CollectionData* data)
      : base_type(data), _pool(pool) {}
  operator VariantRef() {
    void* data = _data;  // prevent warning cast-align
    return VariantRef(_pool, reinterpret_cast<VariantData*>(data));
  }
  operator ArrayConstRef() const {
    return ArrayConstRef(_data);
  }
  VariantRef addElement() const {
    return VariantRef(_pool, arrayAdd(_data, _pool));
  }
  FORCE_INLINE iterator begin() const {
    if (!_data)
      return iterator();
    return iterator(_pool, _data->head());
  }
  FORCE_INLINE iterator end() const {
    return iterator();
  }
  FORCE_INLINE bool set(ArrayConstRef src) const {
    if (!_data || !src._data)
      return false;
    return _data->copyFrom(*src._data, _pool);
  }
  FORCE_INLINE bool operator==(ArrayRef rhs) const {
    return arrayEquals(_data, rhs._data);
  }
  FORCE_INLINE VariantRef getOrAddElement(size_t index) const {
    return VariantRef(_pool, _data ? _data->getOrAddElement(index, _pool) : 0);
  }
  FORCE_INLINE VariantRef getElement(size_t index) const {
    return VariantRef(_pool, _data ? _data->getElement(index) : 0);
  }
  FORCE_INLINE void remove(iterator it) const {
    if (!_data)
      return;
    _data->removeSlot(it.internal());
  }
  FORCE_INLINE void remove(size_t index) const {
    if (!_data)
      return;
    _data->removeElement(index);
  }
  void clear() const {
    if (!_data)
      return;
    _data->clear();
  }
 private:
  MemoryPool* _pool;
};
template <>
struct Converter<ArrayConstRef> {
  static bool toJson(VariantConstRef src, VariantRef dst) {
    return variantCopyFrom(getData(dst), getData(src), getPool(dst));
  }
  static ArrayConstRef fromJson(VariantConstRef src) {
    return ArrayConstRef(variantAsArray(getData(src)));
  }
  static bool checkJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data && data->isArray();
  }
};
template <>
struct Converter<ArrayRef> {
  static bool toJson(VariantConstRef src, VariantRef dst) {
    return variantCopyFrom(getData(dst), getData(src), getPool(dst));
  }
  static ArrayRef fromJson(VariantRef src) {
    VariantData* data = getData(src);
    MemoryPool* pool = getPool(src);
    return ArrayRef(pool, data != 0 ? data->asArray() : 0);
  }
  static InvalidConversion<VariantConstRef, ArrayRef> fromJson(VariantConstRef);
  static bool checkJson(VariantConstRef) {
    return false;
  }
  static bool checkJson(VariantRef src) {
    VariantData* data = getData(src);
    return data && data->isArray();
  }
};
template <typename TVisitor>
typename TVisitor::result_type objectAccept(const CollectionData *obj,
                                            TVisitor &visitor) {
  if (obj)
    return visitor.visitObject(*obj);
  else
    return visitor.visitNull();
}
inline bool objectEquals(const CollectionData *lhs, const CollectionData *rhs) {
  if (lhs == rhs)
    return true;
  if (!lhs || !rhs)
    return false;
  return lhs->equalsObject(*rhs);
}
template <typename TAdaptedString>
inline VariantData *objectGetMember(const CollectionData *obj,
                                    TAdaptedString key) {
  if (!obj)
    return 0;
  return obj->getMember(key);
}
template <typename TAdaptedString>
void objectRemove(CollectionData *obj, TAdaptedString key) {
  if (!obj)
    return;
  obj->removeMember(key);
}
template <typename TAdaptedString>
inline VariantData *objectGetOrAddMember(CollectionData *obj,
                                         TAdaptedString key, MemoryPool *pool) {
  if (!obj)
    return 0;
  return obj->getOrAddMember(key, pool);
}
class String {
 public:
  String() : _data(0), _isStatic(true) {}
  String(const char* data, bool isStaticData = true)
      : _data(data), _isStatic(isStaticData) {}
  const char* c_str() const {
    return _data;
  }
  bool isNull() const {
    return !_data;
  }
  bool isStatic() const {
    return _isStatic;
  }
  friend bool operator==(String lhs, String rhs) {
    if (lhs._data == rhs._data)
      return true;
    if (!lhs._data)
      return false;
    if (!rhs._data)
      return false;
    return strcmp(lhs._data, rhs._data) == 0;
  }
  friend bool operator!=(String lhs, String rhs) {
    if (lhs._data == rhs._data)
      return false;
    if (!lhs._data)
      return true;
    if (!rhs._data)
      return true;
    return strcmp(lhs._data, rhs._data) != 0;
  }
 private:
  const char* _data;
  bool _isStatic;
};
class StringAdapter : public RamStringAdapter {
 public:
  StringAdapter(const String& str)
      : RamStringAdapter(str.c_str()), _isStatic(str.isStatic()) {}
  bool isStatic() const {
    return _isStatic;
  }
  typedef storage_policies::decide_at_runtime storage_policy;
 private:
  bool _isStatic;
};
template <>
struct IsString<String> : true_type {};
inline StringAdapter adaptString(const String& str) {
  return StringAdapter(str);
}
class Pair {
 public:
  Pair(MemoryPool* pool, VariantSlot* slot) {
    if (slot) {
      _key = String(slot->key(), !slot->ownsKey());
      _value = VariantRef(pool, slot->data());
    }
  }
  String key() const {
    return _key;
  }
  VariantRef value() const {
    return _value;
  }
 private:
  String _key;
  VariantRef _value;
};
class PairConst {
 public:
  PairConst(const VariantSlot* slot) {
    if (slot) {
      _key = String(slot->key(), !slot->ownsKey());
      _value = VariantConstRef(slot->data());
    }
  }
  String key() const {
    return _key;
  }
  VariantConstRef value() const {
    return _value;
  }
 private:
  String _key;
  VariantConstRef _value;
};
class PairPtr {
 public:
  PairPtr(MemoryPool *pool, VariantSlot *slot) : _pair(pool, slot) {}
  const Pair *operator->() const {
    return &_pair;
  }
  const Pair &operator*() const {
    return _pair;
  }
 private:
  Pair _pair;
};
class ObjectIterator {
 public:
  ObjectIterator() : _slot(0) {}
  explicit ObjectIterator(MemoryPool *pool, VariantSlot *slot)
      : _pool(pool), _slot(slot) {}
  Pair operator*() const {
    return Pair(_pool, _slot);
  }
  PairPtr operator->() {
    return PairPtr(_pool, _slot);
  }
  bool operator==(const ObjectIterator &other) const {
    return _slot == other._slot;
  }
  bool operator!=(const ObjectIterator &other) const {
    return _slot != other._slot;
  }
  ObjectIterator &operator++() {
    _slot = _slot->next();
    return *this;
  }
  ObjectIterator &operator+=(size_t distance) {
    _slot = _slot->next(distance);
    return *this;
  }
  VariantSlot *internal() {
    return _slot;
  }
 private:
  MemoryPool *_pool;
  VariantSlot *_slot;
};
class PairConstPtr {
 public:
  PairConstPtr(const VariantSlot *slot) : _pair(slot) {}
  const PairConst *operator->() const {
    return &_pair;
  }
  const PairConst &operator*() const {
    return _pair;
  }
 private:
  PairConst _pair;
};
class ObjectConstIterator {
 public:
  ObjectConstIterator() : _slot(0) {}
  explicit ObjectConstIterator(const VariantSlot *slot) : _slot(slot) {}
  PairConst operator*() const {
    return PairConst(_slot);
  }
  PairConstPtr operator->() {
    return PairConstPtr(_slot);
  }
  bool operator==(const ObjectConstIterator &other) const {
    return _slot == other._slot;
  }
  bool operator!=(const ObjectConstIterator &other) const {
    return _slot != other._slot;
  }
  ObjectConstIterator &operator++() {
    _slot = _slot->next();
    return *this;
  }
  ObjectConstIterator &operator+=(size_t distance) {
    _slot = _slot->next(distance);
    return *this;
  }
  const VariantSlot *internal() {
    return _slot;
  }
 private:
  const VariantSlot *_slot;
};
}  // namespace ARDUINOJSON_NAMESPACE
#define JSON_OBJECT_SIZE(NUMBER_OF_ELEMENTS) \
  ((NUMBER_OF_ELEMENTS) * sizeof(ARDUINOJSON_NAMESPACE::VariantSlot))
namespace ARDUINOJSON_NAMESPACE {
template <typename TData>
class ObjectRefBase {
 public:
  operator VariantConstRef() const {
    const void* data = _data;  // prevent warning cast-align
    return VariantConstRef(reinterpret_cast<const VariantData*>(data));
  }
  template <typename TVisitor>
  typename TVisitor::result_type accept(TVisitor& visitor) const {
    return objectAccept(_data, visitor);
  }
  FORCE_INLINE bool isNull() const {
    return _data == 0;
  }
  FORCE_INLINE operator bool() const {
    return _data != 0;
  }
  FORCE_INLINE size_t memoryUsage() const {
    return _data ? _data->memoryUsage() : 0;
  }
  FORCE_INLINE size_t nesting() const {
    return _data ? _data->nesting() : 0;
  }
  FORCE_INLINE size_t size() const {
    return _data ? _data->size() : 0;
  }
 protected:
  ObjectRefBase(TData* data) : _data(data) {}
  TData* _data;
};
class ObjectConstRef : public ObjectRefBase<const CollectionData>,
                       public Visitable {
  friend class ObjectRef;
  typedef ObjectRefBase<const CollectionData> base_type;
 public:
  typedef ObjectConstIterator iterator;
  ObjectConstRef() : base_type(0) {}
  ObjectConstRef(const CollectionData* data) : base_type(data) {}
  FORCE_INLINE iterator begin() const {
    if (!_data)
      return iterator();
    return iterator(_data->head());
  }
  FORCE_INLINE iterator end() const {
    return iterator();
  }
  template <typename TString>
  FORCE_INLINE bool containsKey(const TString& key) const {
    return !getMember(key).isUndefined();
  }
  template <typename TChar>
  FORCE_INLINE bool containsKey(TChar* key) const {
    return !getMember(key).isUndefined();
  }
  template <typename TString>
  FORCE_INLINE VariantConstRef getMember(const TString& key) const {
    return get_impl(adaptString(key));
  }
  template <typename TChar>
  FORCE_INLINE VariantConstRef getMember(TChar* key) const {
    return get_impl(adaptString(key));
  }
  template <typename TString>
  FORCE_INLINE
      typename enable_if<IsString<TString>::value, VariantConstRef>::type
      operator[](const TString& key) const {
    return get_impl(adaptString(key));
  }
  template <typename TChar>
  FORCE_INLINE
      typename enable_if<IsString<TChar*>::value, VariantConstRef>::type
      operator[](TChar* key) const {
    return get_impl(adaptString(key));
  }
  FORCE_INLINE bool operator==(ObjectConstRef rhs) const {
    return objectEquals(_data, rhs._data);
  }
 private:
  template <typename TAdaptedString>
  FORCE_INLINE VariantConstRef get_impl(TAdaptedString key) const {
    return VariantConstRef(objectGetMember(_data, key));
  }
};
class ObjectRef : public ObjectRefBase<CollectionData>,
                  public ObjectShortcuts<ObjectRef>,
                  public Visitable {
  typedef ObjectRefBase<CollectionData> base_type;
 public:
  typedef ObjectIterator iterator;
  FORCE_INLINE ObjectRef() : base_type(0), _pool(0) {}
  FORCE_INLINE ObjectRef(MemoryPool* buf, CollectionData* data)
      : base_type(data), _pool(buf) {}
  operator VariantRef() const {
    void* data = _data;  // prevent warning cast-align
    return VariantRef(_pool, reinterpret_cast<VariantData*>(data));
  }
  operator ObjectConstRef() const {
    return ObjectConstRef(_data);
  }
  FORCE_INLINE iterator begin() const {
    if (!_data)
      return iterator();
    return iterator(_pool, _data->head());
  }
  FORCE_INLINE iterator end() const {
    return iterator();
  }
  void clear() const {
    if (!_data)
      return;
    _data->clear();
  }
  FORCE_INLINE bool set(ObjectConstRef src) {
    if (!_data || !src._data)
      return false;
    return _data->copyFrom(*src._data, _pool);
  }
  template <typename TString>
  FORCE_INLINE VariantRef getMember(const TString& key) const {
    return VariantRef(_pool, objectGetMember(_data, adaptString(key)));
  }
  template <typename TChar>
  FORCE_INLINE VariantRef getMember(TChar* key) const {
    return VariantRef(_pool, objectGetMember(_data, adaptString(key)));
  }
  template <typename TString>
  FORCE_INLINE VariantRef getOrAddMember(const TString& key) const {
    return VariantRef(_pool,
                      objectGetOrAddMember(_data, adaptString(key), _pool));
  }
  template <typename TChar>
  FORCE_INLINE VariantRef getOrAddMember(TChar* key) const {
    return VariantRef(_pool,
                      objectGetOrAddMember(_data, adaptString(key), _pool));
  }
  FORCE_INLINE bool operator==(ObjectRef rhs) const {
    return objectEquals(_data, rhs._data);
  }
  FORCE_INLINE void remove(iterator it) const {
    if (!_data)
      return;
    _data->removeSlot(it.internal());
  }
  template <typename TString>
  FORCE_INLINE void remove(const TString& key) const {
    objectRemove(_data, adaptString(key));
  }
  template <typename TChar>
  FORCE_INLINE void remove(TChar* key) const {
    objectRemove(_data, adaptString(key));
  }
 private:
  MemoryPool* _pool;
};
template <>
struct Converter<ObjectConstRef> {
  static bool toJson(VariantConstRef src, VariantRef dst) {
    return variantCopyFrom(getData(dst), getData(src), getPool(dst));
  }
  static ObjectConstRef fromJson(VariantConstRef src) {
    return ObjectConstRef(variantAsObject(getData(src)));
  }
  static bool checkJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data && data->isObject();
  }
};
template <>
struct Converter<ObjectRef> {
  static bool toJson(VariantConstRef src, VariantRef dst) {
    return variantCopyFrom(getData(dst), getData(src), getPool(dst));
  }
  static ObjectRef fromJson(VariantRef src) {
    VariantData* data = getData(src);
    MemoryPool* pool = getPool(src);
    return ObjectRef(pool, data != 0 ? data->asObject() : 0);
  }
  static InvalidConversion<VariantConstRef, ObjectRef> fromJson(
      VariantConstRef);
  static bool checkJson(VariantConstRef) {
    return false;
  }
  static bool checkJson(VariantRef src) {
    VariantData* data = getData(src);
    return data && data->isObject();
  }
};
class ArrayRef;
class ObjectRef;
class VariantRef;
template <typename T>
struct VariantTo {};
template <>
struct VariantTo<ArrayRef> {
  typedef ArrayRef type;
};
template <>
struct VariantTo<ObjectRef> {
  typedef ObjectRef type;
};
template <>
struct VariantTo<VariantRef> {
  typedef VariantRef type;
};
}  // namespace ARDUINOJSON_NAMESPACE
#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable : 4522)
#endif
namespace ARDUINOJSON_NAMESPACE {
template <typename TArray>
class ElementProxy : public VariantOperators<ElementProxy<TArray> >,
                     public VariantShortcuts<ElementProxy<TArray> >,
                     public Visitable,
                     public VariantTag {
  typedef ElementProxy<TArray> this_type;
 public:
  typedef VariantRef variant_type;
  FORCE_INLINE ElementProxy(TArray array, size_t index)
      : _array(array), _index(index) {}
  FORCE_INLINE ElementProxy(const ElementProxy& src)
      : _array(src._array), _index(src._index) {}
  FORCE_INLINE this_type& operator=(const this_type& src) {
    getOrAddUpstreamElement().set(src.as<VariantConstRef>());
    return *this;
  }
  template <typename T>
  FORCE_INLINE this_type& operator=(const T& src) {
    getOrAddUpstreamElement().set(src);
    return *this;
  }
  template <typename T>
  FORCE_INLINE this_type& operator=(T* src) {
    getOrAddUpstreamElement().set(src);
    return *this;
  }
  FORCE_INLINE void clear() const {
    getUpstreamElement().clear();
  }
  FORCE_INLINE bool isNull() const {
    return getUpstreamElement().isNull();
  }
  template <typename T>
  FORCE_INLINE typename enable_if<!is_same<T, char*>::value, T>::type as()
      const {
    return getUpstreamElement().template as<T>();
  }
  template <typename T>
  FORCE_INLINE typename enable_if<is_same<T, char*>::value, const char*>::type
  ARDUINOJSON_DEPRECATED("Replace as<char*>() with as<const char*>()")
      as() const {
    return as<const char*>();
  }
  template <typename T>
  FORCE_INLINE operator T() const {
    return getUpstreamElement();
  }
  template <typename T>
  FORCE_INLINE bool is() const {
    return getUpstreamElement().template is<T>();
  }
  template <typename T>
  FORCE_INLINE typename VariantTo<T>::type to() const {
    return getOrAddUpstreamElement().template to<T>();
  }
  template <typename TValue>
  FORCE_INLINE bool set(const TValue& value) const {
    return getOrAddUpstreamElement().set(value);
  }
  template <typename TValue>
  FORCE_INLINE bool set(TValue* value) const {
    return getOrAddUpstreamElement().set(value);
  }
  template <typename TVisitor>
  typename TVisitor::result_type accept(TVisitor& visitor) const {
    return getUpstreamElement().accept(visitor);
  }
  FORCE_INLINE size_t size() const {
    return getUpstreamElement().size();
  }
  template <typename TNestedKey>
  VariantRef getMember(TNestedKey* key) const {
    return getUpstreamElement().getMember(key);
  }
  template <typename TNestedKey>
  VariantRef getMember(const TNestedKey& key) const {
    return getUpstreamElement().getMember(key);
  }
  template <typename TNestedKey>
  VariantRef getOrAddMember(TNestedKey* key) const {
    return getOrAddUpstreamElement().getOrAddMember(key);
  }
  template <typename TNestedKey>
  VariantRef getOrAddMember(const TNestedKey& key) const {
    return getOrAddUpstreamElement().getOrAddMember(key);
  }
  VariantRef addElement() const {
    return getOrAddUpstreamElement().addElement();
  }
  VariantRef getElement(size_t index) const {
    return getOrAddUpstreamElement().getElement(index);
  }
  VariantRef getOrAddElement(size_t index) const {
    return getOrAddUpstreamElement().getOrAddElement(index);
  }
  FORCE_INLINE void remove(size_t index) const {
    getUpstreamElement().remove(index);
  }
  template <typename TChar>
  FORCE_INLINE typename enable_if<IsString<TChar*>::value>::type remove(
      TChar* key) const {
    getUpstreamElement().remove(key);
  }
  template <typename TString>
  FORCE_INLINE typename enable_if<IsString<TString>::value>::type remove(
      const TString& key) const {
    getUpstreamElement().remove(key);
  }
 private:
  FORCE_INLINE VariantRef getUpstreamElement() const {
    return _array.getElement(_index);
  }
  FORCE_INLINE VariantRef getOrAddUpstreamElement() const {
    return _array.getOrAddElement(_index);
  }
  friend bool convertToJson(const this_type& src, VariantRef dst) {
    return dst.set(src.getUpstreamElement());
  }
  TArray _array;
  const size_t _index;
};
}  // namespace ARDUINOJSON_NAMESPACE
#ifdef _MSC_VER
#  pragma warning(pop)
#endif
#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable : 4522)
#endif
namespace ARDUINOJSON_NAMESPACE {
template <typename TObject, typename TStringRef>
class MemberProxy : public VariantOperators<MemberProxy<TObject, TStringRef> >,
                    public VariantShortcuts<MemberProxy<TObject, TStringRef> >,
                    public Visitable,
                    public VariantTag {
  typedef MemberProxy<TObject, TStringRef> this_type;
 public:
  typedef VariantRef variant_type;
  FORCE_INLINE MemberProxy(TObject variant, TStringRef key)
      : _object(variant), _key(key) {}
  FORCE_INLINE MemberProxy(const MemberProxy &src)
      : _object(src._object), _key(src._key) {}
  FORCE_INLINE operator VariantConstRef() const {
    return getUpstreamMember();
  }
  FORCE_INLINE this_type &operator=(const this_type &src) {
    getOrAddUpstreamMember().set(src);
    return *this;
  }
  template <typename TValue>
  FORCE_INLINE typename enable_if<!is_array<TValue>::value, this_type &>::type
  operator=(const TValue &src) {
    getOrAddUpstreamMember().set(src);
    return *this;
  }
  template <typename TChar>
  FORCE_INLINE this_type &operator=(TChar *src) {
    getOrAddUpstreamMember().set(src);
    return *this;
  }
  FORCE_INLINE void clear() const {
    getUpstreamMember().clear();
  }
  FORCE_INLINE bool isNull() const {
    return getUpstreamMember().isNull();
  }
  template <typename T>
  FORCE_INLINE typename enable_if<!is_same<T, char *>::value, T>::type as()
      const {
    return getUpstreamMember().template as<T>();
  }
  template <typename T>
  FORCE_INLINE typename enable_if<is_same<T, char *>::value, const char *>::type
  ARDUINOJSON_DEPRECATED("Replace as<char*>() with as<const char*>()")
      as() const {
    return as<const char *>();
  }
  template <typename T>
  FORCE_INLINE operator T() const {
    return getUpstreamMember();
  }
  template <typename TValue>
  FORCE_INLINE bool is() const {
    return getUpstreamMember().template is<TValue>();
  }
  FORCE_INLINE size_t size() const {
    return getUpstreamMember().size();
  }
  FORCE_INLINE void remove(size_t index) const {
    getUpstreamMember().remove(index);
  }
  template <typename TChar>
  FORCE_INLINE typename enable_if<IsString<TChar *>::value>::type remove(
      TChar *key) const {
    getUpstreamMember().remove(key);
  }
  template <typename TString>
  FORCE_INLINE typename enable_if<IsString<TString>::value>::type remove(
      const TString &key) const {
    getUpstreamMember().remove(key);
  }
  template <typename TValue>
  FORCE_INLINE typename VariantTo<TValue>::type to() {
    return getOrAddUpstreamMember().template to<TValue>();
  }
  template <typename TValue>
  FORCE_INLINE bool set(const TValue &value) {
    return getOrAddUpstreamMember().set(value);
  }
  template <typename TChar>
  FORCE_INLINE bool set(TChar *value) {
    return getOrAddUpstreamMember().set(value);
  }
  template <typename TVisitor>
  typename TVisitor::result_type accept(TVisitor &visitor) const {
    return getUpstreamMember().accept(visitor);
  }
  FORCE_INLINE VariantRef addElement() const {
    return getOrAddUpstreamMember().addElement();
  }
  FORCE_INLINE VariantRef getElement(size_t index) const {
    return getUpstreamMember().getElement(index);
  }
  FORCE_INLINE VariantRef getOrAddElement(size_t index) const {
    return getOrAddUpstreamMember().getOrAddElement(index);
  }
  template <typename TChar>
  FORCE_INLINE VariantRef getMember(TChar *key) const {
    return getUpstreamMember().getMember(key);
  }
  template <typename TString>
  FORCE_INLINE VariantRef getMember(const TString &key) const {
    return getUpstreamMember().getMember(key);
  }
  template <typename TChar>
  FORCE_INLINE VariantRef getOrAddMember(TChar *key) const {
    return getOrAddUpstreamMember().getOrAddMember(key);
  }
  template <typename TString>
  FORCE_INLINE VariantRef getOrAddMember(const TString &key) const {
    return getOrAddUpstreamMember().getOrAddMember(key);
  }
 private:
  FORCE_INLINE VariantRef getUpstreamMember() const {
    return _object.getMember(_key);
  }
  FORCE_INLINE VariantRef getOrAddUpstreamMember() const {
    return _object.getOrAddMember(_key);
  }
  friend bool convertToJson(const this_type &src, VariantRef dst) {
    return dst.set(src.getUpstreamMember());
  }
  TObject _object;
  TStringRef _key;
};
}  // namespace ARDUINOJSON_NAMESPACE
#ifdef _MSC_VER
#  pragma warning(pop)
#endif
namespace ARDUINOJSON_NAMESPACE {
class JsonDocument : public Visitable {
 public:
  template <typename TVisitor>
  typename TVisitor::result_type accept(TVisitor& visitor) const {
    return getVariant().accept(visitor);
  }
  template <typename T>
  T as() {
    return getVariant().template as<T>();
  }
  template <typename T>
  T as() const {
    return getVariant().template as<T>();
  }
  void clear() {
    _pool.clear();
    _data.init();
  }
  template <typename T>
  bool is() {
    return getVariant().template is<T>();
  }
  template <typename T>
  bool is() const {
    return getVariant().template is<T>();
  }
  bool isNull() const {
    return getVariant().isNull();
  }
  size_t memoryUsage() const {
    return _pool.size();
  }
  bool overflowed() const {
    return _pool.overflowed();
  }
  size_t nesting() const {
    return _data.nesting();
  }
  size_t capacity() const {
    return _pool.capacity();
  }
  size_t size() const {
    return _data.size();
  }
  bool set(const JsonDocument& src) {
    return to<VariantRef>().set(src.as<VariantConstRef>());
  }
  template <typename T>
  typename enable_if<!is_base_of<JsonDocument, T>::value, bool>::type set(
      const T& src) {
    return to<VariantRef>().set(src);
  }
  template <typename T>
  typename VariantTo<T>::type to() {
    clear();
    return getVariant().template to<T>();
  }
  MemoryPool& memoryPool() {
    return _pool;
  }
  VariantData& data() {
    return _data;
  }
  ArrayRef createNestedArray() {
    return addElement().to<ArrayRef>();
  }
  template <typename TChar>
  ArrayRef createNestedArray(TChar* key) {
    return getOrAddMember(key).template to<ArrayRef>();
  }
  template <typename TString>
  ArrayRef createNestedArray(const TString& key) {
    return getOrAddMember(key).template to<ArrayRef>();
  }
  ObjectRef createNestedObject() {
    return addElement().to<ObjectRef>();
  }
  template <typename TChar>
  ObjectRef createNestedObject(TChar* key) {
    return getOrAddMember(key).template to<ObjectRef>();
  }
  template <typename TString>
  ObjectRef createNestedObject(const TString& key) {
    return getOrAddMember(key).template to<ObjectRef>();
  }
  template <typename TChar>
  bool containsKey(TChar* key) const {
    return !getMember(key).isUndefined();
  }
  template <typename TString>
  bool containsKey(const TString& key) const {
    return !getMember(key).isUndefined();
  }
  template <typename TString>
  FORCE_INLINE typename enable_if<IsString<TString>::value,
                                  MemberProxy<JsonDocument&, TString> >::type
  operator[](const TString& key) {
    return MemberProxy<JsonDocument&, TString>(*this, key);
  }
  template <typename TChar>
  FORCE_INLINE typename enable_if<IsString<TChar*>::value,
                                  MemberProxy<JsonDocument&, TChar*> >::type
  operator[](TChar* key) {
    return MemberProxy<JsonDocument&, TChar*>(*this, key);
  }
  template <typename TString>
  FORCE_INLINE
      typename enable_if<IsString<TString>::value, VariantConstRef>::type
      operator[](const TString& key) const {
    return getMember(key);
  }
  template <typename TChar>
  FORCE_INLINE
      typename enable_if<IsString<TChar*>::value, VariantConstRef>::type
      operator[](TChar* key) const {
    return getMember(key);
  }
  FORCE_INLINE ElementProxy<JsonDocument&> operator[](size_t index) {
    return ElementProxy<JsonDocument&>(*this, index);
  }
  FORCE_INLINE VariantConstRef operator[](size_t index) const {
    return getElement(index);
  }
  FORCE_INLINE VariantRef getElement(size_t index) {
    return VariantRef(&_pool, _data.getElement(index));
  }
  FORCE_INLINE VariantConstRef getElement(size_t index) const {
    return VariantConstRef(_data.getElement(index));
  }
  FORCE_INLINE VariantRef getOrAddElement(size_t index) {
    return VariantRef(&_pool, _data.getOrAddElement(index, &_pool));
  }
  template <typename TChar>
  FORCE_INLINE VariantConstRef getMember(TChar* key) const {
    return VariantConstRef(_data.getMember(adaptString(key)));
  }
  template <typename TString>
  FORCE_INLINE
      typename enable_if<IsString<TString>::value, VariantConstRef>::type
      getMember(const TString& key) const {
    return VariantConstRef(_data.getMember(adaptString(key)));
  }
  template <typename TChar>
  FORCE_INLINE VariantRef getMember(TChar* key) {
    return VariantRef(&_pool, _data.getMember(adaptString(key)));
  }
  template <typename TString>
  FORCE_INLINE typename enable_if<IsString<TString>::value, VariantRef>::type
  getMember(const TString& key) {
    return VariantRef(&_pool, _data.getMember(adaptString(key)));
  }
  template <typename TChar>
  FORCE_INLINE VariantRef getOrAddMember(TChar* key) {
    return VariantRef(&_pool, _data.getOrAddMember(adaptString(key), &_pool));
  }
  template <typename TString>
  FORCE_INLINE VariantRef getOrAddMember(const TString& key) {
    return VariantRef(&_pool, _data.getOrAddMember(adaptString(key), &_pool));
  }
  FORCE_INLINE VariantRef addElement() {
    return VariantRef(&_pool, _data.addElement(&_pool));
  }
  template <typename TValue>
  FORCE_INLINE bool add(const TValue& value) {
    return addElement().set(value);
  }
  template <typename TChar>
  FORCE_INLINE bool add(TChar* value) {
    return addElement().set(value);
  }
  FORCE_INLINE void remove(size_t index) {
    _data.remove(index);
  }
  template <typename TChar>
  FORCE_INLINE typename enable_if<IsString<TChar*>::value>::type remove(
      TChar* key) {
    _data.remove(adaptString(key));
  }
  template <typename TString>
  FORCE_INLINE typename enable_if<IsString<TString>::value>::type remove(
      const TString& key) {
    _data.remove(adaptString(key));
  }
  FORCE_INLINE operator VariantConstRef() const {
    return VariantConstRef(&_data);
  }
  bool operator==(VariantConstRef rhs) const {
    return getVariant() == rhs;
  }
  bool operator!=(VariantConstRef rhs) const {
    return getVariant() != rhs;
  }
 protected:
  JsonDocument() : _pool(0, 0) {
    _data.init();
  }
  JsonDocument(MemoryPool pool) : _pool(pool) {
    _data.init();
  }
  JsonDocument(char* buf, size_t capa) : _pool(buf, capa) {
    _data.init();
  }
  ~JsonDocument() {}
  void replacePool(MemoryPool pool) {
    _pool = pool;
  }
  VariantRef getVariant() {
    return VariantRef(&_pool, &_data);
  }
  VariantConstRef getVariant() const {
    return VariantConstRef(&_data);
  }
  MemoryPool _pool;
  VariantData _data;
 private:
  JsonDocument(const JsonDocument&);
  JsonDocument& operator=(const JsonDocument&);
};
inline bool convertToJson(const JsonDocument& src, VariantRef dst) {
  return dst.set(src.as<VariantConstRef>());
}
template <typename TAllocator>
class AllocatorOwner {
 public:
  AllocatorOwner() {}
  AllocatorOwner(const AllocatorOwner& src) : _allocator(src._allocator) {}
  AllocatorOwner(TAllocator a) : _allocator(a) {}
  void* allocate(size_t size) {
    return _allocator.allocate(size);
  }
  void deallocate(void* ptr) {
    if (ptr)
      _allocator.deallocate(ptr);
  }
  void* reallocate(void* ptr, size_t new_size) {
    return _allocator.reallocate(ptr, new_size);
  }
  TAllocator& allocator() {
    return _allocator;
  }
 private:
  TAllocator _allocator;
};
template <typename TAllocator>
class BasicJsonDocument : AllocatorOwner<TAllocator>, public JsonDocument {
 public:
  explicit BasicJsonDocument(size_t capa, TAllocator alloc = TAllocator())
      : AllocatorOwner<TAllocator>(alloc), JsonDocument(allocPool(capa)) {}
  BasicJsonDocument(const BasicJsonDocument& src)
      : AllocatorOwner<TAllocator>(src), JsonDocument() {
    copyAssignFrom(src);
  }
#if ARDUINOJSON_HAS_RVALUE_REFERENCES
  BasicJsonDocument(BasicJsonDocument&& src) : AllocatorOwner<TAllocator>(src) {
    moveAssignFrom(src);
  }
#endif
  BasicJsonDocument(const JsonDocument& src) {
    copyAssignFrom(src);
  }
  template <typename T>
  BasicJsonDocument(
      const T& src,
      typename enable_if<
          is_same<T, VariantRef>::value || is_same<T, VariantConstRef>::value ||
          is_same<T, ArrayRef>::value || is_same<T, ArrayConstRef>::value ||
          is_same<T, ObjectRef>::value ||
          is_same<T, ObjectConstRef>::value>::type* = 0)
      : JsonDocument(allocPool(src.memoryUsage())) {
    set(src);
  }
  BasicJsonDocument(VariantRef src)
      : JsonDocument(allocPool(src.memoryUsage())) {
    set(src);
  }
  ~BasicJsonDocument() {
    freePool();
  }
  BasicJsonDocument& operator=(const BasicJsonDocument& src) {
    copyAssignFrom(src);
    return *this;
  }
#if ARDUINOJSON_HAS_RVALUE_REFERENCES
  BasicJsonDocument& operator=(BasicJsonDocument&& src) {
    moveAssignFrom(src);
    return *this;
  }
#endif
  template <typename T>
  BasicJsonDocument& operator=(const T& src) {
    reallocPoolIfTooSmall(src.memoryUsage());
    set(src);
    return *this;
  }
  void shrinkToFit() {
    ptrdiff_t bytes_reclaimed = _pool.squash();
    if (bytes_reclaimed == 0)
      return;
    void* old_ptr = _pool.buffer();
    void* new_ptr = this->reallocate(old_ptr, _pool.capacity());
    ptrdiff_t ptr_offset =
        static_cast<char*>(new_ptr) - static_cast<char*>(old_ptr);
    _pool.movePointers(ptr_offset);
    _data.movePointers(ptr_offset, ptr_offset - bytes_reclaimed);
  }
  bool garbageCollect() {
    BasicJsonDocument tmp(*this);
    if (!tmp.capacity())
      return false;
    tmp.set(*this);
    moveAssignFrom(tmp);
    return true;
  }
  using AllocatorOwner<TAllocator>::allocator;
 private:
  MemoryPool allocPool(size_t requiredSize) {
    size_t capa = addPadding(requiredSize);
    return MemoryPool(reinterpret_cast<char*>(this->allocate(capa)), capa);
  }
  void reallocPoolIfTooSmall(size_t requiredSize) {
    if (requiredSize <= capacity())
      return;
    freePool();
    replacePool(allocPool(addPadding(requiredSize)));
  }
  void freePool() {
    this->deallocate(memoryPool().buffer());
  }
  void copyAssignFrom(const JsonDocument& src) {
    reallocPoolIfTooSmall(src.capacity());
    set(src);
  }
  void moveAssignFrom(BasicJsonDocument& src) {
    freePool();
    _data = src._data;
    _pool = src._pool;
    src._data.setNull();
    src._pool = MemoryPool(0, 0);
  }
};
}  // namespace ARDUINOJSON_NAMESPACE
#include <stdlib.h>
namespace ARDUINOJSON_NAMESPACE {
struct DefaultAllocator {
  void* allocate(size_t size) {
    return malloc(size);
  }
  void deallocate(void* ptr) {
    free(ptr);
  }
  void* reallocate(void* ptr, size_t new_size) {
    return realloc(ptr, new_size);
  }
};
typedef BasicJsonDocument<DefaultAllocator> DynamicJsonDocument;
template <size_t desiredCapacity>
class StaticJsonDocument : public JsonDocument {
  static const size_t _capacity =
      AddPadding<Max<1, desiredCapacity>::value>::value;
 public:
  StaticJsonDocument() : JsonDocument(_buffer, _capacity) {}
  StaticJsonDocument(const StaticJsonDocument& src)
      : JsonDocument(_buffer, _capacity) {
    set(src);
  }
  template <typename T>
  StaticJsonDocument(const T& src,
                     typename enable_if<IsVisitable<T>::value>::type* = 0)
      : JsonDocument(_buffer, _capacity) {
    set(src);
  }
  StaticJsonDocument(VariantRef src) : JsonDocument(_buffer, _capacity) {
    set(src);
  }
  StaticJsonDocument operator=(const StaticJsonDocument& src) {
    set(src);
    return *this;
  }
  template <typename T>
  StaticJsonDocument operator=(const T& src) {
    set(src);
    return *this;
  }
  void garbageCollect() {
    StaticJsonDocument tmp(*this);
    set(tmp);
  }
 private:
  char _buffer[_capacity];
};
template <typename TArray>
inline ArrayRef ArrayShortcuts<TArray>::createNestedArray() const {
  return impl()->addElement().template to<ArrayRef>();
}
template <typename TArray>
inline ObjectRef ArrayShortcuts<TArray>::createNestedObject() const {
  return impl()->addElement().template to<ObjectRef>();
}
template <typename TArray>
inline ElementProxy<TArray> ArrayShortcuts<TArray>::operator[](
    size_t index) const {
  return ElementProxy<TArray>(*impl(), index);
}
template <typename TResult>
struct Visitor {
  typedef TResult result_type;
  TResult visitArray(const CollectionData &) {
    return TResult();
  }
  TResult visitBoolean(bool) {
    return TResult();
  }
  TResult visitFloat(Float) {
    return TResult();
  }
  TResult visitSignedInteger(Integer) {
    return TResult();
  }
  TResult visitNull() {
    return TResult();
  }
  TResult visitObject(const CollectionData &) {
    return TResult();
  }
  TResult visitUnsignedInteger(UInt) {
    return TResult();
  }
  TResult visitRawJson(const char *, size_t) {
    return TResult();
  }
  TResult visitString(const char *) {
    return TResult();
  }
};
template <typename T, size_t N, typename TDestination>
inline typename enable_if<!is_array<T>::value &&
                              !is_base_of<JsonDocument, TDestination>::value,
                          bool>::type
copyArray(T (&src)[N], const TDestination& dst) {
  return copyArray(src, N, dst);
}
template <typename T, size_t N>
inline bool copyArray(T (&src)[N], JsonDocument& dst) {
  return copyArray(src, dst.to<ArrayRef>());
}
template <typename T, typename TDestination>
inline typename enable_if<!is_array<T>::value &&
                              !is_base_of<JsonDocument, TDestination>::value,
                          bool>::type
copyArray(T* src, size_t len, const TDestination& dst) {
  bool ok = true;
  for (size_t i = 0; i < len; i++) {
    ok &= dst.add(src[i]);
  }
  return ok;
}
template <typename T>
inline bool copyArray(T* src, size_t len, JsonDocument& dst) {
  return copyArray(src, len, dst.to<ArrayRef>());
}
template <typename T, size_t N1, size_t N2, typename TDestination>
inline typename enable_if<!is_base_of<JsonDocument, TDestination>::value,
                          bool>::type
copyArray(T (&src)[N1][N2], const TDestination& dst) {
  bool ok = true;
  for (size_t i = 0; i < N1; i++) {
    ArrayRef nestedArray = dst.createNestedArray();
    for (size_t j = 0; j < N2; j++) {
      ok &= nestedArray.add(src[i][j]);
    }
  }
  return ok;
}
template <typename T, size_t N1, size_t N2>
inline bool copyArray(T (&src)[N1][N2], JsonDocument& dst) {
  return copyArray(src, dst.to<ArrayRef>());
}
template <typename T>
class ArrayCopier1D : public Visitor<size_t> {
 public:
  ArrayCopier1D(T* destination, size_t capacity)
      : _destination(destination), _capacity(capacity) {}
  size_t visitArray(const CollectionData& array) {
    size_t size = 0;
    VariantSlot* slot = array.head();
    while (slot != 0 && size < _capacity) {
      _destination[size++] =
          Converter<T>::fromJson(VariantConstRef(slot->data()));
      slot = slot->next();
    }
    return size;
  }
 private:
  T* _destination;
  size_t _capacity;
};
template <typename T, size_t N1, size_t N2>
class ArrayCopier2D : public Visitor<void> {
 public:
  ArrayCopier2D(T (*destination)[N1][N2]) : _destination(destination) {}
  void visitArray(const CollectionData& array) {
    VariantSlot* slot = array.head();
    size_t n = 0;
    while (slot != 0 && n < N1) {
      ArrayCopier1D<T> copier((*_destination)[n++], N2);
      variantAccept(slot->data(), copier);
      slot = slot->next();
    }
  }
 private:
  T (*_destination)[N1][N2];
  size_t _capacity1, _capacity2;
};
template <typename TSource, typename T, size_t N>
inline typename enable_if<!is_array<T>::value, size_t>::type copyArray(
    const TSource& src, T (&dst)[N]) {
  return copyArray(src, dst, N);
}
template <typename TSource, typename T>
inline size_t copyArray(const TSource& src, T* dst, size_t len) {
  ArrayCopier1D<T> copier(dst, len);
  return src.accept(copier);
}
template <typename TSource, typename T, size_t N1, size_t N2>
inline void copyArray(const TSource& src, T (&dst)[N1][N2]) {
  ArrayCopier2D<T, N1, N2> copier(&dst);
  src.accept(copier);
}
inline bool variantEquals(const VariantData* a, const VariantData* b) {
  return variantCompare(a, b) == COMPARE_RESULT_EQUAL;
}
inline VariantSlot* CollectionData::addSlot(MemoryPool* pool) {
  VariantSlot* slot = pool->allocVariant();
  if (!slot)
    return 0;
  if (_tail) {
    _tail->setNextNotNull(slot);
    _tail = slot;
  } else {
    _head = slot;
    _tail = slot;
  }
  slot->clear();
  return slot;
}
inline VariantData* CollectionData::addElement(MemoryPool* pool) {
  return slotData(addSlot(pool));
}
template <typename TAdaptedString>
inline VariantData* CollectionData::addMember(TAdaptedString key,
                                              MemoryPool* pool) {
  VariantSlot* slot = addSlot(pool);
  if (!slotSetKey(slot, key, pool)) {
    removeSlot(slot);
    return 0;
  }
  return slot->data();
}
inline void CollectionData::clear() {
  _head = 0;
  _tail = 0;
}
template <typename TAdaptedString>
inline bool CollectionData::containsKey(const TAdaptedString& key) const {
  return getSlot(key) != 0;
}
inline bool CollectionData::copyFrom(const CollectionData& src,
                                     MemoryPool* pool) {
  clear();
  for (VariantSlot* s = src._head; s; s = s->next()) {
    VariantData* var;
    if (s->key() != 0) {
      if (s->ownsKey())
        var = addMember(RamStringAdapter(s->key()), pool);
      else
        var = addMember(ConstRamStringAdapter(s->key()), pool);
    } else {
      var = addElement(pool);
    }
    if (!var)
      return false;
    if (!var->copyFrom(*s->data(), pool))
      return false;
  }
  return true;
}
inline bool CollectionData::equalsObject(const CollectionData& other) const {
  size_t count = 0;
  for (VariantSlot* slot = _head; slot; slot = slot->next()) {
    VariantData* v1 = slot->data();
    VariantData* v2 = other.getMember(adaptString(slot->key()));
    if (!variantEquals(v1, v2))
      return false;
    count++;
  }
  return count == other.size();
}
inline bool CollectionData::equalsArray(const CollectionData& other) const {
  VariantSlot* s1 = _head;
  VariantSlot* s2 = other._head;
  for (;;) {
    if (s1 == s2)
      return true;
    if (!s1 || !s2)
      return false;
    if (!variantEquals(s1->data(), s2->data()))
      return false;
    s1 = s1->next();
    s2 = s2->next();
  }
}
template <typename TAdaptedString>
inline VariantSlot* CollectionData::getSlot(TAdaptedString key) const {
  VariantSlot* slot = _head;
  while (slot) {
    if (key.equals(slot->key()))
      break;
    slot = slot->next();
  }
  return slot;
}
inline VariantSlot* CollectionData::getSlot(size_t index) const {
  if (!_head)
    return 0;
  return _head->next(index);
}
inline VariantSlot* CollectionData::getPreviousSlot(VariantSlot* target) const {
  VariantSlot* current = _head;
  while (current) {
    VariantSlot* next = current->next();
    if (next == target)
      return current;
    current = next;
  }
  return 0;
}
template <typename TAdaptedString>
inline VariantData* CollectionData::getMember(TAdaptedString key) const {
  VariantSlot* slot = getSlot(key);
  return slot ? slot->data() : 0;
}
template <typename TAdaptedString>
inline VariantData* CollectionData::getOrAddMember(TAdaptedString key,
                                                   MemoryPool* pool) {
  if (key.isNull())
    return 0;
  VariantSlot* slot = getSlot(key);
  if (slot)
    return slot->data();
  return addMember(key, pool);
}
inline VariantData* CollectionData::getElement(size_t index) const {
  VariantSlot* slot = getSlot(index);
  return slot ? slot->data() : 0;
}
inline VariantData* CollectionData::getOrAddElement(size_t index,
                                                    MemoryPool* pool) {
  VariantSlot* slot = _head;
  while (slot && index > 0) {
    slot = slot->next();
    index--;
  }
  if (!slot)
    index++;
  while (index > 0) {
    slot = addSlot(pool);
    index--;
  }
  return slotData(slot);
}
inline void CollectionData::removeSlot(VariantSlot* slot) {
  if (!slot)
    return;
  VariantSlot* prev = getPreviousSlot(slot);
  VariantSlot* next = slot->next();
  if (prev)
    prev->setNext(next);
  else
    _head = next;
  if (!next)
    _tail = prev;
}
inline void CollectionData::removeElement(size_t index) {
  removeSlot(getSlot(index));
}
inline size_t CollectionData::memoryUsage() const {
  size_t total = 0;
  for (VariantSlot* s = _head; s; s = s->next()) {
    total += sizeof(VariantSlot) + s->data()->memoryUsage();
    if (s->ownsKey())
      total += strlen(s->key()) + 1;
  }
  return total;
}
inline size_t CollectionData::nesting() const {
  size_t maxChildNesting = 0;
  for (VariantSlot* s = _head; s; s = s->next()) {
    size_t childNesting = s->data()->nesting();
    if (childNesting > maxChildNesting)
      maxChildNesting = childNesting;
  }
  return maxChildNesting + 1;
}
inline size_t CollectionData::size() const {
  return slotSize(_head);
}
template <typename T>
inline void movePointer(T*& p, ptrdiff_t offset) {
  if (!p)
    return;
  p = reinterpret_cast<T*>(
      reinterpret_cast<void*>(reinterpret_cast<char*>(p) + offset));
  ARDUINOJSON_ASSERT(isAligned(p));
}
inline void CollectionData::movePointers(ptrdiff_t stringDistance,
                                         ptrdiff_t variantDistance) {
  movePointer(_head, variantDistance);
  movePointer(_tail, variantDistance);
  for (VariantSlot* slot = _head; slot; slot = slot->next())
    slot->movePointers(stringDistance, variantDistance);
}
template <typename TObject>
template <typename TString>
inline ArrayRef ObjectShortcuts<TObject>::createNestedArray(
    const TString& key) const {
  return impl()->getOrAddMember(key).template to<ArrayRef>();
}
template <typename TObject>
template <typename TChar>
inline ArrayRef ObjectShortcuts<TObject>::createNestedArray(TChar* key) const {
  return impl()->getOrAddMember(key).template to<ArrayRef>();
}
template <typename TObject>
template <typename TString>
inline ObjectRef ObjectShortcuts<TObject>::createNestedObject(
    const TString& key) const {
  return impl()->getOrAddMember(key).template to<ObjectRef>();
}
template <typename TObject>
template <typename TChar>
inline ObjectRef ObjectShortcuts<TObject>::createNestedObject(
    TChar* key) const {
  return impl()->getOrAddMember(key).template to<ObjectRef>();
}
template <typename TObject>
template <typename TString>
inline typename enable_if<IsString<TString>::value, bool>::type
ObjectShortcuts<TObject>::containsKey(const TString& key) const {
  return !impl()->getMember(key).isUndefined();
}
template <typename TObject>
template <typename TChar>
inline typename enable_if<IsString<TChar*>::value, bool>::type
ObjectShortcuts<TObject>::containsKey(TChar* key) const {
  return !impl()->getMember(key).isUndefined();
}
template <typename TObject>
template <typename TString>
inline typename enable_if<IsString<TString*>::value,
                          MemberProxy<TObject, TString*> >::type
ObjectShortcuts<TObject>::operator[](TString* key) const {
  return MemberProxy<TObject, TString*>(*impl(), key);
}
template <typename TObject>
template <typename TString>
inline typename enable_if<IsString<TString>::value,
                          MemberProxy<TObject, TString> >::type
ObjectShortcuts<TObject>::operator[](const TString& key) const {
  return MemberProxy<TObject, TString>(*impl(), key);
}
}  // namespace ARDUINOJSON_NAMESPACE
#if ARDUINOJSON_ENABLE_ARDUINO_STRING
#endif
#if ARDUINOJSON_ENABLE_STD_STRING
#endif
namespace ARDUINOJSON_NAMESPACE {
template <typename>
struct IsWriteableString : false_type {};
#if ARDUINOJSON_ENABLE_ARDUINO_STRING
template <>
struct IsWriteableString< ::String> : true_type {};
#endif
#if ARDUINOJSON_ENABLE_STD_STRING
template <typename TCharTraits, typename TAllocator>
struct IsWriteableString<std::basic_string<char, TCharTraits, TAllocator> >
    : true_type {};
#endif
template <typename T, typename Enable>
struct Converter {
  static bool toJson(const T& src, VariantRef dst) {
    return convertToJson(src, dst); // Error here? See https://arduinojson.org/v6/unsupported-set/
  }
  static T fromJson(VariantConstRef src) {
    T result; // Error here? See https://arduinojson.org/v6/non-default-constructible/
    convertFromJson(src, result);  // Error here? See https://arduinojson.org/v6/unsupported-as/
    return result;
  }
  static bool checkJson(VariantConstRef src) {
    T dummy;
    return canConvertFromJson(src, dummy);  // Error here? See https://arduinojson.org/v6/unsupported-is/
  }
};
template <typename T>
struct Converter<
    T, typename enable_if<is_integral<T>::value && !is_same<bool, T>::value &&
                          !is_same<char, T>::value>::type> {
  static bool toJson(T src, VariantRef dst) {
    VariantData* data = getData(dst);
    ARDUINOJSON_ASSERT_INTEGER_TYPE_IS_SUPPORTED(T);
    if (!data)
      return false;
    data->setInteger(src);
    return true;
  }
  static T fromJson(VariantConstRef src) {
    ARDUINOJSON_ASSERT_INTEGER_TYPE_IS_SUPPORTED(T);
    const VariantData* data = getData(src);
    return data ? data->asIntegral<T>() : T();
  }
  static bool checkJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data && data->isInteger<T>();
  }
};
template <typename T>
struct Converter<T, typename enable_if<is_enum<T>::value>::type> {
  static bool toJson(T src, VariantRef dst) {
    return dst.set(static_cast<Integer>(src));
  }
  static T fromJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data ? static_cast<T>(data->asIntegral<int>()) : T();
  }
  static bool checkJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data && data->isInteger<int>();
  }
};
template <>
struct Converter<bool> {
  static bool toJson(bool src, VariantRef dst) {
    VariantData* data = getData(dst);
    if (!data)
      return false;
    data->setBoolean(src);
    return true;
  }
  static bool fromJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data ? data->asBoolean() : false;
  }
  static bool checkJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data && data->isBoolean();
  }
};
template <typename T>
struct Converter<T, typename enable_if<is_floating_point<T>::value>::type> {
  static bool toJson(T src, VariantRef dst) {
    VariantData* data = getData(dst);
    if (!data)
      return false;
    data->setFloat(static_cast<Float>(src));
    return true;
  }
  static T fromJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data ? data->asFloat<T>() : false;
  }
  static bool checkJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data && data->isFloat();
  }
};
template <>
struct Converter<const char*> {
  static bool toJson(const char* src, VariantRef dst) {
    return variantSetString(getData(dst), adaptString(src), getPool(dst));
  }
  static const char* fromJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data ? data->asString() : 0;
  }
  static bool checkJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data && data->isString();
  }
};
template <typename T>
inline typename enable_if<IsString<T>::value, bool>::type convertToJson(
    const T& src, VariantRef dst) {
  VariantData* data = getData(dst);
  MemoryPool* pool = getPool(dst);
  return variantSetString(data, adaptString(src), pool);
}
template <typename T>
inline typename enable_if<IsWriteableString<T>::value>::type convertFromJson(
    VariantConstRef src, T& dst) {
  const VariantData* data = getData(src);
  const char* cstr = data != 0 ? data->asString() : 0;
  if (cstr)
    dst = cstr;
  else
    serializeJson(src, dst);
}
template <typename T>
inline typename enable_if<IsWriteableString<T>::value, bool>::type
canConvertFromJson(VariantConstRef src, const T&) {
  const VariantData* data = getData(src);
  return data && data->isString();
}
template <>
struct Converter<SerializedValue<const char*> > {
  static bool toJson(SerializedValue<const char*> src, VariantRef dst) {
    VariantData* data = getData(dst);
    if (!data)
      return false;
    data->setLinkedRaw(src);
    return true;
  }
};
template <typename T>
struct Converter<SerializedValue<T>,
                 typename enable_if<!is_same<const char*, T>::value>::type> {
  static bool toJson(SerializedValue<T> src, VariantRef dst) {
    VariantData* data = getData(dst);
    MemoryPool* pool = getPool(dst);
    return data != 0 && data->setOwnedRaw(src, pool);
  }
};
#if ARDUINOJSON_HAS_NULLPTR
template <>
struct Converter<decltype(nullptr)> {
  static bool toJson(decltype(nullptr), VariantRef dst) {
    variantSetNull(getData(dst));
    return true;
  }
  static decltype(nullptr) fromJson(VariantConstRef) {
    return nullptr;
  }
  static bool checkJson(VariantConstRef src) {
    const VariantData* data = getData(src);
    return data == 0 || data->isNull();
  }
};
#endif
#if ARDUINOJSON_ENABLE_ARDUINO_STREAM
class MemoryPoolPrint : public Print {
 public:
  MemoryPoolPrint(MemoryPool* pool) : _pool(pool), _size(0) {
    pool->getFreeZone(&_string, &_capacity);
  }
  const char* c_str() {
    _string[_size++] = 0;
    ARDUINOJSON_ASSERT(_size <= _capacity);
    return _pool->saveStringFromFreeZone(_size);
  }
  size_t write(uint8_t c) {
    if (_size >= _capacity)
      return 0;
    _string[_size++] = char(c);
    return 1;
  }
  size_t write(const uint8_t* buffer, size_t size) {
    if (_size + size >= _capacity) {
      _size = _capacity;  // mark as overflowed
      return 0;
    }
    memcpy(&_string[_size], buffer, size);
    _size += size;
    return size;
  }
  bool overflowed() const {
    return _size >= _capacity;
  }
 private:
  MemoryPool* _pool;
  size_t _size;
  char* _string;
  size_t _capacity;
};
inline bool convertToJson(const ::Printable& src, VariantRef dst) {
  MemoryPool* pool = getPool(dst);
  VariantData* data = getData(dst);
  if (!pool || !data)
    return false;
  MemoryPoolPrint print(pool);
  src.printTo(print);
  if (print.overflowed()) {
    pool->markAsOverflowed();
    data->setNull();
    return false;
  }
  data->setStringPointer(print.c_str(), storage_policies::store_by_copy());
  return true;
}
#endif
class CollectionData;
struct ComparerBase : Visitor<CompareResult> {};
template <typename T, typename Enable = void>
struct Comparer;
template <typename T>
struct Comparer<T, typename enable_if<IsString<T>::value>::type>
    : ComparerBase {
  T rhs;
  explicit Comparer(T value) : rhs(value) {}
  CompareResult visitString(const char *lhs) {
    int i = adaptString(rhs).compare(lhs);
    if (i < 0)
      return COMPARE_RESULT_GREATER;
    else if (i > 0)
      return COMPARE_RESULT_LESS;
    else
      return COMPARE_RESULT_EQUAL;
  }
  CompareResult visitNull() {
    if (adaptString(rhs).isNull())
      return COMPARE_RESULT_EQUAL;
    else
      return COMPARE_RESULT_DIFFER;
  }
};
template <typename T>
struct Comparer<T, typename enable_if<is_integral<T>::value ||
                                      is_floating_point<T>::value>::type>
    : ComparerBase {
  T rhs;
  explicit Comparer(T value) : rhs(value) {}
  CompareResult visitFloat(Float lhs) {
    return arithmeticCompare(lhs, rhs);
  }
  CompareResult visitSignedInteger(Integer lhs) {
    return arithmeticCompare(lhs, rhs);
  }
  CompareResult visitUnsignedInteger(UInt lhs) {
    return arithmeticCompare(lhs, rhs);
  }
  CompareResult visitBoolean(bool lhs) {
    return visitUnsignedInteger(static_cast<UInt>(lhs));
  }
};
struct NullComparer : ComparerBase {
  CompareResult visitNull() {
    return COMPARE_RESULT_EQUAL;
  }
};
#if ARDUINOJSON_HAS_NULLPTR
template <>
struct Comparer<decltype(nullptr), void> : NullComparer {
  explicit Comparer(decltype(nullptr)) : NullComparer() {}
};
#endif
struct ArrayComparer : ComparerBase {
  const CollectionData *_rhs;
  explicit ArrayComparer(const CollectionData &rhs) : _rhs(&rhs) {}
  CompareResult visitArray(const CollectionData &lhs) {
    if (lhs.equalsArray(*_rhs))
      return COMPARE_RESULT_EQUAL;
    else
      return COMPARE_RESULT_DIFFER;
  }
};
struct ObjectComparer : ComparerBase {
  const CollectionData *_rhs;
  explicit ObjectComparer(const CollectionData &rhs) : _rhs(&rhs) {}
  CompareResult visitObject(const CollectionData &lhs) {
    if (lhs.equalsObject(*_rhs))
      return COMPARE_RESULT_EQUAL;
    else
      return COMPARE_RESULT_DIFFER;
  }
};
struct RawComparer : ComparerBase {
  const char *_rhsData;
  size_t _rhsSize;
  explicit RawComparer(const char *rhsData, size_t rhsSize)
      : _rhsData(rhsData), _rhsSize(rhsSize) {}
  CompareResult visitRawJson(const char *lhsData, size_t lhsSize) {
    size_t size = _rhsSize < lhsSize ? _rhsSize : lhsSize;
    int n = memcmp(lhsData, _rhsData, size);
    if (n < 0)
      return COMPARE_RESULT_LESS;
    else if (n > 0)
      return COMPARE_RESULT_GREATER;
    else
      return COMPARE_RESULT_EQUAL;
  }
};
template <typename T>
struct Comparer<T, typename enable_if<IsVisitable<T>::value>::type>
    : ComparerBase {
  T rhs;
  explicit Comparer(T value) : rhs(value) {}
  CompareResult visitArray(const CollectionData &lhs) {
    ArrayComparer comparer(lhs);
    return accept(comparer);
  }
  CompareResult visitObject(const CollectionData &lhs) {
    ObjectComparer comparer(lhs);
    return accept(comparer);
  }
  CompareResult visitFloat(Float lhs) {
    Comparer<Float> comparer(lhs);
    return accept(comparer);
  }
  CompareResult visitString(const char *lhs) {
    Comparer<const char *> comparer(lhs);
    return accept(comparer);
  }
  CompareResult visitRawJson(const char *lhsData, size_t lhsSize) {
    RawComparer comparer(lhsData, lhsSize);
    return accept(comparer);
  }
  CompareResult visitSignedInteger(Integer lhs) {
    Comparer<Integer> comparer(lhs);
    return accept(comparer);
  }
  CompareResult visitUnsignedInteger(UInt lhs) {
    Comparer<UInt> comparer(lhs);
    return accept(comparer);
  }
  CompareResult visitBoolean(bool lhs) {
    Comparer<bool> comparer(lhs);
    return accept(comparer);
  }
  CompareResult visitNull() {
    NullComparer comparer;
    return accept(comparer);
  }
 private:
  template <typename TComparer>
  CompareResult accept(TComparer &comparer) {
    CompareResult reversedResult = rhs.accept(comparer);
    switch (reversedResult) {
      case COMPARE_RESULT_GREATER:
        return COMPARE_RESULT_LESS;
      case COMPARE_RESULT_LESS:
        return COMPARE_RESULT_GREATER;
      default:
        return reversedResult;
    }
  }
};
template <typename T1, typename T2>
CompareResult compare(const T1 &lhs, const T2 &rhs) {
  Comparer<T2> comparer(rhs);
  return lhs.accept(comparer);
}
inline int variantCompare(const VariantData *a, const VariantData *b) {
  return compare(VariantConstRef(a), VariantConstRef(b));
}
#ifndef isnan
template <typename T>
bool isnan(T x) {
  return x != x;
}
#endif
#ifndef isinf
template <typename T>
bool isinf(T x) {
  return x != 0.0 && x * 2 == x;
}
#endif
template <typename T, typename F>
struct alias_cast_t {
  union {
    F raw;
    T data;
  };
};
template <typename T, typename F>
T alias_cast(F raw_data) {
  alias_cast_t<T, F> ac;
  ac.raw = raw_data;
  return ac.data;
}
}  // namespace ARDUINOJSON_NAMESPACE
#if ARDUINOJSON_ENABLE_PROGMEM
namespace ARDUINOJSON_NAMESPACE {
template <typename T>
typename enable_if<is_pointer<T>::value, T>::type pgm_read(const void* p) {
  return reinterpret_cast<T>(pgm_read_ptr(p));
}
template <typename T>
typename enable_if<is_floating_point<T>::value &&
                       sizeof(T) == sizeof(float),  // on AVR sizeof(double) ==
                   T>::type
pgm_read(const void* p) {
  return pgm_read_float(p);
}
template <typename T>
typename enable_if<is_same<T, uint32_t>::value, T>::type pgm_read(
    const void* p) {
  return pgm_read_dword(p);
}
}  // namespace ARDUINOJSON_NAMESPACE
#  ifndef ARDUINOJSON_DEFINE_STATIC_ARRAY
#    define ARDUINOJSON_DEFINE_STATIC_ARRAY(type, name, value) \
      static type const name[] PROGMEM = value;
#  endif
#  ifndef ARDUINOJSON_READ_STATIC_ARRAY
#    define ARDUINOJSON_READ_STATIC_ARRAY(type, name, index) \
      pgm_read<type>(name + index)
#  endif
#else  // i.e. ARDUINOJSON_ENABLE_PROGMEM == 0
#  ifndef ARDUINOJSON_DEFINE_STATIC_ARRAY
#    define ARDUINOJSON_DEFINE_STATIC_ARRAY(type, name, value) \
      static type const name[] = value;
#  endif
#  ifndef ARDUINOJSON_READ_STATIC_ARRAY
#    define ARDUINOJSON_READ_STATIC_ARRAY(type, name, index) name[index]
#  endif
#endif
namespace ARDUINOJSON_NAMESPACE {
template <typename T, size_t = sizeof(T)>
struct FloatTraits {};
template <typename T>
struct FloatTraits<T, 8 /*64bits*/> {
  typedef uint64_t mantissa_type;
  static const short mantissa_bits = 52;
  static const mantissa_type mantissa_max =
      (mantissa_type(1) << mantissa_bits) - 1;
  typedef int16_t exponent_type;
  static const exponent_type exponent_max = 308;
  template <typename TExponent>
  static T make_float(T m, TExponent e) {
    if (e > 0) {
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1)
          m *= positiveBinaryPowerOfTen(index);
        e >>= 1;
      }
    } else {
      e = TExponent(-e);
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1)
          m *= negativeBinaryPowerOfTen(index);
        e >>= 1;
      }
    }
    return m;
  }
  static T positiveBinaryPowerOfTen(int index) {
    ARDUINOJSON_DEFINE_STATIC_ARRAY(  //
        uint32_t, factors,
        ARDUINOJSON_EXPAND18({
            0x40240000, 0x00000000,  // 1e1
            0x40590000, 0x00000000,  // 1e2
            0x40C38800, 0x00000000,  // 1e4
            0x4197D784, 0x00000000,  // 1e8
            0x4341C379, 0x37E08000,  // 1e16
            0x4693B8B5, 0xB5056E17,  // 1e32
            0x4D384F03, 0xE93FF9F5,  // 1e64
            0x5A827748, 0xF9301D32,  // 1e128
            0x75154FDD, 0x7F73BF3C   // 1e256
        }));
    return forge(
        ARDUINOJSON_READ_STATIC_ARRAY(uint32_t, factors, 2 * index),
        ARDUINOJSON_READ_STATIC_ARRAY(uint32_t, factors, 2 * index + 1));
  }
  static T negativeBinaryPowerOfTen(int index) {
    ARDUINOJSON_DEFINE_STATIC_ARRAY(  //
        uint32_t, factors,
        ARDUINOJSON_EXPAND18({
            0x3FB99999, 0x9999999A,  // 1e-1
            0x3F847AE1, 0x47AE147B,  // 1e-2
            0x3F1A36E2, 0xEB1C432D,  // 1e-4
            0x3E45798E, 0xE2308C3A,  // 1e-8
            0x3C9CD2B2, 0x97D889BC,  // 1e-16
            0x3949F623, 0xD5A8A733,  // 1e-32
            0x32A50FFD, 0x44F4A73D,  // 1e-64
            0x255BBA08, 0xCF8C979D,  // 1e-128
            0x0AC80628, 0x64AC6F43   // 1e-256
        }));
    return forge(
        ARDUINOJSON_READ_STATIC_ARRAY(uint32_t, factors, 2 * index),
        ARDUINOJSON_READ_STATIC_ARRAY(uint32_t, factors, 2 * index + 1));
  }
  static T negativeBinaryPowerOfTenPlusOne(int index) {
    ARDUINOJSON_DEFINE_STATIC_ARRAY(  //
        uint32_t, factors,
        ARDUINOJSON_EXPAND18({
            0x3FF00000, 0x00000000,  // 1e0
            0x3FB99999, 0x9999999A,  // 1e-1
            0x3F50624D, 0xD2F1A9FC,  // 1e-3
            0x3E7AD7F2, 0x9ABCAF48,  // 1e-7
            0x3CD203AF, 0x9EE75616,  // 1e-15
            0x398039D6, 0x65896880,  // 1e-31
            0x32DA53FC, 0x9631D10D,  // 1e-63
            0x25915445, 0x81B7DEC2,  // 1e-127
            0x0AFE07B2, 0x7DD78B14   // 1e-255
        }));
    return forge(
        ARDUINOJSON_READ_STATIC_ARRAY(uint32_t, factors, 2 * index),
        ARDUINOJSON_READ_STATIC_ARRAY(uint32_t, factors, 2 * index + 1));
  }
  static T nan() {
    return forge(0x7ff80000, 0x00000000);
  }
  static T inf() {
    return forge(0x7ff00000, 0x00000000);
  }
  static T highest() {
    return forge(0x7FEFFFFF, 0xFFFFFFFF);
  }
  static T lowest() {
    return forge(0xFFEFFFFF, 0xFFFFFFFF);
  }
  static T forge(uint32_t msb, uint32_t lsb) {
    return alias_cast<T>((uint64_t(msb) << 32) | lsb);
  }
};
template <typename T>
struct FloatTraits<T, 4 /*32bits*/> {
  typedef uint32_t mantissa_type;
  static const short mantissa_bits = 23;
  static const mantissa_type mantissa_max =
      (mantissa_type(1) << mantissa_bits) - 1;
  typedef int8_t exponent_type;
  static const exponent_type exponent_max = 38;
  template <typename TExponent>
  static T make_float(T m, TExponent e) {
    if (e > 0) {
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1)
          m *= positiveBinaryPowerOfTen(index);
        e >>= 1;
      }
    } else {
      e = -e;
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1)
          m *= negativeBinaryPowerOfTen(index);
        e >>= 1;
      }
    }
    return m;
  }
  static T positiveBinaryPowerOfTen(int index) {
    ARDUINOJSON_DEFINE_STATIC_ARRAY(
        T, factors,
        ARDUINOJSON_EXPAND6({1e1f, 1e2f, 1e4f, 1e8f, 1e16f, 1e32f}));
    return ARDUINOJSON_READ_STATIC_ARRAY(T, factors, index);
  }
  static T negativeBinaryPowerOfTen(int index) {
    ARDUINOJSON_DEFINE_STATIC_ARRAY(
        T, factors,
        ARDUINOJSON_EXPAND6({1e-1f, 1e-2f, 1e-4f, 1e-8f, 1e-16f, 1e-32f}));
    return ARDUINOJSON_READ_STATIC_ARRAY(T, factors, index);
  }
  static T negativeBinaryPowerOfTenPlusOne(int index) {
    ARDUINOJSON_DEFINE_STATIC_ARRAY(
        T, factors,
        ARDUINOJSON_EXPAND6({1e0f, 1e-1f, 1e-3f, 1e-7f, 1e-15f, 1e-31f}));
    return ARDUINOJSON_READ_STATIC_ARRAY(T, factors, index);
  }
  static T forge(uint32_t bits) {
    return alias_cast<T>(bits);
  }
  static T nan() {
    return forge(0x7fc00000);
  }
  static T inf() {
    return forge(0x7f800000);
  }
  static T highest() {
    return forge(0x7f7fffff);
  }
  static T lowest() {
    return forge(0xFf7fffff);
  }
};
#ifndef isdigit
inline bool isdigit(char c) {
  return '0' <= c && c <= '9';
}
#endif
inline bool issign(char c) {
  return '-' == c || c == '+';
}
template <typename A, typename B>
struct choose_largest : conditional<(sizeof(A) > sizeof(B)), A, B> {};
inline bool parseNumber(const char* s, VariantData& result) {
  typedef FloatTraits<Float> traits;
  typedef choose_largest<traits::mantissa_type, UInt>::type mantissa_t;
  typedef traits::exponent_type exponent_t;
  ARDUINOJSON_ASSERT(s != 0);
  bool is_negative = false;
  switch (*s) {
    case '-':
      is_negative = true;
      s++;
      break;
    case '+':
      s++;
      break;
  }
#if ARDUINOJSON_ENABLE_NAN
  if (*s == 'n' || *s == 'N') {
    result.setFloat(traits::nan());
    return true;
  }
#endif
#if ARDUINOJSON_ENABLE_INFINITY
  if (*s == 'i' || *s == 'I') {
    result.setFloat(is_negative ? -traits::inf() : traits::inf());
    return true;
  }
#endif
  if (!isdigit(*s) && *s != '.')
    return false;
  mantissa_t mantissa = 0;
  exponent_t exponent_offset = 0;
  const mantissa_t maxUint = UInt(-1);
  while (isdigit(*s)) {
    uint8_t digit = uint8_t(*s - '0');
    if (mantissa > maxUint / 10)
      break;
    mantissa *= 10;
    if (mantissa > maxUint - digit)
      break;
    mantissa += digit;
    s++;
  }
  if (*s == '\0') {
    if (is_negative) {
      const mantissa_t sintMantissaMax = mantissa_t(1)
                                         << (sizeof(Integer) * 8 - 1);
      if (mantissa <= sintMantissaMax) {
        result.setInteger(Integer(~mantissa + 1));
        return true;
      }
    } else {
      result.setInteger(UInt(mantissa));
      return true;
    }
  }
  while (mantissa > traits::mantissa_max) {
    mantissa /= 10;
    exponent_offset++;
  }
  while (isdigit(*s)) {
    exponent_offset++;
    s++;
  }
  if (*s == '.') {
    s++;
    while (isdigit(*s)) {
      if (mantissa < traits::mantissa_max / 10) {
        mantissa = mantissa * 10 + uint8_t(*s - '0');
        exponent_offset--;
      }
      s++;
    }
  }
  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
    s++;
    bool negative_exponent = false;
    if (*s == '-') {
      negative_exponent = true;
      s++;
    } else if (*s == '+') {
      s++;
    }
    while (isdigit(*s)) {
      exponent = exponent * 10 + (*s - '0');
      if (exponent + exponent_offset > traits::exponent_max) {
        if (negative_exponent)
          result.setFloat(is_negative ? -0.0f : 0.0f);
        else
          result.setFloat(is_negative ? -traits::inf() : traits::inf());
        return true;
      }
      s++;
    }
    if (negative_exponent)
      exponent = -exponent;
  }
  exponent += exponent_offset;
  if (*s != '\0')
    return false;
  Float final_result =
      traits::make_float(static_cast<Float>(mantissa), exponent);
  result.setFloat(is_negative ? -final_result : final_result);
  return true;
}
template <typename T>
inline T parseNumber(const char* s) {
  VariantData value;
  value.init();  // VariantData is a POD, so it has no constructor
  parseNumber(s, value);
  return Converter<T>::fromJson(VariantConstRef(&value));
}
template <typename T>
inline T VariantData::asIntegral() const {
  switch (type()) {
    case VALUE_IS_BOOLEAN:
      return _content.asBoolean;
    case VALUE_IS_UNSIGNED_INTEGER:
      return convertNumber<T>(_content.asUnsignedInteger);
    case VALUE_IS_SIGNED_INTEGER:
      return convertNumber<T>(_content.asSignedInteger);
    case VALUE_IS_LINKED_STRING:
    case VALUE_IS_OWNED_STRING:
      return parseNumber<T>(_content.asString);
    case VALUE_IS_FLOAT:
      return convertNumber<T>(_content.asFloat);
    default:
      return 0;
  }
}
inline bool VariantData::asBoolean() const {
  switch (type()) {
    case VALUE_IS_BOOLEAN:
      return _content.asBoolean;
    case VALUE_IS_SIGNED_INTEGER:
    case VALUE_IS_UNSIGNED_INTEGER:
      return _content.asUnsignedInteger != 0;
    case VALUE_IS_FLOAT:
      return _content.asFloat != 0;
    case VALUE_IS_NULL:
      return false;
    default:
      return true;
  }
}
template <typename T>
inline T VariantData::asFloat() const {
  switch (type()) {
    case VALUE_IS_BOOLEAN:
      return static_cast<T>(_content.asBoolean);
    case VALUE_IS_UNSIGNED_INTEGER:
      return static_cast<T>(_content.asUnsignedInteger);
    case VALUE_IS_SIGNED_INTEGER:
      return static_cast<T>(_content.asSignedInteger);
    case VALUE_IS_LINKED_STRING:
    case VALUE_IS_OWNED_STRING:
      return parseNumber<T>(_content.asString);
    case VALUE_IS_FLOAT:
      return static_cast<T>(_content.asFloat);
    default:
      return 0;
  }
}
inline const char *VariantData::asString() const {
  switch (type()) {
    case VALUE_IS_LINKED_STRING:
    case VALUE_IS_OWNED_STRING:
      return _content.asString;
    default:
      return 0;
  }
}
template <typename T>
inline typename enable_if<is_same<T, ArrayRef>::value, ArrayRef>::type
VariantRef::to() const {
  return ArrayRef(_pool, variantToArray(_data));
}
template <typename T>
typename enable_if<is_same<T, ObjectRef>::value, ObjectRef>::type
VariantRef::to() const {
  return ObjectRef(_pool, variantToObject(_data));
}
template <typename T>
typename enable_if<is_same<T, VariantRef>::value, VariantRef>::type
VariantRef::to() const {
  variantSetNull(_data);
  return *this;
}
inline VariantConstRef VariantConstRef::getElement(size_t index) const {
  return ArrayConstRef(_data != 0 ? _data->asArray() : 0)[index];
}
inline VariantRef VariantRef::addElement() const {
  return VariantRef(_pool, variantAddElement(_data, _pool));
}
inline VariantRef VariantRef::getElement(size_t index) const {
  return VariantRef(_pool, _data != 0 ? _data->getElement(index) : 0);
}
inline VariantRef VariantRef::getOrAddElement(size_t index) const {
  return VariantRef(_pool, variantGetOrAddElement(_data, index, _pool));
}
template <typename TChar>
inline VariantRef VariantRef::getMember(TChar *key) const {
  return VariantRef(_pool, _data != 0 ? _data->getMember(adaptString(key)) : 0);
}
template <typename TString>
inline typename enable_if<IsString<TString>::value, VariantRef>::type
VariantRef::getMember(const TString &key) const {
  return VariantRef(_pool, _data != 0 ? _data->getMember(adaptString(key)) : 0);
}
template <typename TChar>
inline VariantRef VariantRef::getOrAddMember(TChar *key) const {
  return VariantRef(_pool, variantGetOrAddMember(_data, key, _pool));
}
template <typename TString>
inline VariantRef VariantRef::getOrAddMember(const TString &key) const {
  return VariantRef(_pool, variantGetOrAddMember(_data, key, _pool));
}
inline VariantConstRef operator|(VariantConstRef preferedValue,
                                 VariantConstRef defaultValue) {
  return preferedValue ? preferedValue : defaultValue;
}
inline bool VariantRef::set(char value) const {
  return set<signed char>(value);
}
}  // namespace ARDUINOJSON_NAMESPACE
#if ARDUINOJSON_ENABLE_STD_STREAM
#include <ostream>
#endif
namespace ARDUINOJSON_NAMESPACE {
class DeserializationError {
  typedef void (DeserializationError::*bool_type)() const;
  void safeBoolHelper() const {}
 public:
  enum Code {
    Ok,
    EmptyInput,
    IncompleteInput,
    InvalidInput,
    NoMemory,
    TooDeep
  };
  DeserializationError() {}
  DeserializationError(Code c) : _code(c) {}
  friend bool operator==(const DeserializationError& lhs,
                         const DeserializationError& rhs) {
    return lhs._code == rhs._code;
  }
  friend bool operator!=(const DeserializationError& lhs,
                         const DeserializationError& rhs) {
    return lhs._code != rhs._code;
  }
  friend bool operator==(const DeserializationError& lhs, Code rhs) {
    return lhs._code == rhs;
  }
  friend bool operator==(Code lhs, const DeserializationError& rhs) {
    return lhs == rhs._code;
  }
  friend bool operator!=(const DeserializationError& lhs, Code rhs) {
    return lhs._code != rhs;
  }
  friend bool operator!=(Code lhs, const DeserializationError& rhs) {
    return lhs != rhs._code;
  }
  operator bool_type() const {
    return _code != Ok ? &DeserializationError::safeBoolHelper : 0;
  }
  friend bool operator==(bool value, const DeserializationError& err) {
    return static_cast<bool>(err) == value;
  }
  friend bool operator==(const DeserializationError& err, bool value) {
    return static_cast<bool>(err) == value;
  }
  friend bool operator!=(bool value, const DeserializationError& err) {
    return static_cast<bool>(err) != value;
  }
  friend bool operator!=(const DeserializationError& err, bool value) {
    return static_cast<bool>(err) != value;
  }
  Code code() const {
    return _code;
  }
  const char* c_str() const {
    static const char* messages[] = {
        "Ok",           "EmptyInput", "IncompleteInput",
        "InvalidInput", "NoMemory",   "TooDeep"};
    ARDUINOJSON_ASSERT(static_cast<size_t>(_code) <
                       sizeof(messages) / sizeof(messages[0]));
    return messages[_code];
  }
#if ARDUINOJSON_ENABLE_PROGMEM
  const __FlashStringHelper* f_str() const {
    ARDUINOJSON_DEFINE_STATIC_ARRAY(char, s0, "Ok");
    ARDUINOJSON_DEFINE_STATIC_ARRAY(char, s1, "EmptyInput");
    ARDUINOJSON_DEFINE_STATIC_ARRAY(char, s2, "IncompleteInput");
    ARDUINOJSON_DEFINE_STATIC_ARRAY(char, s3, "InvalidInput");
    ARDUINOJSON_DEFINE_STATIC_ARRAY(char, s4, "NoMemory");
    ARDUINOJSON_DEFINE_STATIC_ARRAY(char, s5, "TooDeep");
    ARDUINOJSON_DEFINE_STATIC_ARRAY(
        const char*, messages, ARDUINOJSON_EXPAND6({s0, s1, s2, s3, s4, s5}));
    return ARDUINOJSON_READ_STATIC_ARRAY(const __FlashStringHelper*, messages,
                                         _code);
  }
#endif
 private:
  Code _code;
};
#if ARDUINOJSON_ENABLE_STD_STREAM
inline std::ostream& operator<<(std::ostream& s,
                                const DeserializationError& e) {
  s << e.c_str();
  return s;
}
inline std::ostream& operator<<(std::ostream& s, DeserializationError::Code c) {
  s << DeserializationError(c).c_str();
  return s;
}
#endif
class Filter {
 public:
  explicit Filter(VariantConstRef v) : _variant(v) {}
  bool allow() const {
    return _variant;
  }
  bool allowArray() const {
    return _variant == true || _variant.is<ArrayConstRef>();
  }
  bool allowObject() const {
    return _variant == true || _variant.is<ObjectConstRef>();
  }
  bool allowValue() const {
    return _variant == true;
  }
  template <typename TKey>
  Filter operator[](const TKey& key) const {
    if (_variant == true)  // "true" means "allow recursively"
      return *this;
    else
      return Filter(_variant[key] | _variant["*"]);
  }
 private:
  VariantConstRef _variant;
};
struct AllowAllFilter {
  bool allow() const {
    return true;
  }
  bool allowArray() const {
    return true;
  }
  bool allowObject() const {
    return true;
  }
  bool allowValue() const {
    return true;
  }
  template <typename TKey>
  AllowAllFilter operator[](const TKey&) const {
    return AllowAllFilter();
  }
};
class NestingLimit {
 public:
  NestingLimit() : _value(ARDUINOJSON_DEFAULT_NESTING_LIMIT) {}
  explicit NestingLimit(uint8_t n) : _value(n) {}
  NestingLimit decrement() const {
    ARDUINOJSON_ASSERT(_value > 0);
    return NestingLimit(static_cast<uint8_t>(_value - 1));
  }
  bool reached() const {
    return _value == 0;
  }
 private:
  uint8_t _value;
};
template <typename TSource, typename Enable = void>
struct Reader {
 public:
  Reader(TSource& source) : _source(&source) {}
  int read() {
    return _source->read();
  }
  size_t readBytes(char* buffer, size_t length) {
    return _source->readBytes(buffer, length);
  }
 private:
  TSource* _source;
};
template <typename TSource, typename Enable = void>
struct BoundedReader {
};
template <typename TIterator>
class IteratorReader {
  TIterator _ptr, _end;
 public:
  explicit IteratorReader(TIterator begin, TIterator end)
      : _ptr(begin), _end(end) {}
  int read() {
    if (_ptr < _end)
      return static_cast<unsigned char>(*_ptr++);
    else
      return -1;
  }
  size_t readBytes(char* buffer, size_t length) {
    size_t i = 0;
    while (i < length && _ptr < _end) buffer[i++] = *_ptr++;
    return i;
  }
};
template <typename T>
struct void_ {
  typedef void type;
};
template <typename TSource>
struct Reader<TSource, typename void_<typename TSource::const_iterator>::type>
    : IteratorReader<typename TSource::const_iterator> {
  explicit Reader(const TSource& source)
      : IteratorReader<typename TSource::const_iterator>(source.begin(),
                                                         source.end()) {}
};
template <typename T>
struct IsCharOrVoid {
  static const bool value =
      is_same<T, void>::value || is_same<T, char>::value ||
      is_same<T, unsigned char>::value || is_same<T, signed char>::value;
};
template <typename T>
struct IsCharOrVoid<const T> : IsCharOrVoid<T> {};
template <typename TSource>
struct Reader<TSource*,
              typename enable_if<IsCharOrVoid<TSource>::value>::type> {
  const char* _ptr;
 public:
  explicit Reader(const void* ptr)
      : _ptr(ptr ? reinterpret_cast<const char*>(ptr) : "") {}
  int read() {
    return static_cast<unsigned char>(*_ptr++);
  }
  size_t readBytes(char* buffer, size_t length) {
    for (size_t i = 0; i < length; i++) buffer[i] = *_ptr++;
    return length;
  }
};
template <typename TSource>
struct BoundedReader<TSource*,
                     typename enable_if<IsCharOrVoid<TSource>::value>::type>
    : public IteratorReader<const char*> {
 public:
  explicit BoundedReader(const void* ptr, size_t len)
      : IteratorReader<const char*>(reinterpret_cast<const char*>(ptr),
                                    reinterpret_cast<const char*>(ptr) + len) {}
};
template <typename TArray>
struct Reader<ElementProxy<TArray>, void> : Reader<char*, void> {
  explicit Reader(const ElementProxy<TArray>& x)
      : Reader<char*, void>(x.template as<const char*>()) {}
};
template <typename TObject, typename TStringRef>
struct Reader<MemberProxy<TObject, TStringRef>, void> : Reader<char*, void> {
  explicit Reader(const MemberProxy<TObject, TStringRef>& x)
      : Reader<char*, void>(x.template as<const char*>()) {}
};
template <>
struct Reader<VariantRef, void> : Reader<char*, void> {
  explicit Reader(VariantRef x) : Reader<char*, void>(x.as<const char*>()) {}
};
template <>
struct Reader<VariantConstRef, void> : Reader<char*, void> {
  explicit Reader(VariantConstRef x)
      : Reader<char*, void>(x.as<const char*>()) {}
};
}  // namespace ARDUINOJSON_NAMESPACE
#if ARDUINOJSON_ENABLE_ARDUINO_STREAM
namespace ARDUINOJSON_NAMESPACE {
template <typename TSource>
struct Reader<TSource,
              typename enable_if<is_base_of<Stream, TSource>::value>::type> {
 public:
  explicit Reader(Stream& stream) : _stream(&stream) {}
  int read() {
    char c;
    return _stream->readBytes(&c, 1) ? static_cast<unsigned char>(c) : -1;
  }
  size_t readBytes(char* buffer, size_t length) {
    return _stream->readBytes(buffer, length);
  }
 private:
  Stream* _stream;
};
}  // namespace ARDUINOJSON_NAMESPACE
#endif
#if ARDUINOJSON_ENABLE_ARDUINO_STRING
namespace ARDUINOJSON_NAMESPACE {
template <typename TSource>
struct Reader<TSource,
              typename enable_if<is_base_of< ::String, TSource>::value>::type>
    : BoundedReader<const char*> {
  explicit Reader(const ::String& s)
      : BoundedReader<const char*>(s.c_str(), s.length()) {}
};
}  // namespace ARDUINOJSON_NAMESPACE
#endif
#if ARDUINOJSON_ENABLE_PROGMEM
namespace ARDUINOJSON_NAMESPACE {
template <>
struct Reader<const __FlashStringHelper*, void> {
  const char* _ptr;
 public:
  explicit Reader(const __FlashStringHelper* ptr)
      : _ptr(reinterpret_cast<const char*>(ptr)) {}
  int read() {
    return pgm_read_byte(_ptr++);
  }
  size_t readBytes(char* buffer, size_t length) {
    memcpy_P(buffer, _ptr, length);
    _ptr += length;
    return length;
  }
};
template <>
struct BoundedReader<const __FlashStringHelper*, void> {
  const char* _ptr;
  const char* _end;
 public:
  explicit BoundedReader(const __FlashStringHelper* ptr, size_t size)
      : _ptr(reinterpret_cast<const char*>(ptr)), _end(_ptr + size) {}
  int read() {
    if (_ptr < _end)
      return pgm_read_byte(_ptr++);
    else
      return -1;
  }
  size_t readBytes(char* buffer, size_t length) {
    size_t available = static_cast<size_t>(_end - _ptr);
    if (available < length)
      length = available;
    memcpy_P(buffer, _ptr, length);
    _ptr += length;
    return length;
  }
};
}  // namespace ARDUINOJSON_NAMESPACE
#endif
#if ARDUINOJSON_ENABLE_STD_STREAM
#include <istream>
namespace ARDUINOJSON_NAMESPACE {
template <typename TSource>
struct Reader<TSource, typename enable_if<
                           is_base_of<std::istream, TSource>::value>::type> {
 public:
  explicit Reader(std::istream& stream) : _stream(&stream) {}
  int read() {
    return _stream->get();
  }
  size_t readBytes(char* buffer, size_t length) {
    _stream->read(buffer, static_cast<std::streamsize>(length));
    return static_cast<size_t>(_stream->gcount());
  }
 private:
  std::istream* _stream;
};
}  // namespace ARDUINOJSON_NAMESPACE
#endif
namespace ARDUINOJSON_NAMESPACE {
class StringCopier {
 public:
  StringCopier(MemoryPool& pool) : _pool(&pool) {}
  void startString() {
    _pool->getFreeZone(&_ptr, &_capacity);
    _size = 0;
  }
  const char* save() {
    ARDUINOJSON_ASSERT(_ptr);
    return _pool->saveStringFromFreeZone(_size);
  }
  void append(const char* s) {
    while (*s) append(*s++);
  }
  void append(const char* s, size_t n) {
    while (n-- > 0) append(*s++);
  }
  void append(char c) {
    if (!_ptr)
      return;
    if (_size >= _capacity) {
      _ptr = 0;
      _pool->markAsOverflowed();
      return;
    }
    _ptr[_size++] = c;
  }
  bool isValid() {
    return _ptr != 0;
  }
  const char* c_str() {
    return _ptr;
  }
  typedef storage_policies::store_by_copy storage_policy;
 private:
  MemoryPool* _pool;
  char* _ptr;
  size_t _size, _capacity;
};
class StringMover {
 public:
  StringMover(char* ptr) : _writePtr(ptr) {}
  void startString() {
    _startPtr = _writePtr;
  }
  const char* save() const {
    return _startPtr;
  }
  void append(char c) {
    *_writePtr++ = c;
  }
  bool isValid() const {
    return true;
  }
  const char* c_str() const {
    return _startPtr;
  }
  typedef storage_policies::store_by_address storage_policy;
 private:
  char* _writePtr;
  char* _startPtr;
};
template <typename TInput>
StringCopier makeStringStorage(TInput&, MemoryPool& pool) {
  return StringCopier(pool);
}
template <typename TChar>
StringMover makeStringStorage(
    TChar* input, MemoryPool&,
    typename enable_if<!is_const<TChar>::value>::type* = 0) {
  return StringMover(reinterpret_cast<char*>(input));
}
template <template <typename, typename> class TDeserializer, typename TReader,
          typename TWriter>
TDeserializer<TReader, TWriter> makeDeserializer(MemoryPool &pool,
                                                 TReader reader,
                                                 TWriter writer) {
  return TDeserializer<TReader, TWriter>(pool, reader, writer);
}
template <template <typename, typename> class TDeserializer, typename TString,
          typename TFilter>
typename enable_if<!is_array<TString>::value, DeserializationError>::type
deserialize(JsonDocument &doc, const TString &input, NestingLimit nestingLimit,
            TFilter filter) {
  Reader<TString> reader(input);
  doc.clear();
  return makeDeserializer<TDeserializer>(
             doc.memoryPool(), reader,
             makeStringStorage(input, doc.memoryPool()))
      .parse(doc.data(), filter, nestingLimit);
}
template <template <typename, typename> class TDeserializer, typename TChar,
          typename TFilter>
DeserializationError deserialize(JsonDocument &doc, TChar *input,
                                 size_t inputSize, NestingLimit nestingLimit,
                                 TFilter filter) {
  BoundedReader<TChar *> reader(input, inputSize);
  doc.clear();
  return makeDeserializer<TDeserializer>(
             doc.memoryPool(), reader,
             makeStringStorage(input, doc.memoryPool()))
      .parse(doc.data(), filter, nestingLimit);
}
template <template <typename, typename> class TDeserializer, typename TStream,
          typename TFilter>
DeserializationError deserialize(JsonDocument &doc, TStream &input,
                                 NestingLimit nestingLimit, TFilter filter) {
  Reader<TStream> reader(input);
  doc.clear();
  return makeDeserializer<TDeserializer>(
             doc.memoryPool(), reader,
             makeStringStorage(input, doc.memoryPool()))
      .parse(doc.data(), filter, nestingLimit);
}
class EscapeSequence {
 public:
  static char escapeChar(char c) {
    const char *p = escapeTable(true);
    while (p[0] && p[1] != c) {
      p += 2;
    }
    return p[0];
  }
  static char unescapeChar(char c) {
    const char *p = escapeTable(false);
    for (;;) {
      if (p[0] == '\0')
        return 0;
      if (p[0] == c)
        return p[1];
      p += 2;
    }
  }
 private:
  static const char *escapeTable(bool excludeSolidus) {
    return &"//\"\"\\\\b\bf\fn\nr\rt\t"[excludeSolidus ? 2 : 0];
  }
};
template <typename TReader>
class Latch {
 public:
  Latch(TReader reader) : _reader(reader), _loaded(false) {
#if ARDUINOJSON_DEBUG
    _ended = false;
#endif
  }
  void clear() {
    _loaded = false;
  }
  int last() const {
    return _current;
  }
  FORCE_INLINE char current() {
    if (!_loaded) {
      load();
    }
    return _current;
  }
 private:
  void load() {
    ARDUINOJSON_ASSERT(!_ended);
    int c = _reader.read();
#if ARDUINOJSON_DEBUG
    if (c <= 0)
      _ended = true;
#endif
    _current = static_cast<char>(c > 0 ? c : 0);
    _loaded = true;
  }
  TReader _reader;
  char _current;  // NOLINT(clang-analyzer-optin.cplusplus.UninitializedObject)
  bool _loaded;
#if ARDUINOJSON_DEBUG
  bool _ended;
#endif
};
}  // namespace ARDUINOJSON_NAMESPACE
#if defined(__GNUC__)
#  if __GNUC__ >= 7
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
#  endif
#endif
namespace ARDUINOJSON_NAMESPACE {
namespace Utf16 {
inline bool isHighSurrogate(uint16_t codeunit) {
  return codeunit >= 0xD800 && codeunit < 0xDC00;
}
inline bool isLowSurrogate(uint16_t codeunit) {
  return codeunit >= 0xDC00 && codeunit < 0xE000;
}
class Codepoint {
 public:
  Codepoint() : _highSurrogate(0), _codepoint(0) {}
  bool append(uint16_t codeunit) {
    if (isHighSurrogate(codeunit)) {
      _highSurrogate = codeunit & 0x3FF;
      return false;
    }
    if (isLowSurrogate(codeunit)) {
      _codepoint =
          uint32_t(0x10000 + ((_highSurrogate << 10) | (codeunit & 0x3FF)));
      return true;
    }
    _codepoint = codeunit;
    return true;
  }
  uint32_t value() const {
    return _codepoint;
  }
 private:
  uint16_t _highSurrogate;
  uint32_t _codepoint;
};
}  // namespace Utf16
}  // namespace ARDUINOJSON_NAMESPACE
#if defined(__GNUC__)
#  if __GNUC__ >= 8
#    pragma GCC diagnostic pop
#  endif
#endif
namespace ARDUINOJSON_NAMESPACE {
namespace Utf8 {
template <typename TStringBuilder>
inline void encodeCodepoint(uint32_t codepoint32, TStringBuilder& str) {
  char buf[5];
  char* p = buf;
  *(p++) = 0;
  if (codepoint32 < 0x80) {
    *(p++) = char((codepoint32));
  } else {
    *(p++) = char((codepoint32 | 0x80) & 0xBF);
    uint16_t codepoint16 = uint16_t(codepoint32 >> 6);
    if (codepoint16 < 0x20) {  // 0x800
      *(p++) = char(codepoint16 | 0xC0);
    } else {
      *(p++) = char((codepoint16 | 0x80) & 0xBF);
      codepoint16 = uint16_t(codepoint16 >> 6);
      if (codepoint16 < 0x10) {  // 0x10000
        *(p++) = char(codepoint16 | 0xE0);
      } else {
        *(p++) = char((codepoint16 | 0x80) & 0xBF);
        codepoint16 = uint16_t(codepoint16 >> 6);
        *(p++) = char(codepoint16 | 0xF0);
      }
    }
  }
  while (*(--p)) {
    str.append(*p);
  }
}
}  // namespace Utf8
template <typename TReader, typename TStringStorage>
class JsonDeserializer {
 public:
  JsonDeserializer(MemoryPool &pool, TReader reader,
                   TStringStorage stringStorage)
      : _stringStorage(stringStorage),
        _foundSomething(false),
        _latch(reader),
        _pool(&pool),
        _error(DeserializationError::Ok) {}
  template <typename TFilter>
  DeserializationError parse(VariantData &variant, TFilter filter,
                             NestingLimit nestingLimit) {
    parseVariant(variant, filter, nestingLimit);
    if (!_error && _latch.last() != 0 && !variant.isEnclosed()) {
      return DeserializationError::InvalidInput;
    }
    return _error;
  }
 private:
  char current() {
    return _latch.current();
  }
  void move() {
    _latch.clear();
  }
  bool eat(char charToSkip) {
    if (current() != charToSkip)
      return false;
    move();
    return true;
  }
  template <typename TFilter>
  bool parseVariant(VariantData &variant, TFilter filter,
                    NestingLimit nestingLimit) {
    if (!skipSpacesAndComments())
      return false;
    switch (current()) {
      case '[':
        if (filter.allowArray())
          return parseArray(variant.toArray(), filter, nestingLimit);
        else
          return skipArray(nestingLimit);
      case '{':
        if (filter.allowObject())
          return parseObject(variant.toObject(), filter, nestingLimit);
        else
          return skipObject(nestingLimit);
      case '\"':
      case '\'':
        if (filter.allowValue())
          return parseStringValue(variant);
        else
          return skipString();
      default:
        if (filter.allowValue())
          return parseNumericValue(variant);
        else
          return skipNumericValue();
    }
  }
  bool skipVariant(NestingLimit nestingLimit) {
    if (!skipSpacesAndComments())
      return false;
    switch (current()) {
      case '[':
        return skipArray(nestingLimit);
      case '{':
        return skipObject(nestingLimit);
      case '\"':
      case '\'':
        return skipString();
      default:
        return skipNumericValue();
    }
  }
  template <typename TFilter>
  bool parseArray(CollectionData &array, TFilter filter,
                  NestingLimit nestingLimit) {
    if (nestingLimit.reached()) {
      _error = DeserializationError::TooDeep;
      return false;
    }
    ARDUINOJSON_ASSERT(current() == '[');
    move();
    if (!skipSpacesAndComments())
      return false;
    if (eat(']'))
      return true;
    TFilter memberFilter = filter[0UL];
    for (;;) {
      if (memberFilter.allow()) {
        VariantData *value = array.addElement(_pool);
        if (!value) {
          _error = DeserializationError::NoMemory;
          return false;
        }
        if (!parseVariant(*value, memberFilter, nestingLimit.decrement()))
          return false;
      } else {
        if (!skipVariant(nestingLimit.decrement()))
          return false;
      }
      if (!skipSpacesAndComments())
        return false;
      if (eat(']'))
        return true;
      if (!eat(',')) {
        _error = DeserializationError::InvalidInput;
        return false;
      }
    }
  }
  bool skipArray(NestingLimit nestingLimit) {
    if (nestingLimit.reached()) {
      _error = DeserializationError::TooDeep;
      return false;
    }
    ARDUINOJSON_ASSERT(current() == '[');
    move();
    for (;;) {
      if (!skipVariant(nestingLimit.decrement()))
        return false;
      if (!skipSpacesAndComments())
        return false;
      if (eat(']'))
        return true;
      if (!eat(',')) {
        _error = DeserializationError::InvalidInput;
        return false;
      }
    }
  }
  template <typename TFilter>
  bool parseObject(CollectionData &object, TFilter filter,
                   NestingLimit nestingLimit) {
    if (nestingLimit.reached()) {
      _error = DeserializationError::TooDeep;
      return false;
    }
    ARDUINOJSON_ASSERT(current() == '{');
    move();
    if (!skipSpacesAndComments())
      return false;
    if (eat('}'))
      return true;
    for (;;) {
      if (!parseKey())
        return false;
      if (!skipSpacesAndComments())
        return false;
      if (!eat(':')) {
        _error = DeserializationError::InvalidInput;
        return false;
      }
      const char *key = _stringStorage.c_str();
      TFilter memberFilter = filter[key];
      if (memberFilter.allow()) {
        VariantData *variant = object.getMember(adaptString(key));
        if (!variant) {
          key = _stringStorage.save();
          VariantSlot *slot = object.addSlot(_pool);
          if (!slot) {
            _error = DeserializationError::NoMemory;
            return false;
          }
          slot->setKey(key, typename TStringStorage::storage_policy());
          variant = slot->data();
        }
        if (!parseVariant(*variant, memberFilter, nestingLimit.decrement()))
          return false;
      } else {
        if (!skipVariant(nestingLimit.decrement()))
          return false;
      }
      if (!skipSpacesAndComments())
        return false;
      if (eat('}'))
        return true;
      if (!eat(',')) {
        _error = DeserializationError::InvalidInput;
        return false;
      }
      if (!skipSpacesAndComments())
        return false;
    }
  }
  bool skipObject(NestingLimit nestingLimit) {
    if (nestingLimit.reached()) {
      _error = DeserializationError::TooDeep;
      return false;
    }
    ARDUINOJSON_ASSERT(current() == '{');
    move();
    if (!skipSpacesAndComments())
      return false;
    if (eat('}'))
      return true;
    for (;;) {
      if (!skipVariant(nestingLimit.decrement()))
        return false;
      if (!skipSpacesAndComments())
        return false;
      if (!eat(':')) {
        _error = DeserializationError::InvalidInput;
        return false;
      }
      if (!skipVariant(nestingLimit.decrement()))
        return false;
      if (!skipSpacesAndComments())
        return false;
      if (eat('}'))
        return true;
      if (!eat(',')) {
        _error = DeserializationError::InvalidInput;
        return false;
      }
    }
  }
  bool parseKey() {
    _stringStorage.startString();
    if (isQuote(current())) {
      return parseQuotedString();
    } else {
      return parseNonQuotedString();
    }
  }
  bool parseStringValue(VariantData &variant) {
    _stringStorage.startString();
    if (!parseQuotedString())
      return false;
    const char *value = _stringStorage.save();
    variant.setStringPointer(value, typename TStringStorage::storage_policy());
    return true;
  }
  bool parseQuotedString() {
#if ARDUINOJSON_DECODE_UNICODE
    Utf16::Codepoint codepoint;
#endif
    const char stopChar = current();
    move();
    for (;;) {
      char c = current();
      move();
      if (c == stopChar)
        break;
      if (c == '\0') {
        _error = DeserializationError::IncompleteInput;
        return false;
      }
      if (c == '\\') {
        c = current();
        if (c == '\0') {
          _error = DeserializationError::IncompleteInput;
          return false;
        }
        if (c == 'u') {
#if ARDUINOJSON_DECODE_UNICODE
          move();
          uint16_t codeunit;
          if (!parseHex4(codeunit))
            return false;
          if (codepoint.append(codeunit))
            Utf8::encodeCodepoint(codepoint.value(), _stringStorage);
#else
          _stringStorage.append('\\');
#endif
          continue;
        }
        c = EscapeSequence::unescapeChar(c);
        if (c == '\0') {
          _error = DeserializationError::InvalidInput;
          return false;
        }
        move();
      }
      _stringStorage.append(c);
    }
    _stringStorage.append('\0');
    if (!_stringStorage.isValid()) {
      _error = DeserializationError::NoMemory;
      return false;
    }
    return true;
  }
  bool parseNonQuotedString() {
    char c = current();
    ARDUINOJSON_ASSERT(c);
    if (canBeInNonQuotedString(c)) {  // no quotes
      do {
        move();
        _stringStorage.append(c);
        c = current();
      } while (canBeInNonQuotedString(c));
    } else {
      _error = DeserializationError::InvalidInput;
      return false;
    }
    _stringStorage.append('\0');
    if (!_stringStorage.isValid()) {
      _error = DeserializationError::NoMemory;
      return false;
    }
    return true;
  }
  bool skipString() {
    const char stopChar = current();
    move();
    for (;;) {
      char c = current();
      move();
      if (c == stopChar)
        break;
      if (c == '\0') {
        _error = DeserializationError::IncompleteInput;
        return false;
      }
      if (c == '\\') {
        if (current() != '\0')
          move();
      }
    }
    return true;
  }
  bool parseNumericValue(VariantData &result) {
    uint8_t n = 0;
    char c = current();
    while (canBeInNonQuotedString(c) && n < 63) {
      move();
      _buffer[n++] = c;
      c = current();
    }
    _buffer[n] = 0;
    c = _buffer[0];
    if (c == 't') {  // true
      result.setBoolean(true);
      if (n != 4) {
        _error = DeserializationError::IncompleteInput;
        return false;
      }
      return true;
    }
    if (c == 'f') {  // false
      result.setBoolean(false);
      if (n != 5) {
        _error = DeserializationError::IncompleteInput;
        return false;
      }
      return true;
    }
    if (c == 'n') {  // null
      if (n != 4) {
        _error = DeserializationError::IncompleteInput;
        return false;
      }
      return true;
    }
    if (!parseNumber(_buffer, result)) {
      _error = DeserializationError::InvalidInput;
      return false;
    }
    return true;
  }
  bool skipNumericValue() {
    char c = current();
    while (canBeInNonQuotedString(c)) {
      move();
      c = current();
    }
    return true;
  }
  bool parseHex4(uint16_t &result) {
    result = 0;
    for (uint8_t i = 0; i < 4; ++i) {
      char digit = current();
      if (!digit) {
        _error = DeserializationError::IncompleteInput;
        return false;
      }
      uint8_t value = decodeHex(digit);
      if (value > 0x0F) {
        _error = DeserializationError::InvalidInput;
        return false;
      }
      result = uint16_t((result << 4) | value);
      move();
    }
    return true;
  }
  static inline bool isBetween(char c, char min, char max) {
    return min <= c && c <= max;
  }
  static inline bool canBeInNonQuotedString(char c) {
    return isBetween(c, '0', '9') || isBetween(c, '_', 'z') ||
           isBetween(c, 'A', 'Z') || c == '+' || c == '-' || c == '.';
  }
  static inline bool isQuote(char c) {
    return c == '\'' || c == '\"';
  }
  static inline uint8_t decodeHex(char c) {
    if (c < 'A')
      return uint8_t(c - '0');
    c = char(c & ~0x20);  // uppercase
    return uint8_t(c - 'A' + 10);
  }
  bool skipSpacesAndComments() {
    for (;;) {
      switch (current()) {
        case '\0':
          _error = _foundSomething ? DeserializationError::IncompleteInput
                                   : DeserializationError::EmptyInput;
          return false;
        case ' ':
        case '\t':
        case '\r':
        case '\n':
          move();
          continue;
#if ARDUINOJSON_ENABLE_COMMENTS
        case '/':
          move();  // skip '/'
          switch (current()) {
            case '*': {
              move();  // skip '*'
              bool wasStar = false;
              for (;;) {
                char c = current();
                if (c == '\0') {
                  _error = DeserializationError::IncompleteInput;
                  return false;
                }
                if (c == '/' && wasStar) {
                  move();
                  break;
                }
                wasStar = c == '*';
                move();
              }
              break;
            }
            case '/':
              for (;;) {
                move();
                char c = current();
                if (c == '\0') {
                  _error = DeserializationError::IncompleteInput;
                  return false;
                }
                if (c == '\n')
                  break;
              }
              break;
            default:
              _error = DeserializationError::InvalidInput;
              return false;
          }
          break;
#endif
        default:
          _foundSomething = true;
          return true;
      }
    }
  }
  TStringStorage _stringStorage;
  bool _foundSomething;
  Latch<TReader> _latch;
  MemoryPool *_pool;
  char _buffer[64];  // using a member instead of a local variable because it
  DeserializationError _error;
};
template <typename TString>
DeserializationError deserializeJson(
    JsonDocument &doc, const TString &input,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<JsonDeserializer>(doc, input, nestingLimit,
                                       AllowAllFilter());
}
template <typename TString>
DeserializationError deserializeJson(
    JsonDocument &doc, const TString &input, Filter filter,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<JsonDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TString>
DeserializationError deserializeJson(JsonDocument &doc, const TString &input,
                                     NestingLimit nestingLimit, Filter filter) {
  return deserialize<JsonDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TStream>
DeserializationError deserializeJson(
    JsonDocument &doc, TStream &input,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<JsonDeserializer>(doc, input, nestingLimit,
                                       AllowAllFilter());
}
template <typename TStream>
DeserializationError deserializeJson(
    JsonDocument &doc, TStream &input, Filter filter,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<JsonDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TStream>
DeserializationError deserializeJson(JsonDocument &doc, TStream &input,
                                     NestingLimit nestingLimit, Filter filter) {
  return deserialize<JsonDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TChar>
DeserializationError deserializeJson(
    JsonDocument &doc, TChar *input,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<JsonDeserializer>(doc, input, nestingLimit,
                                       AllowAllFilter());
}
template <typename TChar>
DeserializationError deserializeJson(
    JsonDocument &doc, TChar *input, Filter filter,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<JsonDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TChar>
DeserializationError deserializeJson(JsonDocument &doc, TChar *input,
                                     NestingLimit nestingLimit, Filter filter) {
  return deserialize<JsonDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TChar>
DeserializationError deserializeJson(
    JsonDocument &doc, TChar *input, size_t inputSize,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<JsonDeserializer>(doc, input, inputSize, nestingLimit,
                                       AllowAllFilter());
}
template <typename TChar>
DeserializationError deserializeJson(
    JsonDocument &doc, TChar *input, size_t inputSize, Filter filter,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<JsonDeserializer>(doc, input, inputSize, nestingLimit,
                                       filter);
}
template <typename TChar>
DeserializationError deserializeJson(JsonDocument &doc, TChar *input,
                                     size_t inputSize,
                                     NestingLimit nestingLimit, Filter filter) {
  return deserialize<JsonDeserializer>(doc, input, inputSize, nestingLimit,
                                       filter);
}
template <typename TFloat>
struct FloatParts {
  uint32_t integral;
  uint32_t decimal;
  int16_t exponent;
  int8_t decimalPlaces;
  FloatParts(TFloat value) {
    uint32_t maxDecimalPart = sizeof(TFloat) >= 8 ? 1000000000 : 1000000;
    decimalPlaces = sizeof(TFloat) >= 8 ? 9 : 6;
    exponent = normalize(value);
    integral = uint32_t(value);
    for (uint32_t tmp = integral; tmp >= 10; tmp /= 10) {
      maxDecimalPart /= 10;
      decimalPlaces--;
    }
    TFloat remainder = (value - TFloat(integral)) * TFloat(maxDecimalPart);
    decimal = uint32_t(remainder);
    remainder = remainder - TFloat(decimal);
    decimal += uint32_t(remainder * 2);
    if (decimal >= maxDecimalPart) {
      decimal = 0;
      integral++;
      if (exponent && integral >= 10) {
        exponent++;
        integral = 1;
      }
    }
    while (decimal % 10 == 0 && decimalPlaces > 0) {
      decimal /= 10;
      decimalPlaces--;
    }
  }
  static int16_t normalize(TFloat& value) {
    typedef FloatTraits<TFloat> traits;
    int16_t powersOf10 = 0;
    int8_t index = sizeof(TFloat) == 8 ? 8 : 5;
    int bit = 1 << index;
    if (value >= ARDUINOJSON_POSITIVE_EXPONENTIATION_THRESHOLD) {
      for (; index >= 0; index--) {
        if (value >= traits::positiveBinaryPowerOfTen(index)) {
          value *= traits::negativeBinaryPowerOfTen(index);
          powersOf10 = int16_t(powersOf10 + bit);
        }
        bit >>= 1;
      }
    }
    if (value > 0 && value <= ARDUINOJSON_NEGATIVE_EXPONENTIATION_THRESHOLD) {
      for (; index >= 0; index--) {
        if (value < traits::negativeBinaryPowerOfTenPlusOne(index)) {
          value *= traits::positiveBinaryPowerOfTen(index);
          powersOf10 = int16_t(powersOf10 - bit);
        }
        bit >>= 1;
      }
    }
    return powersOf10;
  }
};
template <typename TWriter>
class CountingDecorator {
 public:
  explicit CountingDecorator(TWriter& writer) : _writer(writer), _count(0) {}
  void write(uint8_t c) {
    _count += _writer.write(c);
  }
  void write(const uint8_t* s, size_t n) {
    _count += _writer.write(s, n);
  }
  size_t count() const {
    return _count;
  }
 private:
  TWriter _writer;
  size_t _count;
};
template <typename TWriter>
class TextFormatter {
 public:
  explicit TextFormatter(TWriter writer) : _writer(writer) {}
  size_t bytesWritten() const {
    return _writer.count();
  }
  void writeBoolean(bool value) {
    if (value)
      writeRaw("true");
    else
      writeRaw("false");
  }
  void writeString(const char *value) {
    ARDUINOJSON_ASSERT(value != NULL);
    writeRaw('\"');
    while (*value) writeChar(*value++);
    writeRaw('\"');
  }
  void writeChar(char c) {
    char specialChar = EscapeSequence::escapeChar(c);
    if (specialChar) {
      writeRaw('\\');
      writeRaw(specialChar);
    } else {
      writeRaw(c);
    }
  }
  template <typename T>
  void writeFloat(T value) {
    if (isnan(value))
      return writeRaw(ARDUINOJSON_ENABLE_NAN ? "NaN" : "null");
#if ARDUINOJSON_ENABLE_INFINITY
    if (value < 0.0) {
      writeRaw('-');
      value = -value;
    }
    if (isinf(value))
      return writeRaw("Infinity");
#else
    if (isinf(value))
      return writeRaw("null");
    if (value < 0.0) {
      writeRaw('-');
      value = -value;
    }
#endif
    FloatParts<T> parts(value);
    writeInteger(parts.integral);
    if (parts.decimalPlaces)
      writeDecimals(parts.decimal, parts.decimalPlaces);
    if (parts.exponent) {
      writeRaw('e');
      writeInteger(parts.exponent);
    }
  }
  template <typename T>
  typename enable_if<is_signed<T>::value>::type writeInteger(T value) {
    typedef typename make_unsigned<T>::type unsigned_type;
    unsigned_type unsigned_value;
    if (value < 0) {
      writeRaw('-');
      unsigned_value = unsigned_type(unsigned_type(~value) + 1);
    } else {
      unsigned_value = unsigned_type(value);
    }
    writeInteger(unsigned_value);
  }
  template <typename T>
  typename enable_if<is_unsigned<T>::value>::type writeInteger(T value) {
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;
    do {
      *--begin = char(value % 10 + '0');
      value = T(value / 10);
    } while (value);
    writeRaw(begin, end);
  }
  void writeDecimals(uint32_t value, int8_t width) {
    char buffer[16];
    char *end = buffer + sizeof(buffer);
    char *begin = end;
    while (width--) {
      *--begin = char(value % 10 + '0');
      value /= 10;
    }
    *--begin = '.';
    writeRaw(begin, end);
  }
  void writeRaw(const char *s) {
    _writer.write(reinterpret_cast<const uint8_t *>(s), strlen(s));
  }
  void writeRaw(const char *s, size_t n) {
    _writer.write(reinterpret_cast<const uint8_t *>(s), n);
  }
  void writeRaw(const char *begin, const char *end) {
    _writer.write(reinterpret_cast<const uint8_t *>(begin),
                  static_cast<size_t>(end - begin));
  }
  template <size_t N>
  void writeRaw(const char (&s)[N]) {
    _writer.write(reinterpret_cast<const uint8_t *>(s), N - 1);
  }
  void writeRaw(char c) {
    _writer.write(static_cast<uint8_t>(c));
  }
 protected:
  CountingDecorator<TWriter> _writer;
 private:
  TextFormatter &operator=(const TextFormatter &);  // cannot be assigned
};
class DummyWriter {
 public:
  size_t write(uint8_t) {
    return 1;
  }
  size_t write(const uint8_t*, size_t n) {
    return n;
  }
};
template <template <typename> class TSerializer, typename TSource>
size_t measure(const TSource &source) {
  DummyWriter dp;
  TSerializer<DummyWriter> serializer(dp);
  return source.accept(serializer);
}
template <typename TDestination, typename Enable = void>
class Writer {
 public:
  explicit Writer(TDestination& dest) : _dest(&dest) {}
  size_t write(uint8_t c) {
    return _dest->write(c);
  }
  size_t write(const uint8_t* s, size_t n) {
    return _dest->write(s, n);
  }
 private:
  TDestination* _dest;
};
class StaticStringWriter {
 public:
  StaticStringWriter(char *buf, size_t size) : end(buf + size), p(buf) {}
  size_t write(uint8_t c) {
    if (p >= end)
      return 0;
    *p++ = static_cast<char>(c);
    return 1;
  }
  size_t write(const uint8_t *s, size_t n) {
    char *begin = p;
    while (p < end && n > 0) {
      *p++ = static_cast<char>(*s++);
      n--;
    }
    return size_t(p - begin);
  }
 private:
  char *end;
  char *p;
};
}  // namespace ARDUINOJSON_NAMESPACE
#if ARDUINOJSON_ENABLE_STD_STRING
namespace ARDUINOJSON_NAMESPACE {
template <class T>
struct is_std_string : false_type {};
template <class TCharTraits, class TAllocator>
struct is_std_string<std::basic_string<char, TCharTraits, TAllocator> >
    : true_type {};
template <typename TDestination>
class Writer<TDestination,
             typename enable_if<is_std_string<TDestination>::value>::type> {
 public:
  Writer(TDestination &str) : _str(&str) {}
  size_t write(uint8_t c) {
    _str->operator+=(static_cast<char>(c));
    return 1;
  }
  size_t write(const uint8_t *s, size_t n) {
    _str->append(reinterpret_cast<const char *>(s), n);
    return n;
  }
 private:
  TDestination *_str;
};
}  // namespace ARDUINOJSON_NAMESPACE
#endif
#if ARDUINOJSON_ENABLE_ARDUINO_STRING
namespace ARDUINOJSON_NAMESPACE {
template <>
class Writer< ::String, void> {
  static const size_t bufferCapacity = ARDUINOJSON_STRING_BUFFER_SIZE;
 public:
  explicit Writer(::String &str) : _destination(&str) {
    _size = 0;
  }
  ~Writer() {
    flush();
  }
  size_t write(uint8_t c) {
    if (_size + 1 >= bufferCapacity)
      if (flush() != 0)
        return 0;
    _buffer[_size++] = static_cast<char>(c);
    return 1;
  }
  size_t write(const uint8_t *s, size_t n) {
    for (size_t i = 0; i < n; i++) {
      write(s[i]);
    }
    return n;
  }
  size_t flush() {
    ARDUINOJSON_ASSERT(_size < bufferCapacity);
    _buffer[_size] = 0;
    if (_destination->concat(_buffer))
      _size = 0;
    return _size;
  }
 private:
  ::String *_destination;
  char _buffer[bufferCapacity];
  size_t _size;
};
}  // namespace ARDUINOJSON_NAMESPACE
#endif
#if ARDUINOJSON_ENABLE_STD_STREAM
namespace ARDUINOJSON_NAMESPACE {
template <typename TDestination>
class Writer<
    TDestination,
    typename enable_if<is_base_of<std::ostream, TDestination>::value>::type> {
 public:
  explicit Writer(std::ostream& os) : _os(&os) {}
  size_t write(uint8_t c) {
    _os->put(static_cast<char>(c));
    return 1;
  }
  size_t write(const uint8_t* s, size_t n) {
    _os->write(reinterpret_cast<const char*>(s),
               static_cast<std::streamsize>(n));
    return n;
  }
 private:
  std::ostream* _os;
};
}  // namespace ARDUINOJSON_NAMESPACE
#endif
#if ARDUINOJSON_ENABLE_ARDUINO_PRINT
namespace ARDUINOJSON_NAMESPACE {
template <typename TDestination>
class Writer<
    TDestination,
    typename enable_if<is_base_of< ::Print, TDestination>::value>::type> {
 public:
  explicit Writer(::Print& print) : _print(&print) {}
  size_t write(uint8_t c) {
    return _print->write(c);
  }
  size_t write(const uint8_t* s, size_t n) {
    return _print->write(s, n);
  }
 private:
  ::Print* _print;
};
}  // namespace ARDUINOJSON_NAMESPACE
#endif
namespace ARDUINOJSON_NAMESPACE {
template <template <typename> class TSerializer, typename TSource,
          typename TWriter>
size_t doSerialize(const TSource &source, TWriter writer) {
  TSerializer<TWriter> serializer(writer);
  return source.accept(serializer);
}
template <template <typename> class TSerializer, typename TSource,
          typename TDestination>
size_t serialize(const TSource &source, TDestination &destination) {
  Writer<TDestination> writer(destination);
  return doSerialize<TSerializer>(source, writer);
}
template <template <typename> class TSerializer, typename TSource>
typename enable_if<!TSerializer<StaticStringWriter>::producesText, size_t>::type
serialize(const TSource &source, void *buffer, size_t bufferSize) {
  StaticStringWriter writer(reinterpret_cast<char *>(buffer), bufferSize);
  return doSerialize<TSerializer>(source, writer);
}
template <template <typename> class TSerializer, typename TSource>
typename enable_if<TSerializer<StaticStringWriter>::producesText, size_t>::type
serialize(const TSource &source, void *buffer, size_t bufferSize) {
  StaticStringWriter writer(reinterpret_cast<char *>(buffer), bufferSize);
  size_t n = doSerialize<TSerializer>(source, writer);
  if (n < bufferSize)
    reinterpret_cast<char *>(buffer)[n] = 0;
  return n;
}
template <template <typename> class TSerializer, typename TSource,
          typename TChar, size_t N>
#if defined _MSC_VER && _MSC_VER < 1900
typename enable_if<sizeof(remove_reference<TChar>::type) == 1, size_t>::type
#else
typename enable_if<sizeof(TChar) == 1, size_t>::type
#endif
serialize(const TSource &source, TChar (&buffer)[N]) {
  return serialize<TSerializer>(source, buffer, N);
}
template <typename TWriter>
class JsonSerializer : public Visitor<size_t> {
 public:
  static const bool producesText = true;
  JsonSerializer(TWriter writer) : _formatter(writer) {}
  FORCE_INLINE size_t visitArray(const CollectionData &array) {
    write('[');
    VariantSlot *slot = array.head();
    while (slot != 0) {
      slot->data()->accept(*this);
      slot = slot->next();
      if (slot == 0)
        break;
      write(',');
    }
    write(']');
    return bytesWritten();
  }
  size_t visitObject(const CollectionData &object) {
    write('{');
    VariantSlot *slot = object.head();
    while (slot != 0) {
      _formatter.writeString(slot->key());
      write(':');
      slot->data()->accept(*this);
      slot = slot->next();
      if (slot == 0)
        break;
      write(',');
    }
    write('}');
    return bytesWritten();
  }
  size_t visitFloat(Float value) {
    _formatter.writeFloat(value);
    return bytesWritten();
  }
  size_t visitString(const char *value) {
    _formatter.writeString(value);
    return bytesWritten();
  }
  size_t visitRawJson(const char *data, size_t n) {
    _formatter.writeRaw(data, n);
    return bytesWritten();
  }
  size_t visitSignedInteger(Integer value) {
    _formatter.writeInteger(value);
    return bytesWritten();
  }
  size_t visitUnsignedInteger(UInt value) {
    _formatter.writeInteger(value);
    return bytesWritten();
  }
  size_t visitBoolean(bool value) {
    _formatter.writeBoolean(value);
    return bytesWritten();
  }
  size_t visitNull() {
    _formatter.writeRaw("null");
    return bytesWritten();
  }
 protected:
  size_t bytesWritten() const {
    return _formatter.bytesWritten();
  }
  void write(char c) {
    _formatter.writeRaw(c);
  }
  void write(const char *s) {
    _formatter.writeRaw(s);
  }
 private:
  TextFormatter<TWriter> _formatter;
};
template <typename TSource, typename TDestination>
size_t serializeJson(const TSource &source, TDestination &destination) {
  return serialize<JsonSerializer>(source, destination);
}
template <typename TSource>
size_t serializeJson(const TSource &source, void *buffer, size_t bufferSize) {
  return serialize<JsonSerializer>(source, buffer, bufferSize);
}
template <typename TSource>
size_t measureJson(const TSource &source) {
  return measure<JsonSerializer>(source);
}
#if ARDUINOJSON_ENABLE_STD_STREAM
template <typename T>
inline typename enable_if<IsVisitable<T>::value, std::ostream &>::type
operator<<(std::ostream &os, const T &source) {
  serializeJson(source, os);
  return os;
}
#endif
template <typename TWriter>
class PrettyJsonSerializer : public JsonSerializer<TWriter> {
  typedef JsonSerializer<TWriter> base;
 public:
  PrettyJsonSerializer(TWriter writer) : base(writer), _nesting(0) {}
  size_t visitArray(const CollectionData &array) {
    VariantSlot *slot = array.head();
    if (slot) {
      base::write("[\r\n");
      _nesting++;
      while (slot != 0) {
        indent();
        slot->data()->accept(*this);
        slot = slot->next();
        base::write(slot ? ",\r\n" : "\r\n");
      }
      _nesting--;
      indent();
      base::write("]");
    } else {
      base::write("[]");
    }
    return this->bytesWritten();
  }
  size_t visitObject(const CollectionData &object) {
    VariantSlot *slot = object.head();
    if (slot) {
      base::write("{\r\n");
      _nesting++;
      while (slot != 0) {
        indent();
        base::visitString(slot->key());
        base::write(": ");
        slot->data()->accept(*this);
        slot = slot->next();
        base::write(slot ? ",\r\n" : "\r\n");
      }
      _nesting--;
      indent();
      base::write("}");
    } else {
      base::write("{}");
    }
    return this->bytesWritten();
  }
 private:
  void indent() {
    for (uint8_t i = 0; i < _nesting; i++) base::write(ARDUINOJSON_TAB);
  }
  uint8_t _nesting;
};
template <typename TSource, typename TDestination>
size_t serializeJsonPretty(const TSource &source, TDestination &destination) {
  return serialize<PrettyJsonSerializer>(source, destination);
}
template <typename TSource>
size_t serializeJsonPretty(const TSource &source, void *buffer,
                           size_t bufferSize) {
  return serialize<PrettyJsonSerializer>(source, buffer, bufferSize);
}
template <typename TSource>
size_t measureJsonPretty(const TSource &source) {
  return measure<PrettyJsonSerializer>(source);
}
template <typename T>
inline void swap(T& a, T& b) {
  T t(a);
  a = b;
  b = t;
}
#if ARDUINOJSON_HAS_RVALUE_REFERENCES
template <typename T>
typename remove_reference<T>::type&& move(T&& t) {
  return static_cast<typename remove_reference<T>::type&&>(t);
}
#else
template <typename T>
T& move(T& t) {
  return t;
}
#endif
#if ARDUINOJSON_LITTLE_ENDIAN
inline void fixEndianess(uint8_t *p, integral_constant<size_t, 8>) {
  swap(p[0], p[7]);
  swap(p[1], p[6]);
  swap(p[2], p[5]);
  swap(p[3], p[4]);
}
inline void fixEndianess(uint8_t *p, integral_constant<size_t, 4>) {
  swap(p[0], p[3]);
  swap(p[1], p[2]);
}
inline void fixEndianess(uint8_t *p, integral_constant<size_t, 2>) {
  swap(p[0], p[1]);
}
inline void fixEndianess(uint8_t *, integral_constant<size_t, 1>) {}
template <typename T>
inline void fixEndianess(T &value) {
  fixEndianess(reinterpret_cast<uint8_t *>(&value),
               integral_constant<size_t, sizeof(T)>());
}
#else
template <typename T>
inline void fixEndianess(T &) {}
#endif
inline void doubleToFloat(const uint8_t d[8], uint8_t f[4]) {
  f[0] = uint8_t((d[0] & 0xC0) | (d[0] << 3 & 0x3f) | (d[1] >> 5));
  f[1] = uint8_t((d[1] << 3) | (d[2] >> 5));
  f[2] = uint8_t((d[2] << 3) | (d[3] >> 5));
  f[3] = uint8_t((d[3] << 3) | (d[4] >> 5));
}
template <typename TReader, typename TStringStorage>
class MsgPackDeserializer {
 public:
  MsgPackDeserializer(MemoryPool &pool, TReader reader,
                      TStringStorage stringStorage)
      : _pool(&pool),
        _reader(reader),
        _stringStorage(stringStorage),
        _error(DeserializationError::Ok),
        _foundSomething(false) {}
  template <typename TFilter>
  DeserializationError parse(VariantData &variant, TFilter filter,
                             NestingLimit nestingLimit) {
    parseVariant(&variant, filter, nestingLimit);
    return _foundSomething ? _error : DeserializationError::EmptyInput;
  }
 private:
  bool invalidInput() {
    _error = DeserializationError::InvalidInput;
    return false;
  }
  template <typename TFilter>
  bool parseVariant(VariantData *variant, TFilter filter,
                    NestingLimit nestingLimit) {
    uint8_t code = 0;  // TODO: why do we need to initialize this variable?
    if (!readByte(code))
      return false;
    _foundSomething = true;
    bool allowValue = filter.allowValue();
    switch (code) {
      case 0xc0:
        return true;
      case 0xc1:
        return invalidInput();
      case 0xc2:
        if (allowValue)
          variant->setBoolean(false);
        return true;
      case 0xc3:
        if (allowValue)
          variant->setBoolean(true);
        return true;
      case 0xc4:  // bin 8 (not supported)
        return skipString<uint8_t>();
      case 0xc5:  // bin 16 (not supported)
        return skipString<uint16_t>();
      case 0xc6:  // bin 32 (not supported)
        return skipString<uint32_t>();
      case 0xc7:  // ext 8 (not supported)
        return skipExt<uint8_t>();
      case 0xc8:  // ext 16 (not supported)
        return skipExt<uint16_t>();
      case 0xc9:  // ext 32 (not supported)
        return skipExt<uint32_t>();
      case 0xca:
        if (allowValue)
          return readFloat<float>(variant);
        else
          return skipBytes(4);
      case 0xcb:
        if (allowValue)
          return readDouble<double>(variant);
        else
          return skipBytes(8);
      case 0xcc:
        if (allowValue)
          return readInteger<uint8_t>(variant);
        else
          return skipBytes(1);
      case 0xcd:
        if (allowValue)
          return readInteger<uint16_t>(variant);
        else
          return skipBytes(2);
      case 0xce:
        if (allowValue)
          return readInteger<uint32_t>(variant);
        else
          return skipBytes(4);
      case 0xcf:
#if ARDUINOJSON_USE_LONG_LONG
        if (allowValue)
          return readInteger<uint64_t>(variant);
        else
          return skipBytes(8);
#else
        return skipBytes(8);  // not supported
#endif
      case 0xd0:
        if (allowValue)
          return readInteger<int8_t>(variant);
        else
          return skipBytes(1);
      case 0xd1:
        if (allowValue)
          return readInteger<int16_t>(variant);
        else
          return skipBytes(2);
      case 0xd2:
        if (allowValue)
          return readInteger<int32_t>(variant);
        else
          return skipBytes(4);
      case 0xd3:
#if ARDUINOJSON_USE_LONG_LONG
        if (allowValue)
          return readInteger<int64_t>(variant);
        else
          return skipBytes(8);  // not supported
#else
        return skipBytes(8);
#endif
      case 0xd4:  // fixext 1 (not supported)
        return skipBytes(2);
      case 0xd5:  // fixext 2 (not supported)
        return skipBytes(3);
      case 0xd6:  // fixext 4 (not supported)
        return skipBytes(5);
      case 0xd7:  // fixext 8 (not supported)
        return skipBytes(9);
      case 0xd8:  // fixext 16 (not supported)
        return skipBytes(17);
      case 0xd9:
        if (allowValue)
          return readString<uint8_t>(variant);
        else
          return skipString<uint8_t>();
      case 0xda:
        if (allowValue)
          return readString<uint16_t>(variant);
        else
          return skipString<uint16_t>();
      case 0xdb:
        if (allowValue)
          return readString<uint32_t>(variant);
        else
          return skipString<uint32_t>();
      case 0xdc:
        return readArray<uint16_t>(variant, filter, nestingLimit);
      case 0xdd:
        return readArray<uint32_t>(variant, filter, nestingLimit);
      case 0xde:
        return readObject<uint16_t>(variant, filter, nestingLimit);
      case 0xdf:
        return readObject<uint32_t>(variant, filter, nestingLimit);
    }
    switch (code & 0xf0) {
      case 0x80:
        return readObject(variant, code & 0x0F, filter, nestingLimit);
      case 0x90:
        return readArray(variant, code & 0x0F, filter, nestingLimit);
    }
    if ((code & 0xe0) == 0xa0) {
      if (allowValue)
        return readString(variant, code & 0x1f);
      else
        return skipBytes(code & 0x1f);
    }
    if (allowValue)
      variant->setInteger(static_cast<int8_t>(code));
    return true;
  }
  bool readByte(uint8_t &value) {
    int c = _reader.read();
    if (c < 0) {
      _error = DeserializationError::IncompleteInput;
      return false;
    }
    value = static_cast<uint8_t>(c);
    return true;
  }
  bool readBytes(uint8_t *p, size_t n) {
    if (_reader.readBytes(reinterpret_cast<char *>(p), n) == n)
      return true;
    _error = DeserializationError::IncompleteInput;
    return false;
  }
  template <typename T>
  bool readBytes(T &value) {
    return readBytes(reinterpret_cast<uint8_t *>(&value), sizeof(value));
  }
  bool skipBytes(size_t n) {
    for (; n; --n) {
      if (_reader.read() < 0) {
        _error = DeserializationError::IncompleteInput;
        return false;
      }
    }
    return true;
  }
  template <typename T>
  bool readInteger(T &value) {
    if (!readBytes(value))
      return false;
    fixEndianess(value);
    return true;
  }
  template <typename T>
  bool readInteger(VariantData *variant) {
    T value;
    if (!readInteger(value))
      return false;
    variant->setInteger(value);
    return true;
  }
  template <typename T>
  typename enable_if<sizeof(T) == 4, bool>::type readFloat(
      VariantData *variant) {
    T value;
    if (!readBytes(value))
      return false;
    fixEndianess(value);
    variant->setFloat(value);
    return true;
  }
  template <typename T>
  typename enable_if<sizeof(T) == 8, bool>::type readDouble(
      VariantData *variant) {
    T value;
    if (!readBytes(value))
      return false;
    fixEndianess(value);
    variant->setFloat(value);
    return true;
  }
  template <typename T>
  typename enable_if<sizeof(T) == 4, bool>::type readDouble(
      VariantData *variant) {
    uint8_t i[8];  // input is 8 bytes
    T value;       // output is 4 bytes
    uint8_t *o = reinterpret_cast<uint8_t *>(&value);
    if (!readBytes(i, 8))
      return false;
    doubleToFloat(i, o);
    fixEndianess(value);
    variant->setFloat(value);
    return true;
  }
  template <typename T>
  bool readString(VariantData *variant) {
    T size;
    if (!readInteger(size))
      return false;
    return readString(variant, size);
  }
  template <typename T>
  bool readString() {
    T size;
    if (!readInteger(size))
      return false;
    return readString(size);
  }
  template <typename T>
  bool skipString() {
    T size;
    if (!readInteger(size))
      return false;
    return skipBytes(size);
  }
  bool readString(VariantData *variant, size_t n) {
    if (!readString(n))
      return false;
    variant->setStringPointer(_stringStorage.save(),
                              typename TStringStorage::storage_policy());
    return true;
  }
  bool readString(size_t n) {
    _stringStorage.startString();
    for (; n; --n) {
      uint8_t c;
      if (!readBytes(c))
        return false;
      _stringStorage.append(static_cast<char>(c));
    }
    _stringStorage.append('\0');
    if (!_stringStorage.isValid()) {
      _error = DeserializationError::NoMemory;
      return false;
    }
    return true;
  }
  template <typename TSize, typename TFilter>
  bool readArray(VariantData *variant, TFilter filter,
                 NestingLimit nestingLimit) {
    TSize size;
    if (!readInteger(size))
      return false;
    return readArray(variant, size, filter, nestingLimit);
  }
  template <typename TFilter>
  bool readArray(VariantData *variant, size_t n, TFilter filter,
                 NestingLimit nestingLimit) {
    if (nestingLimit.reached()) {
      _error = DeserializationError::TooDeep;
      return false;
    }
    bool allowArray = filter.allowArray();
    CollectionData *array = allowArray ? &variant->toArray() : 0;
    TFilter memberFilter = filter[0U];
    for (; n; --n) {
      VariantData *value;
      if (memberFilter.allow()) {
        value = array->addElement(_pool);
        if (!value) {
          _error = DeserializationError::NoMemory;
          return false;
        }
      } else {
        value = 0;
      }
      if (!parseVariant(value, memberFilter, nestingLimit.decrement()))
        return false;
    }
    return true;
  }
  template <typename TSize, typename TFilter>
  bool readObject(VariantData *variant, TFilter filter,
                  NestingLimit nestingLimit) {
    TSize size;
    if (!readInteger(size))
      return false;
    return readObject(variant, size, filter, nestingLimit);
  }
  template <typename TFilter>
  bool readObject(VariantData *variant, size_t n, TFilter filter,
                  NestingLimit nestingLimit) {
    if (nestingLimit.reached()) {
      _error = DeserializationError::TooDeep;
      return false;
    }
    CollectionData *object = filter.allowObject() ? &variant->toObject() : 0;
    for (; n; --n) {
      if (!readKey())
        return false;
      const char *key = _stringStorage.c_str();
      TFilter memberFilter = filter[key];
      VariantData *member;
      if (memberFilter.allow()) {
        key = _stringStorage.save();
        VariantSlot *slot = object->addSlot(_pool);
        if (!slot) {
          _error = DeserializationError::NoMemory;
          return false;
        }
        slot->setKey(key, typename TStringStorage::storage_policy());
        member = slot->data();
      } else {
        member = 0;
      }
      if (!parseVariant(member, memberFilter, nestingLimit.decrement()))
        return false;
    }
    return true;
  }
  bool readKey() {
    uint8_t code;
    if (!readByte(code))
      return false;
    if ((code & 0xe0) == 0xa0)
      return readString(code & 0x1f);
    switch (code) {
      case 0xd9:
        return readString<uint8_t>();
      case 0xda:
        return readString<uint16_t>();
      case 0xdb:
        return readString<uint32_t>();
      default:
        return invalidInput();
    }
  }
  template <typename T>
  bool skipExt() {
    T size;
    if (!readInteger(size))
      return false;
    return skipBytes(size + 1);
  }
  MemoryPool *_pool;
  TReader _reader;
  TStringStorage _stringStorage;
  DeserializationError _error;
  bool _foundSomething;
};
template <typename TString>
DeserializationError deserializeMsgPack(
    JsonDocument &doc, const TString &input,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<MsgPackDeserializer>(doc, input, nestingLimit,
                                          AllowAllFilter());
}
template <typename TString>
DeserializationError deserializeMsgPack(
    JsonDocument &doc, const TString &input, Filter filter,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<MsgPackDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TString>
DeserializationError deserializeMsgPack(JsonDocument &doc, const TString &input,
                                        NestingLimit nestingLimit,
                                        Filter filter) {
  return deserialize<MsgPackDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TStream>
DeserializationError deserializeMsgPack(
    JsonDocument &doc, TStream &input,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<MsgPackDeserializer>(doc, input, nestingLimit,
                                          AllowAllFilter());
}
template <typename TStream>
DeserializationError deserializeMsgPack(
    JsonDocument &doc, TStream &input, Filter filter,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<MsgPackDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TStream>
DeserializationError deserializeMsgPack(JsonDocument &doc, TStream &input,
                                        NestingLimit nestingLimit,
                                        Filter filter) {
  return deserialize<MsgPackDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TChar>
DeserializationError deserializeMsgPack(
    JsonDocument &doc, TChar *input,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<MsgPackDeserializer>(doc, input, nestingLimit,
                                          AllowAllFilter());
}
template <typename TChar>
DeserializationError deserializeMsgPack(
    JsonDocument &doc, TChar *input, Filter filter,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<MsgPackDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TChar>
DeserializationError deserializeMsgPack(JsonDocument &doc, TChar *input,
                                        NestingLimit nestingLimit,
                                        Filter filter) {
  return deserialize<MsgPackDeserializer>(doc, input, nestingLimit, filter);
}
template <typename TChar>
DeserializationError deserializeMsgPack(
    JsonDocument &doc, TChar *input, size_t inputSize,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<MsgPackDeserializer>(doc, input, inputSize, nestingLimit,
                                          AllowAllFilter());
}
template <typename TChar>
DeserializationError deserializeMsgPack(
    JsonDocument &doc, TChar *input, size_t inputSize, Filter filter,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<MsgPackDeserializer>(doc, input, inputSize, nestingLimit,
                                          filter);
}
template <typename TChar>
DeserializationError deserializeMsgPack(JsonDocument &doc, TChar *input,
                                        size_t inputSize,
                                        NestingLimit nestingLimit,
                                        Filter filter) {
  return deserialize<MsgPackDeserializer>(doc, input, inputSize, nestingLimit,
                                          filter);
}
template <typename TWriter>
class MsgPackSerializer : public Visitor<size_t> {
 public:
  static const bool producesText = false;
  MsgPackSerializer(TWriter writer) : _writer(writer) {}
  template <typename T>
  typename enable_if<sizeof(T) == 4, size_t>::type visitFloat(T value32) {
    writeByte(0xCA);
    writeInteger(value32);
    return bytesWritten();
  }
  template <typename T>
  ARDUINOJSON_NO_SANITIZE("float-cast-overflow")
  typename enable_if<sizeof(T) == 8, size_t>::type visitFloat(T value64) {
    float value32 = float(value64);
    if (value32 == value64) {
      writeByte(0xCA);
      writeInteger(value32);
    } else {
      writeByte(0xCB);
      writeInteger(value64);
    }
    return bytesWritten();
  }
  size_t visitArray(const CollectionData& array) {
    size_t n = array.size();
    if (n < 0x10) {
      writeByte(uint8_t(0x90 + array.size()));
    } else if (n < 0x10000) {
      writeByte(0xDC);
      writeInteger(uint16_t(n));
    } else {
      writeByte(0xDD);
      writeInteger(uint32_t(n));
    }
    for (VariantSlot* slot = array.head(); slot; slot = slot->next()) {
      slot->data()->accept(*this);
    }
    return bytesWritten();
  }
  size_t visitObject(const CollectionData& object) {
    size_t n = object.size();
    if (n < 0x10) {
      writeByte(uint8_t(0x80 + n));
    } else if (n < 0x10000) {
      writeByte(0xDE);
      writeInteger(uint16_t(n));
    } else {
      writeByte(0xDF);
      writeInteger(uint32_t(n));
    }
    for (VariantSlot* slot = object.head(); slot; slot = slot->next()) {
      visitString(slot->key());
      slot->data()->accept(*this);
    }
    return bytesWritten();
  }
  size_t visitString(const char* value) {
    ARDUINOJSON_ASSERT(value != NULL);
    size_t n = strlen(value);
    if (n < 0x20) {
      writeByte(uint8_t(0xA0 + n));
    } else if (n < 0x100) {
      writeByte(0xD9);
      writeInteger(uint8_t(n));
    } else if (n < 0x10000) {
      writeByte(0xDA);
      writeInteger(uint16_t(n));
    } else {
      writeByte(0xDB);
      writeInteger(uint32_t(n));
    }
    writeBytes(reinterpret_cast<const uint8_t*>(value), n);
    return bytesWritten();
  }
  size_t visitRawJson(const char* data, size_t size) {
    writeBytes(reinterpret_cast<const uint8_t*>(data), size);
    return bytesWritten();
  }
  size_t visitSignedInteger(Integer value) {
    if (value > 0) {
      visitUnsignedInteger(static_cast<UInt>(value));
    } else if (value >= -0x20) {
      writeInteger(int8_t(value));
    } else if (value >= -0x80) {
      writeByte(0xD0);
      writeInteger(int8_t(value));
    } else if (value >= -0x8000) {
      writeByte(0xD1);
      writeInteger(int16_t(value));
    }
#if ARDUINOJSON_USE_LONG_LONG
    else if (value >= -0x80000000LL)
#else
    else
#endif
    {
      writeByte(0xD2);
      writeInteger(int32_t(value));
    }
#if ARDUINOJSON_USE_LONG_LONG
    else {
      writeByte(0xD3);
      writeInteger(int64_t(value));
    }
#endif
    return bytesWritten();
  }
  size_t visitUnsignedInteger(UInt value) {
    if (value <= 0x7F) {
      writeInteger(uint8_t(value));
    } else if (value <= 0xFF) {
      writeByte(0xCC);
      writeInteger(uint8_t(value));
    } else if (value <= 0xFFFF) {
      writeByte(0xCD);
      writeInteger(uint16_t(value));
    }
#if ARDUINOJSON_USE_LONG_LONG
    else if (value <= 0xFFFFFFFF)
#else
    else
#endif
    {
      writeByte(0xCE);
      writeInteger(uint32_t(value));
    }
#if ARDUINOJSON_USE_LONG_LONG
    else {
      writeByte(0xCF);
      writeInteger(uint64_t(value));
    }
#endif
    return bytesWritten();
  }
  size_t visitBoolean(bool value) {
    writeByte(value ? 0xC3 : 0xC2);
    return bytesWritten();
  }
  size_t visitNull() {
    writeByte(0xC0);
    return bytesWritten();
  }
 private:
  size_t bytesWritten() const {
    return _writer.count();
  }
  void writeByte(uint8_t c) {
    _writer.write(c);
  }
  void writeBytes(const uint8_t* p, size_t n) {
    _writer.write(p, n);
  }
  template <typename T>
  void writeInteger(T value) {
    fixEndianess(value);
    writeBytes(reinterpret_cast<uint8_t*>(&value), sizeof(value));
  }
  CountingDecorator<TWriter> _writer;
};
template <typename TSource, typename TDestination>
inline size_t serializeMsgPack(const TSource& source, TDestination& output) {
  return serialize<MsgPackSerializer>(source, output);
}
template <typename TSource>
inline size_t serializeMsgPack(const TSource& source, void* output,
                               size_t size) {
  return serialize<MsgPackSerializer>(source, output, size);
}
template <typename TSource>
inline size_t measureMsgPack(const TSource& source) {
  return measure<MsgPackSerializer>(source);
}
}  // namespace ARDUINOJSON_NAMESPACE
#ifdef __GNUC__
#define ARDUINOJSON_PRAGMA(x) _Pragma(#x)
#define ARDUINOJSON_COMPILE_ERROR(msg) ARDUINOJSON_PRAGMA(GCC error msg)
#define ARDUINOJSON_STRINGIFY(S) #S
#define ARDUINOJSON_DEPRECATION_ERROR(X, Y) \
  ARDUINOJSON_COMPILE_ERROR(ARDUINOJSON_STRINGIFY(X is a Y from ArduinoJson 5. Please see https:/\/arduinojson.org/upgrade to learn how to upgrade your program to ArduinoJson version 6))
#define StaticJsonBuffer ARDUINOJSON_DEPRECATION_ERROR(StaticJsonBuffer, class)
#define DynamicJsonBuffer ARDUINOJSON_DEPRECATION_ERROR(DynamicJsonBuffer, class)
#define JsonBuffer ARDUINOJSON_DEPRECATION_ERROR(JsonBuffer, class)
#define RawJson ARDUINOJSON_DEPRECATION_ERROR(RawJson, function)
#endif
namespace ArduinoJson {
typedef ARDUINOJSON_NAMESPACE::ArrayConstRef JsonArrayConst;
typedef ARDUINOJSON_NAMESPACE::ArrayRef JsonArray;
typedef ARDUINOJSON_NAMESPACE::Float JsonFloat;
typedef ARDUINOJSON_NAMESPACE::Integer JsonInteger;
typedef ARDUINOJSON_NAMESPACE::ObjectConstRef JsonObjectConst;
typedef ARDUINOJSON_NAMESPACE::ObjectRef JsonObject;
typedef ARDUINOJSON_NAMESPACE::Pair JsonPair;
typedef ARDUINOJSON_NAMESPACE::PairConst JsonPairConst;
typedef ARDUINOJSON_NAMESPACE::String JsonString;
typedef ARDUINOJSON_NAMESPACE::UInt JsonUInt;
typedef ARDUINOJSON_NAMESPACE::VariantConstRef JsonVariantConst;
typedef ARDUINOJSON_NAMESPACE::VariantRef JsonVariant;
using ARDUINOJSON_NAMESPACE::BasicJsonDocument;
using ARDUINOJSON_NAMESPACE::copyArray;
using ARDUINOJSON_NAMESPACE::DeserializationError;
using ARDUINOJSON_NAMESPACE::deserializeJson;
using ARDUINOJSON_NAMESPACE::deserializeMsgPack;
using ARDUINOJSON_NAMESPACE::DynamicJsonDocument;
using ARDUINOJSON_NAMESPACE::JsonDocument;
using ARDUINOJSON_NAMESPACE::measureJson;
using ARDUINOJSON_NAMESPACE::serialized;
using ARDUINOJSON_NAMESPACE::serializeJson;
using ARDUINOJSON_NAMESPACE::serializeJsonPretty;
using ARDUINOJSON_NAMESPACE::serializeMsgPack;
using ARDUINOJSON_NAMESPACE::StaticJsonDocument;
namespace DeserializationOption {
using ARDUINOJSON_NAMESPACE::Filter;
using ARDUINOJSON_NAMESPACE::NestingLimit;
}  // namespace DeserializationOption
}  // namespace ArduinoJson

using namespace ArduinoJson;

#else

#error ArduinoJson requires a C++ compiler, please change file extension to .cc or .cpp

#endif

=== ./src/dependencies/json/AsyncJson-v6.h ===

// AsyncJson-v6.h
/*
  Original file at: https://github.com/baggior/ESPAsyncWebServer/blob/master/src/AsyncJson.h
  Only changes are ArduinoJson lib path and removed content-type check
  
  Async Response to use with ArduinoJson and AsyncWebServer
  Written by Andrew Melvin (SticilFace) with help from me-no-dev and BBlanchon.

  --------------------
  Async Request to use with ArduinoJson and AsyncWebServer
  Written by Arsne von Wyss (avonwyss)
*/
#ifndef ASYNC_JSON_H_
#define ASYNC_JSON_H_
#include "ArduinoJson-v6.h"
#include <Print.h>

#ifdef ESP8266
  #define DYNAMIC_JSON_DOCUMENT_SIZE 8192
#else
  #define DYNAMIC_JSON_DOCUMENT_SIZE 16384
#endif

constexpr const char* JSON_MIMETYPE = "application/json";

/*
 * Json Response
 * */

class ChunkPrint : public Print {
  private:
    uint8_t* _destination;
    size_t _to_skip;
    size_t _to_write;
    size_t _pos;
  public:
    ChunkPrint(uint8_t* destination, size_t from, size_t len)
      : _destination(destination), _to_skip(from), _to_write(len), _pos{0} {}
    virtual ~ChunkPrint(){}
    size_t write(uint8_t c){
      if (_to_skip > 0) {
        _to_skip--;
        return 1;
      } else if (_to_write > 0) {
        _to_write--;
        _destination[_pos++] = c;
        return 1;
      }
      return 0;
    }
    size_t write(const uint8_t *buffer, size_t size)
    {
      return this->Print::write(buffer, size);
    }
};

class AsyncJsonResponse: public AsyncAbstractResponse {
  private:

    DynamicJsonDocument _jsonBuffer;

    JsonVariant _root;
    bool _isValid;

  public:    

    AsyncJsonResponse(JsonDocument *ref, bool isArray=false) : _jsonBuffer(1), _isValid{false} {
      _code = 200;
      _contentType = JSON_MIMETYPE;
      if(isArray)
        _root = ref->to<JsonArray>();
      else
        _root = ref->to<JsonObject>();
    }

    AsyncJsonResponse(size_t maxJsonBufferSize = DYNAMIC_JSON_DOCUMENT_SIZE, bool isArray=false) : _jsonBuffer(maxJsonBufferSize), _isValid{false} {
      _code = 200;
      _contentType = JSON_MIMETYPE;
      if(isArray)
        _root = _jsonBuffer.createNestedArray();
      else
        _root = _jsonBuffer.createNestedObject();
    }

    ~AsyncJsonResponse() {}
    JsonVariant & getRoot() { return _root; }
    bool _sourceValid() const { return _isValid; }
    size_t setLength() {

      _contentLength = measureJson(_root);

      if (_contentLength) { _isValid = true; }
      return _contentLength;
    }

    size_t getSize() { return _root.size(); }

    size_t _fillBuffer(uint8_t *data, size_t len){
      ChunkPrint dest(data, _sentLength, len);

      serializeJson(_root, dest);
      return len;
    }
};

typedef std::function<void(AsyncWebServerRequest *request)> ArJsonRequestHandlerFunction;

class AsyncCallbackJsonWebHandler: public AsyncWebHandler {
private:
protected:
  const String _uri;
  WebRequestMethodComposite _method;
  ArJsonRequestHandlerFunction _onRequest;
  int _contentLength;
  const size_t maxJsonBufferSize;
  int _maxContentLength;
public:

  AsyncCallbackJsonWebHandler(const String& uri, ArJsonRequestHandlerFunction onRequest, size_t maxJsonBufferSize=DYNAMIC_JSON_DOCUMENT_SIZE) 
  : _uri(uri), _method(HTTP_POST|HTTP_PUT|HTTP_PATCH), _onRequest(onRequest), maxJsonBufferSize(maxJsonBufferSize), _maxContentLength(16384) {}
  
  void setMethod(WebRequestMethodComposite method){ _method = method; }
  void setMaxContentLength(int maxContentLength){ _maxContentLength = maxContentLength; }
  void onRequest(ArJsonRequestHandlerFunction fn){ _onRequest = fn; }

  virtual bool canHandle(AsyncWebServerRequest *request) override final{
    if(!_onRequest)
      return false;

    if(!(_method & request->method()))
      return false;

    if(_uri.length() && (_uri != request->url() && !request->url().startsWith(_uri+"/")))
      return false;

    request->addInterestingHeader("ANY");
    return true;
  }

  virtual void handleRequest(AsyncWebServerRequest *request) override final {
    if(_onRequest) {
      if (request->_tempObject != NULL) {
        _onRequest(request);
        return;
      }
      request->send(_contentLength > _maxContentLength ? 413 : 400);
    } else {
      request->send(500);
    }
  }
  virtual void handleUpload(AsyncWebServerRequest *request, const String& filename, size_t index, uint8_t *data, size_t len, bool final) override final {
  }
  virtual void handleBody(AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) override final {
    if (_onRequest) {
      _contentLength = total;
      if (total > 0 && request->_tempObject == NULL && (int)total < _maxContentLength) {
        request->_tempObject = malloc(total);
      }
      if (request->_tempObject != NULL) {
        memcpy((uint8_t*)(request->_tempObject) + index, data, len);
      }
    }
  }
  virtual bool isRequestHandlerTrivial() override final {return _onRequest ? false : true;}
};
#endif
=== ./src/dependencies/network/Network.cpp ===

#include "Network.h"

IPAddress NetworkClass::localIP()
{
  IPAddress localIP;
#if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_ETHERNET)
  localIP = ETH.localIP();
  if (localIP[0] != 0) {
    return localIP;
  }
#endif
  localIP = WiFi.localIP();
  if (localIP[0] != 0) {
    return localIP;
  }

  return INADDR_NONE;
}

IPAddress NetworkClass::subnetMask()
{
#if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_ETHERNET)
  if (ETH.localIP()[0] != 0) {
    return ETH.subnetMask();
  }
#endif
  if (WiFi.localIP()[0] != 0) {
    return WiFi.subnetMask();
  }
  return IPAddress(255, 255, 255, 0);
}

IPAddress NetworkClass::gatewayIP()
{
#if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_ETHERNET)
  if (ETH.localIP()[0] != 0) {
      return ETH.gatewayIP();
  }
#endif
  if (WiFi.localIP()[0] != 0) {
      return WiFi.gatewayIP();
  }
  return INADDR_NONE;
}

bool NetworkClass::isConnected()
{
#if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_ETHERNET)
  return (WiFi.localIP()[0] != 0 && WiFi.status() == WL_CONNECTED) || ETH.localIP()[0] != 0;
#else
  return (WiFi.localIP()[0] != 0 && WiFi.status() == WL_CONNECTED);
#endif
}

bool NetworkClass::isEthernet()
{
#if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_ETHERNET)
  return (ETH.localIP()[0] != 0);
#endif
  return false;
}

NetworkClass Network;
=== ./src/dependencies/network/Network.h ===

#ifdef ESP8266
  #include <ESP8266WiFi.h>
#else // ESP32
  #include <WiFi.h>
  #include <ETH.h>
#endif

#ifndef Network_h
#define Network_h

class NetworkClass
{
public:
  IPAddress localIP();
  IPAddress subnetMask();
  IPAddress gatewayIP();
  bool isConnected();
  bool isEthernet();
};

extern NetworkClass Network;

#endif
=== ./src/dependencies/time/DS1307RTC.cpp ===

/*
 * DS1307RTC.h - library for DS1307 RTC
  
  Copyright (c) Michael Margolis 2009
  This library is intended to be uses with Arduino Time library functions

  The library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  
  30 Dec 2009 - Initial release
  5 Sep 2011 updated for Arduino 1.0
 */


#if defined (__AVR_ATtiny84__) || defined(__AVR_ATtiny85__) || (__AVR_ATtiny2313__)
#include <TinyWireM.h>
#define Wire TinyWireM
#else
#include <Wire.h>
#endif
#include "DS1307RTC.h"

#define DS1307_CTRL_ID 0x68 

// PUBLIC FUNCTIONS
time_t DS1307RTC::get()   // Aquire data from buffer and convert to time_t
{
  tmElements_t tm;
  if (read(tm) == false) return 0;
  return(makeTime(tm));
}

bool DS1307RTC::set(time_t t)
{
  tmElements_t tm;
  breakTime(t, tm);
  return write(tm); 
}

// Aquire data from the RTC chip in BCD format
bool DS1307RTC::read(tmElements_t &tm)
{
  uint8_t sec;
  Wire.beginTransmission(DS1307_CTRL_ID);
#if ARDUINO >= 100  
  Wire.write((uint8_t)0x00); 
#else
  Wire.send(0x00);
#endif  
  if (Wire.endTransmission() != 0) {
    exists = false;
    return false;
  }
  exists = true;

  // request the 7 data fields   (secs, min, hr, dow, date, mth, yr)
  Wire.requestFrom(DS1307_CTRL_ID, tmNbrFields);
  if (Wire.available() < tmNbrFields) return false;
#if ARDUINO >= 100
  sec = Wire.read();
  tm.Second = bcd2dec(sec & 0x7f);   
  tm.Minute = bcd2dec(Wire.read() );
  tm.Hour =   bcd2dec(Wire.read() & 0x3f);  // mask assumes 24hr clock
  tm.Wday = bcd2dec(Wire.read() );
  tm.Day = bcd2dec(Wire.read() );
  tm.Month = bcd2dec(Wire.read() );
  tm.Year = y2kYearToTm((bcd2dec(Wire.read())));
#else
  sec = Wire.receive();
  tm.Second = bcd2dec(sec & 0x7f);   
  tm.Minute = bcd2dec(Wire.receive() );
  tm.Hour =   bcd2dec(Wire.receive() & 0x3f);  // mask assumes 24hr clock
  tm.Wday = bcd2dec(Wire.receive() );
  tm.Day = bcd2dec(Wire.receive() );
  tm.Month = bcd2dec(Wire.receive() );
  tm.Year = y2kYearToTm((bcd2dec(Wire.receive())));
#endif
  if (sec & 0x80) return false; // clock is halted
  return true;
}

bool DS1307RTC::write(tmElements_t &tm)
{
  // To eliminate any potential race conditions,
  // stop the clock before writing the values,
  // then restart it after.
  Wire.beginTransmission(DS1307_CTRL_ID);
#if ARDUINO >= 100  
  Wire.write((uint8_t)0x00); // reset register pointer  
  Wire.write((uint8_t)0x80); // Stop the clock. The seconds will be written last
  Wire.write(dec2bcd(tm.Minute));
  Wire.write(dec2bcd(tm.Hour));      // sets 24 hour format
  Wire.write(dec2bcd(tm.Wday));   
  Wire.write(dec2bcd(tm.Day));
  Wire.write(dec2bcd(tm.Month));
  Wire.write(dec2bcd(tmYearToY2k(tm.Year))); 
#else  
  Wire.send(0x00); // reset register pointer  
  Wire.send(0x80); // Stop the clock. The seconds will be written last
  Wire.send(dec2bcd(tm.Minute));
  Wire.send(dec2bcd(tm.Hour));      // sets 24 hour format
  Wire.send(dec2bcd(tm.Wday));   
  Wire.send(dec2bcd(tm.Day));
  Wire.send(dec2bcd(tm.Month));
  Wire.send(dec2bcd(tmYearToY2k(tm.Year)));   
#endif
  if (Wire.endTransmission() != 0) {
    exists = false;
    return false;
  }
  exists = true;

  // Now go back and set the seconds, starting the clock back up as a side effect
  Wire.beginTransmission(DS1307_CTRL_ID);
#if ARDUINO >= 100  
  Wire.write((uint8_t)0x00); // reset register pointer  
  Wire.write(dec2bcd(tm.Second)); // write the seconds, with the stop bit clear to restart
#else  
  Wire.send(0x00); // reset register pointer  
  Wire.send(dec2bcd(tm.Second)); // write the seconds, with the stop bit clear to restart
#endif
  if (Wire.endTransmission() != 0) {
    exists = false;
    return false;
  }
  exists = true;
  return true;
}

unsigned char DS1307RTC::isRunning()
{
  Wire.beginTransmission(DS1307_CTRL_ID);
#if ARDUINO >= 100  
  Wire.write((uint8_t)0x00); 
#else
  Wire.send(0x00);
#endif  
  Wire.endTransmission();

  // Just fetch the seconds register and check the top bit
  Wire.requestFrom(DS1307_CTRL_ID, 1);
#if ARDUINO >= 100
  return !(Wire.read() & 0x80);
#else
  return !(Wire.receive() & 0x80);
#endif  
}

void DS1307RTC::setCalibration(char calValue)
{
  unsigned char calReg = abs(calValue) & 0x1f;
  if (calValue >= 0) calReg |= 0x20; // S bit is positive to speed up the clock
  Wire.beginTransmission(DS1307_CTRL_ID);
#if ARDUINO >= 100  
  Wire.write((uint8_t)0x07); // Point to calibration register
  Wire.write(calReg);
#else  
  Wire.send(0x07); // Point to calibration register
  Wire.send(calReg);
#endif
  Wire.endTransmission();  
}

char DS1307RTC::getCalibration()
{
  Wire.beginTransmission(DS1307_CTRL_ID);
#if ARDUINO >= 100  
  Wire.write((uint8_t)0x07); 
#else
  Wire.send(0x07);
#endif  
  Wire.endTransmission();

  Wire.requestFrom(DS1307_CTRL_ID, 1);
#if ARDUINO >= 100
  unsigned char calReg = Wire.read();
#else
  unsigned char calReg = Wire.receive();
#endif
  char out = calReg & 0x1f;
  if (!(calReg & 0x20)) out = -out; // S bit clear means a negative value
  return out;
}

// PRIVATE FUNCTIONS

// Convert Decimal to Binary Coded Decimal (BCD)
uint8_t DS1307RTC::dec2bcd(uint8_t num)
{
  return ((num/10 * 16) + (num % 10));
}

// Convert Binary Coded Decimal (BCD) to Decimal
uint8_t DS1307RTC::bcd2dec(uint8_t num)
{
  return ((num/16 * 10) + (num % 16));
}

bool DS1307RTC::exists = false;

DS1307RTC RTC = DS1307RTC(); // create an instance for the user


=== ./src/dependencies/time/DS1307RTC.h ===

/*
 * DS1307RTC.h - library for DS1307 RTC
 * This library is intended to be uses with Arduino Time library functions
 */

#ifndef DS1307RTC_h
#define DS1307RTC_h

#include "TimeLib.h"

// library interface description
class DS1307RTC
{
  // user-accessible "public" interface
  public:
    DS1307RTC() {}
    static void begin() { /*Wire.begin();*/ }  // WLEDSR bugfix 
    static time_t get();
    static bool set(time_t t);
    static bool read(tmElements_t &tm);
    static bool write(tmElements_t &tm);
    static bool chipPresent() { return exists; }
    static unsigned char isRunning();
    static void setCalibration(char calValue);
    static char getCalibration();

  private:
    static bool exists;
    static uint8_t dec2bcd(uint8_t num);
    static uint8_t bcd2dec(uint8_t num);
};

#ifdef RTC
#undef RTC // workaround for Arduino Due, which defines "RTC"...
#endif

extern DS1307RTC RTC;

#endif
 


=== ./src/dependencies/time/DateStrings.cpp ===

/* DateStrings.cpp
 * Definitions for date strings for use with the Time library
 *
 * Updated for Arduino 1.5.7 18 July 2014
 *
 * No memory is consumed in the sketch if your code does not call any of the string methods
 * You can change the text of the strings, make sure the short strings are each exactly 3 characters 
 * the long strings can be any length up to the constant dt_MAX_STRING_LEN defined in TimeLib.h
 * 
 */

#if defined(__AVR__)
#include <avr/pgmspace.h>
#else
// for compatiblity with Arduino Due and Teensy 3.0 and maybe others?
#define PROGMEM
#define PGM_P  const char *
#define pgm_read_byte(addr) (*(const unsigned char *)(addr))
#define pgm_read_word(addr) (*(const unsigned char **)(addr))
#define strcpy_P(dest, src) strcpy((dest), (src))
#endif
#include <string.h> // for strcpy_P or strcpy
#include "TimeLib.h"
 
// the short strings for each day or month must be exactly dt_SHORT_STR_LEN
#define dt_SHORT_STR_LEN  3 // the length of short strings

static char buffer[dt_MAX_STRING_LEN+1];  // must be big enough for longest string and the terminating null

const char monthStr0[] PROGMEM = "";
const char monthStr1[] PROGMEM = "January";
const char monthStr2[] PROGMEM = "February";
const char monthStr3[] PROGMEM = "March";
const char monthStr4[] PROGMEM = "April";
const char monthStr5[] PROGMEM = "May";
const char monthStr6[] PROGMEM = "June";
const char monthStr7[] PROGMEM = "July";
const char monthStr8[] PROGMEM = "August";
const char monthStr9[] PROGMEM = "September";
const char monthStr10[] PROGMEM = "October";
const char monthStr11[] PROGMEM = "November";
const char monthStr12[] PROGMEM = "December";

const PROGMEM char * const PROGMEM monthNames_P[] =
{
    monthStr0,monthStr1,monthStr2,monthStr3,monthStr4,monthStr5,monthStr6,
    monthStr7,monthStr8,monthStr9,monthStr10,monthStr11,monthStr12
};

const char monthShortNames_P[] PROGMEM = "ErrJanFebMarAprMayJunJulAugSepOctNovDec";

const char dayStr0[] PROGMEM = "Err";
const char dayStr1[] PROGMEM = "Sunday";
const char dayStr2[] PROGMEM = "Monday";
const char dayStr3[] PROGMEM = "Tuesday";
const char dayStr4[] PROGMEM = "Wednesday";
const char dayStr5[] PROGMEM = "Thursday";
const char dayStr6[] PROGMEM = "Friday";
const char dayStr7[] PROGMEM = "Saturday";

const PROGMEM char * const PROGMEM dayNames_P[] =
{
   dayStr0,dayStr1,dayStr2,dayStr3,dayStr4,dayStr5,dayStr6,dayStr7
};

const char dayShortNames_P[] PROGMEM = "ErrSunMonTueWedThuFriSat";

/* functions to return date strings */

char* monthStr(uint8_t month)
{
    strcpy_P(buffer, (PGM_P)pgm_read_word(&(monthNames_P[month])));
    return buffer;
}

char* monthShortStr(uint8_t month)
{
   for (int i=0; i < dt_SHORT_STR_LEN; i++)      
      buffer[i] = pgm_read_byte(&(monthShortNames_P[i+ (month*dt_SHORT_STR_LEN)]));  
   buffer[dt_SHORT_STR_LEN] = 0;
   return buffer;
}

char* dayStr(uint8_t day) 
{
   strcpy_P(buffer, (PGM_P)pgm_read_word(&(dayNames_P[day])));
   return buffer;
}

char* dayShortStr(uint8_t day) 
{
   uint8_t index = day*dt_SHORT_STR_LEN;
   for (int i=0; i < dt_SHORT_STR_LEN; i++)      
      buffer[i] = pgm_read_byte(&(dayShortNames_P[index + i]));  
   buffer[dt_SHORT_STR_LEN] = 0; 
   return buffer;
}

=== ./src/dependencies/time/Time.cpp ===

/*
  time.c - low level time and date functions
  Copyright (c) Michael Margolis 2009-2014

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  
  1.0  6  Jan 2010 - initial release
  1.1  12 Feb 2010 - fixed leap year calculation error
  1.2  1  Nov 2010 - fixed setTime bug (thanks to Korman for this)
  1.3  24 Mar 2012 - many edits by Paul Stoffregen: fixed timeStatus() to update
                     status, updated examples for Arduino 1.0, fixed ARM
                     compatibility issues, added TimeArduinoDue and TimeTeensy3
                     examples, add error checking and messages to RTC examples,
                     add examples to DS1307RTC library.
  1.4  5  Sep 2014 - compatibility with Arduino 1.5.7
  2.0  25 May 2021 - removed timing code, only used for conversion between unix and time
*/

#if ARDUINO >= 100
#include <Arduino.h> 
#else
#include <WProgram.h> 
#endif

#include "TimeLib.h"

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated

void refreshCache(time_t t) {
  if (t != cacheTime) {
    breakTime(t, tm); 
    cacheTime = t; 
  }
}

int hour(time_t t) { // the hour for the given time
  refreshCache(t);
  return tm.Hour;  
}

int hourFormat12(time_t t) { // the hour for the given time in 12 hour format
  refreshCache(t);
  if( tm.Hour == 0 )
    return 12; // 12 midnight
  else if( tm.Hour  > 12)
    return tm.Hour - 12 ;
  else
    return tm.Hour ;
}

uint8_t isAM(time_t t) { // returns true if given time is AM
  return !isPM(t);  
}

uint8_t isPM(time_t t) { // returns true if PM
  return (hour(t) >= 12); 
}

int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
}

int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
}

int day(time_t t) { // the day for the given time (0-6)
  refreshCache(t);
  return tm.Day;
}

int weekday(time_t t) {
  refreshCache(t);
  return tm.Wday;
}

int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
}

int year(time_t t) { // the year for the given time
  refreshCache(t);
  return tmYearToCalendar(tm.Year);
}

/*============================================================================*/	
/* functions to convert to and from system time */
/* These are for interfacing with time serivces and are not normally needed in a sketch */

// leap year calulator expects year argument as years offset from 1970
#define LEAP_YEAR(Y)     ( ((1970+Y)>0) && !((1970+Y)%4) && ( ((1970+Y)%100) || !((1970+Y)%400) ) )

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(time_t timeInput, tmElements_t &tm){
// break the given time_t into time components
// this is a more compact version of the C library localtime function
// note that year is offset from 1970 !!!

  uint8_t year;
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
}

time_t makeTime(tmElements_t &tm){   
// assemble time elements into time_t 
// note year argument is offset from 1970 (see macros in time.h to convert to other formats)
// previous version used full four digit year (or digits since 2000),i.e. 2009 was 2009 or 9
  
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    if (LEAP_YEAR(i)) {
      seconds +=  SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    }
  }
  seconds+= (tm.Day-1) * SECS_PER_DAY;
  seconds+= tm.Hour * SECS_PER_HOUR;
  seconds+= tm.Minute * SECS_PER_MIN;
  seconds+= tm.Second;
  return (time_t)seconds; 
}

time_t getUnixTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 //it is converted to years since 1970
  if( yr > 99)
      yr = yr - 1970;
  else
      yr += 30;  
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
  return makeTime(tm);
}
=== ./src/dependencies/time/TimeLib.h ===

/*
  time.h - low level time and date functions
*/

/*
  July 3 2011 - fixed elapsedSecsThisWeek macro (thanks Vincent Valdy for this)
              - fixed  daysToTime_t macro (thanks maniacbug)
*/     

#ifndef _Time_h
#ifdef __cplusplus
#define _Time_h

#include <inttypes.h>
#ifndef __AVR__
#include <sys/types.h> // for __time_t_defined, but avr libc lacks sys/types.h
#endif


#if !defined(__time_t_defined) // avoid conflict with newlib or other posix libc
typedef unsigned long time_t;
#endif


// This ugly hack allows us to define C++ overloaded functions, when included
// from within an extern "C", as newlib's sys/stat.h does.  Actually it is
// intended to include "time.h" from the C library (on ARM, but AVR does not
// have that file at all).  On Mac and Windows, the compiler will find this
// "Time.h" instead of the C library "time.h", so we may cause other weird
// and unpredictable effects by conflicting with the C library header "time.h",
// but at least this hack lets us define C++ functions as intended.  Hopefully
// nothing too terrible will result from overriding the C library header?!
extern "C++" {

typedef enum {
    dowInvalid, dowSunday, dowMonday, dowTuesday, dowWednesday, dowThursday, dowFriday, dowSaturday
} timeDayOfWeek_t;

typedef enum {
    tmSecond, tmMinute, tmHour, tmWday, tmDay,tmMonth, tmYear, tmNbrFields
} tmByteFields;	   

typedef struct  { 
  uint8_t Second; 
  uint8_t Minute; 
  uint8_t Hour; 
  uint8_t Wday;   // day of week, sunday is day 1
  uint8_t Day;
  uint8_t Month; 
  uint8_t Year;   // offset from 1970; 
} 	tmElements_t, TimeElements, *tmElementsPtr_t;

//convenience macros to convert to and from tm years 
#define  tmYearToCalendar(Y) ((Y) + 1970)  // full four digit year 
#define  CalendarYrToTm(Y)   ((Y) - 1970)
#define  tmYearToY2k(Y)      ((Y) - 30)    // offset is from 2000
#define  y2kYearToTm(Y)      ((Y) + 30)   

typedef time_t(*getExternalTime)();
//typedef void  (*setExternalTime)(const time_t); // not used in this version


/*==============================================================================*/
/* Useful Constants */
#define SECS_PER_MIN  ((time_t)(60UL))
#define SECS_PER_HOUR ((time_t)(3600UL))
#define SECS_PER_DAY  ((time_t)(SECS_PER_HOUR * 24UL))
#define DAYS_PER_WEEK ((time_t)(7UL))
#define SECS_PER_WEEK ((time_t)(SECS_PER_DAY * DAYS_PER_WEEK))
#define SECS_PER_YEAR ((time_t)(SECS_PER_WEEK * 52UL))
#define SECS_YR_2000  ((time_t)(946684800UL)) // the time at the start of y2k
 
/* Useful Macros for getting elapsed time */
#define numberOfSeconds(_time_) (_time_ % SECS_PER_MIN)  
#define numberOfMinutes(_time_) ((_time_ / SECS_PER_MIN) % SECS_PER_MIN) 
#define numberOfHours(_time_) (( _time_% SECS_PER_DAY) / SECS_PER_HOUR)
#define dayOfWeek(_time_)  ((( _time_ / SECS_PER_DAY + 4)  % DAYS_PER_WEEK)+1) // 1 = Sunday
#define elapsedDays(_time_) ( _time_ / SECS_PER_DAY)  // this is number of days since Jan 1 1970
#define elapsedSecsToday(_time_)  (_time_ % SECS_PER_DAY)   // the number of seconds since last midnight 
// The following macros are used in calculating alarms and assume the clock is set to a date later than Jan 1 1971
// Always set the correct time before settting alarms
#define previousMidnight(_time_) (( _time_ / SECS_PER_DAY) * SECS_PER_DAY)  // time at the start of the given day
#define nextMidnight(_time_) ( previousMidnight(_time_)  + SECS_PER_DAY )   // time at the end of the given day 
#define elapsedSecsThisWeek(_time_)  (elapsedSecsToday(_time_) +  ((dayOfWeek(_time_)-1) * SECS_PER_DAY) )   // note that week starts on day 1
#define previousSunday(_time_)  (_time_ - elapsedSecsThisWeek(_time_))      // time at the start of the week for the given time
#define nextSunday(_time_) ( previousSunday(_time_)+SECS_PER_WEEK)          // time at the end of the week for the given time


/* Useful Macros for converting elapsed time to a time_t */
#define minutesToTime_t ((M)) ( (M) * SECS_PER_MIN)  
#define hoursToTime_t   ((H)) ( (H) * SECS_PER_HOUR)  
#define daysToTime_t    ((D)) ( (D) * SECS_PER_DAY) // fixed on Jul 22 2011
#define weeksToTime_t   ((W)) ( (W) * SECS_PER_WEEK)   

/*============================================================================*/
/*  time and date functions   */ 
int     hour(time_t t);    // the hour for the given time
int     hourFormat12(time_t t); // the hour for the given time in 12 hour format
uint8_t isAM(time_t t);    // returns true the given time is AM
uint8_t isPM(time_t t);    // returns true the given time is PM
int     minute(time_t t);  // the minute for the given time
int     second(time_t t);  // the second for the given time
int     day(time_t t);     // the day for the given time
int     weekday(time_t t); // the weekday for the given time 
int     month(time_t t);   // the month for the given time
int     year(time_t t);    // the year for the given time

time_t	getUnixTime(int hr,int min,int sec,int day, int month, int yr); //added by Aircoookie to get epoch time

/* date strings */ 
#define dt_MAX_STRING_LEN 9 // length of longest date string (excluding terminating null)
char* monthStr(uint8_t month);
char* dayStr(uint8_t day);
char* monthShortStr(uint8_t month);
char* dayShortStr(uint8_t day);

/* low level functions to convert to and from system time */
void breakTime(time_t time, tmElements_t &tm);  // break time_t into elements
time_t makeTime(tmElements_t &tm);  // convert time elements into time_t

} // extern "C++"
#endif // __cplusplus
#endif /* _Time_h */


=== ./src/dependencies/timezone/Timezone.cpp ===

/*----------------------------------------------------------------------*
 * Arduino Timezone Library v1.0                                        *
 * Jack Christensen Mar 2012                                            *
 *                                                                      *
 * This work is licensed under the Creative Commons Attribution-        *
 * ShareAlike 3.0 Unported License. To view a copy of this license,     *
 * visit http://creativecommons.org/licenses/by-sa/3.0/ or send a       *
 * letter to Creative Commons, 171 Second Street, Suite 300,            *
 * San Francisco, California, 94105, USA.                               *
 *----------------------------------------------------------------------*/

#include "Timezone.h"

//THIS LINE WAS ADDED FOR COMPATIBILY WITH THE WLED DEPENDENCY STRUCTURE. REMOVE IF YOU USE IT OUTSIDE OF WLED!
#include "../time/TimeLib.h"

#ifdef __AVR__
	#include <avr/eeprom.h>
#endif


/*----------------------------------------------------------------------*
 * Create a Timezone object from the given time change rules.           *
 *----------------------------------------------------------------------*/
Timezone::Timezone(TimeChangeRule dstStart, TimeChangeRule stdStart)
{
    _dst = dstStart;
    _std = stdStart;
}

#ifdef __AVR__
/*----------------------------------------------------------------------*
 * Create a Timezone object from time change rules stored in EEPROM     *
 * at the given address.                                                *
 *----------------------------------------------------------------------*/
Timezone::Timezone(int address)
{
    readRules(address);
}
#endif

/*----------------------------------------------------------------------*
 * Convert the given UTC time to local time, standard or                *
 * daylight time, as appropriate.                                       *
 *----------------------------------------------------------------------*/
time_t Timezone::toLocal(time_t utc)
{
    //recalculate the time change points if needed
    if (year(utc) != year(_dstUTC)) calcTimeChanges(year(utc));

    if (utcIsDST(utc))
        return utc + _dst.offset * SECS_PER_MIN;
    else
        return utc + _std.offset * SECS_PER_MIN;
}

/*----------------------------------------------------------------------*
 * Convert the given UTC time to local time, standard or                *
 * daylight time, as appropriate, and return a pointer to the time      *
 * change rule used to do the conversion. The caller must take care     *
 * not to alter this rule.                                              *
 *----------------------------------------------------------------------*/
time_t Timezone::toLocal(time_t utc, TimeChangeRule **tcr)
{
    //recalculate the time change points if needed
    if (year(utc) != year(_dstUTC)) calcTimeChanges(year(utc));

    if (utcIsDST(utc)) {
        *tcr = &_dst;
        return utc + _dst.offset * SECS_PER_MIN;
    }
    else {
        *tcr = &_std;
        return utc + _std.offset * SECS_PER_MIN;
    }
}

/*----------------------------------------------------------------------*
 * Convert the given local time to UTC time.                            *
 *                                                                      *
 * WARNING:                                                             *
 * This function is provided for completeness, but should seldom be     *
 * needed and should be used sparingly and carefully.                   *
 *                                                                      *
 * Ambiguous situations occur after the Standard-to-DST and the         *
 * DST-to-Standard time transitions. When changing to DST, there is     *
 * one hour of local time that does not exist, since the clock moves    *
 * forward one hour. Similarly, when changing to standard time, there   *
 * is one hour of local times that occur twice since the clock moves    *
 * back one hour.                                                       *
 *                                                                      *
 * This function does not test whether it is passed an erroneous time   *
 * value during the Local -> DST transition that does not exist.        *
 * If passed such a time, an incorrect UTC time value will be returned. *
 *                                                                      *
 * If passed a local time value during the DST -> Local transition      *
 * that occurs twice, it will be treated as the earlier time, i.e.      *
 * the time that occurs before the transistion.                         *
 *                                                                      *
 * Calling this function with local times during a transition interval  *
 * should be avoided!                                                   *
 *----------------------------------------------------------------------*/
time_t Timezone::toUTC(time_t local)
{
    //recalculate the time change points if needed
    if (year(local) != year(_dstLoc)) calcTimeChanges(year(local));

    if (locIsDST(local))
        return local - _dst.offset * SECS_PER_MIN;
    else
        return local - _std.offset * SECS_PER_MIN;
}

/*----------------------------------------------------------------------*
 * Determine whether the given UTC time_t is within the DST interval    *
 * or the Standard time interval.                                       *
 *----------------------------------------------------------------------*/
boolean Timezone::utcIsDST(time_t utc)
{
    //recalculate the time change points if needed
    if (year(utc) != year(_dstUTC)) calcTimeChanges(year(utc));

    if (_stdUTC > _dstUTC)    //northern hemisphere
        return (utc >= _dstUTC && utc < _stdUTC);
    else                      //southern hemisphere
        return !(utc >= _stdUTC && utc < _dstUTC);
}

/*----------------------------------------------------------------------*
 * Determine whether the given Local time_t is within the DST interval  *
 * or the Standard time interval.                                       *
 *----------------------------------------------------------------------*/
boolean Timezone::locIsDST(time_t local)
{
    //recalculate the time change points if needed
    if (year(local) != year(_dstLoc)) calcTimeChanges(year(local));

    if (_stdLoc > _dstLoc)    //northern hemisphere
        return (local >= _dstLoc && local < _stdLoc);
    else                      //southern hemisphere
        return !(local >= _stdLoc && local < _dstLoc);
}

/*----------------------------------------------------------------------*
 * Calculate the DST and standard time change points for the given      *
 * given year as local and UTC time_t values.                           *
 *----------------------------------------------------------------------*/
void Timezone::calcTimeChanges(int yr)
{
    _dstLoc = toTime_t(_dst, yr);
    _stdLoc = toTime_t(_std, yr);
    _dstUTC = _dstLoc - _std.offset * SECS_PER_MIN;
    _stdUTC = _stdLoc - _dst.offset * SECS_PER_MIN;
}

/*----------------------------------------------------------------------*
 * Convert the given DST change rule to a time_t value                  *
 * for the given year.                                                  *
 *----------------------------------------------------------------------*/
time_t Timezone::toTime_t(TimeChangeRule r, int yr)
{
    tmElements_t tm;
    time_t t;
    uint8_t m, w;            //temp copies of r.month and r.week

    m = r.month;
    w = r.week;
    if (w == 0) {            //Last week = 0
        if (++m > 12) {      //for "Last", go to the next month
            m = 1;
            yr++;
        }
        w = 1;               //and treat as first week of next month, subtract 7 days later
    }

    tm.Hour = r.hour;
    tm.Minute = 0;
    tm.Second = 0;
    tm.Day = 1;
    tm.Month = m;
    tm.Year = yr - 1970;
    t = makeTime(tm);        //first day of the month, or first day of next month for "Last" rules
    t += (7 * (w - 1) + (r.dow - weekday(t) + 7) % 7) * SECS_PER_DAY;
    if (r.week == 0) t -= 7 * SECS_PER_DAY;    //back up a week if this is a "Last" rule
    return t;
}

#ifdef __AVR__
/*----------------------------------------------------------------------*
 * Read the daylight and standard time rules from EEPROM at				*
 * the given address.                                                   *
 *----------------------------------------------------------------------*/
void Timezone::readRules(int address)
{
    eeprom_read_block((void *) &_dst, (void *) address, sizeof(_dst));
    address += sizeof(_dst);
    eeprom_read_block((void *) &_std, (void *) address, sizeof(_std));
}

/*----------------------------------------------------------------------*
 * Write the daylight and standard time rules to EEPROM at				*
 * the given address.                                                   *
 *----------------------------------------------------------------------*/
void Timezone::writeRules(int address)
{
    eeprom_write_block((void *) &_dst, (void *) address, sizeof(_dst));
    address += sizeof(_dst);
    eeprom_write_block((void *) &_std, (void *) address, sizeof(_std));
}

#endif
=== ./src/dependencies/timezone/Timezone.h ===

/*----------------------------------------------------------------------*
 * Arduino Timezone Library v1.0                                        *
 * Jack Christensen Mar 2012                                            *
 *                                                                      *
 * This work is licensed under the Creative Commons Attribution-        *
 * ShareAlike 3.0 Unported License. To view a copy of this license,     *
 * visit http://creativecommons.org/licenses/by-sa/3.0/ or send a       *
 * letter to Creative Commons, 171 Second Street, Suite 300,            *
 * San Francisco, California, 94105, USA.                               *
 *----------------------------------------------------------------------*/ 
 
#ifndef Timezone_h
#define Timezone_h
#if ARDUINO >= 100
#include <Arduino.h> 
#else
#include <WProgram.h> 
#endif

#include "../time/TimeLib.h"      //http://www.arduino.cc/playground/Code/Time

//convenient constants for dstRules
enum week_t {Last, First, Second, Third, Fourth}; 
enum dow_t {Sun=1, Mon, Tue, Wed, Thu, Fri, Sat};
enum month_t {Jan=1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec};

//structure to describe rules for when daylight/summer time begins,
//or when standard time begins.
struct TimeChangeRule
{
    uint8_t week;      //First, Second, Third, Fourth, or Last week of the month
    uint8_t dow;       //day of week, 1=Sun, 2=Mon, ... 7=Sat
    uint8_t month;     //1=Jan, 2=Feb, ... 12=Dec
    uint8_t hour;      //0-23
    int16_t offset;        //offset from UTC in minutes
};
        
class Timezone
{
    public:
        Timezone(TimeChangeRule dstStart, TimeChangeRule stdStart);
        Timezone(int address);
        time_t toLocal(time_t utc);
        time_t toLocal(time_t utc, TimeChangeRule **tcr);
        time_t toUTC(time_t local);
        boolean utcIsDST(time_t utc);
        boolean locIsDST(time_t local);
        void readRules(int address);
        void writeRules(int address);

    private:
        void calcTimeChanges(int yr);
        time_t toTime_t(TimeChangeRule r, int yr);
        TimeChangeRule _dst;    //rule for start of dst or summer time for any year
        TimeChangeRule _std;    //rule for start of standard time for any year
        time_t _dstUTC;         //dst start for given/current year, given in UTC
        time_t _stdUTC;         //std time start for given/current year, given in UTC
        time_t _dstLoc;         //dst start for given/current year, given in local time
        time_t _stdLoc;         //std time start for given/current year, given in local time
};
#endif

=== ./src/dependencies/toki/Toki.h ===

/*
  Toki.h - Minimal millisecond accurate timekeeping.

  LICENSE
  The MIT License (MIT)
  Copyright (c) 2021 Christian Schwinne
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

#include <Arduino.h> 

#define YEARS_70 2208988800UL

#define TOKI_NO_MS_ACCURACY 1000

//Time source. Sub-100 is second accuracy, higher ms accuracy. Higher value generally means more accurate
#define TOKI_TS_NONE      0 //unsynced (e.g. just after boot)
#define TOKI_TS_UDP       5 //synced via UDP from an instance whose time source is unsynced
#define TOKI_TS_BAD      10 //synced from a time source less than about +- 2s accurate
#define TOKI_TS_UDP_SEC  20 //synced via UDP from an instance whose time source is set from RTC/JSON
#define TOKI_TS_SEC      40 //general second-accurate time source
#define TOKI_TS_RTC      60 //second-accurate real time clock
#define TOKI_TS_JSON     70 //synced second-accurate from a client via JSON-API

#define TOKI_TS_UDP_NTP 110 //synced via UDP from an instance whose time source is NTP
#define TOKI_TS_MS      120 //general better-than-second accuracy time source
#define TOKI_TS_NTP     150 //NTP time, simple round trip estimation. Depending on network, mostly +- 50ms accurate
#define TOKI_TS_NTP_P   170 //NTP time with multi-step sync, higher accuracy. Not implemented in WLED

class Toki {
  typedef enum {
    inactive, marked, active
  } TickT;

  public: 
  typedef struct {
    uint32_t sec;
    uint16_t ms;
  } Time;

  private:
    uint32_t fullSecondMillis = 0;
    uint32_t unix = 0;
    TickT tick = TickT::inactive;
    uint8_t timeSrc = TOKI_TS_NONE;

  public:
    void setTime(Time t, uint8_t timeSource = TOKI_TS_MS) {
      fullSecondMillis = millis() - t.ms;
      unix = t.sec;
      timeSrc = timeSource;
    }

    void setTime(uint32_t sec, uint16_t ms=TOKI_NO_MS_ACCURACY, uint8_t timeSource = TOKI_TS_MS) {
      if (ms >= TOKI_NO_MS_ACCURACY) {
        ms = millisecond(); //just keep current ms if not provided
        if (timeSource > 99) timeSource = TOKI_TS_SEC; //lies
      }
      Time t = {sec, ms};
      setTime(t, timeSource);
    }

    Time fromNTP(byte *timestamp) { //ntp timestamp is 8 bytes, 4 bytes second and 4 bytes sub-second fraction
      unsigned long highWord = word(timestamp[0], timestamp[1]);
      unsigned long lowWord = word(timestamp[2], timestamp[3]);
    
      unsigned long unix = highWord << 16 | lowWord;
      if (!unix) return {0,0};
      unix -= YEARS_70; //NTP begins 1900, Unix 1970

      unsigned long frac = word(timestamp[4], timestamp[5]); //65536ths of a second
      frac = (frac*1000) >> 16; //convert to ms
      return {unix, (uint16_t)frac};
    }

    uint16_t millisecond() {
      uint32_t ms = millis() - fullSecondMillis;
      while (ms > 999) {
        ms -= 1000;
        fullSecondMillis += 1000;
        unix++;
        if (tick == TickT::inactive) tick = TickT::marked; //marked, will be active on next loop
      }
      return ms;
    }

    uint32_t second() {
      millisecond();
      return unix;
    }

    //gets the absolute difference between two timestamps in milliseconds
    uint32_t msDifference(const Time &t0, const Time &t1) {
      bool t1BiggerSec = (t1.sec > t0.sec);
      uint32_t secDiff = (t1BiggerSec) ? t1.sec - t0.sec : t0.sec - t1.sec;
      uint32_t t0ms = t0.ms, t1ms = t1.ms;
      if (t1BiggerSec) t1ms += secDiff*1000;
      else t0ms += secDiff*1000;
      uint32_t msDiff = (t1ms > t0ms) ? t1ms - t0ms : t0ms - t1ms;
      return msDiff;
    }

    //return true if t1 is later than t0
    bool isLater(const Time &t0, const Time &t1) {
      if (t1.sec > t0.sec) return true;
      if (t1.sec < t0.sec) return false;
      if (t1.ms  > t0.ms) return true;
      return false;
    }

    void adjust(Time&t, int32_t offset) {
      int32_t secs = offset /1000;
      int32_t ms = offset - secs*1000;
      t.sec += secs;
      int32_t nms = t.ms + ms;
      if (nms > 1000) {nms -= 1000; t.sec++;}
      if (nms < 0) {nms += 1000; t.sec--;}
      t.ms = nms;
    }

    Time getTime() {
      Time t;
      t.ms = millisecond();
      t.sec = unix;
      return t;
    }

    uint8_t getTimeSource() {
      return timeSrc;
    }

    void setTick() {
      if (tick == TickT::marked) tick = TickT::active;
    }

    void resetTick() {
      if (tick == TickT::active) tick = TickT::inactive;
    }

    bool isTick() {
      return (tick == TickT::active);
    }

    void printTime(const Time& t) {
      Serial.printf_P(PSTR("%u,%03u\n"),t.sec,t.ms);
    }
};
=== ./udp.cpp ===

#include "wled.h"

/*
 * UDP sync notifier / Realtime / Hyperion / TPM2.NET
 */

#define UDP_SEG_SIZE 28
#define SEG_OFFSET (41+(MAX_NUM_SEGMENTS*UDP_SEG_SIZE))
#define WLEDPACKETSIZE (41+(MAX_NUM_SEGMENTS*UDP_SEG_SIZE)+0)
#define UDP_IN_MAXSIZE 1472
#define PRESUMED_NETWORK_DELAY 3 //how many ms could it take on avg to reach the receiver? This will be added to transmitted times

void notify(byte callMode, bool followUp)
{
  if (!udpConnected) return;
  if (!syncGroups) return;
  switch (callMode)
  {
    case CALL_MODE_INIT:          return;
    case CALL_MODE_DIRECT_CHANGE: if (!notifyDirect) return; break;
    case CALL_MODE_BUTTON:        if (!notifyButton) return; break;
    case CALL_MODE_BUTTON_PRESET: if (!notifyButton) return; break;
    case CALL_MODE_NIGHTLIGHT:    if (!notifyDirect) return; break;
    case CALL_MODE_HUE:           if (!notifyHue)    return; break;
    case CALL_MODE_PRESET_CYCLE:  if (!notifyDirect) return; break;
    //case CALL_MODE_BLYNK:         if (!notifyDirect) return; break; // WLEDSR Blynk support removed, as blynk service is closed.
    case CALL_MODE_ALEXA:         if (!notifyAlexa)  return; break;
    default: return;
  }
  byte udpOut[WLEDPACKETSIZE];
  WS2812FX::Segment& mainseg = strip.getMainSegment();
  udpOut[0] = 0; //0: wled notifier protocol 1: WARLS protocol
  udpOut[1] = callMode;
  udpOut[2] = bri;
  uint32_t col = mainseg.colors[0];
  udpOut[3] = R(col);
  udpOut[4] = G(col);
  udpOut[5] = B(col);
  udpOut[6] = nightlightActive;
  udpOut[7] = nightlightDelayMins;
  udpOut[8] = mainseg.mode;
  udpOut[9] = mainseg.speed;
  udpOut[10] = W(col);
  //compatibilityVersionByte:
  //0: old 1: supports white 2: supports secondary color
  //3: supports FX intensity, 24 byte packet 4: supports transitionDelay 5: sup palette
  //6: supports timebase syncing, 29 byte packet 7: supports tertiary color 8: supports sys time sync, 36 byte packet
  //9: supports sync groups, 37 byte packet 10: supports CCT, 39 byte packet 11: per segment options, variable packet length (40+MAX_NUM_SEGMENTS*3)
  udpOut[11] = 11;
  col = mainseg.colors[1];
  udpOut[12] = R(col);
  udpOut[13] = G(col);
  udpOut[14] = B(col);
  udpOut[15] = W(col);
  udpOut[16] = mainseg.intensity;
  udpOut[17] = (transitionDelay >> 0) & 0xFF;
  udpOut[18] = (transitionDelay >> 8) & 0xFF;
  udpOut[19] = mainseg.palette;
  col = mainseg.colors[2];
  udpOut[20] = R(col);
  udpOut[21] = G(col);
  udpOut[22] = B(col);
  udpOut[23] = W(col);

  udpOut[24] = followUp;
  uint32_t t = millis() + strip.timebase;
  udpOut[25] = (t >> 24) & 0xFF;
  udpOut[26] = (t >> 16) & 0xFF;
  udpOut[27] = (t >>  8) & 0xFF;
  udpOut[28] = (t >>  0) & 0xFF;

  //sync system time
  udpOut[29] = toki.getTimeSource();
  Toki::Time tm = toki.getTime();
  uint32_t unix = tm.sec;
  udpOut[30] = (unix >> 24) & 0xFF;
  udpOut[31] = (unix >> 16) & 0xFF;
  udpOut[32] = (unix >>  8) & 0xFF;
  udpOut[33] = (unix >>  0) & 0xFF;
  uint16_t ms = tm.ms;
  udpOut[34] = (ms >> 8) & 0xFF;
  udpOut[35] = (ms >> 0) & 0xFF;

  //sync groups
  udpOut[36] = syncGroups;

  //Might be changed to Kelvin in the future, receiver code should handle that case
  //0: byte 38 contains 0-255 value, 255: no valid CCT, 1-254: Kelvin value MSB
  udpOut[37] = strip.hasCCTBus() ? 0 : 255; //check this is 0 for the next value to be significant
  udpOut[38] = mainseg.cct;

  udpOut[39] = strip.getMaxSegments();
  udpOut[40] = UDP_SEG_SIZE; //size of each loop iteration (one segment)
  for (size_t i = 0; i < strip.getMaxSegments(); i++) {
    WS2812FX::Segment &selseg = strip.getSegment(i);
    uint16_t ofs = 41 + i*UDP_SEG_SIZE; //start of segment offset byte
    udpOut[0 +ofs] = i;
    udpOut[1 +ofs] = selseg.start >> 8;
    udpOut[2 +ofs] = selseg.start & 0xFF;
    udpOut[3 +ofs] = selseg.stop >> 8;
    udpOut[4 +ofs] = selseg.stop & 0xFF;
    udpOut[5 +ofs] = selseg.grouping;
    udpOut[6 +ofs] = selseg.spacing;
    udpOut[7 +ofs] = selseg.offset >> 8;
    udpOut[8 +ofs] = selseg.offset & 0xFF;
    udpOut[9 +ofs] = selseg.options & 0x0F; //only take into account mirrored, selected, on, reversed
    udpOut[10+ofs] = selseg.opacity;
    udpOut[11+ofs] = selseg.mode;
    udpOut[12+ofs] = selseg.speed;
    udpOut[13+ofs] = selseg.intensity;
    udpOut[14+ofs] = selseg.palette;
    udpOut[15+ofs] = R(selseg.colors[0]);
    udpOut[16+ofs] = G(selseg.colors[0]);
    udpOut[17+ofs] = B(selseg.colors[0]);
    udpOut[18+ofs] = W(selseg.colors[0]);
    udpOut[19+ofs] = R(selseg.colors[1]);
    udpOut[20+ofs] = G(selseg.colors[1]);
    udpOut[21+ofs] = B(selseg.colors[1]);
    udpOut[22+ofs] = W(selseg.colors[1]);
    udpOut[23+ofs] = R(selseg.colors[2]);
    udpOut[24+ofs] = G(selseg.colors[2]);
    udpOut[25+ofs] = B(selseg.colors[2]);
    udpOut[26+ofs] = W(selseg.colors[2]);
    udpOut[27+ofs] = selseg.cct;
  }

  //uint16_t offs = SEG_OFFSET;
  //next value to be added has index: udpOut[offs + 0]

  IPAddress broadcastIp;
  broadcastIp = ~uint32_t(Network.subnetMask()) | uint32_t(Network.gatewayIP());

  notifierUdp.beginPacket(broadcastIp, udpPort);
  notifierUdp.write(udpOut, WLEDPACKETSIZE);
  notifierUdp.endPacket();
  notificationSentCallMode = callMode;
  notificationSentTime = millis();
  notificationTwoRequired = (followUp)? false:notifyTwice;
}

void realtimeLock(uint32_t timeoutMs, byte md)
{
  if (!realtimeMode && !realtimeOverride) {
    uint16_t stop, start;
    if (useMainSegmentOnly) {
      WS2812FX::Segment& mainseg = strip.getMainSegment();
      start = mainseg.start;
      stop  = mainseg.stop;
      mainseg.setOption(SEG_OPTION_FREEZE, true, strip.getMainSegmentId());
    } else {
      start = 0;
      stop  = strip.getLengthTotal();
    }
    // clear strip/segment
    for (size_t i = start; i < stop; i++) strip.setPixelColor(i,0,0,0,0);
    // if WLED was off and using main segment only, freeze non-main segments so they stay off
    if (useMainSegmentOnly && bri == 0) {
      for (size_t s=0; s < strip.getMaxSegments(); s++) {
        strip.getSegment(s).setOption(SEG_OPTION_FREEZE, true, s);
      }
    }
  }
  // if strip is off (bri==0) and not already in RTM
  if (briT == 0 && !realtimeMode && !realtimeOverride) {
    strip.setBrightness(scaledBri(briLast), true);
  }

  if (realtimeTimeout != UINT32_MAX) {
    realtimeTimeout = (timeoutMs == 255001 || timeoutMs == 65000) ? UINT32_MAX : millis() + timeoutMs;
  }
  realtimeMode = md;

  if (realtimeOverride) return;
  if (arlsForceMaxBri) strip.setBrightness(scaledBri(255), true);
  if (briT > 0 && md == REALTIME_MODE_GENERIC) strip.show();
}

void exitRealtime() {
  if (!realtimeMode) return;
  if (realtimeOverride == REALTIME_OVERRIDE_ONCE) realtimeOverride = REALTIME_OVERRIDE_NONE;
  strip.setBrightness(scaledBri(bri));
  realtimeTimeout = 0; // cancel realtime mode immediately
  realtimeMode = REALTIME_MODE_INACTIVE; // inform UI immediately
  realtimeIP[0] = 0;
  if (useMainSegmentOnly) { // unfreeze live segment again
    strip.getMainSegment().setOption(SEG_OPTION_FREEZE, false, strip.getMainSegmentId());
  }
  updateInterfaces(CALL_MODE_WS_SEND);
}


#define TMP2NET_OUT_PORT 65442

void sendTPM2Ack() {
  notifierUdp.beginPacket(notifierUdp.remoteIP(), TMP2NET_OUT_PORT);
  uint8_t response_ack = 0xac;
  notifierUdp.write(&response_ack, 1);
  notifierUdp.endPacket();
}


void handleNotifications()
{
  IPAddress localIP;

  //send second notification if enabled
  if(udpConnected && notificationTwoRequired && millis()-notificationSentTime > 250){
    notify(notificationSentCallMode,true);
  }

  if (e131NewData && millis() - strip.getLastShow() > 15)
  {
    e131NewData = false;
    strip.show();
  }

  //unlock strip when realtime UDP times out
  if (realtimeMode && millis() > realtimeTimeout) exitRealtime();

  //receive UDP notifications
  if (!udpConnected) return;

  bool isSupp = false;
  size_t packetSize = notifierUdp.parsePacket();
  if (!packetSize && udp2Connected) {
    packetSize = notifier2Udp.parsePacket();
    isSupp = true;
  }

  //hyperion / raw RGB
  if (!packetSize && udpRgbConnected) {
    packetSize = rgbUdp.parsePacket();
    if (packetSize) {
      if (!receiveDirect) return;
      if (packetSize > UDP_IN_MAXSIZE || packetSize < 3) return;
      realtimeIP = rgbUdp.remoteIP();
      DEBUG_PRINTLN(rgbUdp.remoteIP());
      uint8_t lbuf[packetSize];
      rgbUdp.read(lbuf, packetSize);
      realtimeLock(realtimeTimeoutMs, REALTIME_MODE_HYPERION);
      if (realtimeOverride && !(realtimeMode && useMainSegmentOnly)) return;
      uint16_t id = 0;
      uint16_t totalLen = strip.getLengthTotal();
      for (size_t i = 0; i < packetSize -2; i += 3)
      {
        setRealtimePixel(id, lbuf[i], lbuf[i+1], lbuf[i+2], 0);
        id++; if (id >= totalLen) break;
      }
      if (!(realtimeMode && useMainSegmentOnly)) strip.show();
      return;
    }
  }

  if (!(receiveNotifications || receiveDirect)) return;

  localIP = Network.localIP();
  //notifier and UDP realtime
  if (!packetSize || packetSize > UDP_IN_MAXSIZE) return;
  if (!isSupp && notifierUdp.remoteIP() == localIP) return; //don't process broadcasts we send ourselves

  uint8_t udpIn[packetSize +1];
  uint16_t len;
  if (isSupp) len = notifier2Udp.read(udpIn, packetSize);
  else        len =  notifierUdp.read(udpIn, packetSize);

  // WLED nodes info notifications
  if (isSupp && udpIn[0] == 255 && udpIn[1] == 1 && len >= 40) {
    if (!nodeListEnabled || notifier2Udp.remoteIP() == localIP) return;

    uint8_t unit = udpIn[39];
    NodesMap::iterator it = Nodes.find(unit);
    if (it == Nodes.end() && Nodes.size() < WLED_MAX_NODES) { // Create a new element when not present
      Nodes[unit].age = 0;
      it = Nodes.find(unit);
    }

    if (it != Nodes.end()) {
      for (size_t x = 0; x < 4; x++) {
        it->second.ip[x] = udpIn[x + 2];
      }
      it->second.age = 0; // reset 'age counter'
      char tmpNodeName[33] = { 0 };
      memcpy(&tmpNodeName[0], reinterpret_cast<byte *>(&udpIn[6]), 32);
      tmpNodeName[32]     = 0;
      it->second.nodeName = tmpNodeName;
      it->second.nodeName.trim();
      it->second.nodeType = udpIn[38];
      uint32_t build = 0;
      if (len >= 44)
        for (size_t i=0; i<sizeof(uint32_t); i++)
          build |= udpIn[40+i]<<(8*i);
      it->second.build = build;
    }
    return;
  }

  //wled notifier, ignore if realtime packets active
  if (udpIn[0] == 0 && !realtimeMode && receiveNotifications)
  {
    //ignore notification if received within a second after sending a notification ourselves
    if (millis() - notificationSentTime < 1000) return;
    if (udpIn[1] > 199) return; //do not receive custom versions

    //compatibilityVersionByte:
    byte version = udpIn[11];

    // if we are not part of any sync group ignore message
    if (version < 9 || version > 199) {
      // legacy senders are treated as if sending in sync group 1 only
      if (!(receiveGroups & 0x01)) return;
    } else if (!(receiveGroups & udpIn[36])) return;

    bool someSel = (receiveNotificationBrightness || receiveNotificationColor || receiveNotificationEffects);

    //apply colors from notification to main segment, only if not syncing full segments
    if ((receiveNotificationColor || !someSel) && (version < 11 || !receiveSegmentOptions)) {
      // primary color, only apply white if intented (version > 0)
      strip.setColor(0, RGBW32(udpIn[3], udpIn[4], udpIn[5], (version > 0) ? udpIn[10] : 0));
      if (version > 1) {
        strip.setColor(1, RGBW32(udpIn[12], udpIn[13], udpIn[14], udpIn[15])); // secondary color
      }
      if (version > 6) {
        strip.setColor(2, RGBW32(udpIn[20], udpIn[21], udpIn[22], udpIn[23])); // tertiary color
        if (version > 9 && version < 200 && udpIn[37] < 255) { // valid CCT/Kelvin value
          uint8_t cct = udpIn[38];
          if (udpIn[37] > 0) { //Kelvin
            cct = (((udpIn[37] << 8) + udpIn[38]) - 1900) >> 5;
          }
          strip.setCCT(cct);
        }
      }
    }

    bool timebaseUpdated = false;
    //apply effects from notification
    bool applyEffects = (receiveNotificationEffects || !someSel);
    if (version < 200)
    {
      if (applyEffects && currentPlaylist >= 0) unloadPlaylist();
      if (version > 10 && (receiveSegmentOptions || receiveSegmentBounds)) {
        uint8_t numSrcSegs = udpIn[39];
        for (size_t i = 0; i < numSrcSegs; i++) {
          uint16_t ofs = 41 + i*udpIn[40]; //start of segment offset byte
          uint8_t id = udpIn[0 +ofs];
          if (id > strip.getMaxSegments()) continue;
          WS2812FX::Segment& selseg = strip.getSegment(id);
          uint16_t start  = (udpIn[1+ofs] << 8 | udpIn[2+ofs]);
          uint16_t stop   = (udpIn[3+ofs] << 8 | udpIn[4+ofs]);
          uint16_t offset = (udpIn[7+ofs] << 8 | udpIn[8+ofs]);
          if (!receiveSegmentOptions) {
            strip.setSegment(id, start, stop, selseg.grouping, selseg.spacing, offset);
            continue;
          }
          for (size_t j = 0; j<4; j++) selseg.setOption(j, (udpIn[9 +ofs] >> j) & 0x01); //only take into account mirrored, selected, on, reversed
          selseg.setOpacity(udpIn[10+ofs], id);
          if (applyEffects) {
            strip.setMode(id,  udpIn[11+ofs]);
            selseg.speed     = udpIn[12+ofs];
            selseg.intensity = udpIn[13+ofs];
            selseg.palette   = udpIn[14+ofs];
          }
          if (receiveNotificationColor || !someSel) {
            selseg.setColor(0, RGBW32(udpIn[15+ofs],udpIn[16+ofs],udpIn[17+ofs],udpIn[18+ofs]), id);
            selseg.setColor(1, RGBW32(udpIn[19+ofs],udpIn[20+ofs],udpIn[21+ofs],udpIn[22+ofs]), id);
            selseg.setColor(2, RGBW32(udpIn[23+ofs],udpIn[24+ofs],udpIn[25+ofs],udpIn[26+ofs]), id);
            selseg.setCCT(udpIn[27+ofs], id);
          }
          //setSegment() also properly resets segments
          if (receiveSegmentBounds) {
            strip.setSegment(id, start, stop, udpIn[5+ofs], udpIn[6+ofs], offset);
          } else {
            strip.setSegment(id, selseg.start, selseg.stop, udpIn[5+ofs], udpIn[6+ofs], selseg.offset);
          }
        }
        stateChanged = true;
      }

      // simple effect sync, applies to all selected segments
      if (applyEffects && (version < 11 || !receiveSegmentOptions)) {
        for (size_t i = 0; i < strip.getMaxSegments(); i++) {
          WS2812FX::Segment& seg = strip.getSegment(i);
          if (!seg.isActive() || !seg.isSelected()) continue;
          if (udpIn[8] < strip.getModeCount()) strip.setMode(i, udpIn[8]);
          seg.speed = udpIn[9];
          if (version > 2) seg.intensity = udpIn[16];
          if (version > 4 && udpIn[19] < strip.getPaletteCount()) seg.palette = udpIn[19];
        }
        stateChanged = true;
      }

      if (applyEffects && version > 5) {
        uint32_t t = (udpIn[25] << 24) | (udpIn[26] << 16) | (udpIn[27] << 8) | (udpIn[28]);
        t += PRESUMED_NETWORK_DELAY; //adjust trivially for network delay
        t -= millis();
        strip.timebase = t;
        timebaseUpdated = true;
      }
    }

    //adjust system time, but only if sender is more accurate than self
    if (version > 7 && version < 200)
    {
      Toki::Time tm;
      tm.sec = (udpIn[30] << 24) | (udpIn[31] << 16) | (udpIn[32] << 8) | (udpIn[33]);
      tm.ms = (udpIn[34] << 8) | (udpIn[35]);
      if (udpIn[29] > toki.getTimeSource()) { //if sender's time source is more accurate
        toki.adjust(tm, PRESUMED_NETWORK_DELAY); //adjust trivially for network delay
        uint8_t ts = TOKI_TS_UDP;
        if (udpIn[29] > 99) ts = TOKI_TS_UDP_NTP;
        else if (udpIn[29] >= TOKI_TS_SEC) ts = TOKI_TS_UDP_SEC;
        toki.setTime(tm, ts);
      } else if (timebaseUpdated && toki.getTimeSource() > 99) { //if we both have good times, get a more accurate timebase
        Toki::Time myTime = toki.getTime();
        uint32_t diff = toki.msDifference(tm, myTime);
        strip.timebase -= PRESUMED_NETWORK_DELAY; //no need to presume, use difference between NTP times at send and receive points
        if (toki.isLater(tm, myTime)) {
          strip.timebase += diff;
        } else {
          strip.timebase -= diff;
        }
      }
    }

    if (version > 3)
    {
      transitionDelayTemp = ((udpIn[17] << 0) & 0xFF) + ((udpIn[18] << 8) & 0xFF00);
    }

    nightlightActive = udpIn[6];
    if (nightlightActive) nightlightDelayMins = udpIn[7];

    if (receiveNotificationBrightness || !someSel) bri = udpIn[2];
    stateUpdated(CALL_MODE_NOTIFICATION);
    return;
  }

  if (!receiveDirect) return;

  //TPM2.NET
  if (udpIn[0] == 0x9c)
  {
    //WARNING: this code assumes that the final TMP2.NET payload is evenly distributed if using multiple packets (ie. frame size is constant)
    //if the number of LEDs in your installation doesn't allow that, please include padding bytes at the end of the last packet
    byte tpmType = udpIn[1];
    if (tpmType == 0xaa) { //TPM2.NET polling, expect answer
      sendTPM2Ack(); return;
    }
    if (tpmType != 0xda) return; //return if notTPM2.NET data

    realtimeIP = (isSupp) ? notifier2Udp.remoteIP() : notifierUdp.remoteIP();
    realtimeLock(realtimeTimeoutMs, REALTIME_MODE_TPM2NET);
    if (realtimeOverride && !(realtimeMode && useMainSegmentOnly)) return;

    tpmPacketCount++; //increment the packet count
    if (tpmPacketCount == 1) tpmPayloadFrameSize = (udpIn[2] << 8) + udpIn[3]; //save frame size for the whole payload if this is the first packet
    byte packetNum = udpIn[4]; //starts with 1!
    byte numPackets = udpIn[5];

    uint16_t id = (tpmPayloadFrameSize/3)*(packetNum-1); //start LED
    uint16_t totalLen = strip.getLengthTotal();
    for (size_t i = 6; i < tpmPayloadFrameSize + 4; i += 3)
    {
      if (id < totalLen)
      {
        setRealtimePixel(id, udpIn[i], udpIn[i+1], udpIn[i+2], 0);
        id++;
      }
      else break;
    }
    if (tpmPacketCount == numPackets) //reset packet count and show if all packets were received
    {
      tpmPacketCount = 0;
      strip.show();
    }
    return;
  }

  //UDP realtime: 1 warls 2 drgb 3 drgbw
  if (udpIn[0] > 0 && udpIn[0] < 5)
  {
    realtimeIP = (isSupp) ? notifier2Udp.remoteIP() : notifierUdp.remoteIP();
    DEBUG_PRINTLN(realtimeIP);
    if (packetSize < 2) return;

    if (udpIn[1] == 0)
    {
      realtimeTimeout = 0;
      return;
    } else {
      realtimeLock(udpIn[1]*1000 +1, REALTIME_MODE_UDP);
    }
    if (realtimeOverride && !(realtimeMode && useMainSegmentOnly)) return;

    uint16_t totalLen = strip.getLengthTotal();
    if (udpIn[0] == 1) //warls
    {
      for (size_t i = 2; i < packetSize -3; i += 4)
      {
        setRealtimePixel(udpIn[i], udpIn[i+1], udpIn[i+2], udpIn[i+3], 0);
      }
    } else if (udpIn[0] == 2) //drgb
    {
      uint16_t id = 0;
      for (size_t i = 2; i < packetSize -2; i += 3)
      {
        setRealtimePixel(id, udpIn[i], udpIn[i+1], udpIn[i+2], 0);

        id++; if (id >= totalLen) break;
      }
    } else if (udpIn[0] == 3) //drgbw
    {
      uint16_t id = 0;
      for (size_t i = 2; i < packetSize -3; i += 4)
      {
        setRealtimePixel(id, udpIn[i], udpIn[i+1], udpIn[i+2], udpIn[i+3]);

        id++; if (id >= totalLen) break;
      }
    } else if (udpIn[0] == 4) //dnrgb
    {
      uint16_t id = ((udpIn[3] << 0) & 0xFF) + ((udpIn[2] << 8) & 0xFF00);
      for (size_t i = 4; i < packetSize -2; i += 3)
      {
        if (id >= totalLen) break;
        setRealtimePixel(id, udpIn[i], udpIn[i+1], udpIn[i+2], 0);
        id++;
      }
    } else if (udpIn[0] == 5) //dnrgbw
    {
      uint16_t id = ((udpIn[3] << 0) & 0xFF) + ((udpIn[2] << 8) & 0xFF00);
      for (size_t i = 4; i < packetSize -2; i += 4)
      {
        if (id >= totalLen) break;
        setRealtimePixel(id, udpIn[i], udpIn[i+1], udpIn[i+2], udpIn[i+3]);
        id++;
      }
    }
    strip.show();
    return;
  }

  // API over UDP
  udpIn[packetSize] = '\0';

  if (udpIn[0] >= 'A' && udpIn[0] <= 'Z') { //HTTP API
    String apireq = "win&";
    apireq += (char*)udpIn;
    handleSet(nullptr, apireq);
  } else if (udpIn[0] == '{') { //JSON API
    DynamicJsonDocument jsonBuffer(2048);
    DeserializationError error = deserializeJson(jsonBuffer, udpIn);
    JsonObject root = jsonBuffer.as<JsonObject>();
    if (!error && !root.isNull()) deserializeState(root);
  }
}


void setRealtimePixel(uint16_t i, byte r, byte g, byte b, byte w)
{
  uint16_t pix = i + arlsOffset;
  if (pix < strip.getLengthTotal())
  {
    if (!arlsDisableGammaCorrection && strip.gammaCorrectCol)
    {
      strip.setPixelColor(pix, strip.gamma8(r), strip.gamma8(g), strip.gamma8(b), strip.gamma8(w));
    } else {
      strip.setPixelColor(pix, r, g, b, w);
    }
  }
}

/*********************************************************************************************\
   Refresh aging for remote units, drop if too old...
\*********************************************************************************************/
void refreshNodeList()
{
  for (NodesMap::iterator it = Nodes.begin(); it != Nodes.end();) {
    bool mustRemove = true;

    if (it->second.ip[0] != 0) {
      if (it->second.age < 10) {
        it->second.age++;
        mustRemove = false;
        ++it;
      }
    }

    if (mustRemove) {
      it = Nodes.erase(it);
    }
  }
}

/*********************************************************************************************\
   Broadcast system info to other nodes. (to update node lists)
\*********************************************************************************************/
void sendSysInfoUDP()
{
  if (!udp2Connected) return;

  IPAddress ip = Network.localIP();
  if (!ip || ip == IPAddress(255,255,255,255)) ip = IPAddress(4,3,2,1);

  // TODO: make a nice struct of it and clean up
  //  0: 1 byte 'binary token 255'
  //  1: 1 byte id '1'
  //  2: 4 byte ip
  //  6: 32 char name
  // 38: 1 byte node type id
  // 39: 1 byte node id
  // 40: 4 byte version ID
  // 44 bytes total

  // send my info to the world...
  uint8_t data[44] = {0};
  data[0] = 255;
  data[1] = 1;

  for (size_t x = 0; x < 4; x++) {
    data[x + 2] = ip[x];
  }
  memcpy((byte *)data + 6, serverDescription, 32);
  #ifdef ESP8266
  data[38] = NODE_TYPE_ID_ESP8266;
  #elif defined(ARDUINO_ARCH_ESP32)
  data[38] = NODE_TYPE_ID_ESP32;
  #else
  data[38] = NODE_TYPE_ID_UNDEFINED;
  #endif
  data[39] = ip[3]; // unit ID == last IP number

  uint32_t build = VERSION;
  for (size_t i=0; i<sizeof(uint32_t); i++)
    data[40+i] = (build>>(8*i)) & 0xFF;

  IPAddress broadcastIP(255, 255, 255, 255);
  notifier2Udp.beginPacket(broadcastIP, udpPort2);
  notifier2Udp.write(data, sizeof(data));
  notifier2Udp.endPacket();
}


/*********************************************************************************************\
 * Art-Net, DDP, E131 output - work in progress
\*********************************************************************************************/

#define DDP_HEADER_LEN 10
#define DDP_SYNCPACKET_LEN 10

#define DDP_FLAGS1_VER 0xc0  // version mask
#define DDP_FLAGS1_VER1 0x40 // version=1
#define DDP_FLAGS1_PUSH 0x01
#define DDP_FLAGS1_QUERY 0x02
#define DDP_FLAGS1_REPLY 0x04
#define DDP_FLAGS1_STORAGE 0x08
#define DDP_FLAGS1_TIME 0x10

#define DDP_ID_DISPLAY 1
#define DDP_ID_CONFIG 250
#define DDP_ID_STATUS 251

// 1440 channels per packet
#define DDP_CHANNELS_PER_PACKET 1440 // 480 leds

//
// Send real time UDP updates to the specified client
//
// type   - protocol type (0=DDP, 1=E1.31, 2=ArtNet)
// client - the IP address to send to
// length - the number of pixels
// buffer - a buffer of at least length*4 bytes long
// isRGBW - true if the buffer contains 4 components per pixel

uint8_t sequenceNumber = 0; // this needs to be shared across all outputs

uint8_t realtimeBroadcast(uint8_t type, IPAddress client, uint16_t length, uint8_t *buffer, uint8_t bri, bool isRGBW)  {
  if (!(apActive || interfacesInited) || !client[0] || !length) return 1;  // network not initialised or dummy/unset IP address  031522 ajn added check for ap

  WiFiUDP ddpUdp;

  switch (type) {
    case 0: // DDP
    {
      // calculate the number of UDP packets we need to send
      size_t channelCount = length * 3; // 1 channel for every R,G,B value
      size_t packetCount = ((channelCount-1) / DDP_CHANNELS_PER_PACKET) +1;

      // there are 3 channels per RGB pixel
      uint32_t channel = 0; // TODO: allow specifying the start channel
      // the current position in the buffer
      size_t bufferOffset = 0;

      for (size_t currentPacket = 0; currentPacket < packetCount; currentPacket++) {
        if (sequenceNumber > 15) sequenceNumber = 0;

        if (!ddpUdp.beginPacket(client, DDP_DEFAULT_PORT)) {  // port defined in ESPAsyncE131.h
          DEBUG_PRINTLN(F("WiFiUDP.beginPacket returned an error"));
          return 1; // problem
        }

        // the amount of data is AFTER the header in the current packet
        size_t packetSize = DDP_CHANNELS_PER_PACKET;

        uint8_t flags = DDP_FLAGS1_VER1;
        if (currentPacket == (packetCount - 1)) {
          // last packet, set the push flag
          // TODO: determine if we want to send an empty push packet to each destination after sending the pixel data
          flags = DDP_FLAGS1_VER1 | DDP_FLAGS1_PUSH;
          if (channelCount % DDP_CHANNELS_PER_PACKET) {
            packetSize = channelCount % DDP_CHANNELS_PER_PACKET;
          }
        }

        // write the header
        /*0*/ddpUdp.write(flags);
        /*1*/ddpUdp.write(sequenceNumber++ & 0x0F); // sequence may be unnecessary unless we are sending twice (as requested in Sync settings)
        /*2*/ddpUdp.write(0);
        /*3*/ddpUdp.write(DDP_ID_DISPLAY);
        // data offset in bytes, 32-bit number, MSB first
        /*4*/ddpUdp.write(0xFF & (channel >> 24));
        /*5*/ddpUdp.write(0xFF & (channel >> 16));
        /*6*/ddpUdp.write(0xFF & (channel >>  8));
        /*7*/ddpUdp.write(0xFF & (channel      ));
        // data length in bytes, 16-bit number, MSB first
        /*8*/ddpUdp.write(0xFF & (packetSize >> 8));
        /*9*/ddpUdp.write(0xFF & (packetSize     ));

        // write the colors, the write write(const uint8_t *buffer, size_t size)
        // function is just a loop internally too
        for (size_t i = 0; i < packetSize; i += 3) {
          ddpUdp.write(scale8(buffer[bufferOffset++], bri)); // R
          ddpUdp.write(scale8(buffer[bufferOffset++], bri)); // G
          ddpUdp.write(scale8(buffer[bufferOffset++], bri)); // B
          if (isRGBW) bufferOffset++;
        }

        if (!ddpUdp.endPacket()) {
          DEBUG_PRINTLN(F("WiFiUDP.endPacket returned an error"));
          return 1; // problem
        }

        channel += packetSize;
      }
    } break;

    case 1: //E1.31
    {
    } break;

    case 2: //ArtNet
    {
    } break;
  }
  return 0;
}

=== ./um_manager.cpp ===

#include "wled.h"
/*
 * Registration and management utility for v2 usermods
 */

//Usermod Manager internals
void UsermodManager::loop()              { for (byte i = 0; i < numMods; i++) ums[i]->loop();  }
void UsermodManager::handleOverlayDraw() { for (byte i = 0; i < numMods; i++) ums[i]->handleOverlayDraw(); }
bool UsermodManager::handleButton(uint8_t b) { 
  bool overrideIO = false;
  for (byte i = 0; i < numMods; i++) {
    if (ums[i]->handleButton(b)) overrideIO = true;
  }
  return overrideIO;
}

void UsermodManager::setup()     { for (byte i = 0; i < numMods; i++) ums[i]->setup(); }
void UsermodManager::connected() { for (byte i = 0; i < numMods; i++) ums[i]->connected(); }

void UsermodManager::addToJsonState(JsonObject& obj)    { for (byte i = 0; i < numMods; i++) ums[i]->addToJsonState(obj); }
void UsermodManager::addToJsonInfo(JsonObject& obj)     { for (byte i = 0; i < numMods; i++) ums[i]->addToJsonInfo(obj); }
void UsermodManager::readFromJsonState(JsonObject& obj) { for (byte i = 0; i < numMods; i++) ums[i]->readFromJsonState(obj); }
void UsermodManager::addToConfig(JsonObject& obj)       { for (byte i = 0; i < numMods; i++) ums[i]->addToConfig(obj); }
bool UsermodManager::readFromConfig(JsonObject& obj)    { 
  bool allComplete = true;
  for (byte i = 0; i < numMods; i++) {
    if (!ums[i]->readFromConfig(obj)) allComplete = false;
  }
  return allComplete;
}
void UsermodManager::onMqttConnect(bool sessionPresent) { for (byte i = 0; i < numMods; i++) ums[i]->onMqttConnect(sessionPresent); }
bool UsermodManager::onMqttMessage(char* topic, char* payload) {
  for (byte i = 0; i < numMods; i++) if (ums[i]->onMqttMessage(topic, payload)) return true;
  return false;
}

/*
 * Enables usermods to lookup another Usermod.
 */
Usermod* UsermodManager::lookup(uint16_t mod_id) {
  for (byte i = 0; i < numMods; i++) {
    if (ums[i]->getId() == mod_id) {
      return ums[i];
    }
  }
  return nullptr;
}

bool UsermodManager::add(Usermod* um)
{
  if (numMods >= WLED_MAX_USERMODS || um == nullptr) return false;
  ums[numMods] = um;
  numMods++;
  return true;
}

byte UsermodManager::getModCount() {return numMods;}
=== ./usermod.cpp ===

#include "wled.h"

static bool serialTxAvaileable = true;   // false means we cannot use Serial.print, as serialTX pin is in use for other purposes (like LEDs)
constexpr uint8_t hardwareTX = 1;        // just a constant to improve code readability

#include "audio_reactive.h"
/*
 * This v1 usermod file allows you to add own functionality to WLED more easily
 * See: https://github.com/Aircoookie/WLED/wiki/Add-own-functionality
 * EEPROM bytes 2750+ are reserved for your custom use case. (if you extend #define EEPSIZE in const.h)
 * If you just need 8 bytes, use 2551-2559 (you do not need to increase EEPSIZE)
 *
 * Consider the v2 usermod API if you need a more advanced feature set!
 */

/*
 * Functions and variable declarations moved to audio_reactive.h
 * Not 100% sure this was done right. There is probably a better way to handle this...
 */

// These variables are feeding the "Info" Page
static unsigned long last_UDPTime = 0;    // time of last valid UDP sound sync datapacket
static float maxSample5sec = 0.0f;        // max sample (after AGC) in last 5 seconds 
static unsigned long sampleMaxTimer = 0;  // last time maxSample5sec was reset
static int receivedFormat = 0;            // last received UDP sound sync format - 0=none, 1=v1 (0.13.x), 2=v2 (0.14.x)
#define CYCLE_SAMPLEMAX 2500              // time window for measuring

// This gets called once at boot. Do all initialization that doesn't depend on network here
void userSetup() {
  disableSoundProcessing = true; // just to be safe
  // Reset I2S peripheral for good measure
  i2s_driver_uninstall(I2S_NUM_0);
  delay(100); // Give this peripheral time to disable to avoid an indeterminate state.
  periph_module_reset(PERIPH_I2S0_MODULE);

  delay(100);         // Give that poor microphone some time to setup.

  // check if Serial can be used for printing messages
  if  (pinManager.isPinAllocated(hardwareTX)) serialTxAvaileable = false; 
  if ((pinManager.isPinAllocated(hardwareTX)) && (pinManager.getPinOwner(hardwareTX) == PinOwner::DebugOut)) serialTxAvaileable = true;  // TX available for debug
  if ((dmType > 0) && ((i2ssdPin == hardwareTX) || (i2swsPin == hardwareTX) || (i2sckPin == hardwareTX))) serialTxAvaileable = false;    // i2S pin == TX (stupid but possible ...)

  useInputFilter = 0;
  // initialize I2S input
  switch (dmType) {
    case 1:
      useInputFilter = 3; // apply 60Hz Low-Cut filter
      if (serialTxAvaileable) {
        Serial.print("AS: Generic I2S Microphone - "); Serial.println(I2S_MIC_CHANNEL_TEXT);
      }
      audioSource = new I2SSource(SAMPLE_RATE, BLOCK_SIZE, 0, 0xFFFFFFFF);
      break;
    case 2:
      useInputFilter = 3; // apply 60Hz Low-Cut filter
      if (serialTxAvaileable) Serial.println("AS: ES7243 Microphone (right channel only).");
      // audioSource = new ES7243(SAMPLE_RATE, BLOCK_SIZE, 0, 0xFFFFFFFF, 1.0f/16.0f);  // for Line Level
      audioSource = new ES7243(SAMPLE_RATE, BLOCK_SIZE, 0, 0xFFFFFFFF);              // for Microphone Level
      break;
    case 3:
      useInputFilter = 3; // apply 60Hz Low-Cut filter
      if (serialTxAvaileable) {
        Serial.print("AS: SPH0645 Microphone - "); Serial.println(I2S_MIC_CHANNEL_TEXT);
      }
      audioSource = new SPH0654(SAMPLE_RATE, BLOCK_SIZE, 0, 0xFFFFFFFF);
      break;
    case 4:
      useInputFilter = 3; // apply 60hz low-cut filter against ground loop noise
      if (mclkPin == hardwareTX) serialTxAvaileable = false;
      if (serialTxAvaileable) {
        Serial.print("AS: Generic I2S Microphone with Master Clock - "); Serial.println(I2S_MIC_CHANNEL_TEXT);
      }
      audioSource = new I2SSourceWithMasterClock(SAMPLE_RATE, BLOCK_SIZE, 0, 0xFFFFFFFF, 1.0f/24.0f);
      break;
    case 5:
      useInputFilter = 1;  // 1 = PDM bandpass filter
      if (serialTxAvaileable) {
        Serial.print("AS: I2S PDM Microphone - "); Serial.println(I2S_MIC_CHANNEL_TEXT);
      }
      audioSource = new I2SPdmSource(SAMPLE_RATE, BLOCK_SIZE, 0, 0xFFFFFFFF, 1.0f/4.0f);
      break;
    case 0:
    default:
      useInputFilter = 1; // useful as ADC analog is notoriously noisy. Also the filter might reduce signal artefacts from non-continuous sampling
      if (serialTxAvaileable) Serial.println("AS: Analog Microphone (left channel only).");
      audioSource = new I2SAdcSource(SAMPLE_RATE, BLOCK_SIZE, 0, 0x0FFF);
      break;
  }

  delay(100);

  audioSource->initialize();
  delay(250);

  if(!audioSource->isInitialized()) {
    if (serialTxAvaileable) 
      Serial.println("AS: Failed to initialize sound input driver. Please check input PIN settings.");
  }

  sampling_period_us = round(1000000*(1.0/SAMPLE_RATE));

  // Define the FFT Task and lock it to core 0
  xTaskCreatePinnedToCore(
        FFTcode,                          // Function to implement the task
        "FFT",                            // Name of the task
        5000,                            // Stack size in words
        NULL,                             // Task input parameter
        1,                                // Priority of the task
        &FFT_Task,                        // Task handle
        0);                               // Core where the task should run

  if(audioSource->isInitialized())
    disableSoundProcessing = false; // let it run
}

// This gets called every time WiFi is (re-)connected. Initialize own network interfaces here
void userConnected() {
}

// userLoop. You can use "if (WLED_CONNECTED)" to check for successful connection
void userLoop() {
  static unsigned long lastUMRun = millis();          // time of last filter run

  // suspend local sound processing when "real time mode" is active (E131, UDP, ADALIGHT, ARTNET)
  if (  (realtimeOverride == REALTIME_OVERRIDE_NONE)  // user override
      &&(useMainSegmentOnly == false)                 // cannot suspend when "main segment only" is set - other segments may still need sound data.
      &&( (realtimeMode == REALTIME_MODE_GENERIC)     // these realtime modes take complete control of all LEDs, so it's safe to disable sound processing
        ||(realtimeMode == REALTIME_MODE_E131)
        ||(realtimeMode == REALTIME_MODE_UDP)
        ||(realtimeMode == REALTIME_MODE_ADALIGHT)
        ||(realtimeMode == REALTIME_MODE_TPM2NET)
        ||(realtimeMode == REALTIME_MODE_ARTNET) ) ) 
  {
    #ifdef WLED_DEBUG
    if ((disableSoundProcessing == false) && (audioSyncEnabled == 0)) {  // we just switched to "disabled"
      DEBUG_PRINTLN("[AS userLoop] realtime mode active - audio processing suspended.");
      DEBUG_PRINTF( "              RealtimeMode = %d; RealtimeOverride = %d useMainSegmentOnly=%d\n", int(realtimeMode), int(realtimeOverride), int(useMainSegmentOnly));
    }
    #endif
    disableSoundProcessing = true;
  } else {
    if(audioSource->isInitialized()) { // only enable if sound input driver was initialized successfully
      #ifdef WLED_DEBUG
      if ((disableSoundProcessing == true) && (audioSyncEnabled == 0)) {    // we just switched to "enabled"
        DEBUG_PRINTLN("[AS userLoop] realtime mode ended - audio processing resumed.");
        DEBUG_PRINTF( "              RealtimeMode = %d; RealtimeOverride = %d useMainSegmentOnly=%d\n", int(realtimeMode), int(realtimeOverride), int(useMainSegmentOnly));
      }
      #endif
      if ((disableSoundProcessing == true) && (audioSyncEnabled == 0)) lastUMRun = millis();  // just left "realtime mode" - update timekeeping
      disableSoundProcessing = false;
    }
  }

  if (audioSyncEnabled & (1 << 1)) 
    disableSoundProcessing = true;   // make sure everything is disabled IF in audio Receive mode
  if (audioSyncEnabled & (1 << 0)  && audioSource->isInitialized()) 
    disableSoundProcessing = false;  // keep running audio IF we're in audio Transmit mode

  int userloopDelay = int(millis() - lastUMRun);
  if (lastUMRun == 0) userloopDelay=0; // startup - don't have valid data from last run.

  if ((!disableSoundProcessing) && (!(audioSyncEnabled & (1 << 1)))) { // Only run the sampling code IF we're not in realtime mode and not in audio Receive mode
    #ifdef WLED_DEBUG
    // compain when audio userloop has been delayed for long. Currently we need userloop running between 500 and 1500 times per second. 
    if ((userloopDelay > 50) || ((dmType != 0) && userloopDelay > 23)) {    // should not happen. Expect lagging in SR effects if you see this mesage !!!
      DEBUG_PRINTF("[AS userLoop] hickup detected -> was inactive for last %d millis!\n", int(millis() - lastUMRun));
    }
    #endif

    unsigned long t_now = millis();
    lastUMRun = t_now;
    if (soundAgc > AGC_NUM_PRESETS) soundAgc = 0; // make sure that AGC preset is valid (to avoid array bounds violation)

    if (userloopDelay <2) userloopDelay = 0;      // minor glitch, no problem
    if (userloopDelay >150) userloopDelay = 150;  // limit number of filter re-runs  
    do {
      getSample();                        // Sample the microphone
      agcAvg(t_now - userloopDelay);      // Calculated the PI adjusted value as sampleAvg
      userloopDelay -= 2;                 // advance "simulated time" by 2ms
    } while (userloopDelay > 0);

    myVals[millis()%32] = sampleAgc;

    static uint8_t lastMode = 0;
    static bool agcEffect = false;
    uint8_t knownMode = strip.getMainSegment().mode;

    if (lastMode != knownMode) { // only execute if mode changes
      char lineBuffer[3];
      /* uint8_t printedChars = */ extractModeName(knownMode, JSON_mode_names, lineBuffer, 3); //is this 'the' way to get mode name here?

      //used the following code to reverse engineer this
      // Serial.println(lineBuffer);
      // for (uint8_t i = 0; i<printedChars; i++) {
      //   Serial.print(i);
      //   Serial.print( ": ");
      //   Serial.println(uint8_t(lineBuffer[i]));
      // }
      agcEffect = (lineBuffer[1] == 226 && lineBuffer[2] == 153); // && (lineBuffer[3] == 170 || lineBuffer[3] == 171 ) encoding of  or 
      // agcEffect = (lineBuffer[4] == 240 && lineBuffer[5] == 159 && lineBuffer[6] == 142 && lineBuffer[7] == 154 ); //encoding of  No clue why as not found here https://www.iemoji.com/view/emoji/918/objects/level-slider

      // if (agcEffect)
      //   Serial.println("found  or ");
    }

    // update inputLevel Slider based on current AGC gain
    if ((soundAgc>0) && agcEffect) {
      static unsigned long last_update_time = 0;
      static unsigned long last_kick_time = 0;
      static int last_user_inputLevel = 0;
      unsigned long now_time = millis();    

      // "user kick" feature - if user has moved the slider by at least 32 units, we "kick" AGC gain by 30% (up or down)
      // only once in 3.5 seconds
      if (   (lastMode == knownMode)
          && (abs(last_user_inputLevel - inputLevel) > 31) 
          && (now_time - last_kick_time > 3500)) {
        if (last_user_inputLevel > inputLevel) multAgc *= 0.60; // down -> reduce gain
        if (last_user_inputLevel < inputLevel) multAgc *= 1.50; // up -> increase gain
        last_kick_time = now_time;
      }

      int new_user_inputLevel = 128.0 * multAgc;                                       // scale AGC multiplier so that "1" is at 128
      if (multAgc > 1.0) new_user_inputLevel = 128.0 * (((multAgc - 1.0) / 4.0) +1.0); // compress range so we can show values up to 4
      new_user_inputLevel = MIN(MAX(new_user_inputLevel, 0),255);

	    // update user interfaces - restrict frequency to avoid flooding UI's with small changes
      if ( ( ((now_time - last_update_time > 3500) && (abs(new_user_inputLevel - inputLevel) > 2))     // small change - every 3.5 sec (max) 
           ||((now_time - last_update_time > 2200) && (abs(new_user_inputLevel - inputLevel) > 15))    // medium change
           ||((now_time - last_update_time > 1200) && (abs(new_user_inputLevel - inputLevel) > 31))    // BIG change - every second
           ) && (now_time - lastInterfaceUpdate > INTERFACE_UPDATE_COOLDOWN))		                     // respect UI cooldown time
      {
        inputLevel = new_user_inputLevel;           // change of least 3 units -> update user variable
        updateInterfaces(CALL_MODE_WS_SEND);        // is this the correct way to notify UIs ? Yes says blazoncek
        last_update_time = now_time;
        last_user_inputLevel = new_user_inputLevel;
      }
    }
    lastMode = knownMode;

#if defined(MIC_LOGGER) || defined(FFT_SAMPLING_LOG)
    static unsigned long last_miclogger_time = 0;
    if (millis() - last_miclogger_time > 24) {
      last_miclogger_time = millis();
      logAudio();
    }
#endif

  }

  // Info Page: keep max sample from last 5 seconds
  if ((millis() -  sampleMaxTimer) > CYCLE_SAMPLEMAX) {
    sampleMaxTimer = millis();
    maxSample5sec = (0.15 * maxSample5sec) + 0.85 *((soundAgc) ? sampleAgc : sampleAvg); // reset, and start with some smoothing
    if (sampleAvg < 1) maxSample5sec = 0; // noise gate 
  } else {
      if ((sampleAvg >= 1)) maxSample5sec = fmaxf(maxSample5sec, (soundAgc) ? rawSampleAgc : sampleRaw); // follow maximum volume
  }

  // limit dynamics (experimental)
  limitSampleDynamics();

  // Begin UDP Microphone Sync
  if (audioSyncEnabled & (1 << 0)) {    // Only run the transmit code IF we're in Transmit mode
    static unsigned long last_transmit_time = 0;
    if (millis() - last_transmit_time > 18) {
        //Serial.println("Transmitting UDP Mic Packet");
        last_transmit_time = millis();
        transmitAudioData();
      }
  }

  if (audioSyncEnabled & (1 << 1)) {    // Only run the audio listener code if we're in Receive mode
    if (millis()-lastTime > delayMs) {
      lastTime = millis();
      if (udpSyncConnected) {
        //Serial.println("Checking for UDP Microphone Packet");
        int packetSize = fftUdp.parsePacket();

        if ((packetSize < 6) || (packetSize > UDPSOUND_MAX_PACKET)) { // packet too small or too big -> discard and clean up buffers
          fftUdp.flush();
          packetSize = 0;
        }

        if (packetSize > 6) {  // packet is big enough to contain at least the header
          // Serial.println("Received UDP Sync Packet");
          static uint8_t fftBuff[UDPSOUND_MAX_PACKET+1];                              // softhack007: use a static buffer that can hold the biggest expected packet.
          fftUdp.read(fftBuff, packetSize);
          static audioSyncPacket receivedPacket;                                      // softhack007: added "static"
          memcpy(&receivedPacket, fftBuff, MIN(sizeof(receivedPacket), packetSize));  // don't copy more that what fits into audioSyncPacket
          receivedPacket.header[5] = '\0';                                            // ensure string termination

          // VERIFY THAT THIS IS A COMPATIBLE PACKET
          if (isValidUdpSyncVersion2(receivedPacket.header)) {
            // decode "V2" packet
            last_UDPTime = millis();                                                  // tell Info page that we are "receiving"
            receivedFormat = 2;
            extract_v2_packet(packetSize, fftBuff);
          } else {

            if (isValidUdpSyncVersion(receivedPacket.header)) {
              // decode "V1" packet
              last_UDPTime = millis();                                                  // tell Info page that we are "receiving"
              receivedFormat = 1;
              for (int i = 0; i < 32; i++ ) myVals[i] = receivedPacket.myVals[i];
              sampleAgc = receivedPacket.sampleAgc;
              rawSampleAgc = receivedPacket.sampleAgc;
              sampleRaw = receivedPacket.sampleRaw;
              sampleAvg = receivedPacket.sampleAvg;

              // auto-reset sample peak. Need to do it here, because getSample() is not running
              uint16_t MinShowDelay = max((uint16_t)33, strip.getMinShowDelay());
              if (millis() - timeOfPeak > MinShowDelay) {   // Auto-reset of samplePeak after a complete frame has passed.
                samplePeak = 0;
                udpSamplePeak = 0;
              }
              if (userVar1 == 0) samplePeak = 0;

              // Only change samplePeak IF it's currently false.
              // If it's true already, then the animation still needs to respond.
              if (samplePeak==0) {
                samplePeak = receivedPacket.samplePeak;
                if (samplePeak >0) timeOfPeak = millis();
                udpSamplePeak = samplePeak;
                userVar1 = samplePeak;
              }
              //These values are only available on the ESP32
              for (int i = 0; i < 16; i++) fftResult[i] = receivedPacket.fftResult[i];
              FFT_Magnitude = fabsf(receivedPacket.FFT_Magnitude);
              FFT_MajorPeak = constrain(receivedPacket.FFT_MajorPeak, 1.0f, 5120.0f); // restrict value to range expected by effects
              //Serial.println("Finished parsing UDP Sync Packet");
            }
          }
        }
      }
    }
  }
} // userLoop()


// Provide Info for Web UI Info page
char audioStatusInfo[7][24] = {{'\0'}, {'\0'}, {'\0'}, {'\0'}, {'\0'}, {'\0'}, {'\0'}};
void usermod_updateInfo(void) {

  // Audio Source
  strcpy(audioStatusInfo[0], "- none");
  strcpy(audioStatusInfo[1], " -");
  if (audioSyncEnabled & 0x02) {                    // UDP sound sync - receive mode
    strcpy(audioStatusInfo[0], "UDP sound sync");
    if (udpSyncConnected) {
      if ((millis() - last_UDPTime) < 2500)
        strcpy(audioStatusInfo[1], " - receiving");
      else
        strcpy(audioStatusInfo[1], " - idle");
    } else {
        strcpy(audioStatusInfo[1], " - no connection");
    }
  } else {                                          // Analog or I2S digital input
    if (audioSource && (audioSource->isInitialized())) { 
      // audio source sucessfully configured
      if ((dmType == 0) && (audioPin > 0)) strcpy(audioStatusInfo[0], "ADC analog");
      if ((dmType > 0) && (i2ssdPin > 0)) strcpy(audioStatusInfo[0], "I2S digital");
      if (maxSample5sec > 1.0) {
        float my_usage = 100.0f * (maxSample5sec / 255.0f);
        snprintf(audioStatusInfo[1], 23, " - peak %3d%%", int(my_usage));
      } else {
        strcpy(audioStatusInfo[1], " - quiet");
      }
    } else {                                        // error during audio source setup
      strcpy(audioStatusInfo[0], "not initialized");
      strcpy(audioStatusInfo[1], " - check pin settings");
    }
  }
  
  // AGC or manual Gain
  if (audioSource && audioSource->isInitialized() && (disableSoundProcessing == false) && !(audioSyncEnabled & 0x02)) {
    if (soundAgc==0) {
      float myGain = ((float)sampleGain/40.0f * (float)inputLevel/128.0f) + 1.0f/16.0f;     // non-AGC gain from presets
      snprintf(audioStatusInfo[2], 23, "%5.2f", roundf(myGain*100.0f) / 100.0f);
    } else {
      snprintf(audioStatusInfo[2], 23, "%5.2f", roundf(multAgc*100.0f) / 100.0f);           // AGC gain
    }
  } else strcpy(audioStatusInfo[2], "");                                                    // nothing

  // UDP Sound Sync status
  strcpy(audioStatusInfo[3], "");
  strcpy(audioStatusInfo[4], "");
  if (audioSyncEnabled > 0) {
    if (audioSyncEnabled & 0x01){ 
      strcpy(audioStatusInfo[3], "send mode");
      if ((udpSyncConnected) && (disableSoundProcessing == false)) strcpy(audioStatusInfo[4], " (v1)");
    } else { 
      if (audioSyncEnabled & 0x02) {
        strcpy(audioStatusInfo[3], "receive mode");
        if ((receivedFormat == 1) && udpSyncConnected && ((millis() - last_UDPTime) < 2500)) strcpy(audioStatusInfo[4], " (v1)");
        if ((receivedFormat == 2) && udpSyncConnected && ((millis() - last_UDPTime) < 2500)) strcpy(audioStatusInfo[4], " (v2)");
      } else strcpy(audioStatusInfo[3], "");
    }
  } else strcpy(audioStatusInfo[3], "off");
  if (audioSyncEnabled && !udpSyncConnected) strcpy(audioStatusInfo[4], " <i>(unconnected)</i>");

  // Sound processing (FFT and input filters)
  if (audioSource && (disableSoundProcessing == false)) {
    strcpy(audioStatusInfo[5], "running");
  } else {
    strcpy(audioStatusInfo[5], "suspended");
  }

  bool foundPot = false;
  if ((dmType == 0) && (audioPin > 0)) { // ADC analog input - warn if Potentiometer is configured
    for (int b=0; b<WLED_MAX_BUTTONS; b++) {
      if ((btnPin[b] >= 0) 
          && (buttonType[b] == BTN_TYPE_ANALOG || buttonType[b] == BTN_TYPE_ANALOG_INVERTED) 
          && (digitalPinToAnalogChannel(btnPin[b]) >= 0) && (digitalPinToAnalogChannel(btnPin[b]) < 9)) // found ADC1(channel 0...8) analog input
        foundPot = true;
    }
  }
  if (foundPot) strcpy(audioStatusInfo[6], "disable analog button");
  else  strcpy(audioStatusInfo[6], "");

  // make sure all strings are terminated properly
  audioStatusInfo[0][23] = '\0'; audioStatusInfo[1][23] = '\0';
  audioStatusInfo[2][23] = '\0'; 
  audioStatusInfo[3][23] = '\0'; audioStatusInfo[4][23] = '\0';
  audioStatusInfo[5][23] = '\0'; 
  audioStatusInfo[6][23] = '\0'; 
}

=== ./usermod_v2_empty.h ===

#pragma once

#include "wled.h"

//This is an empty v2 usermod template. Please see the file usermod_v2_example.h in the EXAMPLE_v2 usermod folder for documentation on the functions you can use!

class UsermodRenameMe : public Usermod {
  private:
    
  public:
    void setup() {
      
    }

    void loop() {
      
    }
};
=== ./usermods_list.cpp ===

#include "wled.h"
/*
 * Register your v2 usermods here!
 *   (for v1 usermods using just usermod.cpp, you can ignore this file)
 */

/*
 * Add/uncomment your usermod filename here (and once more below)
 * || || ||
 * \/ \/ \/
 */
//#include "../usermods/EXAMPLE_v2/usermod_v2_example.h"

#ifdef USERMOD_BATTERY_STATUS_BASIC
#include "../usermods/battery_status_basic/usermod_v2_battery_status_basic.h"
#endif

#ifdef USERMOD_DALLASTEMPERATURE
#include "../usermods/Temperature/usermod_temperature.h"
#endif

#ifdef USERMOD_SN_PHOTORESISTOR
#include "../usermods/SN_Photoresistor/usermod_sn_photoresistor.h"
#endif

#ifdef USERMOD_PWM_FAN
#include "../usermods/PWM_fan/usermod_PWM_fan.h"
#endif

#ifdef USERMOD_BUZZER
#include "../usermods/buzzer/usermod_v2_buzzer.h"
#endif
#ifdef USERMOD_SENSORSTOMQTT
#include "../usermods/sensors_to_mqtt/usermod_v2_SensorsToMqtt.h"
#endif
#ifdef USERMOD_PIRSWITCH
#include "../usermods/PIR_sensor_switch/usermod_PIR_sensor_switch.h"
#endif

#ifdef USERMOD_MODE_SORT
#include "../usermods/usermod_v2_mode_sort/usermod_v2_mode_sort.h"
#endif

// BME280 v2 usermod. Define "USERMOD_BME280" in my_config.h
#ifdef USERMOD_BME280
#include "../usermods/BME280_v2/usermod_bme280.h"
#endif
#ifdef USERMOD_FOUR_LINE_DISPLAY
  #if defined(USE_ALT_DISPLAY) || defined(USE_ALT_DISPlAY)
    #include "../usermods/usermod_v2_four_line_display_ALT/usermod_v2_four_line_display_ALT.h"
  #else
    #include "../usermods/usermod_v2_four_line_display/usermod_v2_four_line_display.h"
  #endif
#endif
#ifdef USERMOD_ROTARY_ENCODER_UI
  #if defined(USE_ALT_DISPLAY) || defined(USE_ALT_DISPlAY)
    #include "../usermods/usermod_v2_rotary_encoder_ui_ALT/usermod_v2_rotary_encoder_ui_ALT.h"
  #else
    #include "../usermods/usermod_v2_rotary_encoder_ui/usermod_v2_rotary_encoder_ui.h"
  #endif
#endif
#ifdef USERMOD_AUTO_SAVE
#include "../usermods/usermod_v2_auto_save/usermod_v2_auto_save.h"
#endif

#ifdef USERMOD_DHT
#include "../usermods/DHT/usermod_dht.h"
#endif

#ifdef USERMOD_VL53L0X_GESTURES
#include <Wire.h> //it's needed here to correctly resolve dependencies
#include "../usermods/VL53L0X_gestures/usermod_vl53l0x_gestures.h"
#endif

#ifdef USERMOD_ANIMATED_STAIRCASE
#include "../usermods/Animated_Staircase/Animated_Staircase.h"
#endif

#ifdef USERMOD_MULTI_RELAY
#include "../usermods/multi_relay/usermod_multi_relay.h"
#endif

#ifdef USERMOD_RTC
#include "../usermods/RTC/usermod_rtc.h"
#endif

#ifdef USERMOD_ELEKSTUBE_IPS
#include "../usermods/EleksTube_IPS/usermod_elekstube_ips.h"
#endif

#ifdef USERMOD_ROTARY_ENCODER_BRIGHTNESS_COLOR
#include "../usermods/usermod_rotary_brightness_color/usermod_rotary_brightness_color.h"
#endif

#ifdef RGB_ROTARY_ENCODER
#include "../usermods/rgb-rotary-encoder/rgb-rotary-encoder.h"
#endif

#ifdef USERMOD_SEVEN_SEGMENT
#include "../usermods/seven_segment_display/usermod_v2_seven_segment_display.h"
#endif

#ifdef USERMOD_SSDR
#include "../usermods/seven_segment_display_reloaded/usermod_seven_segment_reloaded.h"
#endif

#ifdef USERMOD_CRONIXIE
#include "../usermods/Cronixie/usermod_cronixie.h"
#endif

#ifdef QUINLED_AN_PENTA
#include "../usermods/quinled-an-penta/quinled-an-penta.h"
#endif

#ifdef USERMOD_WIZLIGHTS
#include "../usermods/wizlights/wizlights.h"
#endif

#ifdef USERMOD_WORDCLOCK
#include "../usermods/usermod_v2_word_clock/usermod_v2_word_clock.h"
#endif

#ifdef USERMOD_MY9291
#include "../usermods/MY9291/usermode_MY9291.h"
#endif

#ifdef USERMOD_SI7021_MQTT_HA
#include "../usermods/Si7021_MQTT_HA/usermod_si7021_mqtt_ha.h"
#endif

//WLEDMM ARTI-FX
#ifdef USERMOD_ARTIFX
#include "../usermods/artifx/usermod_v2_artifx.h"
#endif


void registerUsermods()
{
/*
   * Add your usermod class name here
   * || || ||
   * \/ \/ \/
   */
  //usermods.add(new MyExampleUsermod());

  #ifdef USERMOD_BATTERY_STATUS_BASIC
  usermods.add(new UsermodBatteryBasic());
  #endif

  #ifdef USERMOD_DALLASTEMPERATURE
  usermods.add(new UsermodTemperature());
  #endif

  #ifdef USERMOD_SN_PHOTORESISTOR
  usermods.add(new Usermod_SN_Photoresistor());
  #endif

  #ifdef USERMOD_PWM_FAN
  usermods.add(new PWMFanUsermod());
  #endif

  #ifdef USERMOD_BUZZER
  usermods.add(new BuzzerUsermod());
  #endif

  #ifdef USERMOD_BME280
  usermods.add(new UsermodBME280());
  #endif
  #ifdef USERMOD_SENSORSTOMQTT
  usermods.add(new UserMod_SensorsToMQTT());
  #endif
  #ifdef USERMOD_PIRSWITCH
  usermods.add(new PIRsensorSwitch());
  #endif

  #ifdef USERMOD_MODE_SORT
  usermods.add(new ModeSortUsermod());
  #endif
  #ifdef USERMOD_FOUR_LINE_DISPLAY
  usermods.add(new FourLineDisplayUsermod());
  #endif
  #ifdef USERMOD_ROTARY_ENCODER_UI
  usermods.add(new RotaryEncoderUIUsermod()); // can use USERMOD_FOUR_LINE_DISPLAY
  #endif
  #ifdef USERMOD_AUTO_SAVE
  usermods.add(new AutoSaveUsermod());  // can use USERMOD_FOUR_LINE_DISPLAY
  #endif

  #ifdef USERMOD_DHT
  usermods.add(new UsermodDHT());
  #endif

  #ifdef USERMOD_VL53L0X_GESTURES
  usermods.add(new UsermodVL53L0XGestures());
  #endif

  #ifdef USERMOD_ANIMATED_STAIRCASE
  usermods.add(new Animated_Staircase());
  #endif

  #ifdef USERMOD_MULTI_RELAY
  usermods.add(new MultiRelay());
  #endif

  #ifdef USERMOD_RTC
  usermods.add(new RTCUsermod());
  #endif

  #ifdef USERMOD_ELEKSTUBE_IPS
  usermods.add(new ElekstubeIPSUsermod());
  #endif

  #ifdef USERMOD_ROTARY_ENCODER_BRIGHTNESS_COLOR
  usermods.add(new RotaryEncoderBrightnessColor());
  #endif

  #ifdef RGB_ROTARY_ENCODER
  usermods.add(new RgbRotaryEncoderUsermod());
  #endif

  #ifdef USERMOD_SEVEN_SEGMENT
  usermods.add(new SevenSegmentDisplay());
  #endif

  #ifdef USERMOD_SSDR
  usermods.add(new UsermodSSDR());
  #endif

  #ifdef USERMOD_CRONIXIE
  usermods.add(new UsermodCronixie());
  #endif

  #ifdef QUINLED_AN_PENTA
  usermods.add(new QuinLEDAnPentaUsermod());
  #endif

  #ifdef USERMOD_WIZLIGHTS
  usermods.add(new WizLightsUsermod());
  #endif
  
  #ifdef USERMOD_WORDCLOCK
  usermods.add(new WordClockUsermod());
  #endif

  #ifdef USERMOD_MY9291
  usermods.add(new MY9291Usermod());
  #endif
  
  #ifdef USERMOD_SI7021_MQTT_HA
  usermods.add(new Si7021_MQTT_HA());
  #endif

  //WLEDMM ARTI-FX
  #ifdef USERMOD_ARTIFX
  usermods.add(new ARTIFXUserMod());
  #endif
}

=== ./util.cpp ===

#include "wled.h"
#include "fcn_declare.h"
#include "const.h"

//threading/network callback details: https://github.com/Aircoookie/WLED/pull/2336#discussion_r762276994
bool requestJSONBufferLock(uint8_t module)
{
  unsigned long now = millis();

  while (jsonBufferLock && millis()-now < 1000) delay(1); // wait for a second for buffer lock

  if (millis()-now >= 1000) {
    DEBUG_PRINT(F("ERROR: Locking JSON buffer failed! ("));
    DEBUG_PRINT(jsonBufferLock);
    DEBUG_PRINTLN(")");
    return false; // waiting time-outed
  }

  jsonBufferLock = module ? module : 255;
  fileDoc = &doc;  // used for applying presets (presets.cpp)
  doc.clear();
  return true;
}


void releaseJSONBufferLock()
{
  DEBUG_PRINT(F("JSON buffer released. ("));
  DEBUG_PRINT(jsonBufferLock);
  DEBUG_PRINTLN(")");
  fileDoc = nullptr;
  jsonBufferLock = 0;
}


// extracts effect mode (or palette) name from names serialized string
// caller must provide large enough buffer for name (incluing SR extensions)!
uint8_t extractModeName(uint8_t mode, const char *src, char *dest, uint8_t maxLen)
{
  uint8_t qComma = 0;
  bool insideQuotes = false;
  uint8_t printedChars = 0;
  char singleJsonSymbol;
  size_t len = strlen_P(src);

  // Find the mode name in JSON
  for (size_t i = 0; i < len; i++) {
    singleJsonSymbol = pgm_read_byte_near(src + i);
    if (singleJsonSymbol == '\0') break;
    if (singleJsonSymbol == '@' && insideQuotes && qComma == mode) break; //stop when SR extension encountered
    switch (singleJsonSymbol) {
      case '"':
        insideQuotes = !insideQuotes;
        break;
      case '[':
      case ']':
        break;
      case ',':
        if (!insideQuotes) qComma++;
      default:
        if (!insideQuotes || (qComma != mode)) break;
        dest[printedChars++] = singleJsonSymbol;
    }
    if ((qComma > mode) || (printedChars >= maxLen)) break;
  }
  dest[printedChars] = '\0';
  return strlen(dest);
}


CRGB getCRGBForBand(int x, int pal) { 
  extern int fftResult[];                         // summary of bins array. 16 summary bins.
  CRGB value;
  CHSV hsv;
  if(pal == 71) { // bit hacky to use palette id here, but don't want to litter the code with lots of different methods. TODO: add enum for palette creation type
    if(x == 1) {
      value = CRGB(uint8_t(fftResult[10]/2), uint8_t(fftResult[4]/2), uint8_t(fftResult[0]/2));
    }
    else if(x == 255) {
      value = CRGB(uint8_t(fftResult[10]/2), uint8_t(fftResult[0]/2), uint8_t(fftResult[4]/2));
    } 
    else {
      value = CRGB(uint8_t(fftResult[0]/2), uint8_t(fftResult[4]/2), uint8_t(fftResult[10]/2));
    } 
  }
  else if(pal == 72) {
    int b = map(x, 1, 255, 0, 8); // convert palette position to lower half of freq band
    hsv = CHSV(uint8_t(fftResult[b]), 255, uint8_t(map(fftResult[b], 0, 255, 30, 255)));  // pick hue
    hsv2rgb_rainbow(hsv, value);  // convert to R,G,B
  }
  return value;
} 
=== ./wled.cpp ===

#define WLED_DEFINE_GLOBAL_VARS //only in one source file, wled.cpp!
#include "wled.h"
#include "wled_ethernet.h"
#include <Arduino.h>

#if defined(ARDUINO_ARCH_ESP32) && defined(WLED_DISABLE_BROWNOUT_DET)
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#endif

// special support for some "M5" devices
#ifdef ARDUINO_M5Stack_ATOM
  #include <M5Atom.h>
#endif
#ifdef ARDUINO_M5Stick_C
  #undef BLACK    // workaroud for some name clashes with M5 display library
  #undef WHITE
  #undef PURPLE
  #undef BLUE
  #undef GREEN
  #undef CYAN
  #undef RED
  #undef MAGENTA
  #undef YELLOW
  #undef ORANGE
  #undef PINK
  #include <M5StickCPlus.h>
#endif

/*
 * Main WLED class implementation. Mostly initialization and connection logic
 */

WLED::WLED()
{
}

// turns all LEDs off and restarts ESP
void WLED::reset()
{
  briT = 0;
  #ifdef WLED_ENABLE_WEBSOCKETS
  ws.closeAll(1012);
  #endif
  long dly = millis();
  while (millis() - dly < 450) {
    yield();        // enough time to send response to client
  }
  applyBri();
  DEBUG_PRINTLN(F("WLED RESET"));
  ESP.restart();
}

bool oappendi(int i)
{
  char s[16];               // WLEDSR max 32bit integer needs 11 chars (sign + 10) not 10
  snprintf(s, 15,"%d", i);  // WLEDSR protect against stack corruption
  return oappend(s);
}

bool oappend(const char* txt)
{
  uint16_t len = strlen(txt);
  if (olen + len >= SETTINGS_STACK_BUF_SIZE) {
    DEBUG_PRINTLN(F("oappend() error: buffer full. Increase SETTINGS_STACK_BUF_SIZE.")); // WLEDSR additional debug message
    return false;        // buffer full
  }
  strcpy(obuf + olen, txt);
  olen += len;
  return true;
}

void prepareHostname(char* hostname)
{
  const char *pC = serverDescription;
  uint8_t pos = 5;

  while (*pC && pos < 24) { // while !null and not over length
    if (isalnum(*pC)) {     // if the current char is alpha-numeric append it to the hostname
      hostname[pos] = *pC;
      pos++;
    } else if (*pC == ' ' || *pC == '_' || *pC == '-' || *pC == '+' || *pC == '!' || *pC == '?' || *pC == '*') {
      hostname[pos] = '-';
      pos++;
    }
    // else do nothing - no leading hyphens and do not include hyphens for all other characters.
    pC++;
  }
  // if the hostname is left blank, use the mac address/default mdns name
  if (pos < 6) {
    sprintf(hostname + 5, "%*s", 6, escapedMac.c_str() + 6);
  } else { //last character must not be hyphen
    hostname[pos] = '\0'; // terminate string
    while (pos > 0 && hostname[pos -1] == '-') {
      hostname[pos -1] = '\0';
      pos--;
    }
  }
}

//handle Ethernet connection event
void WiFiEvent(WiFiEvent_t event)
{
  #ifdef WLED_USE_ETHERNET
  char hostname[25] = "wled-";
  #endif

  switch (event) {
#if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_ETHERNET)
    case SYSTEM_EVENT_ETH_START:
      DEBUG_PRINT(F("ETH Started"));
      break;
    case SYSTEM_EVENT_ETH_CONNECTED:
      DEBUG_PRINT(F("ETH Connected"));
      if (!apActive) {
        WiFi.disconnect(true);
      }
      if (staticIP != (uint32_t)0x00000000 && staticGateway != (uint32_t)0x00000000) {
        ETH.config(staticIP, staticGateway, staticSubnet, IPAddress(8, 8, 8, 8));
      } else {
        ETH.config(INADDR_NONE, INADDR_NONE, INADDR_NONE);
      }
      // convert the "serverDescription" into a valid DNS hostname (alphanumeric)
      prepareHostname(hostname);
      ETH.setHostname(hostname);
      showWelcomePage = false;
      break;
    case SYSTEM_EVENT_ETH_DISCONNECTED:
      DEBUG_PRINT(F("ETH Disconnected"));
      // This doesn't really affect ethernet per se,
      // as it's only configured once.  Rather, it
      // may be necessary to reconnect the WiFi when
      // ethernet disconnects, as a way to provide
      // alternative access to the device.
      forceReconnect = true;
      break;
#endif
    default:
      break;
  }
}

void WLED::loop()
{
  #ifdef WLED_DEBUG
  static unsigned long maxUsermodMillis = 0;
  #endif

  handleTime();
  handleIR();        // 2nd call to function needed for ESP32 to return valid results -- should be good for ESP8266, too
  handleConnection();
  handleSerial();
  handleNotifications();
  handleTransitions();
#ifdef WLED_ENABLE_DMX
  handleDMX();
#endif
  userLoop();

  #ifdef WLED_DEBUG
  unsigned long usermodMillis = millis();
  #endif
  usermods.loop();
  #ifdef WLED_DEBUG
  usermodMillis = millis() - usermodMillis;
  if (usermodMillis > maxUsermodMillis) maxUsermodMillis = usermodMillis;
  #endif

  yield();
  handleIO();
  handleIR();
  #ifndef WLED_DISABLE_ALEXA
  handleAlexa();
  #endif

  yield();

  if (doReboot && !doInitBusses) // if busses have to be inited & saved, wait until next iteration
    reset();
  if (doCloseFile) {
    closeFile();
    yield();
  }

  if (!realtimeMode || realtimeOverride || (realtimeMode && useMainSegmentOnly))  // block stuff if WARLS/Adalight is enabled
  {
    if (apActive) dnsServer.processNextRequest();
    #ifndef WLED_DISABLE_OTA
    if (WLED_CONNECTED && aOtaEnabled) ArduinoOTA.handle();
    #endif
    handleNightlight();
    handlePlaylist();
    yield();

    #ifndef WLED_DISABLE_HUESYNC
    handleHue();
    yield();
    #endif

    yield();

    if (!offMode || strip.isOffRefreshRequired())
      strip.service();
#ifdef ESP8266
    else if (!noWifiSleep)
      delay(1); //required to make sure ESP enters modem sleep (see #1184)
#endif
  }
  yield();
#ifdef ESP8266
  MDNS.update();
#endif

  //millis() rolls over every 50 days
  if (lastMqttReconnectAttempt > millis()) {
    rolloverMillis++;
    lastMqttReconnectAttempt = 0;
    ntpLastSyncTime = 0;
    strip.restartRuntime();
  }
  if (millis() - lastMqttReconnectAttempt > 30000) {
    lastMqttReconnectAttempt = millis();
    initMqtt();
    yield();
    // refresh WLED nodes list
    refreshNodeList();
    if (nodeBroadcastEnabled) sendSysInfoUDP();
    yield();
  }

  //LED settings have been saved, re-init busses
  //This code block causes severe FPS drop on ESP32 with the original "if (busConfigs[0] != nullptr)" conditional. Investigate!
  if (doInitBusses) {
    doInitBusses = false;
    DEBUG_PRINTLN(F("Re-init busses."));
    bool aligned = strip.checkSegmentAlignment(); //see if old segments match old bus(ses)
    busses.removeAll();
    uint32_t mem = 0;
    for (uint8_t i = 0; i < WLED_MAX_BUSSES; i++) {
      if (busConfigs[i] == nullptr) break;
      mem += BusManager::memUsage(*busConfigs[i]);
      if (mem <= MAX_LED_MEMORY) {
        busses.add(*busConfigs[i]);
      }
      delete busConfigs[i]; busConfigs[i] = nullptr;
    }
    strip.finalizeInit();
    loadLedmap = 0;
    if (aligned) strip.makeAutoSegments();
    else strip.fixInvalidSegments();
    yield();
    serializeConfig();
  }
  if (loadLedmap >= 0) {
    strip.deserializeMap(loadLedmap);
    loadLedmap = -1;
  }

  yield();
  handleWs();
  handleStatusLED();

// DEBUG serial logging (every 30s)
#ifdef WLED_DEBUG
  if (millis() - debugTime > 29999) {
    DEBUG_PRINTLN(F("---DEBUG INFO---"));
    DEBUG_PRINT(F("Runtime: "));       DEBUG_PRINTLN(millis());
    DEBUG_PRINT(F("Unix time: "));     toki.printTime(toki.getTime());
    DEBUG_PRINT(F("Free heap: "));     DEBUG_PRINTLN(ESP.getFreeHeap());
    #if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_PSRAM)
    if (psramFound()) {
      DEBUG_PRINT(F("Total PSRAM: "));    DEBUG_PRINT(ESP.getPsramSize()/1024); DEBUG_PRINTLN("kB");
      DEBUG_PRINT(F("Free PSRAM: "));     DEBUG_PRINT(ESP.getFreePsram()/1024); DEBUG_PRINTLN("kB");
    } else
      DEBUG_PRINTLN(F("No PSRAM"));
    #endif
    DEBUG_PRINT(F("Wifi state: "));      DEBUG_PRINTLN(WiFi.status());

    if (WiFi.status() != lastWifiState) {
      wifiStateChangedTime = millis();
    }
    lastWifiState = WiFi.status();
    DEBUG_PRINT(F("State time: "));      DEBUG_PRINTLN(wifiStateChangedTime);
    DEBUG_PRINT(F("NTP last sync: "));   DEBUG_PRINTLN(ntpLastSyncTime);
    DEBUG_PRINT(F("Client IP: "));       DEBUG_PRINTLN(Network.localIP());
    DEBUG_PRINT(F("Loops/sec: "));       DEBUG_PRINTLN(loops / 30);
    DEBUG_PRINT(F("Max UM time[ms]: ")); DEBUG_PRINTLN(maxUsermodMillis);
    loops = 0;
    maxUsermodMillis = 0;
    debugTime = millis();
  }
  loops++;
#endif        // WLED_DEBUG
  toki.resetTick();

#if WLED_WATCHDOG_TIMEOUT > 0
  // we finished our mainloop, reset the watchdog timer
  #ifdef ARDUINO_ARCH_ESP32
    esp_task_wdt_reset();
  #else
    ESP.wdtFeed();
  #endif
#endif
}

void WLED::enableWatchdog() {
#if WLED_WATCHDOG_TIMEOUT > 0
#ifdef ARDUINO_ARCH_ESP32
  esp_err_t watchdog = esp_task_wdt_init(WLED_WATCHDOG_TIMEOUT, true);
  DEBUG_PRINT(F("Watchdog enabled: "));
  if (watchdog == ESP_OK) {
    DEBUG_PRINTLN(F("OK"));
  } else {
    DEBUG_PRINTLN(watchdog);
    return;
  }
  esp_task_wdt_add(NULL);
#else
  ESP.wdtEnable(WLED_WATCHDOG_TIMEOUT * 1000);
#endif
#endif
}

void WLED::disableWatchdog() {
#if WLED_WATCHDOG_TIMEOUT > 0
DEBUG_PRINTLN(F("Watchdog: disabled"));
#ifdef ARDUINO_ARCH_ESP32
  esp_task_wdt_delete(NULL);
#else
  ESP.wdtDisable();
#endif
#endif
}

void WLED::setup()
{
  #if defined(ARDUINO_ARCH_ESP32) && defined(WLED_DISABLE_BROWNOUT_DET)
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); //disable brownout detection
  #endif

  #ifdef ARDUINO_ARCH_ESP32
  pinMode(RX, INPUT_PULLDOWN); delay(1);        // suppress noise in case RX pin is floating (at low noise energy) - see upstream issue #3128
  #endif
  Serial.begin(115200);
  Serial.setTimeout(50);
  DEBUG_PRINTLN();
  DEBUG_PRINT(F("---WLED "));
  DEBUG_PRINT(versionString);
  DEBUG_PRINT(" ");
  DEBUG_PRINT(VERSION);
  DEBUG_PRINTLN(F(" INIT---"));
#ifdef ARDUINO_ARCH_ESP32
  DEBUG_PRINT(F("esp32 "));
  DEBUG_PRINTLN(ESP.getSdkVersion());

  //M5 devices need a special "begin" to actvate on-board hardware.
  #if defined(ARDUINO_M5Stack_ATOM)
  M5.begin(true, false, true);
  #endif
  #if defined(ARDUINO_M5Stick_C)
  M5.begin();
  M5.Lcd.setRotation(3);
  M5.Lcd.fillScreen(BLACK);
  M5.Lcd.setTextColor(WHITE, BLACK);
  M5.Lcd.println("WLED-SR loading");
  #endif

  // WLEDSR begin
  #if defined(ESP_ARDUINO_VERSION)
    //DEBUG_PRINTF(F("arduino-esp32  0x%06x\n"), ESP_ARDUINO_VERSION);
    DEBUG_PRINTF("arduino-esp32 v%d.%d.%d\n", int(ESP_ARDUINO_VERSION_MAJOR), int(ESP_ARDUINO_VERSION_MINOR), int(ESP_ARDUINO_VERSION_PATCH));  // availeable since v2.0.0
  #else
    DEBUG_PRINTLN(F("arduino-esp32 v1.0.x\n"));  // we can't say in more detail.
  #endif
  DEBUG_PRINT(F("CPU:   ")); DEBUG_PRINT(ESP.getChipModel());
  DEBUG_PRINT(F(" rev.")); DEBUG_PRINT(ESP.getChipRevision());
  DEBUG_PRINT(F(", ")); DEBUG_PRINT(ESP.getChipCores()); DEBUG_PRINT(F(" core(s)"));
  DEBUG_PRINT(F(", ")); DEBUG_PRINT(ESP.getCpuFreqMHz()); DEBUG_PRINTLN(F("MHz."));
  DEBUG_PRINT(F("FLASH: ")); DEBUG_PRINT((ESP.getFlashChipSize()/1024)/1024);
  DEBUG_PRINT(F("MB, Mode ")); DEBUG_PRINT(ESP.getFlashChipMode());
  #ifdef WLED_DEBUG
  switch (ESP.getFlashChipMode()) {
    // missing: Octal modes
    case FM_QIO:  DEBUG_PRINT(F(" (QIO)")); break;
    case FM_QOUT: DEBUG_PRINT(F(" (QOUT)"));break;
    case FM_DIO:  DEBUG_PRINT(F(" (DIO?)")); break;
    case FM_DOUT: DEBUG_PRINT(F(" (DOUT?)"));break;
    default: break;
  }
  #endif 
  DEBUG_PRINT(F(", ")); DEBUG_PRINT(int(ESP.getFlashChipSpeed()/1000000)); DEBUG_PRINTLN(F("MHz")); 
  // WLEDSR end
#else
  DEBUG_PRINT(F("esp8266 "));
  DEBUG_PRINTLN(ESP.getCoreVersion());
#endif
  DEBUG_PRINTLN("");
  DEBUG_PRINT(F("heap "));
  DEBUG_PRINTLN(ESP.getFreeHeap());

  enableWatchdog();

  #if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_PSRAM)
  if (psramFound()) {
    // GPIO16/GPIO17 reserved for SPI RAM
    managed_pin_type pins[2] = { {16, true}, {17, true} };
    pinManager.allocateMultiplePins(pins, 2, PinOwner::SPI_RAM);
    DEBUG_PRINT(F("Total PSRAM: "));    DEBUG_PRINT(ESP.getPsramSize()/1024); DEBUG_PRINTLN("kB");
    DEBUG_PRINT(F("Free PSRAM:  "));    DEBUG_PRINT(ESP.getFreePsram()/1024); DEBUG_PRINTLN("kB");
  } else
    DEBUG_PRINTLN(F("No PSRAM"));
  }
  #endif
  #if defined(ARDUINO_ARCH_ESP32) && defined(BOARD_HAS_PSRAM) && !defined(WLED_USE_PSRAM)
      DEBUG_PRINTLN(F("PSRAM availeable but not used."));
  #endif

  //DEBUG_PRINT(F("LEDs inited. heap usage ~"));
  //DEBUG_PRINTLN(heapPreAlloc - ESP.getFreeHeap());

#ifdef WLED_DEBUG
  pinManager.allocatePin(1, true, PinOwner::DebugOut); // GPIO1 reserved for debug output
#endif
#ifdef WLED_ENABLE_DMX //reserve GPIO2 as hardcoded DMX pin
  pinManager.allocatePin(2, true, PinOwner::DMX);
#endif

  DEBUG_PRINTLN(F("Registering usermods ..."));
  registerUsermods();

  for (uint8_t i=1; i<WLED_MAX_BUTTONS; i++) btnPin[i] = -1;

  bool fsinit = false;
  DEBUGFS_PRINTLN(F("Mount FS"));
#ifdef ARDUINO_ARCH_ESP32
  fsinit = WLED_FS.begin(true);
#else
  fsinit = WLED_FS.begin();
#endif
  if (!fsinit) {
    DEBUGFS_PRINTLN(F("FS failed!"));
    errorFlag = ERR_FS_BEGIN;
  } else deEEP();
  updateFSInfo();

  DEBUG_PRINTLN(F("Reading config"));
  deserializeConfigFromFS();

#if STATUSLED
  if (!pinManager.isPinAllocated(STATUSLED)) {
    // NOTE: Special case: The status LED should *NOT* be allocated.
    //       See comments in handleStatusLed().
    pinMode(STATUSLED, OUTPUT);
  }
#endif

  DEBUG_PRINTLN(F("Initializing strip"));
  beginStrip();

  DEBUG_PRINTLN(F("Usermods setup"));
  userSetup();
  usermods.setup();

  if (strcmp(clientSSID, DEFAULT_CLIENT_SSID) == 0)
    showWelcomePage = true;
  WiFi.persistent(false);
  #ifdef WLED_USE_ETHERNET
  WiFi.onEvent(WiFiEvent);
  #endif

  #ifdef WLED_ENABLE_ADALIGHT
  //Serial RX (Adalight, Improv, Serial JSON) only possible if GPIO3 unused
  //Serial TX (Debug, Improv, Serial JSON) only possible if GPIO1 unused
  if (!pinManager.isPinAllocated(3) && (!pinManager.isPinAllocated(1) || (pinManager.getPinOwner(1) == PinOwner::DebugOut))) {    // WLEDSR allow TX = debugOut
    Serial.println(F("Ada"));
  }
  #endif

  // generate module IDs
  escapedMac = WiFi.macAddress();
  escapedMac.replace(":", "");
  escapedMac.toLowerCase();
  if (strcmp(cmDNS, "x") == 0)        // fill in unique mdns default
  {
    strcpy_P(cmDNS, PSTR("wled-"));
    sprintf(cmDNS + 5, "%*s", 6, escapedMac.c_str() + 6);
  }
  if (mqttDeviceTopic[0] == 0) {
    strcpy_P(mqttDeviceTopic, PSTR("wled/"));
    sprintf(mqttDeviceTopic + 5, "%*s", 6, escapedMac.c_str() + 6);
  }
  if (mqttClientID[0] == 0) {
    strcpy_P(mqttClientID, PSTR("WLED-"));
    sprintf(mqttClientID + 5, "%*s", 6, escapedMac.c_str() + 6);
  }

#ifdef WLED_ENABLE_ADALIGHT
  if (Serial.available() > 0 && Serial.peek() == 'I') handleImprovPacket();
#endif

  strip.service();

#ifndef WLED_DISABLE_OTA
  if (aOtaEnabled) {
    ArduinoOTA.onStart([]() {
#ifdef ESP8266
      wifi_set_sleep_type(NONE_SLEEP_T);
#endif
      WLED::instance().disableWatchdog();
      DEBUG_PRINTLN(F("Start ArduinoOTA"));
    });
    ArduinoOTA.onError([](ota_error_t error) {
      // reenable watchdog on failed update
      WLED::instance().enableWatchdog();
    });
    if (strlen(cmDNS) > 0)
      ArduinoOTA.setHostname(cmDNS);
  }
#endif
#ifdef WLED_ENABLE_DMX
  initDMX();
#endif

#ifdef WLED_ENABLE_ADALIGHT
  if (Serial.available() > 0 && Serial.peek() == 'I') handleImprovPacket();
#endif

  // HTTP server page init
  initServer();

  #if defined(ARDUINO_ARCH_ESP32) && defined(WLED_DISABLE_BROWNOUT_DET)
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 1); //enable brownout detector
  #endif
  #ifndef WLED_ENABLE_ADALIGHT
  if (!pinManager.isPinAllocated(1) || (pinManager.getPinOwner(1) == PinOwner::DebugOut)) {
    Serial.println(F("\nWLED-SR ready."));  // WLEDSR "Ada" will not be printed without Adalight support. So tell users "all good".
  }
  #endif
}

void WLED::beginStrip()
{
  // Initialize NeoPixel Strip and button
  strip.finalizeInit(); // busses created during deserializeConfig()
  strip.deserializeMap();
  strip.makeAutoSegments();
  strip.setBrightness(0);
  strip.setShowCallback(handleOverlayDraw);

  if (turnOnAtBoot) {
    if (briS > 0) bri = briS;
    else if (bri == 0) bri = 128;
  } else {
    briLast = briS; bri = 0;
  }
  if (bootPreset > 0) {
    applyPreset(bootPreset, CALL_MODE_INIT);
  }
  colorUpdated(CALL_MODE_INIT);

  // init relay pin
  if (rlyPin>=0)
    digitalWrite(rlyPin, (rlyMde ? bri : !bri));
}

void WLED::initAP(bool resetAP)
{
  if (apBehavior == AP_BEHAVIOR_BUTTON_ONLY && !resetAP)
    return;

  if (!apSSID[0] || resetAP)
    strcpy_P(apSSID, PSTR("WLED-AP"));
  if (resetAP)
    strcpy_P(apPass, PSTR(DEFAULT_AP_PASS));
  Serial.print(F("Opening access point "));
  Serial.println(apSSID);
#ifdef ARDUINO_M5Stick_C
  M5.Lcd.print(F("AP open: "));
  M5.Lcd.println(apSSID);
#endif
  WiFi.softAPConfig(IPAddress(4, 3, 2, 1), IPAddress(4, 3, 2, 1), IPAddress(255, 255, 255, 0));
  WiFi.softAP(apSSID, apPass, apChannel, apHide);

  if (!apActive) // start captive portal if AP active
  {
    Serial.println(F("Init AP interfaces"));
    server.begin();
    if (udpPort > 0 && udpPort != ntpLocalPort) {
      udpConnected = notifierUdp.begin(udpPort);
    }
    if (udpRgbPort > 0 && udpRgbPort != ntpLocalPort && udpRgbPort != udpPort) {
      udpRgbConnected = rgbUdp.begin(udpRgbPort);
    }
    if (udpPort2 > 0 && udpPort2 != ntpLocalPort && udpPort2 != udpPort && udpPort2 != udpRgbPort) {
      udp2Connected = notifier2Udp.begin(udpPort2);
    }

    if (audioSyncPort > 0 || (((audioSyncEnabled)>>(0)) & 1) || (((audioSyncEnabled)>>(1)) & 1)) {
    #ifndef ESP8266
      udpSyncConnected = fftUdp.beginMulticast(IPAddress(239,0,0,1), audioSyncPort);
    #else
      udpSyncConnected = fftUdp.beginMulticast(WiFi.localIP(), IPAddress(239, 0, 0, 1), audioSyncPort);
    #endif
    }
    e131.begin(false, e131Port, e131Universe, E131_MAX_UNIVERSE_COUNT);
    ddp.begin(false, DDP_DEFAULT_PORT);

    dnsServer.setErrorReplyCode(DNSReplyCode::NoError);
    dnsServer.start(53, "*", WiFi.softAPIP());
  }
  apActive = true;
}

bool WLED::initEthernet()
{
#if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_ETHERNET)

  static bool successfullyConfiguredEthernet = false;

  if (successfullyConfiguredEthernet) {
    // DEBUG_PRINTLN(F("initE: ETH already successfully configured, ignoring"));
    return false;
  }
  if (ethernetType == WLED_ETH_NONE) {
    return false;
  }
  if (ethernetType >= WLED_NUM_ETH_TYPES) {
    DEBUG_PRINT(F("initE: Ignoring attempt for invalid ethernetType ")); DEBUG_PRINTLN(ethernetType);
    return false;
  }

  DEBUG_PRINT(F("initE: Attempting ETH config: ")); DEBUG_PRINTLN(ethernetType);

  // Ethernet initialization should only succeed once -- else reboot required
  ethernet_settings es = ethernetBoards[ethernetType];
  managed_pin_type pinsToAllocate[10] = {
    // first six pins are non-configurable
    esp32_nonconfigurable_ethernet_pins[0],
    esp32_nonconfigurable_ethernet_pins[1],
    esp32_nonconfigurable_ethernet_pins[2],
    esp32_nonconfigurable_ethernet_pins[3],
    esp32_nonconfigurable_ethernet_pins[4],
    esp32_nonconfigurable_ethernet_pins[5],
    { (int8_t)es.eth_mdc,   true },  // [6] = MDC  is output and mandatory
    { (int8_t)es.eth_mdio,  true },  // [7] = MDIO is bidirectional and mandatory
    { (int8_t)es.eth_power, true },  // [8] = optional pin, not all boards use
    { ((int8_t)0xFE),       false }, // [9] = replaced with eth_clk_mode, mandatory
  };
  // update the clock pin....
  if (es.eth_clk_mode == ETH_CLOCK_GPIO0_IN) {
    pinsToAllocate[9].pin = 0;
    pinsToAllocate[9].isOutput = false;
  } else if (es.eth_clk_mode == ETH_CLOCK_GPIO0_OUT) {
    pinsToAllocate[9].pin = 0;
    pinsToAllocate[9].isOutput = true;
  } else if (es.eth_clk_mode == ETH_CLOCK_GPIO16_OUT) {
    pinsToAllocate[9].pin = 16;
    pinsToAllocate[9].isOutput = true;
  } else if (es.eth_clk_mode == ETH_CLOCK_GPIO17_OUT) {
    pinsToAllocate[9].pin = 17;
    pinsToAllocate[9].isOutput = true;
  } else {
    DEBUG_PRINT(F("initE: Failing due to invalid eth_clk_mode ("));
    DEBUG_PRINT(es.eth_clk_mode);
    DEBUG_PRINTLN(F(")"));
    return false;
  }

  if (!pinManager.allocateMultiplePins(pinsToAllocate, 10, PinOwner::Ethernet)) {
    DEBUG_PRINTLN(F("initE: Failed to allocate ethernet pins"));
    return false;
  }

  /*
  For LAN8720 the most correct way is to perform clean reset each time before init
  applying LOW to power or nRST pin for at least 100 us (please refer to datasheet, page 59)
  ESP_IDF > V4 implements it (150 us, lan87xx_reset_hw(esp_eth_phy_t *phy) function in 
  /components/esp_eth/src/esp_eth_phy_lan87xx.c, line 280)
  but ESP_IDF < V4 does not. Lets do it:
  [not always needed, might be relevant in some EMI situations at startup and for hot resets]
  */
  #if ESP_IDF_VERSION_MAJOR==3
  if(es.eth_power>0 && es.eth_type==ETH_PHY_LAN8720) {
    pinMode(es.eth_power, OUTPUT);
    digitalWrite(es.eth_power, 0);
    delayMicroseconds(150);
    digitalWrite(es.eth_power, 1);
    delayMicroseconds(10);
  }
  #endif

  if (!ETH.begin(
                (uint8_t) es.eth_address,
                (int)     es.eth_power,
                (int)     es.eth_mdc,
                (int)     es.eth_mdio,
                (eth_phy_type_t)   es.eth_type,
                (eth_clock_mode_t) es.eth_clk_mode
                )) {
    DEBUG_PRINTLN(F("initC: ETH.begin() failed"));
    // de-allocate the allocated pins
    for (managed_pin_type mpt : pinsToAllocate) {
      pinManager.deallocatePin(mpt.pin, PinOwner::Ethernet);
    }
    return false;
  }

  successfullyConfiguredEthernet = true;
  DEBUG_PRINTLN(F("initC: *** Ethernet successfully configured! ***"));
  return true;
#else
  return false; // Ethernet not enabled for build
#endif

}

void WLED::initConnection()
{
  #ifdef WLED_ENABLE_WEBSOCKETS
  ws.onEvent(wsEvent);
  #endif


  WiFi.disconnect(true);        // close old connections
#ifdef ESP8266
  WiFi.setPhyMode(WIFI_PHY_MODE_11N);
#endif

  if (staticIP[0] != 0 && staticGateway[0] != 0) {
    WiFi.config(staticIP, staticGateway, staticSubnet, IPAddress(1, 1, 1, 1));
  } else {
    WiFi.config(IPAddress((uint32_t)0), IPAddress((uint32_t)0), IPAddress((uint32_t)0));
  }

  lastReconnectAttempt = millis();

  if (!WLED_WIFI_CONFIGURED) {
    Serial.print(F("No connection configured. "));
    if (!apActive)
      initAP();        // instantly go to ap mode
    return;
  } else if (!apActive) {
    if (apBehavior == AP_BEHAVIOR_ALWAYS) {
      initAP();
    } else {
      Serial.println(F("Access point disabled."));
      WiFi.softAPdisconnect(true);
      WiFi.mode(WIFI_STA);
    }
  }
  showWelcomePage = false;

  Serial.print(F("Connecting to "));
  Serial.print(clientSSID);
  Serial.println("...");

  // convert the "serverDescription" into a valid DNS hostname (alphanumeric)
  char hostname[25] = "wled-";
  prepareHostname(hostname);

#ifdef ESP8266
  WiFi.hostname(hostname);
#endif

  WiFi.begin(clientSSID, clientPass);

#ifdef ARDUINO_ARCH_ESP32
  WiFi.setSleep(!noWifiSleep);
  WiFi.setHostname(hostname);
#else
  wifi_set_sleep_type((noWifiSleep) ? NONE_SLEEP_T : MODEM_SLEEP_T);
#endif
}

void WLED::initInterfaces()
{
  DEBUG_PRINTLN(F("Init STA interfaces"));

#ifndef WLED_DISABLE_HUESYNC
  IPAddress ipAddress = Network.localIP();
  if (hueIP[0] == 0) {
    hueIP[0] = ipAddress[0];
    hueIP[1] = ipAddress[1];
    hueIP[2] = ipAddress[2];
  }
#endif

  // init Alexa hue emulation
  if (alexaEnabled)
    alexaInit();

#ifndef WLED_DISABLE_OTA
  if (aOtaEnabled)
    ArduinoOTA.begin();
#endif

  strip.service();

  // Set up mDNS responder:
  if (strlen(cmDNS) > 0) {
    // "end" must be called before "begin" is called a 2nd time
    // see https://github.com/esp8266/Arduino/issues/7213
    MDNS.end();
    MDNS.begin(cmDNS);

    DEBUG_PRINTLN(F("mDNS started"));
    MDNS.addService("http", "tcp", 80);
    MDNS.addService("wled", "tcp", 80);
    MDNS.addServiceTxt("wled", "tcp", "mac", escapedMac.c_str());
  }
  server.begin();

  if (udpPort > 0 && udpPort != ntpLocalPort) {
    udpConnected = notifierUdp.begin(udpPort);
    if (udpConnected && udpRgbPort != udpPort)
      udpRgbConnected = rgbUdp.begin(udpRgbPort);
    if (udpConnected && udpPort2 != udpPort && udpPort2 != udpRgbPort)
      udp2Connected = notifier2Udp.begin(udpPort2);
  }
  if (audioSyncPort > 0 || (((audioSyncEnabled)>>(0)) & 1) || (((audioSyncEnabled)>>(1)) & 1)) {
    #ifndef ESP8266
      udpSyncConnected = fftUdp.beginMulticast(IPAddress(239,0,0,1), audioSyncPort);
    #else
      udpSyncConnected = fftUdp.beginMulticast(WiFi.localIP(), IPAddress(239, 0, 0, 1), audioSyncPort);
    #endif
  }
  if (ntpEnabled)
    ntpConnected = ntpUdp.begin(ntpLocalPort);

  e131.begin(e131Multicast, e131Port, e131Universe, E131_MAX_UNIVERSE_COUNT);
  ddp.begin(false, DDP_DEFAULT_PORT);
  reconnectHue();
  initMqtt();
  interfacesInited = true;
  wasConnected = true;
}

void WLED::handleConnection()
{
  static byte stacO = 0;
  static uint32_t lastHeap = UINT32_MAX;
  static unsigned long heapTime = 0;
  unsigned long now = millis();

  if (now < 2000 && (!WLED_WIFI_CONFIGURED || apBehavior == AP_BEHAVIOR_ALWAYS))
    return;
  if (lastReconnectAttempt == 0) {
    initConnection();
    return;
  }

  // reconnect WiFi to clear stale allocations if heap gets too low
  if (now - heapTime > 5000) {
    uint32_t heap = ESP.getFreeHeap();
    if (heap < MIN_HEAP_SIZE && lastHeap < MIN_HEAP_SIZE) {
      DEBUG_PRINT(F("Heap too low! "));
      DEBUG_PRINTLN(heap);
      forceReconnect = true;
    }
    lastHeap = heap;
    heapTime = now;
  }

  byte stac = 0;
  if (apActive) {
#ifdef ESP8266
    stac = wifi_softap_get_station_num();
#else
    wifi_sta_list_t stationList;
    esp_wifi_ap_get_sta_list(&stationList);
    stac = stationList.num;
#endif
    if (stac != stacO) {
      stacO = stac;
      DEBUG_PRINT(F("Connected AP clients: "));
      DEBUG_PRINTLN(stac);
      if (!WLED_CONNECTED && WLED_WIFI_CONFIGURED) {        // trying to connect, but not connected
        if (stac)
          WiFi.disconnect();        // disable search so that AP can work
        else
          initConnection();         // restart search
      }
    }
  }
  if (forceReconnect) {
    Serial.print(F("Forcing reconnect."));
    initConnection();
    interfacesInited = false;
    forceReconnect = false;
    wasConnected = false;
    return;
  }
  if (!Network.isConnected()) {
    if (interfacesInited) {
      Serial.println(F("Disconnected!"));
#ifdef ARDUINO_M5Stick_C
    M5.Lcd.println(F("Net Disconnected!"));
#endif
      interfacesInited = false;
      initConnection();
    }
    //send improv failed 6 seconds after second init attempt (24 sec. after provisioning)
    if (improvActive > 2 && now - lastReconnectAttempt > 6000) {
      sendImprovStateResponse(0x03, true);
      improvActive = 2;
    }
    if (now - lastReconnectAttempt > ((stac) ? 300000 : 18000) && WLED_WIFI_CONFIGURED) {
      if (improvActive == 2) improvActive = 3;
      initConnection();
    }
    if (!apActive && now - lastReconnectAttempt > 12000 && (!wasConnected || apBehavior == AP_BEHAVIOR_NO_CONN))
      initAP();
  } else if (!interfacesInited) { //newly connected
    DEBUG_PRINTLN("");
    Serial.print(F("Connected! IP address: "));
    Serial.println(Network.localIP());
#ifdef ARDUINO_M5Stick_C
    M5.Lcd.println(F("Net Connected!"));
    M5.Lcd.print(F("IP: "));
    M5.Lcd.println(Network.localIP());
#endif

    if (improvActive) {
      if (improvError == 3) sendImprovStateResponse(0x00, true);
      sendImprovStateResponse(0x04);
      if (improvActive > 1) sendImprovRPCResponse(0x01);
    }
    initInterfaces();
    userConnected();
    usermods.connected();

    // shut down AP
    if (apBehavior != AP_BEHAVIOR_ALWAYS && apActive) {
      dnsServer.stop();
      WiFi.softAPdisconnect(true);
      apActive = false;
      Serial.println(F("Access point disabled."));
    }
  }
}

// If status LED pin is allocated for other uses, does nothing
// else blink at 1Hz when WLED_CONNECTED is false (no WiFi, ?? no Ethernet ??)
// else blink at 2Hz when MQTT is enabled but not connected
// else turn the status LED off
void WLED::handleStatusLED()
{
  #if STATUSLED
  static unsigned long ledStatusLastMillis = 0;
  static unsigned short ledStatusType = 0; // current status type - corresponds to number of blinks per second
  static bool ledStatusState = 0; // the current LED state

  if (pinManager.isPinAllocated(STATUSLED)) {
    return; //lower priority if something else uses the same pin
  }

  ledStatusType = WLED_CONNECTED ? 0 : 2;
  if (mqttEnabled && ledStatusType != 2) { // Wi-Fi takes precendence over MQTT
    ledStatusType = WLED_MQTT_CONNECTED ? 0 : 4;
  }
  if (ledStatusType) {
    if (millis() - ledStatusLastMillis >= (1000/ledStatusType)) {
      ledStatusLastMillis = millis();
      ledStatusState = ledStatusState ? 0 : 1;
      digitalWrite(STATUSLED, ledStatusState);
    }
  } else {
    #ifdef STATUSLEDINVERTED
      digitalWrite(STATUSLED, HIGH);
    #else
      digitalWrite(STATUSLED, LOW);
    #endif

  }
  #endif
}

=== ./wled.h ===

#ifndef WLED_H
#define WLED_H
/*
   Main sketch, global variable declarations
   @title WLED project sketch
   @version 0.13.3
   @author Christian Schwinne
 */

// version code in format yymmddb (b = daily build)
#define VERSION 2309021                // WLEDSR specific version
#define SR_VERSION_NAME "0.13.4"       // WLEDSR version name --> some files need manual updating: package.json, package-lock.json, improv.cpp

#define AC_VERSION 2208222             // AC WLED base version; last updated by PR #239 -> Merge AC-0.13.3 into dev
#define AC_VERSION_NAME "0.13.3"       // AC WLED base version name; last change 22.August 2022

//uncomment this if you have a "my_config.h" file you'd like to use
//#define WLED_USE_MY_CONFIG

// ESP8266-01 (blue) got too little storage space to work with WLED. 0.10.2 is the last release supporting this unit.

// ESP8266-01 (black) has 1MB flash and can thus fit the whole program, although OTA update is not possible. Use 1M(128K SPIFFS).
// 2-step OTA may still be possible: https://github.com/Aircoookie/WLED/issues/2040#issuecomment-981111096
// Uncomment some of the following lines to disable features:
// Alternatively, with platformio pass your chosen flags to your custom build target in platformio_override.ini

// You are required to disable over-the-air updates:
//#define WLED_DISABLE_OTA         // saves 14kb

#ifndef ESP32
  #error This sound reactive branch no longer supports the ESP8266. Please try https://github.com/atuline/WLED/tree/ESP8266.
#endif

// You need to choose some of these features to disable:
//#define WLED_DISABLE_ALEXA         // saves 11kb
#define WLED_DISABLE_BLYNK         // saves 6kb
#define WLED_DISABLE_HUESYNC       // saves 4kb
// #define WLED_DISABLE_INFRARED      // there is no pin left for this on ESP8266-01, saves 12kb
#ifndef WLED_DISABLE_MQTT
  #define WLED_ENABLE_MQTT         // saves 12kb
#endif
#ifndef WLED_DISABLE_ADALIGHT      // can be used to disable reading commands from serial RX pin (see issue #3128). 
  #define WLED_ENABLE_ADALIGHT     // disable saves 5Kb (uses GPIO3 (RX) for serial). Related serial protocols: Adalight/TPM2, Improv, Serial JSON 
#else
  #undef WLED_ENABLE_ADALIGHT      // disable has priority over enable
#endif

//#define WLED_ENABLE_DMX          // uses 3.5kb (use LEDPIN other than 2)
//#define WLED_ENABLE_JSONLIVE     // peek LED output via /json/live (WS binary peek is always enabled)
#ifndef WLED_DISABLE_LOXONE
  #define WLED_ENABLE_LOXONE       // uses 1.2kb
#endif
#ifndef WLED_DISABLE_WEBSOCKETS
  #define WLED_ENABLE_WEBSOCKETS
#endif
//#define WLED_DISABLE_SOUND       // saves 1kb

#define WLED_ENABLE_FS_EDITOR      // enable /edit page for editing FS content. Will also be disabled with OTA lock

// to toggle usb serial debug (un)comment the following line
//#define WLED_DEBUG

// filesystem specific debugging
//#define WLED_DEBUG_FS

#ifndef WLED_WATCHDOG_TIMEOUT
  // 3 seconds should be enough to detect a lockup
  // define WLED_WATCHDOG_TIMEOUT=0 to disable watchdog, default
  #define WLED_WATCHDOG_TIMEOUT 0
#endif

//optionally disable brownout detector on ESP32.
//This is generally a terrible idea, but improves boot success on boards with a 3.3v regulator + cap setup that can't provide 400mA peaks
//#define WLED_DISABLE_BROWNOUT_DET

// Library inclusions.
#include <Arduino.h>
#ifdef ESP8266
  #include <ESP8266WiFi.h>
  #include <ESP8266mDNS.h>
  #include <ESPAsyncTCP.h>
  #include <LittleFS.h>
  extern "C"
  {
  #include <user_interface.h>
  }
#else // ESP32
  #include <HardwareSerial.h>  // ensure we have the correct "Serial" on new MCUs (depends on ARDUINO_USB_MODE and ARDUINO_USB_CDC_ON_BOOT)
  #include <WiFi.h>
  #include <ETH.h>
  #include "esp_wifi.h"
  #include <ESPmDNS.h>
  #include <AsyncTCP.h>
  #if LOROL_LITTLEFS
    #ifndef CONFIG_LITTLEFS_FOR_IDF_3_2
      #define CONFIG_LITTLEFS_FOR_IDF_3_2
    #endif
    #include <LITTLEFS.h>
  #else
    #include <LittleFS.h>
  #endif
  #include "esp_task_wdt.h"
#endif
#include <Wire.h>
#include <SPI.h>

#include "src/dependencies/network/Network.h"

#ifdef WLED_USE_MY_CONFIG
  #include "my_config.h"
#endif

#include <ESPAsyncWebServer.h>
#include <EEPROM.h>
#include <WiFiUdp.h>
#include <DNSServer.h>
#ifndef WLED_DISABLE_OTA
  #define NO_OTA_PORT
  #include <ArduinoOTA.h>
#endif
#include <SPIFFSEditor.h>
#include "src/dependencies/time/TimeLib.h"
#include "src/dependencies/timezone/Timezone.h"
#include "src/dependencies/toki/Toki.h"

#ifndef WLED_DISABLE_ALEXA
  #define ESPALEXA_ASYNC
  #define ESPALEXA_NO_SUBPAGE
  #define ESPALEXA_MAXDEVICES 1
  // #define ESPALEXA_DEBUG
  #include "src/dependencies/espalexa/Espalexa.h"
#endif

#ifdef WLED_ENABLE_DMX
 #ifdef ESP8266
  #include "src/dependencies/dmx/ESPDMX.h"
 #else //ESP32
  #include "src/dependencies/dmx/SparkFunDMX.h"
 #endif
#endif

#include "src/dependencies/e131/ESPAsyncE131.h"
#include "src/dependencies/async-mqtt-client/AsyncMqttClient.h"

#define ARDUINOJSON_DECODE_UNICODE 0
#include "src/dependencies/json/AsyncJson-v6.h"
#include "src/dependencies/json/ArduinoJson-v6.h"

// ESP32-WROVER features SPI RAM (aka PSRAM) which can be allocated using ps_malloc()
// we can create custom PSRAMDynamicJsonDocument to use such feature (replacing DynamicJsonDocument)
// The following is a construct to enable code to compile without it.
// There is a code thet will still not use PSRAM though:
//    AsyncJsonResponse is a derived class that implements DynamicJsonDocument (AsyncJson-v6.h)
#if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_PSRAM)
struct PSRAM_Allocator {
  void* allocate(size_t size) {
    if (psramFound()) return ps_malloc(size); // use PSRAM if it exists
    else              return malloc(size);    // fallback
  }
  void deallocate(void* pointer) {
    free(pointer);
  }
};
using PSRAMDynamicJsonDocument = BasicJsonDocument<PSRAM_Allocator>;
#else
#define PSRAMDynamicJsonDocument DynamicJsonDocument
#endif

#include "fcn_declare.h"
#include "html_ui.h"
#include "html_settings.h"
#include "html_other.h"
#include "FX.h"
#include "ir_codes.h"
#include "const.h"
#include "NodeStruct.h"
#include "pin_manager.h"
#include "bus_manager.h"

#ifndef CLIENT_SSID
  #define CLIENT_SSID DEFAULT_CLIENT_SSID
#endif

#ifndef CLIENT_PASS
  #define CLIENT_PASS ""
#endif

#ifndef SPIFFS_EDITOR_AIRCOOOKIE
  #error You are not using the Aircoookie fork of the ESPAsyncWebserver library.\
  Using upstream puts your WiFi password at risk of being served by the filesystem.\
  Comment out this error message to build regardless.
#endif

// begin WLEDSR specific
#if defined(ARDUINO_ARCH_ESP32) && defined(LOROL_LITTLEFS) && !defined(LITTLEFS_threadsafe_SOFTHACK007)
  // the softhack007 fork is at https://github.com/softhack007/LITTLEFS-threadsafe.git#master
  #error You are not using the softhack007 fork of the LOROL LITTLEFS library.\
  Using upstream has a higher risks of ending up with a corrupted LittleFS filesystem on flash.\
  Comment out this error message to build regardlessly.
#endif
// end WLEDSR specific


#ifndef WLED_DISABLE_INFRARED
  #include <IRremoteESP8266.h>
  #include <IRrecv.h>
  #include <IRutils.h>
#endif

//Filesystem to use for preset and config files. SPIFFS or LittleFS on ESP8266, SPIFFS only on ESP32 (now using LITTLEFS port by lorol)
#ifdef ESP8266
  #define WLED_FS LittleFS
#else
  #if LOROL_LITTLEFS
    #define WLED_FS LITTLEFS
  #else
    #define WLED_FS LittleFS
  #endif
#endif

// GLOBAL VARIABLES
// both declared and defined in header (solution from http://www.keil.com/support/docs/1868.htm)
//
//e.g. byte test = 2 becomes WLED_GLOBAL byte test _INIT(2);
//     int arr[]{0,1,2} becomes WLED_GLOBAL int arr[] _INIT_N(({0,1,2}));

#ifndef WLED_DEFINE_GLOBAL_VARS
# define WLED_GLOBAL extern
# define _INIT(x)
# define _INIT_N(x)
#else
# define WLED_GLOBAL
# define _INIT(x) = x

//needed to ignore commas in array definitions
#define UNPACK( ... ) __VA_ARGS__
# define _INIT_N(x) UNPACK x
#endif

#define STRINGIFY(X) #X
#define TOSTRING(X) STRINGIFY(X)

#ifndef WLED_VERSION
  #define WLED_VERSION "dev"
#endif

// Global Variable definitions
WLED_GLOBAL char versionString[] _INIT(TOSTRING(WLED_VERSION));
WLED_GLOBAL char releaseString[] _INIT(TOSTRING(WLED_RELEASE_NAME)); //WLEDSR: to show on update page
#define WLED_CODENAME "Toki+SR"

// AP and OTA default passwords (for maximum security change them!)
WLED_GLOBAL char apPass[65]  _INIT(DEFAULT_AP_PASS);
WLED_GLOBAL char otaPass[33] _INIT(DEFAULT_OTA_PASS);

// Hardware and pin config
#ifndef BTNPIN
WLED_GLOBAL int8_t btnPin[WLED_MAX_BUTTONS] _INIT({0});
#else
WLED_GLOBAL int8_t btnPin[WLED_MAX_BUTTONS] _INIT({BTNPIN});
#endif
#ifndef RLYPIN
WLED_GLOBAL int8_t rlyPin _INIT(-1);
#else
WLED_GLOBAL int8_t rlyPin _INIT(RLYPIN);
#endif
//Relay mode (1 = active high, 0 = active low, flipped in cfg.json)
#ifndef RLYMDE
WLED_GLOBAL bool rlyMde _INIT(true);
#else
WLED_GLOBAL bool rlyMde _INIT(RLYMDE);
#endif
#ifndef IRPIN
WLED_GLOBAL int8_t irPin _INIT(-1);
#else
WLED_GLOBAL int8_t irPin _INIT(IRPIN);
#endif
// SR-WLED HARDWARE PIN CONFIGURATION
#ifndef AUDIOPIN
WLED_GLOBAL int8_t audioPin _INIT(36);
#else
WLED_GLOBAL int8_t audioPin _INIT(AUDIOPIN);
#endif
#ifndef DMENABLED // aka DOUT
WLED_GLOBAL uint8_t dmType _INIT(0);
#else
WLED_GLOBAL uint8_t dmType _INIT(DMENABLED);
#endif
#ifndef I2S_SDPIN // aka DOUT
WLED_GLOBAL int8_t i2ssdPin _INIT(32);
#else
WLED_GLOBAL int8_t i2ssdPin _INIT(I2S_SDPIN);
#endif
#ifndef I2S_WSPIN // aka LRCL
WLED_GLOBAL int8_t i2swsPin _INIT(15);
#else
WLED_GLOBAL int8_t i2swsPin _INIT(I2S_WSPIN);
#endif
#ifndef I2S_CKPIN // aka BCLK
WLED_GLOBAL int8_t i2sckPin _INIT(14);
#else
WLED_GLOBAL int8_t i2sckPin _INIT(I2S_CKPIN);
#endif
#ifndef MCLK_PIN
WLED_GLOBAL int8_t mclkPin  _INIT(0);
#else
WLED_GLOBAL int8_t mclkPin _INIT(MCLK_PIN);
#endif

//WLED_GLOBAL byte presetToApply _INIT(0);

WLED_GLOBAL char ntpServerName[33] _INIT("0.wled.pool.ntp.org");   // NTP server to use

// WiFi CONFIG (all these can be changed via web UI, no need to set them here)
WLED_GLOBAL char clientSSID[33] _INIT(CLIENT_SSID);
WLED_GLOBAL char clientPass[65] _INIT(CLIENT_PASS);
WLED_GLOBAL char cmDNS[33] _INIT("x");                             // mDNS address (placeholder, is replaced by wledXXXXXX.local)
WLED_GLOBAL char apSSID[33] _INIT("");                             // AP off by default (unless setup)
WLED_GLOBAL byte apChannel _INIT(1);                               // 2.4GHz WiFi AP channel (1-13)
WLED_GLOBAL byte apHide    _INIT(0);                               // hidden AP SSID
WLED_GLOBAL byte apBehavior _INIT(AP_BEHAVIOR_BOOT_NO_CONN);       // access point opens when no connection after boot by default
WLED_GLOBAL IPAddress staticIP      _INIT_N(((  0,   0,  0,  0))); // static IP of ESP
WLED_GLOBAL IPAddress staticGateway _INIT_N(((  0,   0,  0,  0))); // gateway (router) IP
WLED_GLOBAL IPAddress staticSubnet  _INIT_N(((255, 255, 255, 0))); // most common subnet in home networks
#if defined(ARDUINO_ARCH_ESP32) && !defined(ARDUINO_ESP32_PICO)    // WLEDSR: PICO board gets a bit warm with "disable wifi sleep"
WLED_GLOBAL bool noWifiSleep _INIT(true);                          // disabling modem sleep modes will increase heat output and power usage, but may help with connection issues
#else
WLED_GLOBAL bool noWifiSleep _INIT(false);
#endif

#ifdef WLED_USE_ETHERNET
  #ifdef WLED_ETH_DEFAULT                                          // default ethernet board type if specified
    WLED_GLOBAL int ethernetType _INIT(WLED_ETH_DEFAULT);          // ethernet board type
  #else
    WLED_GLOBAL int ethernetType _INIT(WLED_ETH_NONE);             // use none for ethernet board type if default not defined
  #endif
#endif

// LED CONFIG
WLED_GLOBAL bool turnOnAtBoot _INIT(true);                // turn on LEDs at power-up
WLED_GLOBAL byte bootPreset   _INIT(0);                   // save preset to load after power-up

//if true, a segment per bus will be created on boot and LED settings save
//if false, only one segment spanning the total LEDs is created,
//but not on LED settings save if there is more than one segment currently
WLED_GLOBAL bool autoSegments _INIT(false);
WLED_GLOBAL bool correctWB _INIT(false); //CCT color correction of RGB color
WLED_GLOBAL bool cctFromRgb _INIT(false); //CCT is calculated from RGB instead of using seg.cct

WLED_GLOBAL byte col[]    _INIT_N(({ 255, 160, 0, 0 }));  // current RGB(W) primary color. col[] should be updated if you want to change the color.
WLED_GLOBAL byte colSec[] _INIT_N(({ 0, 0, 0, 0 }));      // current RGB(W) secondary color
WLED_GLOBAL byte briS     _INIT(128);                     // default brightness

//WLEDSR
WLED_GLOBAL byte inputLevelS    _INIT(128);         // WLEDSR default inputLevel
#if !defined(SR_SQUELCH)
WLED_GLOBAL byte soundSquelch   _INIT(10);          // default squelch value for volume reactive routines
WLED_GLOBAL byte soundAgc       _INIT(0);           // default Automagic gain control
#else
WLED_GLOBAL byte soundSquelch   _INIT(SR_SQUELCH);  // default squelch value
WLED_GLOBAL byte soundAgc       _INIT(2);           // squelch was provided - we can enable AGC by default
#endif
#if !defined(SR_GAIN)
WLED_GLOBAL byte sampleGain     _INIT(40);          // default sample gain
#else
WLED_GLOBAL byte sampleGain     _INIT(SR_GAIN);     // default sample gain
#endif

WLED_GLOBAL byte nightlightTargetBri _INIT(0);      // brightness after nightlight is over
WLED_GLOBAL byte nightlightDelayMins _INIT(60);
WLED_GLOBAL byte nightlightMode      _INIT(NL_MODE_FADE); // See const.h for available modes. Was nightlightFade
WLED_GLOBAL bool fadeTransition      _INIT(true);   // enable crossfading color transition
WLED_GLOBAL uint16_t transitionDelay _INIT(750);    // default crossfade duration in ms

WLED_GLOBAL byte briMultiplier _INIT(100);          // % of brightness to set (to limit power, if you set it to 50 and set bri to 255, actual brightness will be 127)

// User Interface CONFIG
#ifndef SERVERNAME
WLED_GLOBAL char serverDescription[33] _INIT("WLED-SoundReactive");  // Name of module - use default
#else
WLED_GLOBAL char serverDescription[33] _INIT(SERVERNAME);  // use predefined name
#endif
WLED_GLOBAL bool syncToggleReceive     _INIT(false);   // UIs which only have a single button for sync should toggle send+receive if this is true, only send otherwise

// Sync CONFIG
WLED_GLOBAL NodesMap Nodes;
WLED_GLOBAL bool nodeListEnabled _INIT(false);
WLED_GLOBAL bool nodeBroadcastEnabled _INIT(false);

WLED_GLOBAL byte buttonType[WLED_MAX_BUTTONS]  _INIT({BTN_TYPE_PUSH});
#if defined(IRTYPE) && defined(IRPIN)
WLED_GLOBAL byte irEnabled      _INIT(IRTYPE); // Infrared receiver
#else
WLED_GLOBAL byte irEnabled      _INIT(0);     // Infrared receiver disabled
#endif
WLED_GLOBAL bool irApplyToAllSelected _INIT(true); //apply IR to all selected segments

WLED_GLOBAL uint16_t udpPort    _INIT(21324); // WLED notifier default port
WLED_GLOBAL uint16_t udpPort2   _INIT(65506); // WLED notifier supplemental port
WLED_GLOBAL uint16_t udpRgbPort _INIT(19446); // Hyperion port

WLED_GLOBAL uint8_t syncGroups    _INIT(0x01);                    // sync groups this instance syncs (bit mapped)
WLED_GLOBAL uint8_t receiveGroups _INIT(0x01);                    // sync receive groups this instance belongs to (bit mapped)
WLED_GLOBAL bool receiveNotificationBrightness _INIT(true);       // apply brightness from incoming notifications
WLED_GLOBAL bool receiveNotificationColor      _INIT(true);       // apply color
WLED_GLOBAL bool receiveNotificationEffects    _INIT(true);       // apply effects setup
WLED_GLOBAL bool receiveSegmentOptions         _INIT(false);      // apply segment options
WLED_GLOBAL bool receiveSegmentBounds          _INIT(false);      // apply segment bounds (start, stop, offset)
WLED_GLOBAL bool notifyDirect _INIT(false);                       // send notification if change via UI or HTTP API
WLED_GLOBAL bool notifyButton _INIT(false);                       // send if updated by button or infrared remote
WLED_GLOBAL bool notifyAlexa  _INIT(false);                       // send notification if updated via Alexa
WLED_GLOBAL bool notifyMacro  _INIT(false);                       // send notification for macro
WLED_GLOBAL bool notifyHue    _INIT(false);                       // send notification if Hue light changes
WLED_GLOBAL bool notifyTwice  _INIT(false);                       // notifications use UDP: enable if devices don't sync reliably

WLED_GLOBAL bool alexaEnabled _INIT(false);                       // enable device discovery by Amazon Echo
WLED_GLOBAL char alexaInvocationName[33] _INIT("Light");          // speech control name of device. Choose something voice-to-text can understand

WLED_GLOBAL uint16_t realtimeTimeoutMs _INIT(2500);               // ms timeout of realtime mode before returning to normal mode
WLED_GLOBAL int arlsOffset _INIT(0);                              // realtime LED offset
WLED_GLOBAL bool receiveDirect _INIT(true);                       // receive UDP realtime
WLED_GLOBAL bool arlsDisableGammaCorrection _INIT(true);          // activate if gamma correction is handled by the source
WLED_GLOBAL bool arlsForceMaxBri _INIT(false);                    // enable to force max brightness if source has very dark colors that would be black

#ifdef WLED_ENABLE_DMX
 #ifdef ESP8266
  WLED_GLOBAL DMXESPSerial dmx;
 #else //ESP32
  WLED_GLOBAL SparkFunDMX dmx;
 #endif
WLED_GLOBAL uint16_t e131ProxyUniverse _INIT(0);                  // output this E1.31 (sACN) / ArtNet universe via MAX485 (0 = disabled)
#endif
WLED_GLOBAL uint16_t e131Universe _INIT(1);                       // settings for E1.31 (sACN) protocol (only DMX_MODE_MULTIPLE_* can span over consequtive universes)
WLED_GLOBAL uint16_t e131Port _INIT(5568);                        // DMX in port. E1.31 default is 5568, Art-Net is 6454
WLED_GLOBAL byte DMXMode _INIT(DMX_MODE_MULTIPLE_RGB);            // DMX mode (s.a.)
WLED_GLOBAL uint16_t DMXAddress _INIT(1);                         // DMX start address of fixture, a.k.a. first Channel [for E1.31 (sACN) protocol]
WLED_GLOBAL byte DMXOldDimmer _INIT(0);                           // only update brightness on change
WLED_GLOBAL byte e131LastSequenceNumber[E131_MAX_UNIVERSE_COUNT]; // to detect packet loss
WLED_GLOBAL bool e131Multicast _INIT(false);                      // multicast or unicast
WLED_GLOBAL bool e131SkipOutOfSequence _INIT(false);              // freeze instead of flickering

WLED_GLOBAL bool mqttEnabled _INIT(false);
WLED_GLOBAL char mqttDeviceTopic[33] _INIT("");            // main MQTT topic (individual per device, default is wled/mac)
WLED_GLOBAL char mqttGroupTopic[33] _INIT("wled/all");     // second MQTT topic (for example to group devices)
WLED_GLOBAL char mqttServer[33] _INIT("");                 // both domains and IPs should work (no SSL)
WLED_GLOBAL char mqttUser[41] _INIT("");                   // optional: username for MQTT auth
WLED_GLOBAL char mqttPass[65] _INIT("");                   // optional: password for MQTT auth
WLED_GLOBAL char mqttClientID[41] _INIT("");               // override the client ID
WLED_GLOBAL uint16_t mqttPort _INIT(1883);

#ifndef WLED_DISABLE_HUESYNC
WLED_GLOBAL bool huePollingEnabled _INIT(false);           // poll hue bridge for light state
WLED_GLOBAL uint16_t huePollIntervalMs _INIT(2500);        // low values (< 1sec) may cause lag but offer quicker response
WLED_GLOBAL char hueApiKey[47] _INIT("api");               // key token will be obtained from bridge
WLED_GLOBAL byte huePollLightId _INIT(1);                  // ID of hue lamp to sync to. Find the ID in the hue app ("about" section)
WLED_GLOBAL IPAddress hueIP _INIT_N(((0, 0, 0, 0))); // IP address of the bridge
WLED_GLOBAL bool hueApplyOnOff _INIT(true);
WLED_GLOBAL bool hueApplyBri _INIT(true);
WLED_GLOBAL bool hueApplyColor _INIT(true);
#endif

WLED_GLOBAL uint16_t serialBaud _INIT(1152); // serial baud rate, multiply by 100

// Time CONFIG
WLED_GLOBAL bool ntpEnabled _INIT(false);    // get internet time. Only required if you use clock overlays or time-activated macros
WLED_GLOBAL bool useAMPM _INIT(false);       // 12h/24h clock format
WLED_GLOBAL byte currentTimezone _INIT(0);   // Timezone ID. Refer to timezones array in wled10_ntp.ino
WLED_GLOBAL int utcOffsetSecs _INIT(0);      // Seconds to offset from UTC before timzone calculation

WLED_GLOBAL byte overlayCurrent _INIT(0);    // 0: no overlay 1: analog clock 2: was single-digit clock 3: was cronixie
WLED_GLOBAL byte overlayMin _INIT(0), overlayMax _INIT(DEFAULT_LED_COUNT - 1);   // boundaries of overlay mode

WLED_GLOBAL byte analogClock12pixel _INIT(0);               // The pixel in your strip where "midnight" would be
WLED_GLOBAL bool analogClockSecondsTrail _INIT(false);      // Display seconds as trail of LEDs instead of a single pixel
WLED_GLOBAL bool analogClock5MinuteMarks _INIT(false);      // Light pixels at every 5-minute position

WLED_GLOBAL bool countdownMode _INIT(false);                         // Clock will count down towards date
WLED_GLOBAL byte countdownYear _INIT(20), countdownMonth _INIT(1);   // Countdown target date, year is last two digits
WLED_GLOBAL byte countdownDay  _INIT(1) , countdownHour  _INIT(0);
WLED_GLOBAL byte countdownMin  _INIT(0) , countdownSec   _INIT(0);

WLED_GLOBAL byte macroNl   _INIT(0);        // after nightlight delay over
WLED_GLOBAL byte macroCountdown _INIT(0);
WLED_GLOBAL byte macroAlexaOn _INIT(0), macroAlexaOff _INIT(0);
WLED_GLOBAL byte macroButton[WLED_MAX_BUTTONS]        _INIT({0});
WLED_GLOBAL byte macroLongPress[WLED_MAX_BUTTONS]     _INIT({0});
WLED_GLOBAL byte macroDoublePress[WLED_MAX_BUTTONS]   _INIT({0});

// Security CONFIG
WLED_GLOBAL bool otaLock     _INIT(false);  // prevents OTA firmware updates without password. ALWAYS enable if system exposed to any public networks
WLED_GLOBAL bool wifiLock    _INIT(false);  // prevents access to WiFi settings when OTA lock is enabled
WLED_GLOBAL bool aOtaEnabled _INIT(true);   // ArduinoOTA allows easy updates directly from the IDE. Careful, it does not auto-disable when OTA lock is on

WLED_GLOBAL uint16_t userVar0 _INIT(0), userVar1 _INIT(0); //available for use in usermod

#ifdef WLED_ENABLE_DMX
  // dmx CONFIG
  WLED_GLOBAL byte DMXChannels _INIT(7);        // number of channels per fixture
  WLED_GLOBAL byte DMXFixtureMap[15] _INIT_N(({ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }));
  // assigns the different channels to different functions. See wled21_dmx.ino for more information.
  WLED_GLOBAL uint16_t DMXGap _INIT(10);          // gap between the fixtures. makes addressing easier because you don't have to memorize odd numbers when climbing up onto a rig.
  WLED_GLOBAL uint16_t DMXStart _INIT(10);        // start address of the first fixture
  WLED_GLOBAL uint16_t DMXStartLED _INIT(0);      // LED from which DMX fixtures start
#endif

// internal global variable declarations
// wifi
WLED_GLOBAL bool apActive _INIT(false);
WLED_GLOBAL bool forceReconnect _INIT(false);
WLED_GLOBAL uint32_t lastReconnectAttempt _INIT(0);
WLED_GLOBAL bool interfacesInited _INIT(false);
WLED_GLOBAL bool wasConnected _INIT(false);

// color
WLED_GLOBAL byte lastRandomIndex _INIT(0);        // used to save last random color so the new one is not the same

// transitions
WLED_GLOBAL bool transitionActive _INIT(false);
WLED_GLOBAL uint16_t transitionDelayDefault _INIT(transitionDelay);
WLED_GLOBAL uint16_t transitionDelayTemp _INIT(transitionDelay);
WLED_GLOBAL unsigned long transitionStartTime;
WLED_GLOBAL float tperLast _INIT(0);        // crossfade transition progress, 0.0f - 1.0f
WLED_GLOBAL bool jsonTransitionOnce _INIT(false);

// nightlight
WLED_GLOBAL bool nightlightActive _INIT(false);
WLED_GLOBAL bool nightlightActiveOld _INIT(false);
WLED_GLOBAL uint32_t nightlightDelayMs _INIT(10);
WLED_GLOBAL byte nightlightDelayMinsDefault _INIT(nightlightDelayMins);
WLED_GLOBAL unsigned long nightlightStartTime;
WLED_GLOBAL byte briNlT _INIT(0);                     // current nightlight brightness
WLED_GLOBAL byte colNlT[] _INIT_N(({ 0, 0, 0, 0 }));        // current nightlight color

// brightness
WLED_GLOBAL unsigned long lastOnTime _INIT(0);
WLED_GLOBAL bool offMode _INIT(!turnOnAtBoot);
WLED_GLOBAL byte bri _INIT(briS);
WLED_GLOBAL byte briOld _INIT(0);
WLED_GLOBAL byte briT _INIT(0);
WLED_GLOBAL byte briIT _INIT(0);
WLED_GLOBAL byte briLast _INIT(128);          // brightness before turned off. Used for toggle function
WLED_GLOBAL byte whiteLast _INIT(128);        // white channel before turned off. Used for toggle function

// WLEDSR
WLED_GLOBAL byte inputLevel _INIT(inputLevelS);          // inputLevel (set by sliderinputLevel)

// button
WLED_GLOBAL bool buttonPublishMqtt                            _INIT(false);
WLED_GLOBAL bool buttonPressedBefore[WLED_MAX_BUTTONS]        _INIT({false});
WLED_GLOBAL bool buttonLongPressed[WLED_MAX_BUTTONS]          _INIT({false});
WLED_GLOBAL unsigned long buttonPressedTime[WLED_MAX_BUTTONS] _INIT({0});
WLED_GLOBAL unsigned long buttonWaitTime[WLED_MAX_BUTTONS]    _INIT({0});
WLED_GLOBAL byte touchThreshold                               _INIT(TOUCH_THRESHOLD);

// notifications
WLED_GLOBAL bool notifyDirectDefault _INIT(notifyDirect);
WLED_GLOBAL bool receiveNotifications _INIT(true);
WLED_GLOBAL unsigned long notificationSentTime _INIT(0);
WLED_GLOBAL byte notificationSentCallMode _INIT(CALL_MODE_INIT);
WLED_GLOBAL bool notificationTwoRequired _INIT(false);

// effects
WLED_GLOBAL byte effectCurrent _INIT(0);
WLED_GLOBAL byte effectSpeed _INIT(128);
WLED_GLOBAL byte effectIntensity _INIT(128);
WLED_GLOBAL byte effectCustom1 _INIT(128);
WLED_GLOBAL byte effectCustom2 _INIT(128);
WLED_GLOBAL byte effectCustom3 _INIT(128);
WLED_GLOBAL byte effectPalette _INIT(0);
WLED_GLOBAL bool stateChanged _INIT(false);

//  0th bit - transmit enabled/disabled. 1st bit - receive enabled/disabled
WLED_GLOBAL byte audioSyncEnabled _INIT(0);
WLED_GLOBAL uint16_t audioSyncPort _INIT(11988);

// network
WLED_GLOBAL bool udpConnected _INIT(false), udp2Connected _INIT(false), udpRgbConnected _INIT(false), udpSyncConnected _INIT(false);

// ui style
WLED_GLOBAL bool showWelcomePage _INIT(false);

// hue
WLED_GLOBAL byte hueError _INIT(HUE_ERROR_INACTIVE);
// WLED_GLOBAL uint16_t hueFailCount _INIT(0);
WLED_GLOBAL float hueXLast _INIT(0), hueYLast _INIT(0);
WLED_GLOBAL uint16_t hueHueLast _INIT(0), hueCtLast _INIT(0);
WLED_GLOBAL byte hueSatLast _INIT(0), hueBriLast _INIT(0);
WLED_GLOBAL unsigned long hueLastRequestSent _INIT(0);
WLED_GLOBAL bool hueAuthRequired _INIT(false);
WLED_GLOBAL bool hueReceived _INIT(false);
WLED_GLOBAL bool hueStoreAllowed _INIT(false), hueNewKey _INIT(false);

// countdown
WLED_GLOBAL unsigned long countdownTime _INIT(1514764800L);
WLED_GLOBAL bool countdownOverTriggered _INIT(true);

//timer
WLED_GLOBAL byte lastTimerMinute  _INIT(0);
WLED_GLOBAL byte timerHours[]     _INIT_N(({ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }));
WLED_GLOBAL int8_t timerMinutes[] _INIT_N(({ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }));
WLED_GLOBAL byte timerMacro[]     _INIT_N(({ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }));
//weekdays to activate on, bit pattern of arr elem: 0b11111111: sun,sat,fri,thu,wed,tue,mon,validity
WLED_GLOBAL byte timerWeekday[]   _INIT_N(({ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }));
//upper 4 bits start, lower 4 bits end month (default 28: start month 1 and end month 12)
WLED_GLOBAL byte timerMonth[]     _INIT_N(({28,28,28,28,28,28,28,28}));
WLED_GLOBAL byte timerDay[]       _INIT_N(({1,1,1,1,1,1,1,1}));
WLED_GLOBAL byte timerDayEnd[]		_INIT_N(({31,31,31,31,31,31,31,31}));

// blynk
WLED_GLOBAL bool blynkEnabled _INIT(false);

//improv
WLED_GLOBAL byte improvActive _INIT(0); //0: no improv packet received, 1: improv active, 2: provisioning
WLED_GLOBAL byte improvError _INIT(0);

//playlists
WLED_GLOBAL int16_t currentPlaylist _INIT(-1);
//still used for "PL=~" HTTP API command
WLED_GLOBAL byte presetCycCurr _INIT(0);
WLED_GLOBAL byte presetCycMin _INIT(1);
WLED_GLOBAL byte presetCycMax _INIT(5);

// realtime
WLED_GLOBAL byte realtimeMode _INIT(REALTIME_MODE_INACTIVE);
WLED_GLOBAL byte realtimeOverride _INIT(REALTIME_OVERRIDE_NONE);
WLED_GLOBAL IPAddress realtimeIP _INIT_N(((0, 0, 0, 0)));
WLED_GLOBAL unsigned long realtimeTimeout _INIT(0);
WLED_GLOBAL uint8_t tpmPacketCount _INIT(0);
WLED_GLOBAL uint16_t tpmPayloadFrameSize _INIT(0);
WLED_GLOBAL bool useMainSegmentOnly _INIT(false);

// mqtt
WLED_GLOBAL unsigned long lastMqttReconnectAttempt _INIT(0);
WLED_GLOBAL unsigned long lastInterfaceUpdate _INIT(0);
WLED_GLOBAL byte interfaceUpdateCallMode _INIT(CALL_MODE_INIT);
WLED_GLOBAL char mqttStatusTopic[40] _INIT("");        // this must be global because of async handlers

// alexa udp
WLED_GLOBAL String escapedMac;
#ifndef WLED_DISABLE_ALEXA
  WLED_GLOBAL Espalexa espalexa;
  WLED_GLOBAL EspalexaDevice* espalexaDevice;
#endif

// dns server
WLED_GLOBAL DNSServer dnsServer;

// network time
WLED_GLOBAL bool ntpConnected _INIT(false);
WLED_GLOBAL time_t localTime _INIT(0);
WLED_GLOBAL unsigned long ntpLastSyncTime _INIT(999000000L);
WLED_GLOBAL unsigned long ntpPacketSentTime _INIT(999000000L);
WLED_GLOBAL IPAddress ntpServerIP;
WLED_GLOBAL uint16_t ntpLocalPort _INIT(2390);
WLED_GLOBAL uint16_t rolloverMillis _INIT(0);
WLED_GLOBAL float longitude _INIT(0.0);
WLED_GLOBAL float latitude _INIT(0.0);
WLED_GLOBAL time_t sunrise _INIT(0);
WLED_GLOBAL time_t sunset _INIT(0);
WLED_GLOBAL Toki toki _INIT(Toki());

// Temp buffer
WLED_GLOBAL char* obuf;
WLED_GLOBAL uint16_t olen _INIT(0);

// General filesystem
WLED_GLOBAL size_t fsBytesUsed _INIT(0);
WLED_GLOBAL size_t fsBytesTotal _INIT(0);
WLED_GLOBAL unsigned long presetsModifiedTime _INIT(0L);
WLED_GLOBAL JsonDocument* fileDoc;
WLED_GLOBAL bool doCloseFile _INIT(false);

// presets
WLED_GLOBAL byte currentPreset _INIT(0);

WLED_GLOBAL byte errorFlag _INIT(0);

WLED_GLOBAL String messageHead, messageSub;
WLED_GLOBAL byte optionType;

WLED_GLOBAL bool doReboot _INIT(false);        // flag to initiate reboot from async handlers
WLED_GLOBAL bool doPublishMqtt _INIT(false);

// server library objects
WLED_GLOBAL AsyncWebServer server _INIT_N(((80)));
#ifdef WLED_ENABLE_WEBSOCKETS
WLED_GLOBAL AsyncWebSocket ws _INIT_N((("/ws")));
#endif
WLED_GLOBAL AsyncClient* hueClient _INIT(NULL);
WLED_GLOBAL AsyncMqttClient* mqtt _INIT(NULL);

// udp interface objects
WLED_GLOBAL WiFiUDP notifierUdp, rgbUdp, notifier2Udp;
WLED_GLOBAL WiFiUDP ntpUdp;
WLED_GLOBAL WiFiUDP fftUdp;
WLED_GLOBAL ESPAsyncE131 e131 _INIT_N(((handleE131Packet)));
WLED_GLOBAL ESPAsyncE131 ddp  _INIT_N(((handleE131Packet)));
WLED_GLOBAL bool e131NewData _INIT(false);

// led fx library object
WLED_GLOBAL BusManager busses _INIT(BusManager());
WLED_GLOBAL WS2812FX strip _INIT(WS2812FX());
WLED_GLOBAL BusConfig* busConfigs[WLED_MAX_BUSSES] _INIT({nullptr}); //temporary, to remember values from network callback until after
WLED_GLOBAL bool doInitBusses _INIT(false);
WLED_GLOBAL int8_t loadLedmap _INIT(-1);

// Usermod manager
WLED_GLOBAL UsermodManager usermods _INIT(UsermodManager());

#ifndef WLED_USE_DYNAMIC_JSON
// global ArduinoJson buffer
WLED_GLOBAL StaticJsonDocument<JSON_BUFFER_SIZE> doc;
#endif
WLED_GLOBAL volatile uint8_t jsonBufferLock _INIT(0);

WLED_GLOBAL TaskHandle_t FFT_Task; //WLEDSR: Moved from audio_reactive.h to global as OTA updates sets it to idle

// enable additional debug output
#ifdef WLED_DEBUG
  #ifndef ESP8266
  #include <rom/rtc.h>
  #endif
  #define DEBUG_PRINT(x) Serial.print(x)
  #define DEBUG_PRINTLN(x) Serial.println(x)
  #define DEBUG_PRINTF(x...) Serial.printf(x)
#else
  #define DEBUG_PRINT(x)
  #define DEBUG_PRINTLN(x)
  #define DEBUG_PRINTF(x...)
#endif

#ifdef WLED_DEBUG_FS
  #define DEBUGFS_PRINT(x) Serial.print(x)
  #define DEBUGFS_PRINTLN(x) Serial.println(x)
  #define DEBUGFS_PRINTF(x...) Serial.printf(x)
#else
  #define DEBUGFS_PRINT(x)
  #define DEBUGFS_PRINTLN(x)
  #define DEBUGFS_PRINTF(x...)
#endif

// debug macro variable definitions
#ifdef WLED_DEBUG
  WLED_GLOBAL unsigned long debugTime _INIT(0);
  WLED_GLOBAL int lastWifiState _INIT(3);
  WLED_GLOBAL unsigned long wifiStateChangedTime _INIT(0);
  WLED_GLOBAL unsigned long loops _INIT(0);
#endif

#ifdef ARDUINO_ARCH_ESP32
  #define WLED_CONNECTED (WiFi.status() == WL_CONNECTED || ETH.localIP()[0] != 0)
#else
  #define WLED_CONNECTED (WiFi.status() == WL_CONNECTED)
#endif
#define WLED_WIFI_CONFIGURED (strlen(clientSSID) >= 1 && strcmp(clientSSID, DEFAULT_CLIENT_SSID) != 0)
#define WLED_MQTT_CONNECTED (mqtt != nullptr && mqtt->connected())

//macro to convert F to const (needed by some usermods)
#define SET_F(x)  (const char*)F(x)

//color mangling macros
#define RGBW32(r,g,b,w) (uint32_t((byte(w) << 24) | (byte(r) << 16) | (byte(g) << 8) | (byte(b))))
#define R(c) (byte((c) >> 16))
#define G(c) (byte((c) >> 8))
#define B(c) (byte(c))
#define W(c) (byte((c) >> 24))

// append new c string to temp buffer efficiently
bool oappend(const char* txt);
// append new number to temp buffer efficiently
bool oappendi(int i);

class WLED {
public:
  WLED();
  static WLED& instance()
  {
    static WLED instance;
    return instance;
  }

  // boot starts here
  void setup();

  void loop();
  void reset();

  void beginStrip();
  void handleConnection();
  bool initEthernet(); // result is informational
  void initAP(bool resetAP = false);
  void initConnection();
  void initInterfaces();
  void handleStatusLED();
  void enableWatchdog();
  void disableWatchdog();
};
#endif        // WLED_H

=== ./wled_eeprom.cpp ===

#include <EEPROM.h>
#include "wled.h"

/*
 * DEPRECATED, do not use for new settings
 * Only used to restore config from pre-0.11 installations using the deEEP() methods
 *
 * Methods to handle saving and loading to non-volatile memory
 * EEPROM Map: https://github.com/Aircoookie/WLED/wiki/EEPROM-Map
 */

//eeprom Version code, enables default settings instead of 0 init on update
#define EEPVER 22
#define EEPSIZE 3300  //Maximum is 4096
//0 -> old version, default
//1 -> 0.4p 1711272 and up
//2 -> 0.4p 1711302 and up
//3 -> 0.4  1712121 and up
//4 -> 0.5.0 and up
//5 -> 0.5.1 and up
//6 -> 0.6.0 and up
//7 -> 0.7.1 and up
//8 -> 0.8.0-a and up
//9 -> 0.8.0
//10-> 0.8.2
//11-> 0.8.5-dev #mqttauth @TimothyBrown
//12-> 0.8.7-dev
//13-> 0.9.0-dev
//14-> 0.9.0-b1
//15-> 0.9.0-b3
//16-> 0.9.1
//17-> 0.9.1-dmx
//18-> 0.9.1-e131
//19-> 0.9.1n
//20-> 0.9.1p
//21-> 0.10.1p
//22-> 2009260

#define EEP_AUDIO 3072         // Start of Audio Reactive EEPROM Settings - END 3299
/*
 * Erase all (pre 0.11) configuration data on factory reset
 */
void clearEEPROM()
{
  EEPROM.begin(EEPSIZE);
  for (int i = 0; i < EEPSIZE; i++)
  {
    EEPROM.write(i, 0);
  }
  EEPROM.end();
}


void readStringFromEEPROM(uint16_t pos, char* str, uint16_t len)
{
  for (int i = 0; i < len; ++i)
  {
    str[i] = EEPROM.read(pos + i);
    if (str[i] == 0) return;
  }
  str[len] = 0; //make sure every string is properly terminated. str must be at least len +1 big.
}

/*
 * Read all configuration from flash
 */
void loadSettingsFromEEPROM()
{
  if (EEPROM.read(233) != 233) //first boot/reset to default
  {
    DEBUG_PRINTLN(F("EEPROM settings invalid, using defaults..."));
    return;
  }
  int lastEEPROMversion = EEPROM.read(377); //last EEPROM version before update


  readStringFromEEPROM(  0, clientSSID, 32);
  readStringFromEEPROM( 32, clientPass, 64);
  readStringFromEEPROM( 96,      cmDNS, 32);
  readStringFromEEPROM(128,     apSSID, 32);
  readStringFromEEPROM(160,     apPass, 64);

  nightlightDelayMinsDefault = EEPROM.read(224);
  nightlightDelayMins = nightlightDelayMinsDefault;
  nightlightMode = EEPROM.read(225);
  notifyDirectDefault = EEPROM.read(226);
  notifyDirect = notifyDirectDefault;

  apChannel = EEPROM.read(227);
  if (apChannel > 13 || apChannel < 1) apChannel = 1;
  apHide = EEPROM.read(228);
  if (apHide > 1) apHide = 1;
  uint16_t length = EEPROM.read(229) + ((EEPROM.read(398) << 8) & 0xFF00); //was ledCount
  if (length > MAX_LEDS || length == 0) length = 30;
  uint8_t pins[5] = {2, 255, 255, 255, 255};
  uint8_t colorOrder = COL_ORDER_GRB;
  if (lastEEPROMversion > 9) colorOrder = EEPROM.read(383);
  if (colorOrder > COL_ORDER_GBR) colorOrder = COL_ORDER_GRB;
  bool skipFirst = EEPROM.read(2204);
  bool reversed = EEPROM.read(252);
  BusConfig bc = BusConfig(EEPROM.read(372) ? TYPE_SK6812_RGBW : TYPE_WS2812_RGB, pins, 0, length, colorOrder, reversed, skipFirst);
  busses.add(bc);

  notifyButton = EEPROM.read(230);
  notifyTwice = EEPROM.read(231);
  buttonType[0] = EEPROM.read(232) ? BTN_TYPE_PUSH : BTN_TYPE_NONE;

  staticIP[0] = EEPROM.read(234);
  staticIP[1] = EEPROM.read(235);
  staticIP[2] = EEPROM.read(236);
  staticIP[3] = EEPROM.read(237);
  staticGateway[0] = EEPROM.read(238);
  staticGateway[1] = EEPROM.read(239);
  staticGateway[2] = EEPROM.read(240);
  staticGateway[3] = EEPROM.read(241);
  staticSubnet[0] = EEPROM.read(242);
  staticSubnet[1] = EEPROM.read(243);
  staticSubnet[2] = EEPROM.read(244);
  staticSubnet[3] = EEPROM.read(245);

  briS = EEPROM.read(249); bri = briS;
  if (!EEPROM.read(369))
  {
    bri = 0; briLast = briS;
  }
  receiveNotificationBrightness = EEPROM.read(250);
  fadeTransition = EEPROM.read(251);
  transitionDelayDefault = EEPROM.read(253) + ((EEPROM.read(254) << 8) & 0xFF00);
  transitionDelay = transitionDelayDefault;
  briMultiplier = EEPROM.read(255);

  readStringFromEEPROM(256, otaPass, 32);

  nightlightTargetBri = EEPROM.read(288);
  otaLock = EEPROM.read(289);
  udpPort = EEPROM.read(290) + ((EEPROM.read(291) << 8) & 0xFF00);

  readStringFromEEPROM(292, serverDescription, 32);

  ntpEnabled = EEPROM.read(327);
  currentTimezone = EEPROM.read(328);
  useAMPM = EEPROM.read(329);
  strip.gammaCorrectBri = EEPROM.read(330);
  strip.gammaCorrectCol = EEPROM.read(331);
  overlayCurrent = EEPROM.read(332);

  alexaEnabled = EEPROM.read(333);

  readStringFromEEPROM(334, alexaInvocationName, 32);

  notifyAlexa = EEPROM.read(366);
  arlsOffset = EEPROM.read(368);
  if (!EEPROM.read(367)) arlsOffset = -arlsOffset;
  turnOnAtBoot = EEPROM.read(369);
  //strip.isRgbw = EEPROM.read(372);
  //374 - strip.paletteFade

  apBehavior = EEPROM.read(376);

  //377 = lastEEPROMversion
  if (lastEEPROMversion > 3) {
    aOtaEnabled = EEPROM.read(390);
    receiveNotificationColor = EEPROM.read(391);
    receiveNotificationEffects = EEPROM.read(392);
  }
  receiveNotifications = (receiveNotificationBrightness || receiveNotificationColor || receiveNotificationEffects);

  if (lastEEPROMversion > 4) {
    #ifndef WLED_DISABLE_HUESYNC
    huePollingEnabled = EEPROM.read(2048);
    //hueUpdatingEnabled = EEPROM.read(2049);
    for (int i = 2050; i < 2054; ++i)
    {
      hueIP[i-2050] = EEPROM.read(i);
    }

    readStringFromEEPROM(2054, hueApiKey, 46);

    huePollIntervalMs = EEPROM.read(2100) + ((EEPROM.read(2101) << 8) & 0xFF00);
    notifyHue = EEPROM.read(2102);
    hueApplyOnOff = EEPROM.read(2103);
    hueApplyBri = EEPROM.read(2104);
    hueApplyColor = EEPROM.read(2105);
    huePollLightId = EEPROM.read(2106);
    #endif
  }
  if (lastEEPROMversion > 5) {
    overlayMin = EEPROM.read(2150);
    overlayMax = EEPROM.read(2151);
    analogClock12pixel = EEPROM.read(2152);
    analogClock5MinuteMarks = EEPROM.read(2153);
    analogClockSecondsTrail = EEPROM.read(2154);
    countdownMode = EEPROM.read(2155);
    countdownYear = EEPROM.read(2156);
    countdownMonth = EEPROM.read(2157);
    countdownDay = EEPROM.read(2158);
    countdownHour = EEPROM.read(2159);
    countdownMin = EEPROM.read(2160);
    countdownSec = EEPROM.read(2161);
    setCountdown();

    //macroBoot = EEPROM.read(2175);
    macroAlexaOn = EEPROM.read(2176);
    macroAlexaOff = EEPROM.read(2177);
    macroButton[0] = EEPROM.read(2178);
    macroLongPress[0] = EEPROM.read(2179);
    macroCountdown = EEPROM.read(2180);
    macroNl = EEPROM.read(2181);
    macroDoublePress[0] = EEPROM.read(2182);
    if (macroDoublePress[0] > 16) macroDoublePress[0] = 0;
  }

  if (lastEEPROMversion > 6)
  {
    e131Universe = EEPROM.read(2190) + ((EEPROM.read(2191) << 8) & 0xFF00);
    e131Multicast = EEPROM.read(2192);
    realtimeTimeoutMs = EEPROM.read(2193) + ((EEPROM.read(2194) << 8) & 0xFF00);
    arlsForceMaxBri = EEPROM.read(2195);
    arlsDisableGammaCorrection = EEPROM.read(2196);
  }

  if (lastEEPROMversion > 7)
  {
    strip.paletteFade  = EEPROM.read(374);
    strip.paletteBlend = EEPROM.read(382);

    for (int i = 0; i < 8; ++i)
    {
      timerHours[i]   = EEPROM.read(2260 + i);
      timerMinutes[i] = EEPROM.read(2270 + i);
      timerWeekday[i] = EEPROM.read(2280 + i);
      timerMacro[i]   = EEPROM.read(2290 + i);
      if (timerMacro[i] > 0) timerMacro[i] += 16; //add 16 to work with macro --> preset mapping
      if (timerWeekday[i] == 0) timerWeekday[i] = 255;
      if (timerMacro[i] == 0) timerWeekday[i] = timerWeekday[i] & 0b11111110;
    }
  }

  if (lastEEPROMversion > 8)
  {
    readStringFromEEPROM(2300, mqttServer, 32);
    readStringFromEEPROM(2333, mqttDeviceTopic, 32);
    readStringFromEEPROM(2366, mqttGroupTopic, 32);
  }

  if (lastEEPROMversion > 9)
  {
    //strip.setColorOrder(EEPROM.read(383));
    irEnabled = EEPROM.read(385);
    strip.ablMilliampsMax = EEPROM.read(387) + ((EEPROM.read(388) << 8) & 0xFF00);
  } else if (lastEEPROMversion > 1) //ABL is off by default when updating from version older than 0.8.2
  {
    strip.ablMilliampsMax = 65000;
  } else {
    strip.ablMilliampsMax = ABL_MILLIAMPS_DEFAULT;
  }

  if (lastEEPROMversion > 10)
  {
    readStringFromEEPROM(2399, mqttUser, 40);
    readStringFromEEPROM(2440, mqttPass, 40);
    readStringFromEEPROM(2481, mqttClientID, 40);
    mqttPort = EEPROM.read(2522) + ((EEPROM.read(2523) << 8) & 0xFF00);
  }

  if (lastEEPROMversion > 11)
  {
    strip.milliampsPerLed = EEPROM.read(375);
  } else if (strip.ablMilliampsMax == 65000) //65000 indicates disabled ABL in <0.8.7
  {
    strip.ablMilliampsMax = ABL_MILLIAMPS_DEFAULT;
    strip.milliampsPerLed = 0; //disable ABL
  }
  if (lastEEPROMversion > 12)
  {
    readStringFromEEPROM(990, ntpServerName, 32);
  }
  if (lastEEPROMversion > 13)
  {
    mqttEnabled = EEPROM.read(2299);
    syncToggleReceive = EEPROM.read(397);
  } else {
    mqttEnabled = true;
    syncToggleReceive = false;
  }

  if (lastEEPROMversion > 14)
  {
    DMXAddress = EEPROM.read(2197) + ((EEPROM.read(2198) << 8) & 0xFF00);
    DMXMode = EEPROM.read(2199);
  } else {
    DMXAddress = 1;
    DMXMode = DMX_MODE_MULTIPLE_RGB;
  }

  //if (lastEEPROMversion > 15)
  //{
    noWifiSleep = EEPROM.read(370);
  //}

  if (lastEEPROMversion > 17)
  {
    e131SkipOutOfSequence = EEPROM.read(2189);
  } else {
    e131SkipOutOfSequence = true;
  }

  if (lastEEPROMversion > 18)
  {
    e131Port = EEPROM.read(2187) + ((EEPROM.read(2188) << 8) & 0xFF00);
  }

  #ifdef WLED_ENABLE_DMX
  if (lastEEPROMversion > 19)
  {
    e131ProxyUniverse = EEPROM.read(2185) + ((EEPROM.read(2186) << 8) & 0xFF00);
  }
  #endif

  if (lastEEPROMversion > 21) {
    udpPort2 = EEPROM.read(378) + ((EEPROM.read(379) << 8) & 0xFF00);
  }

  receiveDirect = !EEPROM.read(2200);
  notifyMacro = EEPROM.read(2201);

  //strip.rgbwMode = EEPROM.read(2203);
  //skipFirstLed = EEPROM.read(2204);

  bootPreset = EEPROM.read(389);
  wifiLock = EEPROM.read(393);
  utcOffsetSecs = EEPROM.read(394) + ((EEPROM.read(395) << 8) & 0xFF00);
  if (EEPROM.read(396)) utcOffsetSecs = -utcOffsetSecs; //negative
  //!EEPROM.read(399); was enableSecTransition

  //favorite setting (preset) memory (25 slots/ each 20byte)
  //400 - 899 reserved

  //custom macro memory (16 slots/ each 64byte)
  //1024-2047 reserved

  #ifdef WLED_ENABLE_DMX
  // DMX (2530 - 2549)2535
  DMXChannels = EEPROM.read(2530);
  DMXGap = EEPROM.read(2531) + ((EEPROM.read(2532) << 8) & 0xFF00);
  DMXStart = EEPROM.read(2533) + ((EEPROM.read(2534) << 8) & 0xFF00);

  for (int i=0;i<15;i++) {
    DMXFixtureMap[i] = EEPROM.read(2535+i);
  } //last used: 2549
  DMXStartLED = EEPROM.read(2550);
  #endif

  //Usermod memory
  //2551 - 2559 reserved for Usermods, usable by default
  //2560 - 2943 usable, NOT reserved (need to increase EEPSIZE accordingly, new WLED core features may override this section)
  //2944 - 3071 reserved for Usermods (need to increase EEPSIZE to 3072 in const.h)


// WLEDSR / Audio Reactive specific read settings

  if (lastEEPROMversion > 20) {                                   // Version sanity checking
    soundSquelch =  EEPROM.read(EEP_AUDIO);
    audioSyncPort = EEPROM.read(EEP_AUDIO+1) + ((EEPROM.read(EEP_AUDIO+2) << 8) & 0xFF00);
    audioSyncEnabled = EEPROM.read(EEP_AUDIO + 3);

    effectCustom1 = EEPROM.read(EEP_AUDIO+4);
    effectCustom2 = EEPROM.read(EEP_AUDIO+5);
    effectCustom3 = EEPROM.read(EEP_AUDIO+6);

    strip.stripOrMatrixPanel = EEPROM.read(EEP_AUDIO+7);
    strip.matrixWidth = EEPROM.read(EEP_AUDIO+8) + ((EEPROM.read(EEP_AUDIO+9) << 8) & 0xFF00); //if (strip.matrixWidth == 0) strip.matrixWidth = ledCount;
    strip.matrixHeight = EEPROM.read(EEP_AUDIO+10) + ((EEPROM.read(EEP_AUDIO+11) << 8) & 0xFF00); //if (strip.matrixHeight == 0) strip.matrixHeight = 1;

    strip.setStripOrPanelWidthAndHeight();

    strip.matrixPanels = EEPROM.read(EEP_AUDIO+12);
    strip.matrixHorizontalPanels = EEPROM.read(EEP_AUDIO+13);
    strip.matrixVerticalPanels = EEPROM.read(EEP_AUDIO+14);

    strip.panelFirstLedTopBottom = EEPROM.read(EEP_AUDIO+15); // > 0;
    strip.panelFirstLedLeftRight = EEPROM.read(EEP_AUDIO+16); // > 0;
    strip.panelOrientationHorVert = EEPROM.read(EEP_AUDIO+17); // > 0;
    strip.panelSerpentine = EEPROM.read(EEP_AUDIO+18); // > 0;
    strip.panelTranspose = EEPROM.read(EEP_AUDIO+19); // > 0;

    sampleGain = EEPROM.read(EEP_AUDIO+20);
    soundAgc = EEPROM.read(EEP_AUDIO+21);
  }

// FFT Slider Data Preset Protocol 5 bytes, 25 "slots"
// RESERVE 3175-3299 for FFT Preset saves and future expansion
// 3175:      Custom1
// 3176:      Custom2
// 3177:      Custom3
// 3178-3179: ZEROs

// End of Audio Reactive SEGMENT specific read settings
}


//provided for increased compatibility with usermods written for v0.10
void applyMacro(byte index) {
  applyPreset(index+16);
}


// De-EEPROM routine, upgrade from previous versions to v0.11
void deEEP() {
  if (WLED_FS.exists("/presets.json")) return;

  DEBUG_PRINTLN(F("Preset file not found, attempting to load from EEPROM"));
  DEBUGFS_PRINTLN(F("Allocating saving buffer for dEEP"));
  #ifdef WLED_USE_DYNAMIC_JSON
  DynamicJsonDocument doc(JSON_BUFFER_SIZE);
  #else
  if (!requestJSONBufferLock(8)) return;
  #endif

  JsonObject sObj = doc.to<JsonObject>();
  sObj.createNestedObject("0");

  EEPROM.begin(EEPSIZE);
  if (EEPROM.read(233) == 233) { //valid EEPROM save
    for (uint16_t index = 1; index <= 16; index++) { //copy presets to presets.json
      uint16_t i = 380 + index*20;        // Begin main WLED preset data - min400
      uint16_t k = 3170 + index*5;        // Begin FFT slider preset data - min3175
      byte ver = EEPROM.read(i);

      if ((index < 16 && ver != 1) || (index == 16 && (ver < 2 || ver > 3))) continue;

      char nbuf[16];
      sprintf(nbuf, "%d", index);

      JsonObject pObj = sObj.createNestedObject(nbuf);

      sprintf_P(nbuf, (char*)F("Preset %d"), index);
      pObj["n"] = nbuf;

      pObj["bri"] = EEPROM.read(i+1);

      if (index < 16) {
        JsonObject segObj = pObj.createNestedObject("seg");

        JsonArray colarr = segObj.createNestedArray("col");

        byte numChannels = (strip.hasWhiteChannel())? 4:3;

        for (uint8_t k = 0; k < 3; k++) //k=0 primary (i+2) k=1 secondary (i+6) k=2 tertiary color (i+12)
        {
          JsonArray colX = colarr.createNestedArray();
          uint16_t memloc = i + 6*k;
          if (k == 0) memloc += 2;

          for (byte j = 0; j < numChannels; j++) colX.add(EEPROM.read(memloc + j));
        }

        segObj["fx"]     = EEPROM.read(i+10);
        segObj[F("sx")]  = EEPROM.read(i+11);
        segObj[F("ix")]  = EEPROM.read(i+16);
        segObj["pal"]    = EEPROM.read(i+17);
        segObj[F("c1x")] = EEPROM.read(k);      // Read FFT Slider values from EEPROM for presets
        segObj[F("c2x")] = EEPROM.read(k+1);    // Read FFT Slider values from EEPROM for presets
        segObj[F("c3x")] = EEPROM.read(k+2);    // Read FFT Slider values from EEPROM for presets
      } else {
        WS2812FX::Segment* seg = strip.getSegments();
        memcpy(seg, EEPROM.getDataPtr() +i+2, 240);
        if (ver == 2) { //versions before 2004230 did not have opacity
          for (byte j = 0; j < strip.getMaxSegments(); j++)
          {
            strip.getSegment(j).opacity = 255;
            strip.getSegment(j).setOption(SEG_OPTION_ON, 1);
          }
        }
        serializeState(pObj, true, false, true);
      }
    }

    for (uint16_t index = 1; index <= 16; index++) { //copy macros to presets.json
      char m[65];
      readStringFromEEPROM(1024+64*(index-1), m, 64);
      if (m[0]) { //macro exists
        char nbuf[16];
        sprintf(nbuf, "%d", index + 16);
        JsonObject pObj = sObj.createNestedObject(nbuf);
        sprintf_P(nbuf, "Z Macro %d", index);
        pObj["n"] = nbuf;
        pObj["win"] = m;
      }
    }
  }

  EEPROM.end();

  File f = WLED_FS.open("/presets.json", "w");
  if (!f) {
    errorFlag = ERR_FS_GENERAL;
    releaseJSONBufferLock();
    return;
  }
  serializeJson(doc, f);
  f.close();

  releaseJSONBufferLock();

  DEBUG_PRINTLN(F("deEEP complete!"));
}

void deEEPSettings() {
  DEBUG_PRINTLN(F("Restore settings from EEPROM"));
  EEPROM.begin(EEPSIZE);
  loadSettingsFromEEPROM();
  EEPROM.end();

  //call readFromConfig() with an empty object so that usermods can initialize to defaults prior to saving
  JsonObject empty = JsonObject();
  usermods.readFromConfig(empty);

  serializeConfig();
}
=== ./wled_ethernet.h ===

#ifndef WLED_ETHERNET_H
#define WLED_ETHERNET_H

#ifdef WLED_USE_ETHERNET
#include "pin_manager.h"

// For ESP32, the remaining five pins are at least somewhat configurable.
// eth_address  is in range [0..31], indicates which PHY (MAC?) address should be allocated to the interface
// eth_power    is an output GPIO pin used to enable/disable the ethernet port (and/or external oscillator)
// eth_mdc      is an output GPIO pin used to provide the clock for the management data
// eth_mdio     is an input/output GPIO pin used to transfer management data
// eth_type     is the physical ethernet module's type (ETH_PHY_LAN8720, ETH_PHY_TLK110)
// eth_clk_mode defines the GPIO pin and GPIO mode for the clock signal
//              However, there are really only four configurable options on ESP32:
//              ETH_CLOCK_GPIO0_IN    == External oscillator, clock input  via GPIO0
//              ETH_CLOCK_GPIO0_OUT   == ESP32 provides 50MHz clock output via GPIO0
//              ETH_CLOCK_GPIO16_OUT  == ESP32 provides 50MHz clock output via GPIO16
//              ETH_CLOCK_GPIO17_OUT  == ESP32 provides 50MHz clock output via GPIO17
typedef struct EthernetSettings {
  uint8_t        eth_address;
  int            eth_power;
  int            eth_mdc;
  int            eth_mdio;
  eth_phy_type_t eth_type;
  eth_clock_mode_t eth_clk_mode;
} ethernet_settings;

const ethernet_settings ethernetBoards[] = {
  // None
  {
  },
  
  // WT32-EHT01
  {
    1,                 // eth_address, 
    16,                // eth_power, 
    23,                // eth_mdc, 
    18,                // eth_mdio, 
    ETH_PHY_LAN8720,   // eth_type,
    ETH_CLOCK_GPIO0_IN // eth_clk_mode
  },

  // ESP32-POE
  {
     0,                  // eth_address, 
    12,                  // eth_power, 
    23,                  // eth_mdc, 
    18,                  // eth_mdio, 
    ETH_PHY_LAN8720,     // eth_type,
    ETH_CLOCK_GPIO17_OUT // eth_clk_mode
  },

   // WESP32
  {
    0,			              // eth_address,
    -1,			              // eth_power,
    16,			              // eth_mdc,
    17,			              // eth_mdio,
    ETH_PHY_LAN8720,      // eth_type,
    ETH_CLOCK_GPIO0_IN	  // eth_clk_mode
  },

  // QuinLed-ESP32-Ethernet
  {
    0,			              // eth_address,
    5,			              // eth_power,
    23,			              // eth_mdc,
    18,			              // eth_mdio,
    ETH_PHY_LAN8720,      // eth_type,
    ETH_CLOCK_GPIO17_OUT	// eth_clk_mode
  },

  // TwilightLord-ESP32 Ethernet Shield
  {
    0,			              // eth_address,
    5,			              // eth_power,
    23,			              // eth_mdc,
    18,			              // eth_mdio,
    ETH_PHY_LAN8720,      // eth_type,
    ETH_CLOCK_GPIO17_OUT	// eth_clk_mode
  },

  // ESP3DEUXQuattro
  {
    1,                    // eth_address, 
    -1,                   // eth_power, 
    23,                   // eth_mdc, 
    18,                   // eth_mdio, 
    ETH_PHY_LAN8720,      // eth_type,
    ETH_CLOCK_GPIO17_OUT  // eth_clk_mode
  },

  // ESP32-ETHERNET-KIT-VE
  {
    0,                    // eth_address,
    5,                    // eth_power,
    23,                   // eth_mdc,
    18,                   // eth_mdio,
    ETH_PHY_IP101,        // eth_type,
    ETH_CLOCK_GPIO0_IN    // eth_clk_mode
  },

  // QuinLed-Dig-Octa Brainboard-32-8L and LilyGO-T-ETH-POE
  {
    0,			              // eth_address,
    -1,			              // eth_power,
    23,			              // eth_mdc,
    18,			              // eth_mdio,
    ETH_PHY_LAN8720,      // eth_type,
    ETH_CLOCK_GPIO17_OUT	// eth_clk_mode
  },

  // ABC! WLED Controller V43 + Ethernet Shield & compatible
  {
    1,                    // eth_address, 
    5,                    // eth_power, 
    23,                   // eth_mdc, 
    33,                   // eth_mdio, 
    ETH_PHY_LAN8720,      // eth_type,
    ETH_CLOCK_GPIO17_OUT	// eth_clk_mode
  },

  // Serg74-ESP32 Ethernet Shield
  {
    1,                    // eth_address,
    5,                    // eth_power,
    23,                   // eth_mdc,
    18,                   // eth_mdio,
    ETH_PHY_LAN8720,      // eth_type,
    ETH_CLOCK_GPIO17_OUT  // eth_clk_mode
  }
};
#endif

#define WLED_ETH_RSVD_PINS_COUNT 6
// The following six pins are neither configurable nor
// can they be re-assigned through IOMUX / GPIO matrix.
// See https://docs.espressif.com/projects/esp-idf/en/latest/esp32/hw-reference/esp32/get-started-ethernet-kit-v1.1.html#ip101gri-phy-interface
const managed_pin_type esp32_nonconfigurable_ethernet_pins[WLED_ETH_RSVD_PINS_COUNT] = {
    { 21, true  }, // RMII EMAC TX EN  == When high, clocks the data on TXD0 and TXD1 to transmitter
    { 19, true  }, // RMII EMAC TXD0   == First bit of transmitted data
    { 22, true  }, // RMII EMAC TXD1   == Second bit of transmitted data
    { 25, false }, // RMII EMAC RXD0   == First bit of received data
    { 26, false }, // RMII EMAC RXD1   == Second bit of received data
    { 27, true  }, // RMII EMAC CRS_DV == Carrier Sense and RX Data Valid
};

#endif
=== ./wled_math.h ===

#ifndef WLED_MATH_H
#define WLED_MATH_H

/*
 * Contains some trigonometric functions.
 * The ANSI C equivalents are likely faster, but using any sin/cos/tan function incurs a memory penalty of 460 bytes on ESP8266, likely for lookup tables.
 * This implementation has no extra static memory usage.
 * 
 * Source of the cos_t() function: https://web.eecs.utk.edu/~azh/blog/cosine.html (cos_taylor_literal_6terms)
 */

#include <Arduino.h> //PI constant

//#define WLED_DEBUG_MATH

#define modd(x, y) ((x) - (int)((x) / (y)) * (y))

float cos_t(float phi)
{
  float x = modd(phi, TWO_PI);
  if (x < 0) x = -1 * x;
  int8_t sign = 1;
  if (x > PI)
  {
      x -= PI;
      sign = -1;
  }
  float xx = x * x;

  float res = sign * (1 - ((xx) / (2)) + ((xx * xx) / (24)) - ((xx * xx * xx) / (720)) + ((xx * xx * xx * xx) / (40320)) - ((xx * xx * xx * xx * xx) / (3628800)) + ((xx * xx * xx * xx * xx * xx) / (479001600)));
  #ifdef WLED_DEBUG_MATH
  Serial.printf("cos: %f,%f,%f,(%f)\n",phi,res,cos(x),res-cos(x));
  #endif
  return res;
}

float sin_t(float x) {
  float res =  cos_t(HALF_PI - x);
  #ifdef WLED_DEBUG_MATH
  Serial.printf("sin: %f,%f,%f,(%f)\n",x,res,sin(x),res-sin(x));
  #endif
  return res;
}

float tan_t(float x) {
  float c = cos_t(x);
  if (c==0.0) return 0;
  float res = sin_t(x) / c;
  #ifdef WLED_DEBUG_MATH
  Serial.printf("tan: %f,%f,%f,(%f)\n",x,res,tan(x),res-tan(x));
  #endif
  return res;
}

//https://stackoverflow.com/questions/3380628
// Absolute error <= 6.7e-5
float acos_t(float x) {
  float negate = float(x < 0);
  float xabs = std::abs(x);
  float ret = -0.0187293;
  ret = ret * xabs;
  ret = ret + 0.0742610;
  ret = ret * xabs;
  ret = ret - 0.2121144;
  ret = ret * xabs;
  ret = ret + HALF_PI;
  ret = ret * sqrt(1.0-xabs);
  ret = ret - 2 * negate * ret;
  float res = negate * PI + ret;
  #ifdef WLED_DEBUG_MATH
  Serial.printf("acos: %f,%f,%f,(%f)\n",x,res,acos(x),res-acos(x));
  #endif
  return res;
}

float asin_t(float x) {
  float res = HALF_PI - acos_t(x);
  #ifdef WLED_DEBUG_MATH
  Serial.printf("asin: %f,%f,%f,(%f)\n",x,res,asin(x),res-asin(x));
  #endif
  return res;
}

// declare a template with no implementation, and only one specialization
// this allows hiding the constants, while ensuring ODR causes optimizations
// to still apply.  (Fixes issues with conflicting 3rd party #define's)
template <typename T> T atan_t(T x);
template<>
float atan_t(float x) {
  //For A/B/C, see https://stackoverflow.com/a/42542593
  static const double A { 0.0776509570923569 };
  static const double B { -0.287434475393028 };
  static const double C { ((HALF_PI/2) - A - B) };
  // polynominal factors for approximation between 1 and 5
  static const float C0 {  0.089494f };
  static const float C1 {  0.974207f };
  static const float C2 { -0.326175f };
  static const float C3 {  0.05375f  };
  static const float C4 { -0.003445f };

  #ifdef WLED_DEBUG_MATH
  float xinput = x;
  #endif
  bool neg = (x < 0);
  x = std::abs(x);
  float res;
  if (x > 5.0f) { // atan(x) converges to pi/2 - (1/x) for large values
    res = HALF_PI - (1.0f/x);
  } else if (x > 1.0f) { //1 < x < 5
    float xx = x * x;
    res = (C4*xx*xx)+(C3*xx*x)+(C2*xx)+(C1*x)+C0;
  } else { // this approximation is only for x <= 1
    float xx = x * x;
    res = ((A*xx + B)*xx + C)*x;
  }
  if (neg) {
    res = -res;
  }
  #ifdef WLED_DEBUG_MATH
  Serial.printf("atan,%f,%f,%f\n",xinput,res,atan(xinput));
  #endif
  return res;
}

float floor_t(float x) {
  bool neg = x < 0;
  int val = x;
  if (neg) val--;
  #ifdef WLED_DEBUG_MATH
  Serial.printf("floor: %f,%f,%f\n",x,(float)val,floor(x));
  #endif
  return val;
}

float fmod_t(float num, float denom) {
  int tquot = num / denom;
  float res = num - tquot * denom;
  #ifdef WLED_DEBUG_MATH
  Serial.printf("fmod: %f,%f,(%f)\n",res,fmod(num,denom),res-fmod(num,denom));
  #endif
  return res;
}

#endif
=== ./wled_serial.cpp ===

#include "wled.h"

/*
 * Adalight and TPM2 handler
 */

enum class AdaState {
  Header_A,
  Header_d,
  Header_a,
  Header_CountHi,
  Header_CountLo,
  Header_CountCheck,
  Data_Red,
  Data_Green,
  Data_Blue,
  TPM2_Header_Type,
  TPM2_Header_CountHi,
  TPM2_Header_CountLo,
};

uint16_t currentBaud = 1152; //default baudrate 115200 (divided by 100)

void updateBaudRate(uint32_t rate){
  uint16_t rate100 = rate/100;
  if (rate100 == currentBaud || rate100 < 96) return;
  currentBaud = rate100;

  if (!pinManager.isPinAllocated(1) || pinManager.getPinOwner(1) == PinOwner::DebugOut){
    Serial.print(F("Baud is now ")); Serial.println(rate);
  }

  Serial.flush();
  Serial.begin(rate);
}

void handleSerial()
{
  if (pinManager.isPinAllocated(3)) return;

  #ifdef WLED_ENABLE_ADALIGHT
  static auto state = AdaState::Header_A;
  static uint16_t count = 0;
  static uint16_t pixel = 0;
  static byte check = 0x00;
  static byte red   = 0x00;
  static byte green = 0x00;

  while (Serial.available() > 0)
  {
    yield();
    byte next = Serial.peek();
    switch (state) {
      case AdaState::Header_A:
        if (next == 'A') state = AdaState::Header_d;
        else if (next == 0xC9) { //TPM2 start byte
          state = AdaState::TPM2_Header_Type;
        }
        else if (next == 'I') {
          handleImprovPacket();
          return;
        } else if (next == 'v') {
          Serial.print("WLED"); Serial.write(' '); Serial.println(VERSION);

        } else if (next == 0xB0) {updateBaudRate( 115200);
        } else if (next == 0xB1) {updateBaudRate( 230400);
        } else if (next == 0xB2) {updateBaudRate( 460800);
        } else if (next == 0xB3) {updateBaudRate( 500000);
        } else if (next == 0xB4) {updateBaudRate( 576000);
        } else if (next == 0xB5) {updateBaudRate( 921600);
        } else if (next == 0xB6) {updateBaudRate(1000000);
        } else if (next == 0xB7) {updateBaudRate(1500000);

        } else if (next == 'l') { //RGB(W) LED data return as JSON array. Slow, but easy to use on the other end.
          if (!pinManager.isPinAllocated(1) || pinManager.getPinOwner(1) == PinOwner::DebugOut){
            uint16_t used = strip.getLengthTotal();
            Serial.write('[');
            for (uint16_t i=0; i<used; i+=1) {
              Serial.print(strip.getPixelColor(i));
              if (i != used-1) Serial.write(',');
            }
            Serial.println("]");
          }
        } else if (next == 'L') { //RGB LED data returned as bytes in tpm2 format. Faster, and slightly less easy to use on the other end.
          if (!pinManager.isPinAllocated(1) || pinManager.getPinOwner(1) == PinOwner::DebugOut) {
            Serial.write(0xC9); Serial.write(0xDA);
            uint16_t used = strip.getLengthTotal();
            uint16_t len = used*3;
            Serial.write(highByte(len));
            Serial.write(lowByte(len));
            for (uint16_t i=0; i < used; i++) {
              uint32_t c = strip.getPixelColor(i);
              Serial.write(qadd8(W(c), R(c))); //R, add white channel to RGB channels as a simple RGBW -> RGB map
              Serial.write(qadd8(W(c), G(c))); //G
              Serial.write(qadd8(W(c), B(c))); //B
            }
            Serial.write(0x36); Serial.write('\n');
          }
        } else if (next == '{') { //JSON API
          bool verboseResponse = false;
          #ifdef WLED_USE_DYNAMIC_JSON
          DynamicJsonDocument doc(JSON_BUFFER_SIZE);
          #else
          if (!requestJSONBufferLock(16)) return;
          #endif
          Serial.setTimeout(100);
          DeserializationError error = deserializeJson(doc, Serial);
          if (error) {
            releaseJSONBufferLock();
            return;
          }
          verboseResponse = deserializeState(doc.as<JsonObject>());
          //only send response if TX pin is unused for other purposes
          if (verboseResponse && (!pinManager.isPinAllocated(1) || pinManager.getPinOwner(1) == PinOwner::DebugOut)) {
            doc.clear();
            JsonObject state = doc.createNestedObject("state");
            serializeState(state);
            JsonObject info  = doc.createNestedObject("info");
            serializeInfo(info);

            serializeJson(doc, Serial);
            Serial.println();
          }
          releaseJSONBufferLock();
        }
        break;
      case AdaState::Header_d:
        if (next == 'd') state = AdaState::Header_a;
        else             state = AdaState::Header_A;
        break;
      case AdaState::Header_a:
        if (next == 'a') state = AdaState::Header_CountHi;
        else             state = AdaState::Header_A;
        break;
      case AdaState::Header_CountHi:
        pixel = 0;
        count = next * 0x100;
        check = next;
        state = AdaState::Header_CountLo;
        break;
      case AdaState::Header_CountLo:
        count += next + 1;
        check = check ^ next ^ 0x55;
        state = AdaState::Header_CountCheck;
        break;
      case AdaState::Header_CountCheck:
        if (check == next) state = AdaState::Data_Red;
        else               state = AdaState::Header_A;
        break;
      case AdaState::TPM2_Header_Type:
        state = AdaState::Header_A; //(unsupported) TPM2 command or invalid type
        if (next == 0xDA) state = AdaState::TPM2_Header_CountHi; //TPM2 data
        else if (next == 0xAA) Serial.write(0xAC); //TPM2 ping
        break;
      case AdaState::TPM2_Header_CountHi:
        pixel = 0;
        count = (next * 0x100) /3;
        state = AdaState::TPM2_Header_CountLo;
        break;
      case AdaState::TPM2_Header_CountLo:
        count += next /3;
        state = AdaState::Data_Red;
        break;
      case AdaState::Data_Red:
        red   = next;
        state = AdaState::Data_Green;
        break;
      case AdaState::Data_Green:
        green = next;
        state = AdaState::Data_Blue;
        break;
      case AdaState::Data_Blue:
        byte blue  = next;
        if (!realtimeOverride) setRealtimePixel(pixel++, red, green, blue, 0);
        if (--count > 0) state = AdaState::Data_Red;
        else {
          realtimeLock(realtimeTimeoutMs, REALTIME_MODE_ADALIGHT);

          if (!realtimeOverride) strip.show();
          state = AdaState::Header_A;
        }
        break;
    }
    Serial.read(); //discard the byte
  }
  #endif
}

=== ./wled_server.cpp ===

#include "wled.h"

/*
 * Integrated HTTP web server page declarations
 */

//Is this an IP?
bool isIp(String str) {
  for (size_t i = 0; i < str.length(); i++) {
    int c = str.charAt(i);
    if (c != '.' && (c < '0' || c > '9')) {
      return false;
    }
  }
  return true;
}

void handleUpload(AsyncWebServerRequest *request, const String& filename, size_t index, uint8_t *data, size_t len, bool final){
  if (otaLock) {
    if (final) request->send(500, "text/plain", F("Please unlock OTA in security settings!"));
    return;
  }
  if(!index){
    request->_tempFile = WLED_FS.open(filename, "w");
    DEBUG_PRINT("Uploading ");
    DEBUG_PRINTLN(filename);
    if (filename.equals("/presets.json")) presetsModifiedTime = toki.second();    // WLEDSR
  }
  if (len) {
    request->_tempFile.write(data,len);
  }
  if(final){
    request->_tempFile.close();
    if (filename.equalsIgnoreCase("/cfg.json")) { // WLEDSR bugfix from 0.14.0: reboot after uploading cfg.json
      request->send(200, "text/plain", F("Configuration restored successfully.\nRebooting..."));
      doReboot = true;
    } else {
      if (filename.equals("/presets.json")) {  // WLEDSR
        request->send(200, "text/plain", F("Presets File Uploaded!"));
      } else
        request->send(200, "text/plain", F("File Uploaded!"));
    }
  }
}

bool captivePortal(AsyncWebServerRequest *request)
{
  if (ON_STA_FILTER(request)) return false; //only serve captive in AP mode
  String hostH;
  if (!request->hasHeader("Host")) return false;
  hostH = request->getHeader("Host")->value();

  if (!isIp(hostH) && hostH.indexOf("wled.me") < 0 && hostH.indexOf(cmDNS) < 0) {
    DEBUG_PRINTLN("Captive portal");
    AsyncWebServerResponse *response = request->beginResponse(302);
    response->addHeader(F("Location"), F("http://4.3.2.1"));
    request->send(response);
    return true;
  }
  return false;
}

void initServer()
{
  //CORS compatiblity
  DefaultHeaders::Instance().addHeader(F("Access-Control-Allow-Origin"), "*");
  DefaultHeaders::Instance().addHeader(F("Access-Control-Allow-Methods"), "*");
  DefaultHeaders::Instance().addHeader(F("Access-Control-Allow-Headers"), "*");

 #ifdef WLED_ENABLE_WEBSOCKETS
    server.on("/liveview", HTTP_GET, [](AsyncWebServerRequest *request){
      request->send_P(200, "text/html", PAGE_liveviewws);
    });
    // WLEDSR
    server.on("/liveview2D", HTTP_GET, [](AsyncWebServerRequest *request){
      request->send_P(200, "text/html", PAGE_liveviewws2D);
    });
 #else
    server.on("/liveview", HTTP_GET, [](AsyncWebServerRequest *request){
      request->send_P(200, "text/html", PAGE_liveview);
    });
  #endif

  //settings page
  server.on("/settings", HTTP_GET, [](AsyncWebServerRequest *request){
    serveSettings(request);
  });

  server.on("/favicon.ico", HTTP_GET, [](AsyncWebServerRequest *request){
    if(!handleFileRead(request, "/favicon.ico"))
    {
      request->send_P(200, "image/x-icon", favicon, 156);
    }
  });

  server.on("/sliders", HTTP_GET, [](AsyncWebServerRequest *request){
    serveIndex(request);
  });

  server.on("/welcome", HTTP_GET, [](AsyncWebServerRequest *request){
    serveSettings(request);
  });

  server.on("/reset", HTTP_GET, [](AsyncWebServerRequest *request){
    serveMessage(request, 200,F("Rebooting now..."),F("Please wait ~10 seconds..."),129);
    doReboot = true;
  });

  server.on("/settings", HTTP_POST, [](AsyncWebServerRequest *request){
    serveSettings(request, true);
  });

  server.on("/json", HTTP_GET, [](AsyncWebServerRequest *request){
    serveJson(request);
  });

  AsyncCallbackJsonWebHandler* handler = new AsyncCallbackJsonWebHandler("/json", [](AsyncWebServerRequest *request) {
    bool verboseResponse = false;
    bool isConfig = false;
    { //scope JsonDocument so it releases its buffer
      #ifdef WLED_USE_DYNAMIC_JSON
      DynamicJsonDocument doc(JSON_BUFFER_SIZE);
      #else
      if (!requestJSONBufferLock(14)) return;
      #endif

      DeserializationError error = deserializeJson(doc, (uint8_t*)(request->_tempObject));
      JsonObject root = doc.as<JsonObject>();
      if (error || root.isNull()) {
        releaseJSONBufferLock();
        request->send(400, "application/json", F("{\"error\":9}"));
        return;
      }
      const String& url = request->url();
      isConfig = url.indexOf("cfg") > -1;
      if (!isConfig) {
        #ifdef WLED_DEBUG
          DEBUG_PRINTLN(F("Serialized HTTP"));
          serializeJson(root,Serial);
          DEBUG_PRINTLN();
        #endif
        verboseResponse = deserializeState(root);
      } else {
        verboseResponse = deserializeConfig(root); //use verboseResponse to determine whether cfg change should be saved immediately
      }
      releaseJSONBufferLock();
    }
    if (verboseResponse) {
      if (!isConfig) {
        serveJson(request); return; //if JSON contains "v"
      } else {
        serializeConfig(); //Save new settings to FS
      }
    }
    request->send(200, "application/json", F("{\"success\":true}"));
  });
  server.addHandler(handler);

  server.on("/version", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(200, "text/plain", (String)VERSION);
    });

  server.on("/uptime", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(200, "text/plain", (String)millis());
    });

  server.on("/freeheap", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(200, "text/plain", (String)ESP.getFreeHeap());
    });

  server.on("/u", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", PAGE_usermod);
    });
  //Deprecated, use of /json/state and presets recommended instead
  server.on("/url", HTTP_GET, [](AsyncWebServerRequest *request){
    URL_response(request);
    });

  server.on("/teapot", HTTP_GET, [](AsyncWebServerRequest *request){
    serveMessage(request, 418, F("418. I'm a teapot."), F("(Tangible Embedded Advanced Project Of Twinkling)"), 254);
    });

  server.on("/upload", HTTP_POST, [](AsyncWebServerRequest *request) {},
        [](AsyncWebServerRequest *request, const String& filename, size_t index, uint8_t *data,
                      size_t len, bool final) {handleUpload(request, filename, index, data, len, final);}
  );

  //if OTA is allowed
  if (!otaLock){
    #ifdef WLED_ENABLE_FS_EDITOR
     #ifdef ARDUINO_ARCH_ESP32
      server.addHandler(new SPIFFSEditor(WLED_FS));//http_username,http_password));
     #else
      server.addHandler(new SPIFFSEditor("","",WLED_FS));//http_username,http_password));
     #endif
    #else
    server.on("/edit", HTTP_GET, [](AsyncWebServerRequest *request){
      serveMessage(request, 501, "Not implemented", F("The FS editor is disabled in this build."), 254);
    });
    #endif
    //init ota page
    #ifndef WLED_DISABLE_OTA
    server.on("/update", HTTP_GET, [](AsyncWebServerRequest *request){
      serveSettings(request); //WLEDSR: 0.14 style
    });

    server.on("/update", HTTP_POST, [](AsyncWebServerRequest *request){
      if (Update.hasError())
      {
        serveMessage(request, 500, F("Update failed!"), F("Please check your file and retry!"), 254); return;
      }
      serveMessage(request, 200, F("Update successful!"), F("Rebooting..."), 131);
      doReboot = true;
    },[](AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){
      if(!index){
        DEBUG_PRINTLN(F("OTA Update Start"));
        DEBUG_PRINT("OTA running on core: "); DEBUG_PRINTLN(xPortGetCoreID());
        vTaskDelete(FFT_Task);//WLEDSR: Avoid crash due to angry watchdog
        if (udpSyncConnected) { //WLEDSR: close UDP sync connection (if open)
          udpSyncConnected = false;
          fftUdp.stop();
        }
        WLED::instance().disableWatchdog();
        #ifdef ESP8266
        Update.runAsync(true);
        #endif
        Update.begin((ESP.getFreeSketchSpace() - 0x1000) & 0xFFFFF000);
      }
      if(!Update.hasError()) Update.write(data, len);
      if(final){
        if(Update.end(true)){
          DEBUG_PRINTLN(F("Update Success"));
        } else {
          DEBUG_PRINTLN(F("Update Failed"));
          WLED::instance().enableWatchdog();
        }
      }
    });

    #else
    server.on("/update", HTTP_GET, [](AsyncWebServerRequest *request){
      serveMessage(request, 501, "Not implemented", F("OTA updating is disabled in this build."), 254);
    });
    #endif
  } else
  {
    server.on("/edit", HTTP_GET, [](AsyncWebServerRequest *request){
      serveMessage(request, 500, "Access Denied", F("Please unlock OTA in security settings!"), 254);
    });
    server.on("/update", HTTP_GET, [](AsyncWebServerRequest *request){
      serveMessage(request, 500, "Access Denied", F("Please unlock OTA in security settings!"), 254);
    });
  }


  #ifdef WLED_ENABLE_DMX
  server.on("/dmxmap", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", PAGE_dmxmap     , dmxProcessor);
  });
  #else
  server.on("/dmxmap", HTTP_GET, [](AsyncWebServerRequest *request){
    serveMessage(request, 501, "Not implemented", F("DMX support is not enabled in this build."), 254);
  });
  #endif
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    if (captivePortal(request)) return;
    serveIndexOrWelcome(request);
  });

  #ifdef WLED_ENABLE_WEBSOCKETS
  server.addHandler(&ws);
  #endif

  //called when the url is not defined here, ajax-in; get-settings
  server.onNotFound([](AsyncWebServerRequest *request){
    DEBUG_PRINTLN("Not-Found HTTP call:");
    DEBUG_PRINTLN("URI: " + request->url());
    if (captivePortal(request)) return;

    //make API CORS compatible
    if (request->method() == HTTP_OPTIONS)
    {
      AsyncWebServerResponse *response = request->beginResponse(200);
      response->addHeader(F("Access-Control-Max-Age"), F("7200"));
      request->send(response);
      return;
    }

    if(handleSet(request, request->url())) return;
    #ifndef WLED_DISABLE_ALEXA
    if(espalexa.handleAlexaApiCall(request)) return;
    #endif
    if(handleFileRead(request, request->url())) return;
    request->send_P(404, "text/html", PAGE_404);
  });
}


void serveIndexOrWelcome(AsyncWebServerRequest *request)
{
  if (!showWelcomePage){
    serveIndex(request);
  } else {
    serveSettings(request);
  }
}

bool handleIfNoneMatchCacheHeader(AsyncWebServerRequest* request)
{
  AsyncWebHeader* header = request->getHeader("If-None-Match");
  if (header && header->value() == String(VERSION)) {
    request->send(304);
    return true;
  }
  return false;
}

void setStaticContentCacheHeaders(AsyncWebServerResponse *response)
{
  #ifndef WLED_DEBUG
  //this header name is misleading, "no-cache" will not disable cache,
  //it just revalidates on every load using the "If-None-Match" header with the last ETag value
  response->addHeader(F("Cache-Control"),"no-cache");
  #else
  response->addHeader(F("Cache-Control"),"no-store,max-age=0"); // prevent caching if debug build
  #endif
  response->addHeader(F("ETag"), String(VERSION));
}

void serveIndex(AsyncWebServerRequest* request)
{
  if (handleFileRead(request, "/index.htm")) return;

  if (handleIfNoneMatchCacheHeader(request)) return;

  AsyncWebServerResponse *response = request->beginResponse_P(200, "text/html", PAGE_index, PAGE_index_L);

  response->addHeader(F("Content-Encoding"),"gzip");
  setStaticContentCacheHeaders(response);
  request->send(response);
}


String msgProcessor(const String& var)
{
  if (var == "MSG") {
    String messageBody = messageHead;
    messageBody += F("</h2>");
    messageBody += messageSub;
    uint32_t optt = optionType;

    if (optt < 60) //redirect to settings after optionType seconds
    {
      messageBody += F("<script>setTimeout(RS,");
      messageBody +=String(optt*1000);
      messageBody += F(")</script>");
    } else if (optt < 120) //redirect back after optionType-60 seconds, unused
    {
      //messageBody += "<script>setTimeout(B," + String((optt-60)*1000) + ")</script>";
    } else if (optt < 180) //reload parent after optionType-120 seconds
    {
      messageBody += F("<script>setTimeout(RP,");
      messageBody += String((optt-120)*1000);
      messageBody += F(")</script>");
    } else if (optt == 253)
    {
      messageBody += F("<br><br><form action=/settings><button class=\"bt\" type=submit>Back</button></form>"); //button to settings
    } else if (optt == 254)
    {
      messageBody += F("<br><br><button type=\"button\" class=\"bt\" onclick=\"B()\">Back</button>");
    }
    return messageBody;
  }
  return String();
}


void serveMessage(AsyncWebServerRequest* request, uint16_t code, const String& headl, const String& subl, byte optionT)
{
  messageHead = headl;
  messageSub = subl;
  optionType = optionT;

  request->send_P(code, "text/html", PAGE_msg, msgProcessor);
}


String settingsProcessor(const String& var)
{
  if (var == "CSS") {
    char buf[SETTINGS_STACK_BUF_SIZE] = { '\0' }; // WLEDSR ensure buffer is cleared initially
    buf[0] = 0;
    getSettingsJS(optionType, buf);
    //Serial.println(uxTaskGetStackHighWaterMark(NULL));
    return String(buf);
  }

  #ifdef WLED_ENABLE_DMX

  if (var == "DMXMENU") {
    return String(F("<form action=/settings/dmx><button type=submit>DMX Output</button></form>"));
  }

  #endif
  if (var == "SCSS") return String(FPSTR(PAGE_settingsCss));
  return String();
}

String dmxProcessor(const String& var)
{
  String mapJS;
  #ifdef WLED_ENABLE_DMX
    if (var == "DMXVARS") {
      mapJS += "\nCN=" + String(DMXChannels) + ";\n";
      mapJS += "CS=" + String(DMXStart) + ";\n";
      mapJS += "CG=" + String(DMXGap) + ";\n";
      mapJS += "LC=" + String(strip.getLengthTotal()) + ";\n";
      mapJS += "var CH=[";
      for (int i=0;i<15;i++) {
        mapJS += String(DMXFixtureMap[i]) + ",";
      }
      mapJS += "0];";
    }
  #endif

  return mapJS;
}


void serveSettings(AsyncWebServerRequest* request, bool post)
{
  byte subPage = 0;
  const String& url = request->url();
  if (url.indexOf("sett") >= 0)
  {
    if      (url.indexOf("wifi") > 0) subPage = 1;
    else if (url.indexOf("leds") > 0) subPage = 2;
    else if (url.indexOf("ui")   > 0) subPage = 3;
    else if (url.indexOf("sync") > 0) subPage = 4;
    else if (url.indexOf("time") > 0) subPage = 5;
    else if (url.indexOf("sec")  > 0) subPage = 6;
    #ifdef WLED_ENABLE_DMX // include only if DMX is enabled
    else if (url.indexOf("dmx")  > 0) subPage = 7;
    #endif
    else if (url.indexOf("um")   > 0) subPage = 8;
    else if (url.indexOf("sound")> 0) subPage = 9;  // add sound settings page
  } 
  else if (url.indexOf("/update") >= 0) subPage = 10; // WLEDSR 0.14 style. update page, for PIN check
  else subPage = 255; //welcome page

  if (subPage == 1 && wifiLock && otaLock)
  {
    serveMessage(request, 500, "Access Denied", F("Please unlock OTA in security settings!"), 254); return;
  }

  if (post) { //settings/set POST request, saving
    if (subPage != 1 || !(wifiLock && otaLock)) handleSettingsSet(request, subPage);

    char s[32];
    char s2[45] = "";

    switch (subPage) {
      case 1: strcpy_P(s, PSTR("WiFi")); strcpy_P(s2, PSTR("Please connect to the new IP (if changed)")); forceReconnect = true; break;
      case 2: strcpy_P(s, PSTR("LED")); break;
      case 3: strcpy_P(s, PSTR("UI")); break;
      case 4: strcpy_P(s, PSTR("Sync")); break;
      case 5: strcpy_P(s, PSTR("Time")); break;
      case 6: strcpy_P(s, PSTR("Security")); strcpy_P(s2, PSTR("Rebooting, please wait ~10 seconds...")); break;
      case 7: strcpy_P(s, PSTR("DMX")); break;
      case 8: strcpy_P(s, PSTR("Usermods")); break;
      case 9: strcpy_P(s, PSTR("Sound")); break;
    }

    strcat_P(s, PSTR(" settings saved."));
    if (!s2[0]) strcpy_P(s2, PSTR("Redirecting..."));

    if (!doReboot) serveMessage(request, 200, s, s2, (subPage == 1 || subPage == 6) ? 129 : 1);
    if (subPage == 6) doReboot = true;

    return;
  }

  #ifdef WLED_DISABLE_MOBILE_UI //disable welcome page if not enough storage
   if (subPage == 255) {serveIndex(request); return;}
  #endif

  optionType = subPage;

  switch (subPage)
  {
    case 1:   request->send_P(200, "text/html", PAGE_settings_wifi , settingsProcessor); break;
    case 2:   request->send_P(200, "text/html", PAGE_settings_leds , settingsProcessor); break;
    case 3:   request->send_P(200, "text/html", PAGE_settings_ui   , settingsProcessor); break;
    case 4:   request->send_P(200, "text/html", PAGE_settings_sync , settingsProcessor); break;
    case 5:   request->send_P(200, "text/html", PAGE_settings_time , settingsProcessor); break;
    case 6:   request->send_P(200, "text/html", PAGE_settings_sec  , settingsProcessor); break;
    case 7:   request->send_P(200, "text/html", PAGE_settings_dmx  , settingsProcessor); break;
    case 8:   request->send_P(200, "text/html", PAGE_settings_um   , settingsProcessor); break;
    case 9:   request->send_P(200, "text/html", PAGE_settings_sound, settingsProcessor); break;  // add sound settings page
    case 10:  request->send_P(200, "text/html", PAGE_update, settingsProcessor); break;  // WLEDSR add update settings page
    case 255: request->send_P(200, "text/html", PAGE_welcome); break;
    default:  request->send_P(200, "text/html", PAGE_settings     , settingsProcessor);
  }
}

=== ./ws.cpp ===

#include "wled.h"

/*
 * WebSockets server for bidirectional communication
 */
#ifdef WLED_ENABLE_WEBSOCKETS

uint16_t wsLiveClientId = 0;
unsigned long wsLastLiveTime = 0;
//uint8_t* wsFrameBuffer = nullptr;

#define WS_LIVE_INTERVAL 40

void wsEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len)
{
  if(type == WS_EVT_CONNECT){
    //client connected
    sendDataWs(client);
  } else if(type == WS_EVT_DISCONNECT){
    //client disconnected
    if (client->id() == wsLiveClientId) wsLiveClientId = 0;
  } else if(type == WS_EVT_DATA){
    //data packet
    AwsFrameInfo * info = (AwsFrameInfo*)arg;
    if(info->final && info->index == 0 && info->len == len){
      //the whole message is in a single frame and we got all of its data (max. 1450byte)
      if(info->opcode == WS_TEXT)
      {
        if (len > 0 && len < 10 && data[0] == 'p') {
          //application layer ping/pong heartbeat.
          //client-side socket layer ping packets are unresponded (investigate)
          client->text(F("pong"));
          return;
        }
        bool verboseResponse = false;
        { //scope JsonDocument so it releases its buffer
          #ifdef WLED_USE_DYNAMIC_JSON
          DynamicJsonDocument doc(JSON_BUFFER_SIZE);
          #else
          if (!requestJSONBufferLock(11)) return;
          #endif

          DeserializationError error = deserializeJson(doc, data, len);
          JsonObject root = doc.as<JsonObject>();
          if (error || root.isNull()) {
            releaseJSONBufferLock();
            return;
          }
          if (root["v"] && root.size() == 1) {
            //if the received value is just "{"v":true}", send only to this client
            verboseResponse = true;
          } else if (root.containsKey("lv"))
          {
            wsLiveClientId = root["lv"] ? client->id() : 0;
          } else {
            verboseResponse = deserializeState(root);
            if (!interfaceUpdateCallMode) {
              //special case, only on playlist load, avoid sending twice in rapid succession
              if (millis() - lastInterfaceUpdate > (INTERFACE_UPDATE_COOLDOWN -300)) verboseResponse = false;
            }
          }
          releaseJSONBufferLock(); // will clean fileDoc
        }
        //update if it takes longer than 300ms until next "broadcast"
        if (verboseResponse && (millis() - lastInterfaceUpdate < (INTERFACE_UPDATE_COOLDOWN -300) || !interfaceUpdateCallMode)) sendDataWs(client);
      }
    } else {
      //message is comprised of multiple frames or the frame is split into multiple packets
      //if(info->index == 0){
        //if (!wsFrameBuffer && len < 4096) wsFrameBuffer = new uint8_t[4096];
      //}

      //if (wsFrameBuffer && len < 4096 && info->index + info->)
      //{

      //}

      if((info->index + len) == info->len){
        if(info->final){
          if(info->message_opcode == WS_TEXT) {
            client->text(F("{\"error\":9}")); //we do not handle split packets right now
          }
        }
      }
    }
  } else if(type == WS_EVT_ERROR){
    //error was received from the other end

  } else if(type == WS_EVT_PONG){
    //pong message was received (in response to a ping request maybe)

  }
}

void sendDataWs(AsyncWebSocketClient * client)
{
  if (!ws.count()) return;
  AsyncWebSocketMessageBuffer * buffer;

  { //scope JsonDocument so it releases its buffer
    #ifdef WLED_USE_DYNAMIC_JSON
    DynamicJsonDocument doc(JSON_BUFFER_SIZE);
    #else
    if (!requestJSONBufferLock(12)) return;
    #endif
    JsonObject state = doc.createNestedObject("state");
    serializeState(state);
    JsonObject info  = doc.createNestedObject("info");
    serializeInfo(info);
    size_t len = measureJson(doc);
    size_t heap1 = ESP.getFreeHeap();
    buffer = ws.makeBuffer(len); // will not allocate correct memory sometimes
    size_t heap2 = ESP.getFreeHeap();
    if (!buffer || heap1-heap2<len) {
      releaseJSONBufferLock();
      ws.closeAll(1013); //code 1013 = temporary overload, try again later
      ws.cleanupClients(0); //disconnect all clients to release memory
      return; //out of memory
    }
    serializeJson(doc, (char *)buffer->get(), len +1);
    releaseJSONBufferLock();
  }
  if (client) {
    client->text(buffer);
  } else {
    ws.textAll(buffer);
  }
}

#define MAX_LIVE_LEDS_WS 1024 //WLEDSR: support 32x32 matrices max

bool sendLiveLedsWs(uint32_t wsClient)
{
  AsyncWebSocketClient * wsc = ws.client(wsClient);
  if (!wsc || wsc->queueLength() > 0) return false; //only send if queue free

  uint16_t used = strip.getLengthTotal();
  uint16_t n = ((used -1)/MAX_LIVE_LEDS_WS) +1; //only serve every n'th LED if count over MAX_LIVE_LEDS_WS
  uint16_t bufSize = 8 + (used/n)*3;
  AsyncWebSocketMessageBuffer * wsBuf = ws.makeBuffer(bufSize);
  if (!wsBuf) return false; //out of memory
  uint8_t* buffer = wsBuf->get();
  buffer[0] = 'L';
  buffer[1] = 1; //version
  buffer[2] = strip.stripOrMatrixPanel; //1D, 2D or 3D
  buffer[3] = strip.matrixWidth; //WLEDSR: send width and height
  buffer[4] = strip.matrixHeight; //WLEDSR: send width and height
  buffer[5] = 1; //WLEDSR 
  buffer[6] = currentPreset;
  buffer[7] = currentPlaylist;

  if (strip.stripOrMatrixPanel == 2) { //3D
    uint16_t matrixWidth = strip.matrixWidth;
    //workaround to get width, height and depth
    //balance dimensions
    while (matrixWidth > buffer[4]) { //width > heigth
      if (buffer[4] < buffer[5])
        buffer[4] ++; //height ++
      else
        buffer[5] ++; //depth ++
      matrixWidth =  strip.matrixWidth / buffer[4] / buffer[5];
    }
    buffer[3] = matrixWidth;
  }

  uint16_t pos = 8;
  for (uint16_t i= 0; pos < bufSize - 2; i += n)
  {
    uint32_t c = strip.getPixelColor(i);
    buffer[pos++] = qadd8(W(c), R(c)); //R, add white channel to RGB channels as a simple RGBW -> RGB map
    buffer[pos++] = qadd8(W(c), G(c)); //G
    buffer[pos++] = qadd8(W(c), B(c)); //B
  }

  wsc->binary(wsBuf);
  return true;
}

void handleWs()
{
  if (millis() - wsLastLiveTime > WS_LIVE_INTERVAL)
  {
    #ifdef ESP8266
    ws.cleanupClients(3);
    #else
    ws.cleanupClients();
    #endif
    bool success = true;
    if (wsLiveClientId)
      success = sendLiveLedsWs(wsLiveClientId);
    wsLastLiveTime = millis();
    if (!success) wsLastLiveTime -= 20; //try again in 20ms if failed due to non-empty WS queue
  }
}

#else
void handleWs() {}
void sendDataWs(AsyncWebSocketClient * client) {}
#endif
=== ./xml.cpp ===

#include "wled.h"
#include "wled_ethernet.h"

/*
 * Sending XML status files to client
 */

//macro to convert F to const
#define SET_F(x)  (const char*)F(x)

//build XML response to HTTP /win API request
void XML_response(AsyncWebServerRequest *request, char* dest)
{
  char sbuf[(dest == nullptr)?1024:1]; //allocate local buffer if none passed
  obuf = (dest == nullptr)? sbuf:dest;

  olen = 0;
  oappend(SET_F("<?xml version=\"1.0\" ?><vs><ac>"));
  oappendi((nightlightActive && nightlightMode > NL_MODE_SET) ? briT : bri);
  oappend(SET_F("</ac>"));

  for (int i = 0; i < 3; i++)
  {
   oappend("<cl>");
   oappendi(col[i]);
   oappend("</cl>");
  }
  for (int i = 0; i < 3; i++)
  {
   oappend("<cs>");
   oappendi(colSec[i]);
   oappend("</cs>");
  }
  oappend(SET_F("<ns>"));
  oappendi(notifyDirect);
  oappend(SET_F("</ns><nr>"));
  oappendi(receiveNotifications);
  oappend(SET_F("</nr><nl>"));
  oappendi(nightlightActive);
  oappend(SET_F("</nl><nf>"));
  oappendi(nightlightMode > NL_MODE_SET);
  oappend(SET_F("</nf><nd>"));
  oappendi(nightlightDelayMins);
  oappend(SET_F("</nd><nt>"));
  oappendi(nightlightTargetBri);
  oappend(SET_F("</nt><sq>"));
  oappendi(soundSquelch);
  oappend(SET_F("</sq><gn>"));
  oappendi(sampleGain);
  oappend(SET_F("</gn><fx>"));
  oappendi(effectCurrent);
  oappend(SET_F("</fx><sx>"));
  oappendi(effectSpeed);
  oappend(SET_F("</sx><ix>"));
  oappendi(effectIntensity);
  oappend(SET_F("</ix><f1>"));
  oappendi(effectCustom1);
  oappend(SET_F("</f1><f2>"));
  oappendi(effectCustom2);
  oappend(SET_F("</f2><f3>"));
  oappendi(effectCustom3);
  oappend(SET_F("</f3><fp>"));
  oappendi(effectPalette);
  oappend(SET_F("</fp><wv>"));
  if (strip.hasWhiteChannel()) {
   oappendi(col[3]);
  } else {
   oappend("-1");
  }
  oappend(SET_F("</wv><ws>"));
  oappendi(colSec[3]);
  oappend(SET_F("</ws><ps>"));
  oappendi(currentPreset);
  oappend(SET_F("</ps><cy>"));
  oappendi(currentPlaylist >= 0);
  oappend(SET_F("</cy><ds>"));
  oappend(serverDescription);
  if (realtimeMode)
  {
    oappend(SET_F(" (live)"));
  }
  oappend(SET_F("</ds><ss>"));
  oappendi(strip.getFirstSelectedSegId());
  oappend(SET_F("</ss></vs>"));
  if (request != nullptr) request->send(200, "text/xml", obuf);
}

//Deprecated, use of /json/state and presets recommended instead
void URL_response(AsyncWebServerRequest *request)
{
  char sbuf[256];
  char s2buf[100];
  obuf = s2buf;
  olen = 0;

  char s[16];
  oappend(SET_F("http://"));
  IPAddress localIP = Network.localIP();
  sprintf(s, "%d.%d.%d.%d", localIP[0], localIP[1], localIP[2], localIP[3]);
  oappend(s);

  oappend(SET_F("/win&A="));
  oappendi(bri);
  oappend(SET_F("&CL=h"));
  for (int i = 0; i < 3; i++)
  {
   sprintf(s,"%02X", col[i]);
   oappend(s);
  }
  oappend(SET_F("&C2=h"));
  for (int i = 0; i < 3; i++)
  {
   sprintf(s,"%02X", colSec[i]);
   oappend(s);
  }
  oappend(SET_F("&FX="));
  oappendi(effectCurrent);
  oappend(SET_F("&SX="));
  oappendi(effectSpeed);
  oappend(SET_F("&IX="));
  oappendi(effectIntensity);
  oappend(SET_F("&C1="));
  oappendi(effectCustom1);
  oappend(SET_F("&C2="));
  oappendi(effectCustom2);
  oappend(SET_F("&C3="));
  oappendi(effectCustom3);
  oappend(SET_F("&FP="));
  oappendi(effectPalette);

  obuf = sbuf;
  olen = 0;

  oappend(SET_F("<html><body><a href=\""));
  oappend(s2buf);
  oappend(SET_F("\" target=\"_blank\">"));
  oappend(s2buf);
  oappend(SET_F("</a></body></html>"));

  if (request != nullptr) request->send(200, "text/html", obuf);
}

//append a numeric setting to string buffer
void sappend(char stype, const char* key, int val)
{
  char ds[] = "d.Sf.";

  switch(stype)
  {
    case 'c': //checkbox
      oappend(ds);
      oappend(key);
      oappend(".checked=");
      oappendi(val);
      oappend(";");
      break;
    case 'v': //numeric
      oappend(ds);
      oappend(key);
      oappend(".value=");
      oappendi(val);
      oappend(";");
      break;
    case 'i': //selectedIndex
      oappend(ds);
      oappend(key);
      oappend(SET_F(".selectedIndex="));
      oappendi(val);
      oappend(";");
      break;
  }
}

//append a string setting to buffer
void sappends(char stype, const char* key, char* val)
{
  switch(stype)
  {
    case 's': { //string (we can interpret val as char*)
      oappend("d.Sf.");
      oappend(key);
      oappend(".value=\"");
      //convert "%" to "%%" to make EspAsyncWebServer happy
      char buf[130];
      uint8_t len = strlen(val) +1;
      uint8_t s = 0;
      for (uint8_t i = 0; i < len; i++) {
        buf[i+s] = val[i];
        if (val[i] == '%') {
          s++; buf[i+s] = '%';
        }
      }

      oappend(buf);
      oappend("\";");
      break; }
    case 'm': //message
      oappend(SET_F("d.getElementsByClassName"));
      oappend(key);
      oappend(SET_F(".innerHTML=\""));
      oappend(val);
      oappend("\";");
      break;
  }
}

void extractPin(JsonObject &obj, const char *key) {
  if (obj[key].is<JsonArray>()) {
    JsonArray pins = obj[key].as<JsonArray>();
    for (JsonVariant pv : pins) {
      if (pv.as<int>() > -1) { oappend(","); oappendi(pv.as<int>()); }
    }
  } else {
    if (obj[key].as<int>() > -1) { oappend(","); oappendi(obj[key].as<int>()); }
  }
}

// oappend used pins by scanning JsonObject (1 level deep)
void fillUMPins(JsonObject &mods)
{
  for (JsonPair kv : mods) {
    // kv.key() is usermod name or subobject key
    // kv.value() is object itself
    JsonObject obj = kv.value();
    if (!obj.isNull()) {
      // element is an JsonObject
      if (!obj["pin"].isNull()) {
        extractPin(obj, "pin");
      } else {
        // scan keys (just one level deep as is possible with usermods)
        for (JsonPair so : obj) {
          const char *key = so.key().c_str();
          if (strstr(key, "pin")) {
            // we found a key containing "pin" substring
            if (strlen(strstr(key, "pin")) == 3) {
              // and it is at the end, we found another pin
              extractPin(obj, key);
              continue;
            }
          }
          if (!obj[so.key()].is<JsonObject>()) continue;
          JsonObject subObj = obj[so.key()];
          if (!subObj["pin"].isNull()) {
            // get pins from subobject
            extractPin(subObj, "pin");
          }
        }
      }
    }
  }
}


//get values for settings form in javascript
void getSettingsJS(byte subPage, char* dest)
{
  //0: menu 1: wifi 2: leds 3: ui 4: sync 5: time 6: sec 7: DMX 8: usermods 9: sound
  DEBUG_PRINT(F("settings resp"));
  DEBUG_PRINTLN(subPage);
  obuf = dest;
  olen = 0;

  if (subPage <1 || subPage >10) return; //WLEDSR: 10 as update.htm also added

  if (subPage == 1)
  {
    sappends('s',SET_F("CS"),clientSSID);

    byte l = strlen(clientPass);
    char fpass[l+1]; //fill password field with ***
    fpass[l] = 0;
    memset(fpass,'*',l);
    sappends('s',SET_F("CP"),fpass);

    char k[3]; k[2] = 0; //IP addresses
    for (int i = 0; i<4; i++)
    {
      k[1] = 48+i; //ascii 0,1,2,3
      k[0] = 'I'; sappend('v',k,staticIP[i]);
      k[0] = 'G'; sappend('v',k,staticGateway[i]);
      k[0] = 'S'; sappend('v',k,staticSubnet[i]);
    }

    sappends('s',SET_F("CM"),cmDNS);
    sappend('i',SET_F("AB"),apBehavior);
    sappends('s',SET_F("AS"),apSSID);
    sappend('c',SET_F("AH"),apHide);

    l = strlen(apPass);
    char fapass[l+1]; //fill password field with ***
    fapass[l] = 0;
    memset(fapass,'*',l);
    sappends('s',SET_F("AP"),fapass);

    sappend('v',SET_F("AC"),apChannel);
    sappend('c',SET_F("WS"),noWifiSleep);

    #ifdef WLED_USE_ETHERNET
    sappend('v',SET_F("ETH"),ethernetType);
    #else
    //hide ethernet setting if not compiled in
    oappend(SET_F("document.getElementById('ethd').style.display='none';"));
    #endif

    if (Network.isConnected()) //is connected
    {
      char s[32];
      IPAddress localIP = Network.localIP();
      sprintf(s, "%d.%d.%d.%d", localIP[0], localIP[1], localIP[2], localIP[3]);

      #if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_ETHERNET)
      if (Network.isEthernet()) strcat_P(s ,SET_F(" (Ethernet)"));
      #endif
      sappends('m',SET_F("(\"sip\")[0]"),s);
    } else
    {
      sappends('m',SET_F("(\"sip\")[0]"),(char*)F("Not connected"));
    }

    if (WiFi.softAPIP()[0] != 0) //is active
    {
      char s[16];
      IPAddress apIP = WiFi.softAPIP();
      sprintf(s, "%d.%d.%d.%d", apIP[0], apIP[1], apIP[2], apIP[3]);
      sappends('m',SET_F("(\"sip\")[1]"),s);
    } else
    {
      sappends('m',SET_F("(\"sip\")[1]"),(char*)F("Not active"));
    }
  }

  if (subPage == 2)
  {
    char nS[8];

    // Pin reservations will become unnecessary when settings pages will read cfg.json directly
    // add reserved and usermod pins as d.um_p array
    oappend(SET_F("d.um_p=[6,7,8,9,10,11"));

    { // scope so buffer can be released earlier
    #ifdef WLED_USE_DYNAMIC_JSON
    DynamicJsonDocument doc(3072);
    #else
    if (!requestJSONBufferLock(6)) return;
    #endif

    JsonObject mods = doc.createNestedObject(F("um"));
    usermods.addToConfig(mods);
    if (!mods.isNull()) fillUMPins(mods);
    releaseJSONBufferLock();
    }

    #ifdef WLED_ENABLE_DMX
      oappend(SET_F(",2")); // DMX hardcoded pin
    #endif

    //Note: Using pin 3 (RX) disables Adalight / Serial JSON

    #ifdef WLED_DEBUG
      oappend(SET_F(",1")); // debug output (TX) pin
    #endif

    #if defined(ARDUINO_ARCH_ESP32) && defined(WLED_USE_PSRAM)
      if (psramFound()) oappend(SET_F(",16,17")); // GPIO16 & GPIO17 reserved for SPI RAM
    #endif

    #ifdef WLED_USE_ETHERNET
    if (ethernetType != WLED_ETH_NONE && ethernetType < WLED_NUM_ETH_TYPES) {
      for (uint8_t p=0; p<WLED_ETH_RSVD_PINS_COUNT; p++) { oappend(","); oappend(itoa(esp32_nonconfigurable_ethernet_pins[p].pin,nS,10)); }
      if (ethernetBoards[ethernetType].eth_power>=0)     { oappend(","); oappend(itoa(ethernetBoards[ethernetType].eth_power,nS,10)); }
      if (ethernetBoards[ethernetType].eth_mdc>=0)       { oappend(","); oappend(itoa(ethernetBoards[ethernetType].eth_mdc,nS,10)); }
      if (ethernetBoards[ethernetType].eth_mdio>=0)      { oappend(","); oappend(itoa(ethernetBoards[ethernetType].eth_mdio,nS,10)); }
      switch (ethernetBoards[ethernetType].eth_clk_mode) {
        case ETH_CLOCK_GPIO0_IN:
        case ETH_CLOCK_GPIO0_OUT:
          oappend(SET_F(",0"));
          break;
        case ETH_CLOCK_GPIO16_OUT:
          oappend(SET_F(",16"));
          break;
        case ETH_CLOCK_GPIO17_OUT:
          oappend(SET_F(",17"));
          break;
      }
    }
    #endif

    oappend(SET_F("];"));

    // set limits
    oappend(SET_F("bLimits("));
    // WLEDSR: special handling not needed any more - see recent changes to bus_wrapper.h
//#if defined(ESP32) && !defined(CONFIG_IDF_TARGET_ESP32S2) && !defined(CONFIG_IDF_TARGET_ESP32S3)
//    oappend(itoa(WLED_MAX_BUSSES-2,nS,10));  oappend(",");    // WLEDSR: // prevent use of I2S buses, as they are needed for audio input. See https://github.com/blazoncek/WLED/issues/33
//#else 
    oappend(itoa(WLED_MAX_BUSSES,nS,10));  oappend(",");
//#endif
    oappend(itoa(MAX_LEDS_PER_BUS,nS,10)); oappend(",");
    oappend(itoa(MAX_LED_MEMORY,nS,10)); oappend(",");
    oappend(itoa(MAX_LEDS,nS,10));
    oappend(SET_F(");"));

    sappend('c',SET_F("MS"),autoSegments);
    sappend('c',SET_F("CCT"),correctWB);
    sappend('c',SET_F("CR"),cctFromRgb);
    sappend('v',SET_F("CB"),strip.cctBlending);
    sappend('v',SET_F("FR"),strip.getTargetFps());
    sappend('v',SET_F("AW"),strip.autoWhiteMode);
    sappend('v',SET_F("SOMP"),strip.stripOrMatrixPanel);
    sappend('v',SET_F("MXW"),strip.matrixWidth);
    sappend('v',SET_F("MXH"),strip.matrixHeight);
    sappend('c',SET_F("MXP"),strip.matrixPanels);
    sappend('v',SET_F("MPH"),strip.matrixHorizontalPanels);
    sappend('v',SET_F("MPV"),strip.matrixVerticalPanels);
    sappend('v',SET_F("PFLTB"),strip.panelFirstLedTopBottom);
    sappend('v',SET_F("PFLLR"),strip.panelFirstLedLeftRight);
    sappend('v',SET_F("POHV"),strip.panelOrientationHorVert);
    sappend('c',SET_F("PNLS"),strip.panelSerpentine);
    sappend('c',SET_F("PNLT"),strip.panelTranspose);

    for (uint8_t s=0; s < busses.getNumBusses(); s++) {
      Bus* bus = busses.getBus(s);
      if (bus == nullptr) continue;
      char lp[4] = "L0"; lp[2] = 48+s; lp[3] = 0; //ascii 0-9 //strip data pin
      char lc[4] = "LC"; lc[2] = 48+s; lc[3] = 0; //strip length
      char co[4] = "CO"; co[2] = 48+s; co[3] = 0; //strip color order
      char lt[4] = "LT"; lt[2] = 48+s; lt[3] = 0; //strip type
      char ls[4] = "LS"; ls[2] = 48+s; ls[3] = 0; //strip start LED
      char cv[4] = "CV"; cv[2] = 48+s; cv[3] = 0; //strip reverse
      char sl[4] = "SL"; sl[2] = 48+s; sl[3] = 0; //skip 1st LED
      char rf[4] = "RF"; rf[2] = 48+s; rf[3] = 0; //off refresh
      oappend(SET_F("addLEDs(1);"));
      uint8_t pins[5];
      uint8_t nPins = bus->getPins(pins);
      for (uint8_t i = 0; i < nPins; i++) {
        lp[1] = 48+i;
        if (pinManager.isPinOk(pins[i]) || bus->getType()>=TYPE_NET_DDP_RGB) sappend('v',lp,pins[i]);
      }
      sappend('v',lc,bus->getLength());
      sappend('v',lt,bus->getType());
      sappend('v',co,bus->getColorOrder());
      sappend('v',ls,bus->getStart());
      sappend('c',cv,bus->reversed);
      sappend('v',sl,bus->skippedLeds());
      sappend('c',rf,bus->isOffRefreshRequired());
    }
    sappend('v',SET_F("MA"),strip.ablMilliampsMax);
    sappend('v',SET_F("LA"),strip.milliampsPerLed);
    if (strip.currentMilliamps)
    {
      sappends('m',SET_F("(\"pow\")[0]"),(char*)"");
      olen -= 2; //delete ";
      oappendi(strip.currentMilliamps);
      oappend(SET_F("mA\";"));
    }

    oappend(SET_F("resetCOM("));
    oappend(itoa(WLED_MAX_COLOR_ORDER_MAPPINGS,nS,10));
    oappend(SET_F(");"));
    const ColorOrderMap& com = busses.getColorOrderMap();
    for (uint8_t s=0; s < com.count(); s++) {
      const ColorOrderMapEntry* entry = com.get(s);
      if (entry == nullptr) break;
      oappend(SET_F("addCOM("));
      oappend(itoa(entry->start,nS,10));  oappend(",");
      oappend(itoa(entry->len,nS,10));  oappend(",");
      oappend(itoa(entry->colorOrder,nS,10));  oappend(");");
    }

    sappend('v',SET_F("CA"),briS);

    sappend('c',SET_F("BO"),turnOnAtBoot);
    sappend('v',SET_F("BP"),bootPreset);

    sappend('c',SET_F("GB"),strip.gammaCorrectBri);
    sappend('c',SET_F("GC"),strip.gammaCorrectCol);
    sappend('c',SET_F("TF"),fadeTransition);
    sappend('v',SET_F("TD"),transitionDelayDefault);
    sappend('c',SET_F("PF"),strip.paletteFade);
    sappend('v',SET_F("BF"),briMultiplier);
    sappend('v',SET_F("TB"),nightlightTargetBri);
    sappend('v',SET_F("TL"),nightlightDelayMinsDefault);
    sappend('v',SET_F("TW"),nightlightMode);
    sappend('i',SET_F("PB"),strip.paletteBlend);
    sappend('v',SET_F("RL"),rlyPin);
    sappend('c',SET_F("RM"),rlyMde);
    for (uint8_t i=0; i<WLED_MAX_BUTTONS; i++) {
      oappend(SET_F("addBtn("));
      oappend(itoa(i,nS,10));  oappend(",");
      oappend(itoa(btnPin[i],nS,10)); oappend(",");
      oappend(itoa(buttonType[i],nS,10));
      oappend(SET_F(");"));
    }
    sappend('v',SET_F("TT"),touchThreshold);
    sappend('v',SET_F("IR"),irPin);
    sappend('v',SET_F("IT"),irEnabled);
    sappend('c',SET_F("MSO"),!irApplyToAllSelected);
    #if !defined(WLED_DISABLE_INFRARED)
    oappend(SET_F("hideNoIR();"));  // WLEDSR: hide "not compiled in" message
    #endif

    // 2D Matrix Settings
    sappend('v',SET_F("SOMP"),strip.stripOrMatrixPanel);
    sappend('v',SET_F("MXW"),strip.matrixWidth);
    sappend('v',SET_F("MXH"),strip.matrixHeight);
    // 2D Panel Settings
    sappend('c',SET_F("MXP"),strip.matrixPanels);
    sappend('v',SET_F("MPH"),strip.matrixHorizontalPanels);
    sappend('v',SET_F("MPV"),strip.matrixVerticalPanels);
    sappend('v',SET_F("PFLTB"),strip.panelFirstLedTopBottom);
    sappend('v',SET_F("PFLLR"),strip.panelFirstLedLeftRight);
    sappend('v',SET_F("POHV"),strip.panelOrientationHorVert);
    sappend('c',SET_F("PNLS"),strip.panelSerpentine);
    sappend('c',SET_F("PNLT"),strip.panelTranspose);
  }

  if (subPage == 3)
  {
    sappends('s',SET_F("DS"),serverDescription);
    sappend('c',SET_F("ST"),syncToggleReceive);
  }

  if (subPage == 4)
  {
    sappend('v',SET_F("UP"),udpPort);
    sappend('v',SET_F("U2"),udpPort2);
    sappend('v',SET_F("GS"),syncGroups);
    sappend('v',SET_F("GR"),receiveGroups);

    sappend('c',SET_F("RB"),receiveNotificationBrightness);
    sappend('c',SET_F("RC"),receiveNotificationColor);
    sappend('c',SET_F("RX"),receiveNotificationEffects);
    sappend('c',SET_F("SO"),receiveSegmentOptions);
    sappend('c',SET_F("SG"),receiveSegmentBounds);
    sappend('c',SET_F("SD"),notifyDirectDefault);
    sappend('c',SET_F("SB"),notifyButton);
    sappend('c',SET_F("SH"),notifyHue);
    sappend('c',SET_F("SM"),notifyMacro);
    sappend('c',SET_F("S2"),notifyTwice);

    sappend('c',SET_F("NL"),nodeListEnabled);
    sappend('c',SET_F("NB"),nodeBroadcastEnabled);

    sappend('c',SET_F("RD"),receiveDirect);
    sappend('c',SET_F("MO"),useMainSegmentOnly);
    sappend('v',SET_F("EP"),e131Port);
    sappend('c',SET_F("ES"),e131SkipOutOfSequence);
    sappend('c',SET_F("EM"),e131Multicast);
    sappend('v',SET_F("EU"),e131Universe);
#ifdef WLED_ENABLE_DMX
    oappend(SET_F("hideNoDMX();"));  // WLEDSR: hide "not compiled in" message    
#endif
    sappend('v',SET_F("DA"),DMXAddress);
    sappend('v',SET_F("DM"),DMXMode);
    sappend('v',SET_F("ET"),realtimeTimeoutMs);
    sappend('c',SET_F("FB"),arlsForceMaxBri);
    sappend('c',SET_F("RG"),arlsDisableGammaCorrection);
    sappend('v',SET_F("WO"),arlsOffset);
    sappend('c',SET_F("AL"),alexaEnabled);
    sappends('s',SET_F("AI"),alexaInvocationName);
    sappend('c',SET_F("SA"),notifyAlexa);
    #ifndef WLED_DISABLE_ALEXA
    oappend(SET_F("hideNoALEXA();"));  //WLEDSR: hide "not compiled in" message
    #else
    oappend(SET_F("hideALEXA();"));    //WLEDSR: hide Alexa setting if not compiled in
    #endif
    sappends('s',SET_F("BK"),(char*)((blynkEnabled)?SET_F("Hidden"):""));
    oappend(SET_F("hideBLYNK();"));    //WLEDSR: hide BLYNK setting - supported removed as Blynk service is closed.
    if (!(((audioSyncEnabled)>>(0)) & 1) && !(((audioSyncEnabled)>>(1)) & 1)) {
      // 0 == udp audio sync off
      sappend('v',SET_F("ASE"), 0);
    }
    else if ((((audioSyncEnabled)>>(0)) & 1) && !(((audioSyncEnabled)>>(1)) & 1)) {
      // 1 == transmit only
      sappend('v',SET_F("ASE"), 1);
    }
    else if (!(((audioSyncEnabled)>>(0)) & 1) && (((audioSyncEnabled)>>(1)) & 1)) {
      // 2 == receive only
      sappend('v',SET_F("ASE"), 2);
    }
    sappend('v',SET_F("ASP"), audioSyncPort);

    #ifdef WLED_ENABLE_MQTT
    sappend('c',SET_F("MQ"),mqttEnabled);
    sappends('s',SET_F("MS"),mqttServer);
    sappend('v',SET_F("MQPORT"),mqttPort);
    sappends('s',SET_F("MQUSER"),mqttUser);
    byte l = strlen(mqttPass);
    char fpass[l+1]; //fill password field with ***
    fpass[l] = 0;
    memset(fpass,'*',l);
    sappends('s',SET_F("MQPASS"),fpass);
    sappends('s',SET_F("MQCID"),mqttClientID);
    sappends('s',"MD",mqttDeviceTopic);
    sappends('s',SET_F("MG"),mqttGroupTopic);
    sappend('c',SET_F("BM"),buttonPublishMqtt);
    oappend(SET_F("hideNoMQTT();"));  //WLEDSR: hide "not compiled in" message
    #else
    oappend(SET_F("hideMQTT();"));    //WLEDSR: hide MQTT setting if not compiled in
    #endif

    #ifndef WLED_DISABLE_HUESYNC
    sappend('v',SET_F("H0"),hueIP[0]);
    sappend('v',SET_F("H1"),hueIP[1]);
    sappend('v',SET_F("H2"),hueIP[2]);
    sappend('v',SET_F("H3"),hueIP[3]);
    sappend('v',SET_F("HL"),huePollLightId);
    sappend('v',SET_F("HI"),huePollIntervalMs);
    sappend('c',SET_F("HP"),huePollingEnabled);
    sappend('c',SET_F("HO"),hueApplyOnOff);
    sappend('c',SET_F("HB"),hueApplyBri);
    sappend('c',SET_F("HC"),hueApplyColor);
    char hueErrorString[25];
    switch (hueError)
    {
      case HUE_ERROR_INACTIVE     : strcpy(hueErrorString,(char*)F("Inactive"));                break;
      case HUE_ERROR_ACTIVE       : strcpy(hueErrorString,(char*)F("Active"));                  break;
      case HUE_ERROR_UNAUTHORIZED : strcpy(hueErrorString,(char*)F("Unauthorized"));            break;
      case HUE_ERROR_LIGHTID      : strcpy(hueErrorString,(char*)F("Invalid light ID"));        break;
      case HUE_ERROR_PUSHLINK     : strcpy(hueErrorString,(char*)F("Link button not pressed")); break;
      case HUE_ERROR_JSON_PARSING : strcpy(hueErrorString,(char*)F("JSON parsing error"));      break;
      case HUE_ERROR_TIMEOUT      : strcpy(hueErrorString,(char*)F("Timeout"));                 break;
      default: sprintf(hueErrorString,(char*)F("Bridge Error %i"),hueError);
    }

    sappends('m',SET_F("(\"sip\")[0]"),hueErrorString);
    oappend(SET_F("hideNoHUE();"));  //WLEDSR: hide "not compiled in" message
    #else
    oappend(SET_F("hideHUE();"));    //WLEDSR: hide Hue Sync setting if not compiled in
    #endif
    sappend('v',SET_F("BD"),serialBaud);

#if defined(WLED_ENABLE_ADALIGHT)
    oappend(SET_F("hideNoADA();"));  // WLEDSR: hide "not compiled in" message    
#endif
#ifdef WLED_ENABLE_LOXONE
    oappend(SET_F("hideNoLOX();"));  // WLEDSR: hide "not compiled in" message    
#endif 
  }

  if (subPage == 5)
  {
    sappend('c',SET_F("NT"),ntpEnabled);
    sappends('s',SET_F("NS"),ntpServerName);
    sappend('c',SET_F("CF"),!useAMPM);
    sappend('i',SET_F("TZ"),currentTimezone);
    sappend('v',SET_F("UO"),utcOffsetSecs);
    char tm[32];
    dtostrf(longitude,4,2,tm);
    sappends('s',SET_F("LN"),tm);
    dtostrf(latitude,4,2,tm);
    sappends('s',SET_F("LT"),tm);
    getTimeString(tm);
    sappends('m',SET_F("(\"times\")[0]"),tm);
    if ((int)(longitude*10.) || (int)(latitude*10.)) {
      sprintf_P(tm, PSTR("Sunrise: %02d:%02d Sunset: %02d:%02d"), hour(sunrise), minute(sunrise), hour(sunset), minute(sunset));
      sappends('m',SET_F("(\"times\")[1]"),tm);
    }
    sappend('c',SET_F("OL"),overlayCurrent);
    sappend('v',SET_F("O1"),overlayMin);
    sappend('v',SET_F("O2"),overlayMax);
    sappend('v',SET_F("OM"),analogClock12pixel);
    sappend('c',SET_F("OS"),analogClockSecondsTrail);
    sappend('c',SET_F("O5"),analogClock5MinuteMarks);

    sappend('c',SET_F("CE"),countdownMode);
    sappend('v',SET_F("CY"),countdownYear);
    sappend('v',SET_F("CI"),countdownMonth);
    sappend('v',SET_F("CD"),countdownDay);
    sappend('v',SET_F("CH"),countdownHour);
    sappend('v',SET_F("CM"),countdownMin);
    sappend('v',SET_F("CS"),countdownSec);

    sappend('v',SET_F("A0"),macroAlexaOn);
    sappend('v',SET_F("A1"),macroAlexaOff);
    sappend('v',SET_F("MC"),macroCountdown);
    sappend('v',SET_F("MN"),macroNl);
    for (uint8_t i=0; i<WLED_MAX_BUTTONS; i++) {
      oappend(SET_F("addRow("));
      oappend(itoa(i,tm,10));  oappend(",");
      oappend(itoa(macroButton[i],tm,10)); oappend(",");
      oappend(itoa(macroLongPress[i],tm,10)); oappend(",");
      oappend(itoa(macroDoublePress[i],tm,10));
      oappend(SET_F(");"));
    }

    char k[4];
    k[2] = 0; //Time macros
    for (int i = 0; i<10; i++)
    {
      k[1] = 48+i; //ascii 0,1,2,3
      if (i<8) { k[0] = 'H'; sappend('v',k,timerHours[i]); }
      k[0] = 'N'; sappend('v',k,timerMinutes[i]);
      k[0] = 'T'; sappend('v',k,timerMacro[i]);
      k[0] = 'W'; sappend('v',k,timerWeekday[i]);
      if (i<8) {
        k[0] = 'M'; sappend('v',k,(timerMonth[i] >> 4) & 0x0F);
				k[0] = 'P'; sappend('v',k,timerMonth[i] & 0x0F);
        k[0] = 'D'; sappend('v',k,timerDay[i]);
				k[0] = 'E'; sappend('v',k,timerDayEnd[i]);
      }
    }
  }

  if (subPage == 6)
  {
    sappend('c',SET_F("NO"),otaLock);
    sappend('c',SET_F("OW"),wifiLock);
    sappend('c',SET_F("AO"),aOtaEnabled);
    sappends('m',SET_F("(\"sip\")[0]"),(char*)F("WLED "));
    olen -= 2; //delete ";
    oappend(versionString);
    oappend(SET_F(" (build "));
    oappendi(VERSION);
    oappend(SET_F(")\";"));
  }

  #ifdef WLED_ENABLE_DMX // include only if DMX is enabled
  if (subPage == 7)
  {
    sappend('v',SET_F("PU"),e131ProxyUniverse);

    sappend('v',SET_F("CN"),DMXChannels);
    sappend('v',SET_F("CG"),DMXGap);
    sappend('v',SET_F("CS"),DMXStart);
    sappend('v',SET_F("SL"),DMXStartLED);

    sappend('i',SET_F("CH1"),DMXFixtureMap[0]);
    sappend('i',SET_F("CH2"),DMXFixtureMap[1]);
    sappend('i',SET_F("CH3"),DMXFixtureMap[2]);
    sappend('i',SET_F("CH4"),DMXFixtureMap[3]);
    sappend('i',SET_F("CH5"),DMXFixtureMap[4]);
    sappend('i',SET_F("CH6"),DMXFixtureMap[5]);
    sappend('i',SET_F("CH7"),DMXFixtureMap[6]);
    sappend('i',SET_F("CH8"),DMXFixtureMap[7]);
    sappend('i',SET_F("CH9"),DMXFixtureMap[8]);
    sappend('i',SET_F("CH10"),DMXFixtureMap[9]);
    sappend('i',SET_F("CH11"),DMXFixtureMap[10]);
    sappend('i',SET_F("CH12"),DMXFixtureMap[11]);
    sappend('i',SET_F("CH13"),DMXFixtureMap[12]);
    sappend('i',SET_F("CH14"),DMXFixtureMap[13]);
    sappend('i',SET_F("CH15"),DMXFixtureMap[14]);
  }
  #endif

  if (subPage == 8) //usermods
  {
    oappend(SET_F("numM="));
    oappendi(usermods.getModCount());
    oappend(";");
  }

  if (subPage == 9) // sound reactive
  {
    sappend('v',SET_F("SQ"),soundSquelch);
    sappend('v',SET_F("GN"),sampleGain);
    sappend('i',SET_F("AGC"),soundAgc);
    sappend('v',SET_F("SI"),audioPin);
    sappend('i',SET_F("DMM"),dmType);
    sappend('v',SET_F("DI"),i2ssdPin);
    sappend('v',SET_F("LR"),i2swsPin);
    sappend('v',SET_F("CK"),i2sckPin);
    sappend('v',SET_F("MCLK"),mclkPin);
  }

  //WLEDSR: add update.htm
  if (subPage == 10) // update
  {
    //WLEDSR: show bin name
    sappends('m',SET_F("(\"sip\")[0]"),(char*)F("WLEDSR_"));
    olen -= 2; //delete ";
    oappend(versionString);
    oappend(SET_F(" "));
    oappend(releaseString);
    oappend(SET_F(".bin"));
    #ifdef ARDUINO_ARCH_ESP32
    oappend(SET_F("<br>(ESP32"));
    #else
    oappend(SET_F("<br>(ESP8266"));
    #endif
    oappend(SET_F(" build "));
    oappendi(VERSION);
    oappend(SET_F(")\";"));
  }

  oappend(SET_F("}</script>"));
}
